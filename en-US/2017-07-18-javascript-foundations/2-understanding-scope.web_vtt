WEBVTT

1
00:00:00.260 --> 00:00:02.270
&gt;&gt; Kyle Simpson: First,
what you need to know definition.

2
00:00:02.270 --> 00:00:04.710
Scope means where to look for things.

3
00:00:04.710 --> 00:00:08.440
It's the set of rules that helps us
figure out where stuff is found,

4
00:00:08.440 --> 00:00:10.120
how to resolve something.

5
00:00:10.120 --> 00:00:13.170
So that definition should ask or

6
00:00:13.170 --> 00:00:16.700
should bring up at least
two questions in your mind.

7
00:00:16.700 --> 00:00:21.330
The first question that should come to
your mind is, what are we looking for?

8
00:00:21.330 --> 00:00:23.650
Great question,
the thing we're looking for

9
00:00:23.650 --> 00:00:28.620
is any variable, any identifier regardless
of how it's used in our program.

10
00:00:28.620 --> 00:00:31.080
It turns out there's only two
ways that something can be used.

11
00:00:31.080 --> 00:00:35.780
A variable can either show up in a
position where we're retrieving the value

12
00:00:35.780 --> 00:00:40.120
from it, or it can show up in a position
where we're adding the value to it, or

13
00:00:40.120 --> 00:00:41.612
we're setting a value into it.

14
00:00:41.612 --> 00:00:44.020
Those are the only two places
a variable can show up, but

15
00:00:44.020 --> 00:00:48.620
wherever it shows up,
that variable belongs to some bucket.

16
00:00:48.620 --> 00:00:53.415
I like to think visually of our program
as a division where every variable is

17
00:00:53.415 --> 00:00:57.612
a colored marble, and this is my
visual way of thinking about it.

18
00:00:57.612 --> 00:00:58.990
It's like sorting all the marbles.

19
00:00:58.990 --> 00:01:01.040
So I put all the red marbles
in the red bucket and

20
00:01:01.040 --> 00:01:05.160
all the blue marbles in the blue bucket
and the green marbles in the green bucket.

21
00:01:05.160 --> 00:01:08.180
Scope is the set of rules by
which we sort all those marbles.

22
00:01:08.180 --> 00:01:13.820
When we want the red marble, we know what
bucket to go and get it out of, okay?

23
00:01:13.820 --> 00:01:14.640
That's the first question.

24
00:01:14.640 --> 00:01:15.470
What are we looking for?

25
00:01:15.470 --> 00:01:16.958
We're looking for the colored marbles.

26
00:01:16.958 --> 00:01:18.694
We're looking for those identifiers.

27
00:01:18.694 --> 00:01:22.180
But there's another more subtle question
and I wanna take a few moments to talk

28
00:01:22.180 --> 00:01:29.780
about scope from the perspective of what's
going on inside of the JavaScript engine.

29
00:01:29.780 --> 00:01:32.000
I've already said this, so
I already kinda gave it away,

30
00:01:32.000 --> 00:01:36.410
but many of you have heard JavaScript
is an interpreted language.

31
00:01:36.410 --> 00:01:37.460
It's a dynamic language.

32
00:01:37.460 --> 00:01:40.870
So if I were to assert to you
JavaScript is absolutely,

33
00:01:40.870 --> 00:01:45.719
positively a compiled language, that
might fly against some of your intuition.

34
00:01:46.720 --> 00:01:49.020
You've always been told before
it's an interpreted language and

35
00:01:49.020 --> 00:01:53.310
I will tell you, absolutely, positively,
JavaScript is a compiled language.

36
00:01:54.370 --> 00:01:57.908
So I wanna dig into that for a moment
because the second question they should

37
00:01:57.908 --> 00:01:59.827
ask is who's doing the looking, okay?

38
00:01:59.827 --> 00:02:01.445
Who's doing the looking?

39
00:02:01.445 --> 00:02:06.575
Is it just a JavaScript interpreter trying
to find dynamically allocated memory or

40
00:02:06.575 --> 00:02:07.390
something?

41
00:02:07.390 --> 00:02:09.728
Or is there something deeper going on?

42
00:02:09.728 --> 00:02:13.855
And this is really at the heart
of this whole unit of discussion,

43
00:02:13.855 --> 00:02:19.050
is that scope is a compile time

44
00:02:19.050 --> 00:02:24.060
process, that our program does
go through a compile step, and

45
00:02:24.060 --> 00:02:27.630
it is at the compile time that all of
these scope decisions will happen.

46
00:02:28.980 --> 00:02:32.600
We like to think of it being
more like a runtime thing,

47
00:02:32.600 --> 00:02:36.670
that JavaScript is a single pass
interpreted program language.

48
00:02:36.670 --> 00:02:42.100
But it really isn't that way, and
I'm gonna point out multiple points

49
00:02:42.100 --> 00:02:47.880
throughout the rest of our discussion
where the difference can be very dramatic.

50
00:02:47.880 --> 00:02:51.220
The difference where we say well,

51
00:02:51.220 --> 00:02:56.670
I think that it's in a single pass, and
I think the variable should be this value.

52
00:02:56.670 --> 00:02:58.550
And it turns out it's something
entirely different, and

53
00:02:58.550 --> 00:03:01.060
you're like, I don't understand
where my thinking is wrong.

54
00:03:01.060 --> 00:03:03.610
And that root thinking problem

55
00:03:03.610 --> 00:03:07.390
is that you're thinking about
JavaScript as a single pass, okay?

56
00:03:07.390 --> 00:03:08.586
So JavaScript is absolutely compiled.

57
00:03:08.586 --> 00:03:10.595
[COUGH] Let me dig into that for a moment.

58
00:03:10.595 --> 00:03:14.847
When people say JavaScript
is not a compiled language,

59
00:03:14.847 --> 00:03:19.913
it's a dynamic interpreted language,
and they compare it to what

60
00:03:19.913 --> 00:03:26.640
is more traditionally thought of as
a compiled language, like a C++ or a Java.

61
00:03:26.640 --> 00:03:31.030
What they're usually thinking
of is the distribution model for

62
00:03:31.030 --> 00:03:33.045
the end result of the compilation.

63
00:03:34.045 --> 00:03:37.269
They're usually thinking,
well, the compiled language,

64
00:03:37.269 --> 00:03:41.305
I run it through a compiler and I produce
some executable code on the outside.

65
00:03:41.305 --> 00:03:44.955
And then, I take that executable code and
I distribute them.

66
00:03:44.955 --> 00:03:47.148
So you think, well, I do that with Java,
I could produce by code.

67
00:03:47.148 --> 00:03:51.535
I do that with C++ and
I produce the binary ones and zeros.

68
00:03:51.535 --> 00:03:57.640
But with JavaScript, I don't comply ahead
of time and produce some executable code.

69
00:03:57.640 --> 00:03:59.670
I ship the source code.

70
00:03:59.670 --> 00:04:04.975
So we think our paradigm is what is
the distribution mode for the program.

71
00:04:04.975 --> 00:04:10.250
Do we distribute it as the executable
code or as a source code?

72
00:04:10.250 --> 00:04:15.100
I remember in CS a really
long time ago now, but

73
00:04:15.100 --> 00:04:19.820
I remember sitting in CS courses and
having an instructor essentially intimate

74
00:04:19.820 --> 00:04:23.450
that that is the major difference
between the languages.

75
00:04:23.450 --> 00:04:25.020
But I think that's wrong.

76
00:04:25.020 --> 00:04:26.890
I think, while that may or

77
00:04:26.890 --> 00:04:32.290
may not be a true validation, there's
nuance there even to pick apart there.

78
00:04:32.290 --> 00:04:35.718
But while that may or may not be true,
I don't think that's at all the most

79
00:04:35.718 --> 00:04:39.668
relevant difference between a compiled
language and an interpretative language.

80
00:04:39.668 --> 00:04:43.720
Let me prove to you for
just a moment that JavaScript is compiled.

81
00:04:43.720 --> 00:04:45.020
There's multiple ways I could do that.

82
00:04:45.020 --> 00:04:46.550
We could open up the source code for

83
00:04:46.550 --> 00:04:50.260
V8 and we'd find that there's
actually a compiler there.

84
00:04:50.260 --> 00:04:53.840
Source code for Mozilla SpiderMonkey,
there's a compiler there.

85
00:04:53.840 --> 00:04:56.700
Let me prove it to you more pragmatically.

86
00:04:56.700 --> 00:05:01.640
Have any of you ever had a JavaScript bug,
anybody?

87
00:05:01.640 --> 00:05:03.240
Okay, good, we're all among friends.

88
00:05:03.240 --> 00:05:04.670
We've all written bugs before.

89
00:05:04.670 --> 00:05:09.364
Have any of your bugs ever been something
where you syntactically did something

90
00:05:09.364 --> 00:05:13.565
wrong, like you were missing a comma,
or you left off a curly brace, or

91
00:05:13.565 --> 00:05:16.038
some kind of syntax error that occurred.

92
00:05:16.038 --> 00:05:20.224
Okay, in that scenario, since we're all
nodding our heads, in that scenario,

93
00:05:20.224 --> 00:05:24.530
if you've ever created a syntax error in
a program, did you ever think to yourself,

94
00:05:24.530 --> 00:05:26.980
well, gee,
that syntax error was on line ten.

95
00:05:28.170 --> 00:05:31.490
But when I went to run the program,
it did not

96
00:05:31.490 --> 00:05:36.440
run lines one through nine first and
then give me the error on line ten.

97
00:05:37.600 --> 00:05:38.860
When did it give me the error?

98
00:05:40.010 --> 00:05:42.580
Before it ever ran line one, right?

99
00:05:43.670 --> 00:05:45.020
Well, how do you suppose it did that?

100
00:05:46.090 --> 00:05:50.874
How do you suppose JavaScript knew in
advance that there was gonna be a syntax

101
00:05:50.874 --> 00:05:53.950
error on line 10 before
it had ever run line 1.

102
00:05:53.950 --> 00:05:56.387
We have a very simple
answer to that question,

103
00:05:56.387 --> 00:05:59.459
because the JavaScript engine
compiled your code first.

104
00:06:00.850 --> 00:06:04.335
And the compilation validated
the syntax long before it

105
00:06:04.335 --> 00:06:07.830
ever handed it off to some
part of the engine to execute.

106
00:06:09.650 --> 00:06:13.070
So at a minimum,
I need to adjust your thinking

107
00:06:13.070 --> 00:06:17.110
about how you process JavaScript programs
from thinking about this as a single pass.

108
00:06:17.110 --> 00:06:21.087
We go all the way through the program
top to bottom to thinking about this as,

109
00:06:21.087 --> 00:06:22.470
at minimum, a dual pass.

110
00:06:22.470 --> 00:06:26.989
We already saw an example of the wrong
thinking here earlier in this

111
00:06:26.989 --> 00:06:29.500
course when I showed you that no off.

112
00:06:29.500 --> 00:06:32.634
I had the var baz equals two,
and then I did another var baz,

113
00:06:32.634 --> 00:06:35.723
and it seemed like it was
a redeclaration of the variable.

114
00:06:35.723 --> 00:06:39.290
And then I said,
there's no such thing as redeclaration.

115
00:06:39.290 --> 00:06:40.550
You know why there isn't?

116
00:06:40.550 --> 00:06:43.770
Cuz that thing isn't gonna
get handled at runtime.

117
00:06:43.770 --> 00:06:47.270
It's gonna get handled at compile time,
okay?

118
00:06:47.270 --> 00:06:47.980
We'll dig more into it.

119
00:06:47.980 --> 00:06:50.665
&gt;&gt; Speaker 2: Are you using that
interchangeably with parsing?

120
00:06:50.665 --> 00:06:52.600
I mean,
it's really just parsing it, right?

121
00:06:52.600 --> 00:06:55.210
Is that the same thing as compiling?

122
00:06:55.210 --> 00:06:57.330
&gt;&gt; Kyle Simpson: Well, okay,
that's a great question.

123
00:06:57.330 --> 00:07:04.050
So the question was, am I using
compilation interchangeably with parsing?

124
00:07:05.580 --> 00:07:10.030
Yes and no, the important part
of what we're talking about

125
00:07:10.030 --> 00:07:12.585
is the fact that parsing
does need to occur.

126
00:07:12.585 --> 00:07:16.083
Cuz obviously parsing needs to happen for
compilation to occur.

127
00:07:16.083 --> 00:07:22.730
But there's multiple stages to
what we mean by a compiler.

128
00:07:22.730 --> 00:07:24.980
So I'm gonna digress a little
bit into compiler theory.

129
00:07:24.980 --> 00:07:28.110
I'm one of those people that
actually enjoyed that class.

130
00:07:28.110 --> 00:07:29.780
That was my favorite class in CS.

131
00:07:29.780 --> 00:07:31.350
I loved compiler theory.

132
00:07:31.350 --> 00:07:33.710
I write compilers for fun now.

133
00:07:33.710 --> 00:07:36.320
I understand many people
may not be like that, but

134
00:07:36.320 --> 00:07:38.300
my brain seems to like this, all right?

135
00:07:38.300 --> 00:07:41.590
So there are multiple stages
through the compiler.

136
00:07:41.590 --> 00:07:46.400
The last step of compilation
is code generation and

137
00:07:46.400 --> 00:07:49.600
linking to create your executable code.

138
00:07:49.600 --> 00:07:52.460
So does that happen with JavaScript?

139
00:07:52.460 --> 00:07:57.110
Or is it just the first stages where
we have lexing tokenization and

140
00:07:57.110 --> 00:07:59.950
parsing into an abstract syntax string?

141
00:07:59.950 --> 00:08:01.060
Which of those two is true?

142
00:08:02.090 --> 00:08:03.870
There's two ways to answer this question.

143
00:08:03.870 --> 00:08:06.420
First off, at the most base level,

144
00:08:06.420 --> 00:08:10.592
the JavaScript engine absolutely
does code generation.

145
00:08:10.592 --> 00:08:14.829
It absolutely does produce an intermediary
representation from the source code to

146
00:08:14.829 --> 00:08:17.549
the thing that it hands off
in the JavaScript engine,

147
00:08:17.549 --> 00:08:22.580
which is actually literally in some cases
called the JavaScript virtual machine.

148
00:08:22.580 --> 00:08:24.360
That's actually akin to a bytecode,

149
00:08:24.360 --> 00:08:27.800
not terribly dissimilar from
what's handed off from Java.

150
00:08:27.800 --> 00:08:30.620
When you compile a Java program,
you produce a bytecode.

151
00:08:30.620 --> 00:08:33.670
Now that bytecode that's handed off to
the Javascript virtual machine is not

152
00:08:33.670 --> 00:08:34.700
portable.

153
00:08:34.700 --> 00:08:37.110
It's not platform independent
like it is with Java.

154
00:08:38.140 --> 00:08:40.499
But it is akin to a byte code, okay,

155
00:08:40.499 --> 00:08:44.536
a set of instructions that
are the binary representations.

156
00:08:44.536 --> 00:08:48.441
So it's not literally handing off,
say, an abstract syntax tree.

157
00:08:48.441 --> 00:08:51.450
It's actually a binary
intermediate representation.

158
00:08:52.600 --> 00:08:57.120
But [COUGH] modern JavaScript engines are
actually fantastically more complex than

159
00:08:57.120 --> 00:09:01.490
what I'm boiling down now because there
is all kind of things like JITing and

160
00:09:01.490 --> 00:09:02.238
other stuff like that.

161
00:09:02.238 --> 00:09:05.520
JIT is J-I-T, Just In Time compilation.

162
00:09:05.520 --> 00:09:06.750
And as a matter of fact, and

163
00:09:06.750 --> 00:09:09.630
this part I don't fully understand
even with my knowledge of CS,

164
00:09:09.630 --> 00:09:13.820
I don't fully understand how you can
partially JIT compile a piece of code.

165
00:09:13.820 --> 00:09:15.038
To me, it's an all or nothing.

166
00:09:15.038 --> 00:09:17.865
You either compile it or
you don't compile it, but

167
00:09:17.865 --> 00:09:22.284
actually modern engines are going through
three or four different JIT passes.

168
00:09:22.284 --> 00:09:25.854
They have like a first JIT and
slower JIT and an even slower one.

169
00:09:25.854 --> 00:09:29.956
And they go through it multiple times and
they figure out more about the program as

170
00:09:29.956 --> 00:09:33.160
they go through it, and
then they trace with runtime.

171
00:09:33.160 --> 00:09:37.394
And then the engine is recompiling
stuff based upon what it knows.

172
00:09:37.394 --> 00:09:41.247
As it sees stuff happen in runtime,
it will throw away a set of guesses and

173
00:09:41.247 --> 00:09:43.700
recompile another set and hot swap it in.

174
00:09:43.700 --> 00:09:47.420
There's all kinds of complexities going
on, so it's actually not even a two pass.

175
00:09:47.420 --> 00:09:48.878
It's very much more complex.

176
00:09:48.878 --> 00:09:51.712
But if we just simplify
it down to the two pass,

177
00:09:51.712 --> 00:09:56.074
there's a single step that compiles
which does the parsing, produces

178
00:09:56.074 --> 00:10:00.821
some representation of that program
that in execution knows what to do with.

179
00:10:00.821 --> 00:10:04.067
I'm gonna call that an IR,
an intermediary representation.

180
00:10:04.067 --> 00:10:05.122
It's like a bytecode.

181
00:10:05.122 --> 00:10:08.311
And then there's a second
pass that executes it.

182
00:10:08.311 --> 00:10:12.119
So when I say compile, I mean JavaScript
goes through those two passes.

183
00:10:12.119 --> 00:10:13.320
Did I help you answer that question?

184
00:10:13.320 --> 00:10:15.248
&gt;&gt; Speaker 2: Yeah, yeah.

185
00:10:15.248 --> 00:10:18.663
&gt;&gt; Kyle Simpson: Okay, so what I'm
asserting is that that first pass has to

186
00:10:18.663 --> 00:10:21.490
occur because parsing has to happen.

187
00:10:21.490 --> 00:10:25.738
Otherwise, we'd never know about a syntax
error on line ten if we were on line one.

188
00:10:25.738 --> 00:10:30.301
As a matter of fact there's more
proof that the parsing is happening

189
00:10:30.301 --> 00:10:35.105
because JavaScript has a set of things
which are enforced in the parsing

190
00:10:35.105 --> 00:10:36.900
stage of the grammar.

191
00:10:36.900 --> 00:10:39.523
They're enforced in what
is called early errors.

192
00:10:39.523 --> 00:10:44.003
For example, in strict mode, if you
have a JavaScript function that has two

193
00:10:44.003 --> 00:10:48.763
different parameters with the same lexical
name, like you have function foo and

194
00:10:48.763 --> 00:10:52.030
then you say a,a in
the function signature.

195
00:10:52.030 --> 00:10:56.470
That's not a syntactic error,
that's totally syntactically valid.

196
00:10:56.470 --> 00:11:00.320
But that is still thrown
as an early static error.

197
00:11:00.320 --> 00:11:04.550
In other words, before the program is
ever run, an error is thrown to tell you,

198
00:11:04.550 --> 00:11:06.980
you're not allowed to have two
parameters of the same name.

199
00:11:08.010 --> 00:11:12.480
That could only happen if there was first
a full pass through the program to do all

200
00:11:12.480 --> 00:11:16.970
the parsing and validation of the code,
and know everything that they need to know

201
00:11:16.970 --> 00:11:20.610
to verify these parameters are the same,
right?

202
00:11:20.610 --> 00:11:25.359
So there has to be that
first pass that occurs.

203
00:11:25.359 --> 00:11:29.282
[COUGH] So all I really want you to do is
to just reset your thinking from the one

204
00:11:29.282 --> 00:11:31.280
pass to the two pass.

205
00:11:31.280 --> 00:11:35.210
First, think about there's this pass
that happens to validate my program.

206
00:11:35.210 --> 00:11:39.144
And it's during that pass that
lexical scope gets set up.

207
00:11:40.260 --> 00:11:43.680
It's during that first
pass that scoping happens.

208
00:11:43.680 --> 00:11:45.520
It is not during the second pass,

209
00:11:45.520 --> 00:11:50.850
which is what most of us have sort
of loosely come to believe, okay?

210
00:11:52.790 --> 00:11:55.150
So JavaScript is absolutely
a compiled language.

211
00:11:55.150 --> 00:11:59.030
As a matter of fact, I would make the case
that that compiler architecture that I

212
00:11:59.030 --> 00:12:02.640
just quickly alluded to there,
is vastly more sophisticated than

213
00:12:02.640 --> 00:12:06.190
any compiler architecture for
any other language in existence.

214
00:12:06.190 --> 00:12:09.160
Because we're demanding so much more of
JavaScript and they've come up with all

215
00:12:09.160 --> 00:12:12.415
these different techniques that were
never even relevant to other things.

216
00:12:12.415 --> 00:12:16.970
I mean for the C++ compiler to be a JIT
compiler, it wouldn't even make sense,

217
00:12:16.970 --> 00:12:19.530
right, cuz you do all AOT.

218
00:12:19.530 --> 00:12:22.160
It's all ahead of time compilation.

219
00:12:22.160 --> 00:12:26.140
So JavaScript has to do a whole lot more.

220
00:12:26.140 --> 00:12:28.404
It's a lot more sophisticated.

221
00:12:28.404 --> 00:12:30.970
Now [COUGH] I'm gonna make this statement.

222
00:12:30.970 --> 00:12:35.180
There is an asterisk here,
when I say JavaScript organizes its scopes

223
00:12:35.180 --> 00:12:39.140
by functions, that's not entirely true.

224
00:12:39.140 --> 00:12:43.150
We are gonna talk about block
skipping later in this unit, but for

225
00:12:43.150 --> 00:12:45.860
now, we're gonna simplify things and

226
00:12:45.860 --> 00:12:50.140
say the individual unit of
scope is the function, okay?

227
00:12:52.780 --> 00:12:57.780
So here's a piece of code
that is deceptively simple.

228
00:12:57.780 --> 00:13:00.300
This piece of code

229
00:13:00.300 --> 00:13:03.540
doesn't even look like it does much
cuz it just makes some variables.

230
00:13:03.540 --> 00:13:07.550
There's no logic or branching or
looping or any of that stuff.

231
00:13:07.550 --> 00:13:09.790
So you'd be inclined to just
sort of skip over it and say,

232
00:13:09.790 --> 00:13:11.690
well, this isn't all that interesting.

233
00:13:12.740 --> 00:13:15.600
I'm probably gonna have this slide up for
like 20 or 30 minutes,

234
00:13:15.600 --> 00:13:19.250
because there's way more to
this than you think there is.

235
00:13:19.250 --> 00:13:24.200
For us to fully unpack what it means for
this to be a two-pass system, to start

236
00:13:24.200 --> 00:13:28.340
to rewire our brains to think a little
bit more like the JavaScript engine.

237
00:13:28.340 --> 00:13:31.500
The vast majority of the complexity of

238
00:13:31.500 --> 00:13:35.440
compiler theory is not stuff we
need to concern ourselves with.

239
00:13:35.440 --> 00:13:37.312
People like me like to obsess about it,
but

240
00:13:37.312 --> 00:13:42.990
it's not necessary that you be a compiler
theorist to understand JavaScript.

241
00:13:42.990 --> 00:13:47.680
But there are a few things that you should
be at least moderately aware of, okay?

242
00:13:47.680 --> 00:13:51.370
So I will use a few different terminology,
a few different concepts.

243
00:13:51.370 --> 00:13:54.670
But for the most part,
the only thing we're really concerned with

244
00:13:54.670 --> 00:13:57.590
is in that first pass when we
compile the code, we wanna look for

245
00:13:57.590 --> 00:14:01.740
all the variable declarations and
all the scopes that they get added to.

246
00:14:01.740 --> 00:14:03.640
That's the important part.

247
00:14:03.640 --> 00:14:07.570
Don't worry about tokenization or abstract
syntax trees or any of that other stuff.

248
00:14:07.570 --> 00:14:10.966
All we wanna care about is how
do those buckets get created and

249
00:14:10.966 --> 00:14:14.306
how do we sort those marbles
into those different buckets?

250
00:14:14.306 --> 00:14:14.960
Make sense?

251
00:14:17.704 --> 00:14:18.964
&gt;&gt; Kyle Simpson: So to do that,

252
00:14:18.964 --> 00:14:24.960
I've got a little trick that I
do when I teach this material.

253
00:14:24.960 --> 00:14:28.460
And it's gonna feel silly and
a little bit strange.

254
00:14:28.460 --> 00:14:30.540
If you're listening live or

255
00:14:30.540 --> 00:14:34.800
if you're watching this video later, even
if you're not actually physically here,

256
00:14:34.800 --> 00:14:38.390
I'm going to encourage you to do this,
even if it seems silly.

257
00:14:38.390 --> 00:14:43.090
I'm gonna take you through a little
exercise here where we have an out loud

258
00:14:43.090 --> 00:14:50.300
conversation, and the things that we say
are gonna sound a little bit ridiculous.

259
00:14:50.300 --> 00:14:53.180
But it's okay because we're
just doing this all together.

260
00:14:53.180 --> 00:14:55.710
So we're all gonna sound
ridiculous together.

261
00:14:55.710 --> 00:15:00.671
It's a little teacher trick that
we use to help something that's

262
00:15:00.671 --> 00:15:04.743
a bit abstract get stuck
virally in your head, okay?

263
00:15:04.743 --> 00:15:06.990
So I'm just being completely
transparent about it.

264
00:15:06.990 --> 00:15:10.880
It's silly on purpose because it helps
something that you otherwise wouldn't

265
00:15:10.880 --> 00:15:12.970
really think about that much.

266
00:15:12.970 --> 00:15:13.900
It helps it get stuck.

267
00:15:13.900 --> 00:15:17.420
And the important part is not that
you'll ever repeat this exercise.

268
00:15:17.420 --> 00:15:20.270
You'll never actually say
these things ever again, but

269
00:15:20.270 --> 00:15:23.450
the concept will get stuck
virally in your head, okay?

270
00:15:24.530 --> 00:15:27.520
So we're gonna go through a conversation

271
00:15:27.520 --> 00:15:29.579
that the different parts of
the JavaScript engine have.

272
00:15:30.610 --> 00:15:33.260
A fancy word,
we're gonna anthropomorphize.

273
00:15:33.260 --> 00:15:36.850
That means to take something that's
not a human and treat it as if it is.

274
00:15:36.850 --> 00:15:41.120
We're gonna anthropomorphize the parts of
the JavaScript engine that are relevant

275
00:15:41.120 --> 00:15:47.450
and eavesdrop on a conversation that's
occurring as this code is being processed.

276
00:15:47.450 --> 00:15:49.650
And I style it as a conversation so

277
00:15:49.650 --> 00:15:54.926
that we understand the different
responsibilities and how they're divided.

278
00:15:54.926 --> 00:15:59.198
So that's why we talk as if these are two
different people having a conversation.

279
00:15:59.198 --> 00:16:02.010
And we're gonna go through
this in two passes.

280
00:16:03.030 --> 00:16:07.684
So the first pass through this code, we're
going to be doing that compiling step,

281
00:16:07.684 --> 00:16:09.821
that looking for lexical scope step.

282
00:16:09.821 --> 00:16:14.741
And [COUGH] we're going to be having
a conversation or listening in or

283
00:16:14.741 --> 00:16:19.420
pretending to have a conversation
between these two entities.

284
00:16:19.420 --> 00:16:22.090
The first one would be
the compiler itself.

285
00:16:22.090 --> 00:16:24.040
It's actually processing the code.

286
00:16:24.040 --> 00:16:27.009
And the second one is gonna
be the scope manager.

287
00:16:27.009 --> 00:16:29.921
That's the kid at the playground
that manages the buckets and

288
00:16:29.921 --> 00:16:33.040
puts the marbles into the bucket buckets,
okay?

289
00:16:33.040 --> 00:16:37.840
These two are gonna have a conversation
as this code is processed.

290
00:16:37.840 --> 00:16:40.990
And the goal is to set up those
buckets and properly sort the marbles.

291
00:16:42.530 --> 00:16:45.432
And that conversation is gonna
start a little something like this.

292
00:16:45.432 --> 00:16:47.530
We're gonna start on line one.

293
00:16:47.530 --> 00:16:50.073
We're gonna be looking for
formal declarations,

294
00:16:50.073 --> 00:16:53.810
formal declarations of variables and
formal declarations of functions.

295
00:16:54.880 --> 00:16:59.190
Line 1 is a formal variable declaration
because we see the var keyword there.

296
00:16:59.190 --> 00:17:02.560
Line 3 is a formal function declaration
cuz we see the function keyword there.

297
00:17:03.630 --> 00:17:06.830
There are informal declarations
which we do not care about.

298
00:17:06.830 --> 00:17:08.990
We're only looking for formal ones, okay?

299
00:17:10.910 --> 00:17:12.560
So we get to line 1.

300
00:17:12.560 --> 00:17:15.300
We're the compiler, and we're gonna
be talking to the scope manager.

301
00:17:15.300 --> 00:17:20.000
We get to line 1, we're gonna say,
I'm the compiler speaking.

302
00:17:20.000 --> 00:17:23.030
Hey, global scope manager,
because I'm in the global scope, so

303
00:17:23.030 --> 00:17:24.380
I'm talking to the global scope manager.

304
00:17:24.380 --> 00:17:27.853
Hey, global scope manager,
I found a formal declaration for foo.

305
00:17:27.853 --> 00:17:30.730
And then I'm gonna ask this question,
I'm gonna say, have you ever heard of him?

306
00:17:31.940 --> 00:17:34.260
Now the question might seem irrelevant,
but

307
00:17:34.260 --> 00:17:36.690
actually the question is really important.

308
00:17:36.690 --> 00:17:41.640
Because the question lets you in on
that division of responsibility,

309
00:17:43.400 --> 00:17:45.610
and that's important to keep straight.

310
00:17:45.610 --> 00:17:48.740
So the compiler is saying,
I don't know whether this variable exists.

311
00:17:48.740 --> 00:17:52.189
Who's the only one that can answer
if this marble's ever been found?

312
00:17:52.189 --> 00:17:53.870
The scope manager.

313
00:17:53.870 --> 00:17:57.210
So hey, scope manager,
you ever seen this red marble before?

314
00:17:57.210 --> 00:17:59.480
I have a formal declaration for
a variable called foo.

315
00:17:59.480 --> 00:18:00.270
Have you ever heard of him?

316
00:18:00.270 --> 00:18:05.690
And there's only two answers,
yes or no, okay?

317
00:18:05.690 --> 00:18:06.766
In this case, what's the answer gonna be?

318
00:18:06.766 --> 00:18:07.266
&gt;&gt; Students: No.

319
00:18:09.150 --> 00:18:10.570
&gt;&gt; Kyle Simpson: No, never heard of him.

320
00:18:10.570 --> 00:18:15.260
But now that you mention it, I'll go ahead
and put that marble into the red bucket.

321
00:18:15.260 --> 00:18:17.820
So now we have a red bucket
with a red marble in it.

322
00:18:17.820 --> 00:18:20.295
The variable foo has been
registered into the global scope.

323
00:18:20.295 --> 00:18:24.761
Okay, we didn't pay any attention to what
was going on on the right-hand side,

324
00:18:24.761 --> 00:18:27.268
the equal sign that's all executable code.

325
00:18:27.268 --> 00:18:28.820
We'll get to that later.

326
00:18:28.820 --> 00:18:32.420
All we care about now is these formal
declarations and sorting out the marbles.

