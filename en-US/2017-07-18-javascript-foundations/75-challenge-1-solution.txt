[00:00:00]
>> Kyle Simpson: Let's talk about exercise one. Hopefully you felt you had adequate time to get yourself acquainted with that code and with what it is supposed to be doing, and had a chance to dig through it. So I wanna point out a little resource that may not have been obvious if you looked at the file system.

[00:00:19]
But in the exercise folder, not only do I provide the solution file for each of these exercises, which by the way, there's not always only one right way, okay? So if yours differs from it, don't feel weird or whatever. There's multiple ways to approach it. This just represents one good way of going about it.

[00:00:39]
But in addition to that, what I also provided was a diff between the exercise file and the solution file in each of those directories, it's called diff.txt. And that's just the side by side diff output from comparing those two files. So for example, if I open up the diff here, you'll notice, and of course, I need to turn off my word graph here.

[00:01:05]
You'll notice that I have a side by side diff going. Might be easier to look at this in VI or in the terminal or something like that. Seems like my spacing and my editor is going weird here. I don't know why my editor's not looking at things correctly.

[00:01:22]
Look at it in your console [COUGH] in VI or something like that or count the output of it. But that should be a resource for you to be able to look and check to make sure that you addressed each of the things that I addressed. So we'll kind of walk through a few of these things.

[00:01:36]
The README said to check to see if there were strings that should have become numbers or vice versa. There were a couple of places where that ended up happening, so I wanted to point those out. The first is if we look in this click handler right here, the one that starts on line ten, this click handler is what happens when you click the button to add the entry that you've put into the form.

[00:02:02]
And you'll notice that we're pulling those values directly out of the form and then passing them along to this add to work function on line 23. We're just passing them along as is. Now the projectID and the minutes are actually numbers, and there are places where we rely upon those to be numbers so that they're matching correctly.

[00:02:23]
In particular, the projectID, we hard code the project in, like the project name. But the ID for the project, when it's generated, if you come to the addProject function, you'll notice that that's a randomly generated number. So whatever number is passed in from the Select box, we need to make sure that's a number because there's gonna be a check done.

[00:02:47]
That check happens right here. To check to make sure that the projectID that's passed in is the same as what's in the projects element. And you'll notice I'm using a === there to make sure that it exactly matches. So one option would have been for you to relax that with a ==.

[00:03:04]
That's one way of approaching it. And typically speaking, I would generally say, yeah, that's not a bad idea for there to be a == there. What difference does it make whether if it's the string, or the number equivalent? But I'm actually gonna do it the other way, because there's a bigger question at play.

[00:03:21]
Because minutes definitely needs to be a number. So as a rule of thumb, I don't wanna pass around or propagate a piece of data through a system if it's not yet in its appropriate type representation. So the first place for me to fix that is right here. So I could fix that by explicitly coercing both the projectID and the minutes to the number form.

[00:03:45]
So I'm gonna use the Number function to do that.
>> Kyle Simpson: [COUGH] Now I don't to change that === to a == because we're ensuring that in all places where the projectID is compared, it's a number. So the === is fine. You could also simplify it to a == based only on the notion that if they're both numbers, there's no reason for the === here.

[00:04:17]
The == suffices, cuz they're of the same type. So either way you wanted to go about that, you could set it as == or leave it as ===, okay? Now that we've made the minutes into numbers, you might have then started to notice, if you tried it, you might have then started to notice that when it was printing out the time, it was clearly doing some concatenation with an undefined value or something like that.

[00:04:41]
That's because currently the addition of those minutes is not happening with a value that's already guaranteed to be zero. So for example, right here when we keep track of the project, the total project time, we're just saying project time essentially incrementing by that number of minutes. But if projects.time has not already been set to some number, then now we're concatenating or adding undefined with minutes and that's gonna end up as NaN, right, because undefined coerces to NaN.

[00:05:12]
So there's a couple of ways you could have solved that. You could have, in the project entry, you could have forcibly set, right here you could have forcibly set time to 0. That's one way of doing it. You could initialize it to 0. The other way of doing it, which was a little bit more coercive, is to coerce this thing to definitely be a number, or to ensure that this is definitely a number using what we know about coercion.

[00:05:37]
Here the default value idiom might have been appropriate. So we could have said, projects.time || 0. Cuz if it's not already set, or even if it was set, but it was set to zero, it doesn't matter. We can use zero as the base point for that numeric addition.

[00:05:52]
So the default idiom seems to be a little bit more appropriate here for encoding our intent, which is, our intent is if it's not already set, just use zero as the base point. There's another place where that happens and that is,
>> Kyle Simpson: Let's check where we add up the work.

[00:06:14]

>> Kyle Simpson: That happens right here. Again if the project entry doesn't already have the time, so we can default idiom, the project entry to 0.
>> Kyle Simpson: Okay, so that should take care of the items unless I'm forgetting something. That should take care several of these items. But there's a couple of other places where things still wouldn't be working correct.

[00:06:39]
In particular, and you might have discovered that the output when we formatted the time, the output seemed to be incorrect. And it's because I intentionally have the order of operations here not saved to the type conversions that we're doing. This is something obviously that TypeScript would have caught for you.

[00:06:56]
So this is one of those examples of places where people would say, well, TypeScript would have let me know that my variable was changing types. But you'll notice that here I change minutes to be a string and then I rely upon minutes to be checked to see whether it's 0 to just return the empty string.

[00:07:18]
You might not have caught that unless you tried to enter in no time for an element and it should have printed out as empty, and it might have been printing out as something different, perhaps with a NaN or something. So [COUGH] here the order of those two operations needs to be swapped.

[00:07:35]
Because we can't rely upon, now line 150, needs to rely upon minutes still being a number if it's gonna do that comparison against 0. We can't change it to be a string and especially a string that would have other stuff in it, or it wouldn't compare.
>> Kyle Simpson: Okay?

[00:07:59]

>> Kyle Simpson: Next we need to look at the validateWorkEntry function and implement those validation rules. First, the rule is that the description text needs to be at least five characters long. Rather than reimplement this function, I'm simply gonna switch to the solution file, and show you how I did that.

[00:08:15]
You'll notice that description.link, if it's less than five, I return false. I have a bias here in my validate functions to always return a boolean. A false or a true. Sometimes people just do an early return, and then rely upon, the undefined that gets returned as coercing to a false value, because you'll notice, we use the validateWorkEntry here, we just do a boolean check against it.

[00:08:47]
So you could just do a return here without anything, but I think this more clearly communicates the intent. I'm affirmatively saying, the validation failed by saying return false, and the same down here with true. I'm saying, if we get to this point, the validation clearly succeeded and I'm returning true.

[00:09:06]
Make sense? So my description check, length check, if it's less than five, that's a failure. The read me says to also make sure that minutes has to be a non-empty value ignoring the leading and trailing white space. So I kind of knew right of the bat, okay I'm gonna need something like a regular expression or something like that to ignore.

[00:09:29]
So the first thing is, if I enter in something consisting only of white space, that's what this check is doing. If I have something consisting only of white space, or if it's empty, cuz I use the star here, then that lets me know that this was a failed entry.

[00:09:47]
You'll notice in the read me it says, leaving minutes blank is not valid, it's invalid. So I wanted to check to make sure that I wasn't leaving minutes blank. [COUGH] I also wanted to check to make sure that what was being put into minutes could validly be coerced to a number.

[00:10:05]
So I first coerced it to a number and then checked to make sure that it wasn't NaN, and I used Number.isNaN. I could have also used Object.isThere if you prefer, and then I checked to make sure that minutes, given that I knew that it was in the correct range, I checked to make sure that minutes was within the appropriate range where it wasn't less than 0, so it wasn't negative, and it wasn't greater than 600.

[00:10:27]
That allows me then to set a minutes of zero, if I didn't wanna log any time against a particular work action.
>> Kyle Simpson: The less than and greater than here are taking advantage of implicit coercion. I did not, at the top of my validate function, explicitly coerce minutes to a number, and then do my checks against numbers.

[00:10:52]
Why didn't I do that? Anybody spot why?
>> Speaker 2: Cuz you have-
>> Speaker 3: Is it the regex?
>> Kyle Simpson: What's that?
>> Speaker 3: The regex.
>> Kyle Simpson: Yeah, because I wanted to test, if I had coerced minutes to a number, like if I had said minutes = Number(minutes), cuz the first time I was making this exercise that was my first approach, and then I thought, well wait a minute.

[00:11:17]
What happens if somebody leaves it blank? It's an empty string, and what's that gonna coerce to? That's gonna coerce to zero. Zero is supposed to be an allowed value here, according to the validation rules, that's an allowed value, but empty is not an allowed value. So I can't coerce first before I check whether or not it's been passed in as an empty string.

[00:11:39]
Make sense? So I needed to do my check first against the string value, and then do my check against the coerced value. I took advantage of the fact, on lines 35 and 36 here, that the less than and greater than operators will automatically coerce those to numbers, since they're doing a comparison with numbers.

[00:12:02]

>> Kyle Simpson: And that represents the work to do on the exercise. So, what questions can I answer about exercise one?
>> Speaker 4: Can you please explain what happens if you remove the line Number.isNaN?
>> Kyle Simpson: This one?
>> Speaker 4: Yeah, I mean what case? I just don't quite get what case that it won't work correctly.

[00:12:24]

>> Kyle Simpson: So if we compare a string with a number, like if minutes came in as a string and it was something other than a number representation, then what would happen, let me just. I'll literally comment it out, I got to remember to undo it, but I'll literally comment that out.

[00:12:50]

>> Kyle Simpson: So, if I type in a,
>> Kyle Simpson: You notice that it allowed it through. Now, why did it allow it through? It obviously ended up failing with this NaN thing. Why did that pass through the validation function? Well first of all it failed this check, right, but then we asked the question is quote a less than zero?

[00:13:12]
That's the first question, and when there's a string involved it's gonna actually do a lexicographic check, which is alphabetic character check in ASCII code.
>> Speaker 4: So it changed,-
>> Kyle Simpson: And quote a is not less than zero.
>> Speaker 4: Okay.
>> Kyle Simpson: And it's also not greater than 600, okay? So it failed both of those tests because NaN, even though it was doing the number check, NaN is not less than zero, nor is it greater than 600.

[00:13:40]
So either lexicographically or numerically NaN would pass through just fine, which is not what we want. So we need to test for the NaN.
>> Speaker 4: So when in comparison, it first converted to a number, which will make it a NaN, and then automatically?
>> Kyle Simpson: Well let me answer that definitively by modeling for you how you should be answering these questions.

[00:14:06]
You don't have somebody's book handy, which we could go and look at my book, but let's just see what the spec has to say. It is section 7, of the abstract operations.
>> Kyle Simpson: And operations on objects.
>> Kyle Simpson: All right, so these are those algorithms, you remember the abstract equality one, right?

[00:14:43]
We looked at that one already 7.2.13 Abstract relational comparison is the less than and greater than. So let's see what this algorithm says, let's see if I can figure out what it's talking about here. The comparison x < y, where x and y are values, produces true, false or undefined.

[00:15:02]
In addition, it takes a Boolean flag named LeftFirst as a parameter. We're gonna assume LeftFirst. So we were asking if the string a was less than zero, why would that fail? So it said, if the LeftFlag is true, which it would be, then we wanna take primitive of x, which it's already a primitive.

[00:15:29]

>> Kyle Simpson: Okay, so here it says, if both comparisons are already strings, then it's gonna do a lexicographic comparison, that's what it's doing here. It's gonna look at the string characters and do that comparison, otherwise it's gonna make them both into numbers. So it would of taken that quote a, and make it into a number, and then it had the zero, and it would have said, is NaN less than zero?

[00:15:48]
So then we have here,
>> Kyle Simpson: Let's see, nx. Nx would be NaN because it was the quote a that got coerced through a number so now it's the number representation of it. It's saying if nx is NaN return undefined. So that less than operation wouldn't have returned false it would have returned undefined, but undefined is a False value, right?

[00:16:18]
So that would have failed that condition. The exact same logic applies when we try the quote a greater than 600 is that it's gonna make quote A into NaN and NaN is not greater than 600 for the exact same reason. So both would have been undefined and undefined and both of those are false, those test.

[00:16:36]

>> Speaker 4: It's just my approach was different. I used a return, and I actually compared that this is greater or equals than 0, less than or equals 600. That's why it worked in my case.
>> Kyle Simpson: Okay, so the greater than or equals actually does something interesting, and I won't get fully into that.

[00:16:57]
This is covered in the types of grammar book. But we think that greater than or equals does the same thing as doing greater than or an equality comparison. Turns out greater than or equals, does the less than and negates the result. So what was the less than? The less than was undefined.

[00:17:16]

>> Speaker 4: Was undefined.
>> Kyle Simpson: And then it would have negated that to make it true.
>> Speaker 4: True, okay.
>> Kyle Simpson: So that's why it worked. So one of those happy accidents for you.
>> Speaker 5: So as for a bonus for this exercise, you ask how would you go about writing simple tasks to test the behaviour of this application.

[00:17:34]
How would that be different from the function validate work entry? Is the function validate work entry just kind of a date validator?
>> Kyle Simpson: It's an input validator but that's not testing the application. I remember by testing the application is, if I call the add work entry or whatever that function is called.

[00:17:57]
Add work to project, if I called add work to project from certain set of inputs Does it actually end up producing the dom elements that I expect in exactly the right place with exactly the right contents, right? That' kind of an integration level test. There are also unit level tests that can be performed on several of these, like for example to find project entry, I can validate that if I pass in a specific project ID I get the project entry, if I pass in a non-existent one I get nothing.

[00:18:21]
So there's both unit tests and integration tests that you could do here. I wasn't actually expecting you to do that, I just wanted you to think about how would I test this project? I'm glad you brought that up though, because as we get further along here, you may find it to be useful because this is certainly what I did when I was writing the code.

[00:18:41]
Did I go back and fix that thing? You might find this useful.
>> Kyle Simpson: I didn't fix that.
>> Kyle Simpson: That should give us an error and it does. So what I did is, I was doing this to make sure as I did each iteration of this project, that it still did the correct thing, is I actually had sort of a unit test or integration test.

[00:19:18]
I guess, more integration test that I just ran in the console of my browser. So I basically called a set of calls. I said addWorkToProject. And I said, since I knew projects was a public array, I could get at whatever the ID was that was randomly generated for the first project.

[00:19:38]
And then give it a really long comment and then some number. So this was basically my integration test that when I ran that, I expected to see exactly this behavior where I had 114 as my output and 36 or whatever. So I just visually made sure that every time I made all these to the code that this code ran, gave me the exact same results.

[00:20:01]
I didn't verify it fully as a test week, but that was kinda my Ad hoc testing. Then may be useful to you as you go through your exercises 2 through 8 to come up with some kind of test like that for yourself. Okay, so that represents our first core.

[00:20:16]
The types and coercion system. Again, the takeaway there is to hope that you will look at types and coercion with a fresh set of eyes. And ask how can I use that appropriately, as opposed to just ignoring that topic or make a link to remove any possibility of it.

[00:20:33]
Where are places that I can use my knowledge correctly to make my code better, more expressive more readable?

