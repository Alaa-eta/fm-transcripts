[00:00:00]
>> Kyle: A third way for a function to be called is with a .call, or the .apply method. Look at line 9. I'm calling foo, but I'm actually calling it using foo.call. I could have said, foo.apply as well. You'll notice that the first argument passed to both call and apply is used as the this binding for that function.

[00:00:22]
So, here we are explicitly saying, call foo, and use obj as it's this context. Which is why we get bar2
>> Kyle: That's a third way for a function to be called. So, three rules down, default rule, implicitly binding rule, explicit binding rule. We're gonna take a slight detour and talk about a variation of explicit binding, which is a problem that we often run into, you may have run into this before.

[00:00:54]
It's often referred to informally as losing the this binding, or having this unbound. What happens is the function call site is the important part. So, let's say you take a function like, for example, the one from line 10. And you pass in 02.foo as a callback to some other utility.

[00:01:16]
And when that utility invokes the function, what is it's call site gonna look like, it's gonna override, or throw away the 02 this binding that you otherwise normally would have, because it's the call site that matters. So, one of the problems that we have is when we make this this aware functions, we are not in control of how they're going to be invoked.

[00:01:39]
And if we're not in control of how they're being invoked, then we cannot predict what this keyword is going to point to. It's called losing your this binding, everybody follwoing that? So, let's imagine this scenario where I could do something called hard binding. If I wanted to pass in a function, or if I wanted to make a function that no matter how it was called and had a predict of all this.

[00:02:04]
On line 11, I have made, I am calling what is referred to as a hard bound function. Look at how foo is defined on line 9. Foo is defined on line 9 to hard-code the .call into it, so that it forcibly says, use obj no matter how you're called.

[00:02:25]
Which is why on line 12 if we try to overwrite it, it just silently ignores that and says, thanks very much I'm going to use obj. So, line 12 would actually still print out bar, not bar2.
>> Kyle: Now, that pattern of making a function that hard binds it, that explicitly says, using .call, or .apply, the reason why this is not a new rule, but a variation is, because under the covers, it's using a .call, or a .apply, which is explicit binding.

[00:02:58]
But we don't want to go making these functions ourselves. That's ugly to have to make a function like we do on line 9. We could make the utility for that, and it turns out that there's a utility built into JavaScript to make these hard bound functions and it's called .bind.

[00:03:14]
On line 7 I make a hard bound version of foo by calling .bind, and the first argument that I passed in obj is the this that it will be hard bound too. So, now, on line 9 when I call it, it doesn't matter how I call it, it's always gonna use the obj as it's this.

[00:03:37]

>> Kyle: That's called a hard bound function. So, any time you've got a function that is this sensitive, or this aware, and you reference it and pass it in somewhere, and you're not going to be in control of the call site, the way to solve that problem is to instead of passing in the function itself, pass in a hard bound version of the function.

[00:03:58]
And then you know it's always going to be used calling the this that I want it to be called. Okay? Now, I want to stop for a moment and ask you to analyze, think critically for a moment. Do we see the benefit to gaining some predictability here with these functions when you say, I want it to always use, I want to lock it to this specific this?

[00:04:24]
Do we see the benefit that allows us to pass those functions around and not worry about them losing a this? What's the downside?
>> Speaker 2: You lose flexibility.
>> Kyle: You lose the flexibility, right? Isn't the whole reason for that this keyword to have flexibility? What other system have already learned about in this workshop where we get predictability?

[00:04:58]

>> Kyle: Lexical scope? Remember that? Lexical scope is all about being fixed at all through time, it's all about predictability. That this keyword is all about flexibility, using a function in multiple different contexts. So, wait a minute, we've just created a pattern which shoots ourself in the foot. Hard binding takes this whole dynamic system and throws away all the dynamicism and makes it predictable again.

[00:05:24]
Why would we want to do that? What I'm getting at here is that there is a tension between flexibility and predictability. There's no one right answer here, there's a tension. And, because there's a tension, you have to make subjective judgment calls as to which is the appropriate mechanism.

[00:05:44]
So, let me share with you a heuristic that I use to determine, am I doing things the appropriate way? Is this best practice? Say I architect my code and I've got all these this aware functions defined on some object named space somewhere. And let's look at all of my call sites, and let's imagine that on all of my call sites, they all look like maybe this one.

[00:06:09]
They all look like o2.foo, okay, great. No big deal, because I'm using the system the way it's appropriately designed. And let's say every once in a while I have to make one of these hard bound versions like we see here on line 7 of this slide. Every once in a while I have to make a hard bound version, but most of the time it just say o2.foo.

[00:06:31]
In that scenario I am taking full advantage of the dynamicism and every once in a while inserting back in some predictability. I would say that is a reasonable usage of this mechanism. On the other hand, if I went to all the trouble to put this dot in front of every single property and method reference.

[00:06:53]
And then, I find myself having to do hard binding everywhere, I might then step back and say, [SOUND] maybe I should just switch the Lexical Scope, because it appears that the flexibility isn't actually that important in this piece of code, it appears that predictability is more important.
>> Kyle: The truth is, different parts of your code will answer that tension differently.

[00:07:17]
Some parts of your code, the predictability will be more important, some parts, the flexibility will be more important. You are a better JavaScript developer, if you can use both of those techniques appropriately in your code, not one, or the other. JavaScript is great in part, because it has both available to you.

[00:07:35]
Using one all the time is not appropriate, I know that's our instinct, we want just give me that one pattern to rule them all, give me the one ring to rule them all, but what I'm really saying is, you need to learn to use both systems. For what they're better at.

[00:07:52]
If flexibility is important, if reuse of a function across multiple contexts is important, use this aware programming. If predictability is more important, the lexical system is better at that.

