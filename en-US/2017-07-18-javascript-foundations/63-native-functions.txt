[00:00:00]
>> Kyle: Let's turn our attention to natives. I've listed out for you, and you notice that they all have capital letters here. I've listed out for you the built-in natives. There are actually more than these, but these are the ones we'll pay attention to. These might look familiar because these might look to you like these are the built-in types that you see in Java.

[00:00:17]
For example, like capital String, it looks like the capital String class that's built into Java, so it'll be tempting to think of these as native types. Many people will refer to them as native types. They're not actually dealt with as types in from the perspective of the spec, if you read the specification for JavaScript, it does talk about these.

[00:00:38]
And as a matter of fact, calling them natives is not even fully agreed upon, that's just kind of a term of art that people seem to have settled upon. But I've heard people have different answers as to what these should even be called. So they're not really types, they're not really objects, although in a sense, all functions are objects, so they're kind of objects.

[00:00:58]
But calling them native objects can sound a little bit strange. The capital Object is definitely used more like an object than a function, but it's not really appropriate to call them, you would typically think of them in the context of what you did with Java, where you put the new keyword in front of them and called them as a constructor.

[00:01:14]
So you might think of these as native constructors. But I really think the most appropriate way to approach these is that you virtually, in almost all of these cases, you will never want to call them with the new keyword. As a matter of fact, most of these cases, you'll wanna call them as regular functions.

[00:01:31]
So I think maybe we should just call them the native functions. And capital Native, we don't mean native like built-in, that's a special thing to distinguish it from the primitives, okay? So what are these things? Well used as constructors, they definitely produce a representation of the value that is similar to the primitive equivalent.

[00:01:52]
So if I called new capital String, I'm gonna get a thing that seems like it's related to the actual primitive string. But they're not really the same, they're just a different representation. As a matter of fact, kind of an object wrap around. Same thing with numbers, same thing with boolean.

[00:02:06]
Now some of these act as, there are differences here, there's not a lot of consistencies. So some of these will act as constructors, meaning you have to call them with new or if you don't, they'll behave differently. Some of them will act as constructors regardless of whether you call them with new.

[00:02:23]
Like the function will produce a dynamic function regardless of whether you use the new keyword with it. Object will do a different thing, array doesn't need the new keyword, regex doesn't need the new keyword. So some of these require the new keyword and some of them don't, so there's some weird inconsistency, but I think it's more appropriate to think of using them as functions.

[00:02:43]
So if we compare, for example, what happens when we call new capital String and pass in some value when we ask, what is foo there on line 2? Turns out that foo, if we represent it, if you tried that in your console, it's actually gonna be represented as an object.

[00:03:00]
It'll be represented as an object that has properties like 0, the value f, and 1, with the value o, and 2 with the value of, so it presents itself almost like an array like object. And it has these weird special built-in properties like bracket, bracket, primitive value, and other strange things like that.

[00:03:20]
Another battle that I fought with the browser vendors by the way, because the way they represent these values in the developer console, is in large part, going to contribute to whether or not you understand what you're doing, or whether you're confused as a developer. And Firefox used to be the worst offender of this.

[00:03:37]
They would represent the String object as almost identical to the String primitive, the only difference being that the String object they printed in italics. And I'm like, are you kidding me? You expect developers to distinguish in the font between italic and non-italic, and that's how they know whether it's an object or a primitive?

[00:03:54]
That is just deliberately asking for people to be confused. Finally they changed that, and they actually changed it according to my recommendations. I'm still waiting on Chrome to catch up with it, cuz Chrome's representation is bad in a different sort of way. Okay but these are objects, they're not primitives, that's the takeaway here.

[00:04:14]
And if you do typeof foo, you're gonna get quote object because it's a real object, it's not some special kind of string thing. The way to think about that is it's a wrapper object around the primitive string value, the one that we passed in quote foo. [COUGH] Now you'll notice on line 7 I called the string function without the new keyword.

[00:04:35]
The string function when used as a function rather than used as a constructor, it does something very different. Instead of constructing an object wrapper around a value, it actually coerces whatever you pass in to that primitive value type. Capital String used as a function without the new keyword will take whatever you pass in, even something like the number 42, and coerce it to a primitive string.

[00:05:01]
So it would say quote 42, would be the output. That is a vastly more useful mechanism to us than creating these weird string object things that nobody actually wants to deal with in JavaScript anyway. So my recommendations specifically for string, number, and boolean, use them as functions, specifically for coercion, don't use them as constructors with the new keyword.

[00:05:27]

>> Kyle: Line 10 would produce a number object wrapped around the 37 value, that's strange, okay? Examples of the strangeness that you might get if you represent these things as objects like a Java developer would typically do. If you said number of zero. Zero as a primitive value is falsy.

[00:05:48]
Zero as a number object is truthy, you're setting yourself up for failure then. Same thing with boolean. False as a boolean primitive is falsy. False as a boolean object is truthy, okay? Don't construct these objects, there's just no reason for them. They will set landmines not only for yourself, for your future self, but also your other teammates, okay?

[00:06:19]

>> Kyle: Array, the array constructor has its own set of problems. But the nice thing about array is that there is a literal syntax that we can use instead, the square brackets that we see on line 5. The literal syntax is vastly preferred to the constructor form. Use the literal form wherever possible, don't use the constructor form.

[00:06:40]
There's a got you with this particular constructor, which is if I said new array 42, many people would assume that I would then get an array that was presized. I mean that was set with the value 42 in it because I passed in array 1, 2, 3 and I got an array of 1, 2, 3, so they would think if I passed in a single value.

[00:07:02]
Unfortunately, the array constructor is overloaded. Overloading is never a good idea in software design, but it's overloaded here. To say if you pass in a number and there's only one of them, then that number is considered to be the length of the new array that you wanna create.

[00:07:18]
So we'd actually get an empty array presized to length 42. But that's not even the craziest part. The craziest part, the part that is really legitimately a WTF of JavaScript, is that we have this notion of what's called a sparse array. If I create an array that is empty, and then I set it's length, I literally say array dot length equals, and I say 42.

[00:07:45]
It will present itself as being an array that has 42 slots in it, but only from the perspective of how the console deals with it. If you try to loop over its values with something like .map, it's not gonna have any values to loop over. They're like phantom fake slots, or so called empty slots.

[00:08:06]
This literally, the worst design I've ever seen in any programming. I've seen a lot of crazy, crappy stuff, but to create a value that has phantom locations in it, it's like a giant neon sign that says I am trying to confuse you. I'm trying to make you trip up, I'm trying to create a pit of failures on you.

[00:08:29]
Never, ever, ever, design an array and intentionally create empty slots, and that's what you do when you do array parenthesis and some number. Our notion is for performance, I wanna pre-size my array, right? That's nonsense, JavaScript does not preallocate 42 units of memory for your array. It literally creates an empty array, which JavaScript typically represents as linked list by the way, and it just arbitrarily sets the length property to 42.

[00:08:58]
Thereby making these phantom slots appear that they're there, and they're not really there. So don't ever do it under any circumstances cuz there's no performance benefit, and there is a ton of confusion coming around it. So just don't use the constructor form for array, use the literal, it's always more preferable.

[00:09:17]
Object, Object as a function will take a value, and try to coerce it to its object representation. There are some nuances around it, I don't recommend using Object very often. But new Object() creates an Object instance, exactly the same as the curly brace instance, the curly brace literal form.

[00:09:38]
The literal form is shorter, more straightforward, and technically, slightly more efficient, cuz it's statically analyzable where the imperative property assignment of line 8, 9, and 10 is not. So the literal form here, yet again, is gonna be more optimizable by the engine because it's the declarative form as opposed to the imperative form on line 7 through 10.

[00:10:00]
So again, prefer the literal syntax over the imperative syntax of the constructor.
>> Speaker 2: So the benefit here is really statics and not necessarily performance, right? It's just being a little bit more better in communication.
>> Kyle: I mean there is a performance issue to be gained because we can say okay, great.

[00:10:23]
I know that the engine either already, or eventually, can more statically analyze a literal and know what to do with it. For example, the array literal, it literally can see at the parsing stage how many elements you've added. So it goes ahead and pre-reserves that amount, it doesn't have to add it or whatever, it just knows I'm gonna need these many, and then it puts all of them in.

[00:10:44]
So because it's statically analyzable, it's more efficient that way. Now we're talking about microseconds. But it is more efficient because it's a declarative syntax the compiler can recognize as opposed to line 8, 9, and 10, it's just figuring that out line by line, by line, so it has to keep growing the object every time.

[00:11:02]

>> Speaker 2: Yeah.
>> Kyle: Right, so there is a performance aspect, but really this is more about code communication even than performance. The literal on line 10, and the literal on line 5 communicate more clearly my intent. They're declarative as opposed to imperative.
>> Kyle: There are some where you're gonna want the new keyword specifically for regex, you're gonna need to use the new keyword if you want to dynamically create a regular expression.

[00:11:33]
Now you should prefer the literal syntax if at all possible, because the literal syntax gets compiled once. It doesn't get re-run at run time whereas the dynamic regular expression has to get re-run every time that code runs. So you should prefer the literal from performance, and declarative coding reasons.

[00:11:54]
But there are some times when your pattern needs to be dynamic. Part of the pattern is a value in your program that you've programmatically, logically decided. Then you're gonna need the regular expression constructor form, okay? So it's entirely okay to use that if you have to, prefer the literal syntax if possible.

[00:12:11]
Dates on the other hand, have no literal. This I think is a huge mistake, it's a missing gap in the design of JavaScript. We should have a date literal, dates are pretty important. And we should come up with a good date literal that everybody can agree on, make it the UTC, one of those ISO standards or whatever, just agree upon it.

[00:12:30]
But we don't have that right now. [COUGH] There are some people that are talking about adding it, but we don't have that right now. So if you wanna construct the date timestamp, you have to use the constructor form of the date constructor. You have to say new date, that's gonna construct a new, by default, with no arguments going to construct a timestamp that represents this exact moment.

[00:12:49]
It's kinda the Unix timestamp milliseconds thing, right? Now [COUGH] I will say most of the time that you construct the date object, it's because you wanna get the current timestamp of right now. And if you get a date object, you then have to extract that number timestamp from it by calling a function or coercing it, we'll talk about that later.

[00:13:11]
There's a much better way of getting that and it's called Date.now(). It's a static function, it gives you that timestamp. So you really should prefer not to ever construct data instances if possible. Most of the time you can get away with not needing the constructed data instance. But if you do need to, you're gonna have to use the new constructor to do it.

[00:13:36]

>> Kyle: Pause right there with our literals, and see if there's any questions about literals and natives before we move on to.
>> Kyle: Yeah?
>> Speaker 3: So that example on the previous slide with the curly braces declaring array. If you tried to for some reason it doesn't come back as an array in the console, it's more of an object.

[00:14:00]

>> Kyle: Which one? The curly braces do an object, the square brackets do an array.
>> Speaker 3: Okay that's what I thought.
>> Kyle: So if you do curly braces that's an object, square brackets, array. So question here from Cray, what advantage is a date library like moment in JS? I wouldn't do any date stuff in JavaScript without a good date library.

[00:14:18]
At the moment, JS just happens to be a really good one. I know one of the
>> [CROSSTALK]
>> Speaker 2: It's pretty big though, so there's micro libraries that won't bloat up your project so much. But moments great because it's robust, you can do timezones. You can do timezone math.

[00:14:34]
You can add a few days, you can subtract, you can compare.
>> Kyle: Stream moment has a lot if capability to it. I know one of the maintainers of moment is actually working on getting some of that stuff just built into JavaScript, so we don't need such heavy libraries to do it.

[00:14:48]
Dates are a big gap in behavior of JavaScript stuff. We need the standard library to just grow that capability.

