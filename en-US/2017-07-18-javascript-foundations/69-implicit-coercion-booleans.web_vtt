WEBVTT

1
00:00:00.300 --> 00:00:01.356
&gt;&gt; Kyle Simpson: What about Booleans?

2
00:00:01.356 --> 00:00:04.404
Anybody ever done an if statement before
where you just passed in something that

3
00:00:04.404 --> 00:00:07.060
wasn't already a Boolean,
whoever that done before?

4
00:00:07.060 --> 00:00:10.160
You might not have thought,
I'm doing an implicit coercion.

5
00:00:10.160 --> 00:00:12.510
You might have done so
well writing a blog post saying,

6
00:00:12.510 --> 00:00:17.100
implicit coercion is bad,
that's implicit coercion.

7
00:00:17.100 --> 00:00:20.359
The if statement requires a Boolean and
if you don't give it a Boolean,

8
00:00:20.359 --> 00:00:21.732
guess what's gonna happen?

9
00:00:21.732 --> 00:00:23.215
It's gonna implicitly coerce it.

10
00:00:23.215 --> 00:00:24.619
Does that mean it's bad?

11
00:00:24.619 --> 00:00:27.754
Absolutely not, I think this is one of
my favorite parts of JavaScript that it

12
00:00:27.754 --> 00:00:29.732
implicitly coerces those
things to Boolean, so

13
00:00:29.732 --> 00:00:31.760
I don't have to worry about that detail.

14
00:00:31.760 --> 00:00:32.396
You know why?

15
00:00:32.396 --> 00:00:37.060
Cuz that is not an important
detail on that line of code.

16
00:00:37.060 --> 00:00:42.204
What I'm communicating here is that if
it is truthy, make this thing happen.

17
00:00:42.204 --> 00:00:46.863
I don't need to clutter up that code by
explicitly coercing it to a Boolean, so

18
00:00:46.863 --> 00:00:48.359
that I can do an if check.

19
00:00:48.359 --> 00:00:53.304
The implicit system here is helpful
because it hides the unnecessary noise.

20
00:00:55.298 --> 00:00:57.823
&gt;&gt; Kyle Simpson: I'm a big
fan of line two, but

21
00:00:57.823 --> 00:01:03.184
I don't see how you can be
consistent in your world view point.

22
00:01:03.184 --> 00:01:07.034
To talk bad about implicit coercion and
then code about that,

23
00:01:07.034 --> 00:01:08.744
there are people who do so.

24
00:01:08.744 --> 00:01:12.579
Go look at Doug Crockford's code and
compare that to what he says

25
00:01:12.579 --> 00:01:16.069
about coercion,
compared to what he writes in his codes.

26
00:01:16.069 --> 00:01:20.752
I didn't mean it as an insult, but this is
one those do as I say not as I do moments.

27
00:01:22.569 --> 00:01:23.705
&gt;&gt; Kyle Simpson: I think we
should be more consistent.

28
00:01:25.912 --> 00:01:28.457
&gt;&gt; Kyle Simpson: So string 123,
it's truthy, right?

29
00:01:28.457 --> 00:01:31.409
Cuz it's not on the falsy list,
so we pass the if statement.

30
00:01:31.409 --> 00:01:36.370
The 0 on line 6 is that truthy or falsy?

31
00:01:36.370 --> 00:01:38.589
So on the falsy list, so it's false.

32
00:01:38.589 --> 00:01:40.379
So we're gonna print the right.

33
00:01:40.379 --> 00:01:42.534
Now what about line 10?

34
00:01:42.534 --> 00:01:45.470
Line 10's where things start to
get a little bit strange here.

35
00:01:46.610 --> 00:01:51.937
Cuz it works, we compare 0 to
false with that dreaded ==,

36
00:01:51.937 --> 00:01:56.210
which we're gonna get lots into I promise.

37
00:01:56.210 --> 00:02:01.040
We compare 0 to false and
it turns out that the check passes.

38
00:02:01.040 --> 00:02:04.547
So what's going on?

39
00:02:04.547 --> 00:02:09.074
Here's why I said earlier, I made you
write down in your notes that the rules

40
00:02:09.074 --> 00:02:11.975
for Boolean coercion only
happen if the rules for

41
00:02:11.975 --> 00:02:14.611
Boolean coercion are actually happening.

42
00:02:14.611 --> 00:02:16.703
Remember that whole no op that I said?

43
00:02:16.703 --> 00:02:21.020
Sounded like a Buddhist monk saying
something weird or whatever,

44
00:02:21.020 --> 00:02:23.726
like it only works when it works, right?

45
00:02:23.726 --> 00:02:24.890
Okay, gee, thanks.

46
00:02:26.010 --> 00:02:27.110
Here's what's happening.

47
00:02:27.110 --> 00:02:30.772
When you look at foo == false, 0 == false,

48
00:02:30.772 --> 00:02:36.268
I'm willing to bet that most if not
all of you think to yourselves well,

49
00:02:36.268 --> 00:02:39.220
0 is falsy, so it's gonna be false.

50
00:02:39.220 --> 00:02:44.155
And then I compare false to false,
and of course they're the same,

51
00:02:44.155 --> 00:02:48.147
so we pass the check,
that's not what happens at all.

52
00:02:48.147 --> 00:02:53.948
As a matter of fact, line 10 only
works because of a happy accident.

53
00:02:53.948 --> 00:02:58.526
I don't like relying on happy accidents
in my code, I don't know about you.

54
00:02:58.526 --> 00:03:00.375
Line 10 only works because
of a happy accident.

55
00:03:00.375 --> 00:03:02.180
Here's what actually happens.

56
00:03:02.180 --> 00:03:05.610
We're gonna get into == in a minute,
but I'll just tell you right now

57
00:03:07.280 --> 00:03:11.770
that what actually happens is that
the == prefers to compare numbers.

58
00:03:13.400 --> 00:03:16.290
So what it's actually gonna do
instead of making 0 into false and

59
00:03:16.290 --> 00:03:17.421
comparing the two falses.

60
00:03:17.421 --> 00:03:24.050
It's gonna make false into 0 and
compare the two 0s.

61
00:03:24.050 --> 00:03:25.170
Why?
I don't know,

62
00:03:25.170 --> 00:03:28.424
probably cuz number of comparison is
a lot more efficient in the internals

63
00:03:28.424 --> 00:03:28.956
of the CPU.

64
00:03:31.106 --> 00:03:33.146
&gt;&gt; Kyle Simpson: But
that's the way the algorithm was written.

65
00:03:33.146 --> 00:03:34.905
It prefers to compare numbers.

66
00:03:36.962 --> 00:03:39.633
&gt;&gt; Kyle Simpson: I bet that's another one
of those ones you could trip people on in

67
00:03:39.633 --> 00:03:40.680
an interview question.

68
00:03:42.060 --> 00:03:44.212
Cuz most people never stop to think,
how does that work?

69
00:03:44.212 --> 00:03:46.553
You just assume that
is a Boolean coercion.

70
00:03:46.553 --> 00:03:49.265
Nope, it's not, and here it works.

71
00:03:49.265 --> 00:03:52.370
Your assumption works out okay for
you, but it's a happy accident.

72
00:03:52.370 --> 00:03:55.358
On the next screen, I'm gonna show you
something where that does not work so

73
00:03:55.358 --> 00:03:55.926
well, okay?

74
00:03:58.376 --> 00:04:05.230
&gt;&gt; Kyle Simpson: Line 14, that OR
operator, that pipe that we have there.

75
00:04:05.230 --> 00:04:10.684
Everybody recognizes that as the OR
operator, the &amp;&amp; being the AND operator.

76
00:04:10.684 --> 00:04:11.998
What do those things do?

77
00:04:11.998 --> 00:04:19.278
Well those things are often called logical
operators, that's how they're labeled.

78
00:04:19.278 --> 00:04:22.047
That's how they're labeled in
the official spec in the documentation.

79
00:04:22.047 --> 00:04:24.690
They're called logical operators,
why do you think they're called that?

80
00:04:25.840 --> 00:04:29.818
Well because in their original design,

81
00:04:29.818 --> 00:04:37.082
they produced a logical value aka true or
false, that was their purpose.

82
00:04:37.082 --> 00:04:39.931
Their purpose was to produce a true or
false.

83
00:04:39.931 --> 00:04:45.179
That is not how these operators work
in JavaScript or Ruby or Python.

84
00:04:45.179 --> 00:04:47.470
The difference is subtle, but
actually pretty important.

85
00:04:48.570 --> 00:04:53.090
The OR operator here is not
producing a true or a false.

86
00:04:53.090 --> 00:04:55.400
Baz is not going to be true or false.

87
00:04:55.400 --> 00:04:56.956
Baz is going to be quote foo.

88
00:04:56.956 --> 00:04:59.202
Woah, woah, wait a minute.

89
00:04:59.202 --> 00:05:01.229
The end result is not a logical result.

90
00:05:01.229 --> 00:05:06.530
The end result is that we actually
just picked one of the operands.

91
00:05:08.370 --> 00:05:12.630
The OR operator and
the AND operator, these so

92
00:05:12.630 --> 00:05:16.960
called logical operators, actually
are more like selection operators.

93
00:05:18.060 --> 00:05:24.386
They take two operands, they do a Boolean
coercion test against the first one.

94
00:05:24.386 --> 00:05:26.590
And based upon that end result,
pick one of the two.

95
00:05:28.430 --> 00:05:30.921
They select one of the two operands,
that's what they do.

96
00:05:30.921 --> 00:05:35.069
That's why we have this default value
idiom that we've all probably seen.

97
00:05:35.069 --> 00:05:38.645
Where I can say,
make baz equal to either foo or

98
00:05:38.645 --> 00:05:44.446
backup to quote foo as a default,
if the variable foo wasn't already set.

99
00:05:44.446 --> 00:05:49.166
Cuz we're gonna do a Boolean check against
foo and if it passes, we're gonna use foo.

100
00:05:49.166 --> 00:05:52.870
Otherwise we're gonna use the thing
on the other side, the other operand.

101
00:05:54.810 --> 00:05:59.705
So this thing is selecting one of the two
operands, aame thing with the ampersand.

102
00:05:59.705 --> 00:06:04.604
Here, we call it the default
value idiom with the ampersand.

103
00:06:04.604 --> 00:06:06.908
I don't know if any of you have
ever seen this before, but

104
00:06:06.908 --> 00:06:10.325
elite JavaScript programmers like to show
off their skills and how clever they are.

105
00:06:10.325 --> 00:06:15.511
And they'll write cb&amp;&amp;cb(),
which is a shorthand

106
00:06:15.511 --> 00:06:21.810
way of saying if the callback has
been set then invoke the callback.

107
00:06:22.840 --> 00:06:23.572
Why?

108
00:06:23.572 --> 00:06:26.760
Because we're checking
the value of the cb, and

109
00:06:26.760 --> 00:06:30.350
it only goes to the second
operand if it passes as true.

110
00:06:31.460 --> 00:06:36.462
If it fails as false, we short circuit
out and don't try to execute it.

111
00:06:36.462 --> 00:06:41.208
So we're showing off our skills, relying
upon, not only this implicit coercion

112
00:06:41.208 --> 00:06:45.914
happening, but also we're relying upon
short circuiting of these operators.

113
00:06:45.914 --> 00:06:49.748
I'm not negative on that,
I think those are great features, but

114
00:06:49.748 --> 00:06:53.650
we have to be honest that
they're implicit features.

115
00:06:53.650 --> 00:06:59.414
How many of you have every written
something like if A or B, or if A and

116
00:06:59.414 --> 00:07:04.992
B, and in all of those cases were
those things already Booleans?

117
00:07:08.641 --> 00:07:12.570
&gt;&gt; Kyle Simpson: So you're already
relying upon implicit coercion.

118
00:07:14.130 --> 00:07:17.650
Does that create an identity crisis for
you that you should go back and

119
00:07:17.650 --> 00:07:21.299
fix all your code and put in all those
double negates all over the place?

120
00:07:21.299 --> 00:07:22.573
I would argue this is a place for

121
00:07:22.573 --> 00:07:25.220
the implicit coercion is helping
the readability of your code.

122
00:07:27.070 --> 00:07:28.100
Are we following that reasoning?

123
00:07:31.660 --> 00:07:35.614
Here's where the == stuff starts
to get crazy for us because here,

124
00:07:35.614 --> 00:07:37.467
we have the string 1, 2, 3.

125
00:07:37.467 --> 00:07:41.483
Now the string 1,2,3 we've already
established that it's truthy, right?

126
00:07:41.483 --> 00:07:48.378
So when I == it to true and that fails,
my whole world starts to fall apart.

127
00:07:48.378 --> 00:07:51.308
How can something be truthy,
but not == to true?

128
00:07:54.657 --> 00:07:58.240
&gt;&gt; Kyle Simpson: Well it's cuz the ==
isn't doing a Boolean coercion at all,

129
00:07:58.240 --> 00:08:00.422
just like I said before.

130
00:08:00.422 --> 00:08:03.289
The == prefers to compare numbers, so

131
00:08:03.289 --> 00:08:07.856
if I give it a string and a Boolean,
guess what's gonna happen?

132
00:08:07.856 --> 00:08:10.724
Both of them are gonna
get coerced to numbers.

133
00:08:10.724 --> 00:08:13.865
The string is gonna coerce
to the number 1, 2, 3.

134
00:08:13.865 --> 00:08:17.405
The true is gonna coerce to the number 1,
and the number 1, 2, 3 and

135
00:08:17.405 --> 00:08:20.297
the number 1 are most definitely
not equal to each other.

136
00:08:23.133 --> 00:08:24.574
&gt;&gt; Kyle Simpson: Now you may
be thinking at this point,

137
00:08:24.574 --> 00:08:26.292
I promise we're getting to == in a minute.

138
00:08:26.292 --> 00:08:28.697
But you may be thinking at this point,
well jeez,

139
00:08:28.697 --> 00:08:30.999
this == just seems hopelessly complicated.

140
00:08:30.999 --> 00:08:33.697
I'm never gonna be able to
fully understand this == thing.

141
00:08:35.020 --> 00:08:37.550
Not true,
it's actually a very simple algorithm.

142
00:08:37.550 --> 00:08:41.190
Here's the one key take away,
we'll come back to this.

143
00:08:41.190 --> 00:08:45.690
If you just know,
the == prefers to compare numbers,

144
00:08:45.690 --> 00:08:49.220
most of the behavior simplifies itself.

145
00:08:49.220 --> 00:08:55.331
That's just something nobody's ever taught
you before, == prefers to compare numbers.

146
00:08:55.331 --> 00:09:01.577
Just that one fact eliminates most
of the confusion of the ==, okay?

147
00:09:01.577 --> 00:09:03.028
We'll get into more of that.

148
00:09:03.028 --> 00:09:06.160
So here,
it's not doing a Boolean coercion.

149
00:09:06.160 --> 00:09:08.880
So let me give you a take away,
you're looking for

150
00:09:08.880 --> 00:09:10.300
like I don't wanna talk about abstract.

151
00:09:10.300 --> 00:09:12.850
Give me practical stuff,
here's a take away.

152
00:09:12.850 --> 00:09:17.303
Don't ever under any circumstances and
I don't very often use absolutes, but

153
00:09:17.303 --> 00:09:18.442
this is one of them.

154
00:09:18.442 --> 00:09:24.543
Don't ever under any circumstances
compare with == true or == false.

155
00:09:24.543 --> 00:09:28.328
Just never, ever, ever, ever, ever do it.

156
00:09:28.328 --> 00:09:33.433
Because most likely it's only
gonna work as a happy accident,

157
00:09:33.433 --> 00:09:38.936
and in the worst case,
it's gonna confuse people and create bugs.

158
00:09:38.936 --> 00:09:41.333
Just don't do it.

159
00:09:41.333 --> 00:09:44.294
We've already talked about
multiple other ways for

160
00:09:44.294 --> 00:09:48.612
you to either let it do the implicit
coercion for you or be explicit about it.

161
00:09:48.612 --> 00:09:51.497
But don't rely upon == to true or
== to false,

162
00:09:51.497 --> 00:09:55.011
cuz they aren't gonna do what
you're expecting them to do.

163
00:09:57.596 --> 00:10:00.489
&gt;&gt; Kyle Simpson: And more importantly
they're not gonna do what the future

164
00:10:00.489 --> 00:10:02.564
reader of your code is expecting it to do.

165
00:10:07.605 --> 00:10:09.870
&gt;&gt; Kyle Simpson: Same thing down
on line 7, we got an array.

166
00:10:11.240 --> 00:10:14.650
We know the array, even though
it's an empty array, it's truthy.

167
00:10:14.650 --> 00:10:15.401
Why is it truthy?

168
00:10:17.455 --> 00:10:19.382
&gt;&gt; Kyle Simpson: It's not
on the falsy list, right?

169
00:10:19.382 --> 00:10:22.316
Even though an empty array seems like it
ought to be, it's not on the falsy list so

170
00:10:22.316 --> 00:10:24.110
it's gotta be truthy.

171
00:10:24.110 --> 00:10:28.440
So we do an if test for it, and
sure enough it passes as true.

172
00:10:28.440 --> 00:10:32.610
So we've established that it's truthy,
but on line 10 we ==it to false, and

173
00:10:32.610 --> 00:10:34.170
that also passes.

174
00:10:34.170 --> 00:10:37.159
How can something be both truthy and
== to false?

175
00:10:38.947 --> 00:10:42.710
&gt;&gt; Kyle Simpson: Well maybe it's cuz
the == doesn't do a Boolean coercion.

176
00:10:42.710 --> 00:10:46.670
Maybe it's cuz that == is gonna try and
do a numeric coercion.

177
00:10:46.670 --> 00:10:49.393
So we're gonna take the empty array.

178
00:10:49.393 --> 00:10:53.209
Remember, primitives need to be, I mean
non primitives need to become primitives.

179
00:10:53.209 --> 00:10:59.584
So what is the two primitives
of an empty array gonna produce?

180
00:10:59.584 --> 00:11:00.239
&gt;&gt; Speaker 2: String zero.

181
00:11:00.239 --> 00:11:01.838
&gt;&gt; Kyle Simpson: An empty string.

182
00:11:01.838 --> 00:11:03.246
First before getting there, right?

183
00:11:03.246 --> 00:11:04.113
You're right.

184
00:11:04.113 --> 00:11:05.593
We're gonna produce an empty string.

185
00:11:05.593 --> 00:11:10.460
So now what we really have
is empty string == to false.

186
00:11:10.460 --> 00:11:12.885
Now we still prefer numbers, right?

187
00:11:12.885 --> 00:11:14.956
So we're gonna turn the empty
string into a number.

188
00:11:14.956 --> 00:11:17.724
Which one does that become?

189
00:11:17.724 --> 00:11:18.705
&gt;&gt; Speaker 2: 0.
&gt;&gt; Kyle Simpson: 0.

190
00:11:18.705 --> 00:11:22.174
We're gonna turn false into a number
which one does that become?

191
00:11:22.174 --> 00:11:23.991
So now we have these 0s.

192
00:11:23.991 --> 00:11:27.517
There's our root of all evil again.

193
00:11:27.517 --> 00:11:31.078
I told you,
it could be coming back to that around.

194
00:11:31.078 --> 00:11:36.350
The gateway drug here is the == comparison
with the Boolean, just don't do it

