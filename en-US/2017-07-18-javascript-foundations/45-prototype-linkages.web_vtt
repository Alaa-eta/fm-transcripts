WEBVTT

1
00:00:00.186 --> 00:00:03.220
&gt;&gt; Kyle: Now,
let me throw a wrench into the mix.

2
00:00:03.220 --> 00:00:07.905
What happens if I were to add
an identify right here, and

3
00:00:07.905 --> 00:00:10.805
then I called a1.identifying?

4
00:00:10.805 --> 00:00:11.920
Where is it gonna find it?

5
00:00:13.400 --> 00:00:14.668
&gt;&gt; Speaker 2: On a1.
&gt;&gt; Kyle: It's gonna find it right here.

6
00:00:14.668 --> 00:00:17.687
So we're gonna be calling line 13.

7
00:00:17.687 --> 00:00:21.640
What is the this key we're gonna
be pointing at on line 13?

8
00:00:21.640 --> 00:00:22.800
&gt;&gt; Speaker 3: a1.

9
00:00:22.800 --> 00:00:25.235
&gt;&gt; Kyle: Still a1, do you see the problem?

10
00:00:25.235 --> 00:00:28.960
We're gonna have this circular recursion
thing where we keep calling this thing.

11
00:00:28.960 --> 00:00:33.370
Because we want to,
like class-oriented coding, relatively,

12
00:00:33.370 --> 00:00:37.070
polymorphically, refer to that one.

13
00:00:37.070 --> 00:00:39.180
But because we are using this keyword,

14
00:00:39.180 --> 00:00:41.199
it's just gonna infinitely
recurse on itself.

15
00:00:42.480 --> 00:00:45.665
So, what do you think we should do to
get from this function to that function?

16
00:00:49.637 --> 00:00:55.196
&gt;&gt; Kyle: Well, we could try calling the,
oops, calling the,

17
00:00:58.385 --> 00:01:02.090
&gt;&gt; Kyle: this.__proto__.identify, right?

18
00:01:02.090 --> 00:01:07.360
We could say this.__proto__.identify but
there's a problem here.

19
00:01:07.360 --> 00:01:09.180
That isn't gonna work.

20
00:01:09.180 --> 00:01:11.966
It's not gonna print out the Hello,
I am a1.

21
00:01:11.966 --> 00:01:13.473
Can you spot why?

22
00:01:13.473 --> 00:01:14.678
&gt;&gt; Speaker 2: The this context.

23
00:01:14.678 --> 00:01:16.260
&gt;&gt; Kyle: The this context.

24
00:01:16.260 --> 00:01:20.850
When we call that identify up on line 6,
what is the this keyword gonna point at?

25
00:01:20.850 --> 00:01:21.980
&gt;&gt; Speaker 4: On the proto?

26
00:01:21.980 --> 00:01:25.560
&gt;&gt; Kyle: It's gonna point at
the Foo.prototype object, not at a1.

27
00:01:27.140 --> 00:01:28.040
So that's not gonna work.

28
00:01:28.040 --> 00:01:33.032
We can't say this.__proto__.identify,
we'd actually have to say

29
00:01:33.032 --> 00:01:37.482
this.__proto__.identify.call(this), which
sucks.

30
00:01:39.150 --> 00:01:41.890
But there's a bigger reason why it sucks.

31
00:01:41.890 --> 00:01:45.320
Because we use one __proto there, but

32
00:01:45.320 --> 00:01:48.700
guess what happens if some
day later we come along and

33
00:01:48.700 --> 00:01:54.214
we add another x object into the chain and
then we call x.identify.

34
00:01:55.520 --> 00:01:57.030
Does x have an identify?

35
00:01:58.550 --> 00:02:00.032
So, where are we gonna go?

36
00:02:00.032 --> 00:02:01.411
&gt;&gt; Speaker 2: a1.identify.

37
00:02:01.411 --> 00:02:05.494
&gt;&gt; Kyle: Now, we're gonna be calling
that identify function, the line 14,

38
00:02:05.494 --> 00:02:06.460
if you will.

39
00:02:06.460 --> 00:02:09.167
What is the this keyword gonna
be pointing out on line 14?

40
00:02:09.167 --> 00:02:10.020
&gt;&gt; Speaker 4: x.

41
00:02:10.020 --> 00:02:12.503
&gt;&gt; Kyle: x, so
we're gonna go x.__proto and

42
00:02:12.503 --> 00:02:16.240
get back to here and
have our infinite recursion.

43
00:02:16.240 --> 00:02:19.114
How many __protos do we need now?

44
00:02:19.114 --> 00:02:20.010
&gt;&gt; Speaker 2: Two.

45
00:02:20.010 --> 00:02:20.970
&gt;&gt; Kyle: We need two.

46
00:02:20.970 --> 00:02:24.064
If you add another object,
now you need three.

47
00:02:24.064 --> 00:02:28.424
So every time you extend your inheritance
chain, you're gonna have to go back and

48
00:02:28.424 --> 00:02:31.180
fix all those references and
add more __protos.

49
00:02:31.180 --> 00:02:33.400
But that's not even the worst part.

50
00:02:33.400 --> 00:02:37.702
Let's say we did change that line
14 to have two __protos in it,

51
00:02:37.702 --> 00:02:42.130
then you call a1.identify,
what's gonna happen?

52
00:02:42.130 --> 00:02:42.860
&gt;&gt; Speaker 2: It's gonna break.

53
00:02:42.860 --> 00:02:47.220
&gt;&gt; Kyle: It's gonna go from here to here,
and then from here to here.

54
00:02:47.220 --> 00:02:48.710
Does this one have an identify?

55
00:02:48.710 --> 00:02:50.260
Not gonna work.

56
00:02:50.260 --> 00:02:52.906
The point I'm trying to make is
it's impossible to know how many

57
00:02:52.906 --> 00:02:53.838
__protos you need.

58
00:02:55.681 --> 00:03:01.268
&gt;&gt; Kyle: Because the this and
__proto system is not relative.

59
00:03:01.268 --> 00:03:05.179
The way class-oriented coding gives
us relative polymorphism, that

60
00:03:05.179 --> 00:03:09.491
mechanism is not relative, it's always
absolute to the bottom of the chain.

61
00:03:09.491 --> 00:03:13.872
So you can't do relative polymorphism,
you can't override a function.

62
00:03:13.872 --> 00:03:18.733
Which is what you do in polymorphism,
you make a child class with the method and

63
00:03:18.733 --> 00:03:20.520
override it and call super.

64
00:03:20.520 --> 00:03:23.650
You don't have that with
the prototype system.

65
00:03:23.650 --> 00:03:27.480
So, you know what you end up having
to do to make a reliable reference?

66
00:03:27.480 --> 00:03:30.328
You have to skip the prototype
chain entirely and

67
00:03:30.328 --> 00:03:34.370
just do it like that,
Foo.prototype.identify.call(this).

68
00:03:36.597 --> 00:03:39.774
&gt;&gt; Kyle: Which completely skips out
on the whole prototype chain and

69
00:03:39.774 --> 00:03:42.325
totally shoots all of
the dynamism in the foot.

70
00:03:45.315 --> 00:03:46.191
&gt;&gt; Kyle: I have a term for

71
00:03:46.191 --> 00:03:51.250
that Foo.prototype.identify.call(this),
which is such a mouthful.

72
00:03:51.250 --> 00:03:54.770
Mostly I just made this term up
to make myself feel smarter.

73
00:03:54.770 --> 00:03:59.706
Here's the term,
explicit pseudopolymorphism.

74
00:03:59.706 --> 00:04:03.050
I just sound smart when I say it, don't I?

75
00:04:03.050 --> 00:04:04.960
That's trademarked by the way,
don't steal that.

76
00:04:04.960 --> 00:04:06.820
Explicit pseudopolymorphism.

77
00:04:07.840 --> 00:04:11.050
Because it's not really polymorphic,
it's not using the prototype chain.

78
00:04:11.050 --> 00:04:13.710
And we have to explicitly
tell it which method to call.

79
00:04:13.710 --> 00:04:15.167
We can't relatively figure it out.

80
00:04:20.965 --> 00:04:26.008
&gt;&gt; Kyle: Takeaway here is, you opt
into these problems, these problems of

81
00:04:26.008 --> 00:04:31.850
explicit pseudopolymorphism,
when you choose to do shadowing.

82
00:04:31.850 --> 00:04:36.050
Because you called identify and
identify, you opt into that problem.

83
00:04:36.050 --> 00:04:38.976
Now you might just say, well, that's cool,
I just won't opt into that problem.

84
00:04:38.976 --> 00:04:40.330
I just won't shadow.

85
00:04:41.510 --> 00:04:43.670
I agree, you should not shadow.

86
00:04:43.670 --> 00:04:47.135
But if you don't shadow,
you lose one of the most important parts

87
00:04:47.135 --> 00:04:51.548
of all of class-oriented design, which
is method overriding and polymorphism.

88
00:04:54.053 --> 00:04:56.077
&gt;&gt; Kyle: In class-oriented design,
they tell you,

89
00:04:56.077 --> 00:04:59.940
make a method in the child class, override
it, call the base parent with super.

90
00:04:59.940 --> 00:05:01.447
You lose that if you do shadowing.

91
00:05:04.829 --> 00:05:07.985
&gt;&gt; Kyle: So maybe this system is great,
but maybe it's not so

92
00:05:07.985 --> 00:05:10.009
great at representing classes.

93
00:05:15.224 --> 00:05:18.677
&gt;&gt; Kyle: On the other hand,
if we have methods of different names,

94
00:05:18.677 --> 00:05:19.740
like I have here.

95
00:05:20.740 --> 00:05:22.670
I have both a speak and an identify.

96
00:05:23.770 --> 00:05:28.059
If I say this.identify on line 11,
what is the this keyword gonna point at?

97
00:05:31.590 --> 00:05:32.679
&gt;&gt; Speaker 2: a1.
&gt;&gt; Kyle: a1, so

98
00:05:32.679 --> 00:05:38.930
I started out at a1.speak on line 16,
went up to find speak on the prototype.

99
00:05:38.930 --> 00:05:43.110
Then I came back to a1, and now I
walk back up and find it on identify.

100
00:05:43.110 --> 00:05:46.460
And what's the this keyword
on line 6 gonna point at?

101
00:05:46.460 --> 00:05:47.000
&gt;&gt; Speaker 2: a1.

102
00:05:47.000 --> 00:05:50.600
&gt;&gt; Kyle: Still a1, no matter how many
times I have to walk up the prototype

103
00:05:50.600 --> 00:05:54.500
chain, and no matter how far up
the prototype chain I need to look,

104
00:05:54.500 --> 00:05:59.320
we always stay rooted at the call site
which is the object that we care about.

105
00:05:59.320 --> 00:06:00.880
I call this super unicorn magic.

106
00:06:01.960 --> 00:06:03.790
It's a beautifully designed system.

107
00:06:05.180 --> 00:06:09.510
It only falls apart when you
try to do shadowing, AKA,

108
00:06:09.510 --> 00:06:11.160
when you try to put classes on top of it.

109
00:06:13.280 --> 00:06:16.547
It's a great system,
it's just not a great class system.

