WEBVTT

1
00:00:00.070 --> 00:00:02.430
&gt;&gt; Kyle Simpson: To be honest with you,
it surprises me.

2
00:00:02.430 --> 00:00:06.130
Although maybe it shouldn't having been
at this now, I've been a developer,

3
00:00:06.130 --> 00:00:06.820
almost 20 years.

4
00:00:06.820 --> 00:00:12.040
But it does surprise me that developers
in JavaScript tend to approach

5
00:00:12.040 --> 00:00:16.070
understanding of JavaScript as,
I only need to get just far enough

6
00:00:16.070 --> 00:00:19.420
that I can ship my code and
then that's good enough, right?

7
00:00:19.420 --> 00:00:21.180
We're very pragmatic in that sense.

8
00:00:21.180 --> 00:00:24.094
I get it,
I found this thing on stack overflow.

9
00:00:24.094 --> 00:00:27.220
I vaguely understand kind of what it's
doing, I tweaked it a little bit.

10
00:00:28.770 --> 00:00:31.314
I like to refer to this
as house of cards design,

11
00:00:31.314 --> 00:00:33.553
where you kinda put some stuff together.

12
00:00:33.553 --> 00:00:35.567
And you're not really sure
exactly why it works, but

13
00:00:35.567 --> 00:00:39.190
you keep tweaking at it until it works,
and then you're like, my God, it works.

14
00:00:39.190 --> 00:00:42.580
I'm not really sure why, you put a code
comment there that says nobody touch this.

15
00:00:42.580 --> 00:00:43.940
And then you hold your breath and

16
00:00:43.940 --> 00:00:47.390
slowly back away hoping that
it doesn't fall, right?

17
00:00:47.390 --> 00:00:50.560
As long as it's in the code base long
enough that I'm not gonna get blame for

18
00:00:50.560 --> 00:00:52.330
it, we're good, right?

19
00:00:52.330 --> 00:00:55.870
That is a very ultra-pragmatic
way of thinking about things.

20
00:00:55.870 --> 00:00:57.860
My boss just expects me to ship the code,

21
00:00:57.860 --> 00:01:01.330
so it doesn't matter if I know what
it's doing, as long as it seems to work.

22
00:01:02.710 --> 00:01:05.260
This is also happy
path-driven development.

23
00:01:06.360 --> 00:01:10.320
Whenever we think optimistically that all
that matters is that the code works now.

24
00:01:11.970 --> 00:01:14.730
And if the code does work now,
but I don't understand it,

25
00:01:14.730 --> 00:01:17.880
it doesn't really matter at the end
of the day, because I went home,

26
00:01:17.880 --> 00:01:20.910
I collected my paycheck and
some code shift to production.

27
00:01:20.910 --> 00:01:26.460
That's happy path driven development,
because if it works of course it's great.

28
00:01:27.490 --> 00:01:30.440
But how many of you have ever had
a piece of code break before?

29
00:01:30.440 --> 00:01:31.080
Anybody?

30
00:01:31.080 --> 00:01:33.230
Can we all agree that we're
in a big family of friends?

31
00:01:33.230 --> 00:01:38.050
We all are pretty good, and I'm probably
better at you at breaking code,

32
00:01:38.050 --> 00:01:39.700
at writing broken code.

33
00:01:39.700 --> 00:01:43.530
I've got a lot more experience than
some of you at writing broken code.

34
00:01:43.530 --> 00:01:48.030
So, why is it that we focus so myopically
on the happy path, and don't think

35
00:01:48.030 --> 00:01:53.400
about what's gonna happen when I have to
revisit this code because it's broken?

36
00:01:53.400 --> 00:01:56.950
What is the scenario by which I'm gonna
get to come back and revisit this code?

37
00:01:56.950 --> 00:02:00.430
Romantically, we think to ourselves, I'm
gonna get to come back and revisit this

38
00:02:00.430 --> 00:02:03.430
code next Spring, because I filed
myself a ticket that says come back and

39
00:02:03.430 --> 00:02:05.470
fix my technical debt, do it right.

40
00:02:05.470 --> 00:02:08.030
And I even put a code comment
there that says, to do, fix this.

41
00:02:09.230 --> 00:02:11.000
But in reality,
most of us never go back and

42
00:02:11.000 --> 00:02:17.330
see that line of code until
there's a huge fire in production.

43
00:02:17.330 --> 00:02:18.470
Something is melting down.

44
00:02:18.470 --> 00:02:21.900
The performance is terrible, there's
a feature that nobody thought of when they

45
00:02:21.900 --> 00:02:23.394
put a real dataset in front of it.

46
00:02:23.394 --> 00:02:28.580
And your boss' hair is on fire, and
now you don't know what to do, but

47
00:02:28.580 --> 00:02:31.370
you are in the worst possible
circumstances to figure it out,

48
00:02:31.370 --> 00:02:35.120
because you don't have the time and
luxury to plan it out.

49
00:02:35.120 --> 00:02:37.720
You simply have to do more of the same.

50
00:02:37.720 --> 00:02:42.610
Just keep throwing more cards at
the house of cards until it stands.

51
00:02:42.610 --> 00:02:46.320
And that, my friends is how code

52
00:02:47.550 --> 00:02:52.480
grows into that legacy of
frustration that we have.

53
00:02:52.480 --> 00:02:55.480
And you might have noticed something
that I've noticed for a long time.

54
00:02:55.480 --> 00:02:56.956
Because I've been around so long and

55
00:02:56.956 --> 00:02:59.059
I've seen this cycle repeat
now four of five times.

56
00:02:59.059 --> 00:03:03.022
You might have noticed that about every
three to four years, and sometimes faster

57
00:03:03.022 --> 00:03:06.584
than that, somebody comes along and
reinvents an entire new framework,

58
00:03:06.584 --> 00:03:09.284
an entire new architecture,
a whole new set of jargon,

59
00:03:09.284 --> 00:03:13.100
to describe how we ought to build and
architect, our front end applications.

60
00:03:14.110 --> 00:03:16.610
And people flock in
droves to this new thing.

61
00:03:17.920 --> 00:03:22.151
And it's not even fully clear exactly
at that moment why that new thing is so

62
00:03:22.151 --> 00:03:22.969
much better.

63
00:03:22.969 --> 00:03:25.274
But you know why I think
people flock in droves so

64
00:03:25.274 --> 00:03:27.910
quickly whenever somebody
invents something.

65
00:03:27.910 --> 00:03:31.700
Somebody in this room or online is
probably inventing the next big framework.

66
00:03:31.700 --> 00:03:35.470
There's just the odds are,
somebody's working on that right now.

67
00:03:35.470 --> 00:03:38.060
But why is it that we
flock in droves to them?

68
00:03:38.060 --> 00:03:41.960
Well, part of the reason is that we
just get so frustrated by going back and

69
00:03:41.960 --> 00:03:45.060
having to fix the code, and
work on the code, and struggle with it.

70
00:03:45.060 --> 00:03:48.660
And tell me if you've ever had this
conversation before, cuz I certainly have,

71
00:03:48.660 --> 00:03:50.750
and I've certainly heard it many times.

72
00:03:50.750 --> 00:03:53.740
At some point you're frustrated, you're
working on it, you're trying to fix a bug,

73
00:03:53.740 --> 00:03:55.000
or add a feature.

74
00:03:55.000 --> 00:03:57.782
And you have this conversation with
a co-worker or a boss and you say,

75
00:03:57.782 --> 00:03:58.405
you know what?

76
00:03:58.405 --> 00:04:02.820
It would just be faster if I rewrote it,
right?

77
00:04:03.870 --> 00:04:08.910
That's the mindset here, because we
struggle so much to read and understand

78
00:04:08.910 --> 00:04:14.860
the existing code and fix the existing
code, because we have taken to an extreme.

79
00:04:14.860 --> 00:04:18.720
The concept of Agile Development
is a good, strong, positive.

80
00:04:18.720 --> 00:04:22.425
And I'm not talking negatively about
Agile, but we did with that exactly

81
00:04:22.425 --> 00:04:25.470
what we developers,
the sin that we all do with everything,

82
00:04:25.470 --> 00:04:27.880
which is that we took it
to its logical extreme.

83
00:04:27.880 --> 00:04:31.590
And said,
every single statement needs to be agile.

84
00:04:31.590 --> 00:04:33.680
Who cares whether it makes any sense?

85
00:04:33.680 --> 00:04:35.925
Who cares whether I know what it does?

86
00:04:35.925 --> 00:04:37.298
I'll have time to fix that later.

87
00:04:37.298 --> 00:04:40.571
At a macrolevel, Agile is a great pattern.

88
00:04:40.571 --> 00:04:43.571
But at the microlevel of
the code that we write,

89
00:04:43.571 --> 00:04:46.350
its a terrible idea to
approach it that way.

90
00:04:47.760 --> 00:04:51.890
Researchers have studied the process
of software development.

91
00:04:51.890 --> 00:04:55.549
And they've studied what we
do we spend our time one?

92
00:04:55.549 --> 00:04:58.464
And I found this fascinating
reading this white paper.

93
00:04:58.464 --> 00:05:02.776
They found that more than 70%
of the time that we spend on

94
00:05:02.776 --> 00:05:07.352
a day-to-day basis in the process
of developing software,

95
00:05:07.352 --> 00:05:11.934
more than 70% of that time we
spend reading existing code.

96
00:05:13.256 --> 00:05:16.636
&gt;&gt; Kyle Simpson: Think about
your typical eight hour a day.

97
00:05:16.636 --> 00:05:21.161
Researchers say up to 70% of that
eight hour a day is spent just reading

98
00:05:21.161 --> 00:05:25.850
the code that you wrote yesterday
that you don't understand.

99
00:05:25.850 --> 00:05:26.903
Anybody ever had that before?

100
00:05:26.903 --> 00:05:29.920
You wrote some code and then the next day,
or the next week, or the next month.

101
00:05:29.920 --> 00:05:32.710
It's been said that code that you wrote
six months ago might as well have been

102
00:05:32.710 --> 00:05:34.920
written by somebody else entirely.

103
00:05:34.920 --> 00:05:36.820
For me, that horizon's about two weeks.

104
00:05:37.900 --> 00:05:42.450
If it's gone about two weeks and I haven't
seen a piece of code, there's no hope.

105
00:05:42.450 --> 00:05:48.840
I wrote code yesterday on the plane ride
here, that today, I don't understand.

106
00:05:48.840 --> 00:05:51.020
I'm good at that, okay?

107
00:05:51.020 --> 00:05:55.400
We write code to ship,
and that's a good thing.

108
00:05:55.400 --> 00:05:57.440
We all need to ship,
cuz we all need to make a paycheck.

109
00:05:58.770 --> 00:06:01.720
But if we don't balance that with,
I should understand this code,

110
00:06:01.720 --> 00:06:03.640
because guess what?

111
00:06:03.640 --> 00:06:07.540
I'm probably going to have to
read this a few more times, or

112
00:06:07.540 --> 00:06:10.810
a few hundred more times, or
a few thousand more times.

113
00:06:10.810 --> 00:06:14.810
Maybe if we spent a little bit more effort
understanding what we were doing from

114
00:06:14.810 --> 00:06:21.050
the get-go, there would be less of this
desire to churn and completely rewrite.

115
00:06:21.050 --> 00:06:24.580
Maybe every line of code could
be slightly more durable.

116
00:06:24.580 --> 00:06:27.070
If it was written in such a way
that the person who wrote it

117
00:06:27.070 --> 00:06:30.350
understood what they were doing, why,
and how it did what it was doing.

118
00:06:32.080 --> 00:06:33.215
And here's the really important part,

119
00:06:33.215 --> 00:06:38.145
cuz this is where it goes from a science
to an art, they communicated that well.

120
00:06:38.145 --> 00:06:40.005
They communicated their
thought process well.

121
00:06:41.135 --> 00:06:43.955
You've heard me say,
probably on many occasions in the past,

122
00:06:43.955 --> 00:06:45.835
I'm kind of a broken record on this.

123
00:06:45.835 --> 00:06:49.145
I believe this so deeply that it's
almost a religious belief for

124
00:06:49.145 --> 00:06:51.745
me, that code is about communication.

125
00:06:53.275 --> 00:06:54.815
Did you know that code is not first and

126
00:06:54.815 --> 00:06:57.415
foremost to instruct the ones and
zeroes to the computer?

127
00:06:59.490 --> 00:07:04.290
Years and years ago, decades ago, when
we first invented programming languages

128
00:07:04.290 --> 00:07:09.250
on top of the ones and zeros, we started
to create a separation, a gap between

129
00:07:09.250 --> 00:07:12.900
the code that we write and the precise
instructions that the computer writes.

130
00:07:12.900 --> 00:07:15.140
Even assembly language was an abstraction.

131
00:07:15.140 --> 00:07:18.900
There's a pretty close one-to-one
correlation, but not exactly.

132
00:07:18.900 --> 00:07:23.690
So even at that level, we started to move
and create a gap between what the computer

133
00:07:23.690 --> 00:07:27.150
actually does, and what we express to
the computer through our source code.

134
00:07:27.150 --> 00:07:30.350
And the more that we've done that,
the more languages that we've created, and

135
00:07:30.350 --> 00:07:34.330
we're on third slash fourth
generation languages at this point.

136
00:07:34.330 --> 00:07:37.220
We're approaching more of
the natural language kind of things.

137
00:07:37.220 --> 00:07:39.366
You have SQL, for example,
it's been around for a while.

138
00:07:39.366 --> 00:07:42.517
But SQL is kind of more
the traditional fourth generation.

139
00:07:42.517 --> 00:07:45.088
It's more natural language oriented.

140
00:07:45.088 --> 00:07:48.321
Or we're moving in those directions even
more with voice-oriented stuff through

141
00:07:48.321 --> 00:07:49.992
Alexa and all those other things, right?

142
00:07:49.992 --> 00:07:54.931
So we're seeing the progress of creating
obstruction in the way we instruct

143
00:07:54.931 --> 00:07:56.100
their computer.

144
00:07:57.430 --> 00:08:01.280
We're creating this barriers between
what we do, what we express in our code,

145
00:08:01.280 --> 00:08:03.630
and what the computer runs.

146
00:08:03.630 --> 00:08:08.220
So at best, our code is not
a precise set of instructions, but

147
00:08:08.220 --> 00:08:10.040
rather a set of suggestions
to the computer.

148
00:08:11.750 --> 00:08:15.190
Really, it's a set of suggestions,
and the computer looks at it.

149
00:08:15.190 --> 00:08:20.090
You obsess over should I do ++i or i++,
because you're thinking in your mind,

150
00:08:20.090 --> 00:08:21.847
I saw some JS perf somewhere.

151
00:08:21.847 --> 00:08:27.339
And it told me that ++i was a couple
microseconds faster than i++.

152
00:08:27.339 --> 00:08:30.515
So I have some instinct in my head
that I need to do that everywhere,

153
00:08:30.515 --> 00:08:32.860
because let's save on
all these microseconds.

154
00:08:34.150 --> 00:08:36.410
And what's really true,
and I like to think of it,

155
00:08:36.410 --> 00:08:39.526
literally I will role play this in
my head when I'm looking at my code.

156
00:08:39.526 --> 00:08:42.204
I like to imagine that the JavaScript
engine just sort of chuckles at me.

157
00:08:42.204 --> 00:08:44.810
It's like, thanks very much, but
I'm not gonna do either one of them.

158
00:08:46.000 --> 00:08:47.830
Cuz it turns out,
there's a more efficient way to do it.

159
00:08:49.280 --> 00:08:53.390
I am glad that the computer is better at
writing efficient code than I am, because

160
00:08:53.390 --> 00:08:56.530
if it were up to me, I would have failed
out of this industry a long time ago.

161
00:08:57.650 --> 00:09:01.730
The computer is vastly better
at writing more efficient code

162
00:09:01.730 --> 00:09:05.830
than any of us ever will be,
and it's getting more so.

163
00:09:05.830 --> 00:09:08.760
They're catching up,
they're doing things even better and

164
00:09:08.760 --> 00:09:11.540
more sophisticated than
they ever have before.

165
00:09:11.540 --> 00:09:14.350
So when you obsess about,
I have this thing and

166
00:09:14.350 --> 00:09:18.800
I'm gonna sacrifice the readability of
my code, because this micro performance

167
00:09:18.800 --> 00:09:22.730
benchmark tells me I've got to make sure
that I squeeze this microsecond out of it,

168
00:09:22.730 --> 00:09:26.450
and do this weird thing with a bit
wise operation or something like that.

169
00:09:26.450 --> 00:09:27.760
When you obsess about that,

170
00:09:27.760 --> 00:09:31.360
what you are really doing is
betting against the future.

171
00:09:32.530 --> 00:09:37.530
You are betting that your current
skill level is better than

172
00:09:37.530 --> 00:09:42.060
any skill level that will ever happen
to the systems that run that code for

173
00:09:42.060 --> 00:09:43.459
the entire lifetime of that code.

174
00:09:44.950 --> 00:09:48.540
Now, in a sense, code gets rewritten all
the time, so what difference does it make?

175
00:09:48.540 --> 00:09:50.410
But actually, code lives a lot longer.

176
00:09:50.410 --> 00:09:53.002
It just churns, and churns, and churns,

177
00:09:53.002 --> 00:09:55.819
lives a lot longer than
we might want to admit.

178
00:09:57.862 --> 00:10:00.045
&gt;&gt; Kyle Simpson: So, maybe stop betting so
much against the future and

179
00:10:00.045 --> 00:10:02.890
maybe start saying,
what should I invest my time in?

180
00:10:02.890 --> 00:10:07.010
If it's not to precisely instruct
the computer, if I should instead try

181
00:10:07.010 --> 00:10:09.930
to come up with a way to describe
what I want to have happened.

182
00:10:11.110 --> 00:10:13.170
There's a term for that,
it's called declarative.

183
00:10:13.170 --> 00:10:16.990
You wanna describe what you want
to have happened as opposed to

184
00:10:16.990 --> 00:10:20.510
precisely instructing how to do
it that's called imperative.

185
00:10:21.540 --> 00:10:25.600
If you can be more declarative about your
code, you open up more opportunities for

186
00:10:25.600 --> 00:10:30.210
future improvement in the performance and
the optimization of that code,

187
00:10:30.210 --> 00:10:33.210
they system will be able to optimize
it better the more declarative you are.

188
00:10:33.210 --> 00:10:38.140
As a matter of fact the more imperative
you are, the more you try to tinker with

189
00:10:38.140 --> 00:10:42.330
all of those things, the harder you make
that code for the engine to optimize.

190
00:10:43.390 --> 00:10:47.400
You actually work against your own
favor when you have this myopic, well,

191
00:10:47.400 --> 00:10:52.760
I just got to optimize this code.

192
00:10:52.760 --> 00:10:55.425
Code is not about a precise
set of instructions.

193
00:10:55.425 --> 00:10:59.082
And code should not be about
obsessing about a micro performance

194
00:10:59.082 --> 00:11:03.088
difference of a few microseconds here or
there, because guess what?

195
00:11:03.088 --> 00:11:06.770
It scaled the engines gonna do,
it's gonna profile your code in real time.

196
00:11:06.770 --> 00:11:10.232
It's not gonna pay any attention to
this individual benchmark that you

197
00:11:10.232 --> 00:11:11.278
ran in JSperf.com.

198
00:11:11.278 --> 00:11:15.476
It's gonna run it in the entire context,
and make very, very different, and

199
00:11:15.476 --> 00:11:18.990
sometimes completely counterintuitive
decisions to your own.

200
00:11:19.990 --> 00:11:21.440
Stop betting against the future,

201
00:11:21.440 --> 00:11:25.770
stop betting that you are better at
what the computer is clearly better at.

202
00:11:25.770 --> 00:11:28.994
You're just not gonna be better than
the computer at those things, ever.

203
00:11:28.994 --> 00:11:32.838
And that's not meant as a criticism,
I'm talking to my self here,

204
00:11:32.838 --> 00:11:34.667
we're just not built for that.

205
00:11:34.667 --> 00:11:36.610
You know who's not good
at running programs?

206
00:11:36.610 --> 00:11:37.839
Us.

207
00:11:37.839 --> 00:11:38.628
You know who is?

208
00:11:38.628 --> 00:11:41.669
The computer.

209
00:11:41.669 --> 00:11:47.600
But does that mean the developers
are eventually gonna become irrelevant?

210
00:11:47.600 --> 00:11:50.420
Are we being programmed
out of our own jobs?

211
00:11:50.420 --> 00:11:53.920
Are we making AI systems where eventually
the computers will make their own code?

212
00:11:53.920 --> 00:11:54.880
There are some that believe that.

213
00:11:54.880 --> 00:11:57.320
There are some that believe that A,

214
00:11:58.700 --> 00:12:01.770
software developers
are the new blue collar worker.

215
00:12:01.770 --> 00:12:03.250
We're commoditized.

216
00:12:03.250 --> 00:12:05.300
We're just on an assembly line.

217
00:12:05.300 --> 00:12:06.210
We're not creative.

218
00:12:06.210 --> 00:12:09.210
We're not doing something
bigger than ourselves.

219
00:12:09.210 --> 00:12:10.780
We're just cogs in a wheel.

220
00:12:10.780 --> 00:12:11.837
There are some that believe that.

221
00:12:11.837 --> 00:12:14.433
And there are some that
believe that just like that,

222
00:12:14.433 --> 00:12:16.852
because we have become
a new blue collar worker.

223
00:12:16.852 --> 00:12:19.146
And we are now workers on a factory line,
and

224
00:12:19.146 --> 00:12:23.002
that's not to say anything negative
about factory working, by the way.

225
00:12:23.002 --> 00:12:26.510
It's the backbone of this country, so
I don't mean to suggest that at all.

226
00:12:26.510 --> 00:12:29.480
But to suggest that software developers
have become that is to suggest that

227
00:12:29.480 --> 00:12:35.470
software developers are also subject to
automation, that our jobs will go away.

228
00:12:35.470 --> 00:12:36.910
Is that true?

229
00:12:36.910 --> 00:12:40.440
I mean we already see AI being
able to do small scale things like

230
00:12:40.440 --> 00:12:45.270
the Microsoft AI Chatbot that was able
to pull code from Stack Overflow, and

231
00:12:45.270 --> 00:12:48.390
solve little small coding exercises,
or things like that.

232
00:12:48.390 --> 00:12:49.540
Is that true?

233
00:12:49.540 --> 00:12:55.329
Well, here's what I think the computer
will never be better than us at, ever.

234
00:12:55.329 --> 00:12:58.004
It's tough to make a statement like that,

235
00:12:58.004 --> 00:13:03.000
where you make some prediction against
the long future, but I'm saying ever.

236
00:13:03.000 --> 00:13:06.789
I'm drawing a line in the sand and
I say, I think there is one thing that

237
00:13:06.789 --> 00:13:11.350
the computer will never be better than us
at, communicating with other humans, and

238
00:13:11.350 --> 00:13:14.199
communicating empathetically
with other humans.

239
00:13:15.300 --> 00:13:18.386
That's the one thing that we
will always be better at.

240
00:13:18.386 --> 00:13:21.177
It will never be the case where we
don't need to communicate anymore,

241
00:13:21.177 --> 00:13:24.440
the computer just communicates for
us, that's nonsense.

242
00:13:24.440 --> 00:13:25.850
We will always need to communicate, and

243
00:13:25.850 --> 00:13:27.870
we will always do that
better than the system.

244
00:13:29.350 --> 00:13:31.030
So maybe that's where
our attention should be.

245
00:13:32.230 --> 00:13:34.820
Understanding the tools that
we use to get our job done.

246
00:13:34.820 --> 00:13:38.940
Yes, we have to ship code, but
maybe we should focus a little bit more on

247
00:13:38.940 --> 00:13:41.890
understanding and
communicating more clearly with our code.

248
00:13:44.660 --> 00:13:47.590
Of the infinite number of choices
there are of programs that

249
00:13:47.590 --> 00:13:50.570
will produce the exact same
sequence of ones and zeroes.

250
00:13:50.570 --> 00:13:55.043
Maybe the best code,
keep using better and best,

251
00:13:55.043 --> 00:14:00.484
maybe the best code is the code
that fully describes itself.

252
00:14:00.484 --> 00:14:04.255
That to untrained reader who has no
idea what the problem domain is,

253
00:14:04.255 --> 00:14:08.158
has no idea why you've tried and
failed before, can read that code and

254
00:14:08.158 --> 00:14:12.880
on the first pass through the code, fully
understand everything they need to know.

255
00:14:14.570 --> 00:14:16.210
I know that's idealized, right?

256
00:14:16.210 --> 00:14:18.120
That's not really realistic.

257
00:14:18.120 --> 00:14:19.420
But shouldn't that be a goal of ours?

258
00:14:20.620 --> 00:14:23.130
To communicate so clearly with our code?

259
00:14:23.130 --> 00:14:26.580
That there's no question upon reading
that it's doing what it's supposed to do.

260
00:14:26.580 --> 00:14:29.935
Or there's no question upon reading, it's
glaringly obvious where the bug is, or

261
00:14:29.935 --> 00:14:31.082
the problem in our logic is.

262
00:14:31.082 --> 00:14:35.876
What the problem in our logic is,
that's my life's quest at this point and

263
00:14:35.876 --> 00:14:38.554
I use this vehicle of teaching to do that.

264
00:14:38.554 --> 00:14:40.390
Let me let you in on a little secret.

265
00:14:40.390 --> 00:14:43.580
I'm not qualified to be a teacher,
I'm not.

266
00:14:43.580 --> 00:14:45.030
I don't have a degree in teaching.

267
00:14:45.030 --> 00:14:47.870
I don't know anything
formal about teaching.

268
00:14:47.870 --> 00:14:51.830
I don't know the terminology
around teaching methods.

269
00:14:51.830 --> 00:14:54.980
All I'm doing is going on a journey
of learning this stuff better, and

270
00:14:54.980 --> 00:14:57.330
I'm taking you along
with me on that journey.

271
00:14:57.330 --> 00:14:59.900
So, what I'm about to
present to you in this course

272
00:14:59.900 --> 00:15:03.080
is just the distillation of my
current location in that journey.

273
00:15:04.320 --> 00:15:06.230
It's a curve and approaching more and

274
00:15:06.230 --> 00:15:10.870
more understanding, and you're just
a little bit behind me on that curve.

275
00:15:10.870 --> 00:15:12.800
But I'm inviting you to
join me on that journey.

276
00:15:14.430 --> 00:15:18.550
Because I wanna learn better how to
communicate clearly with my code.

277
00:15:18.550 --> 00:15:21.360
And that starts with understanding
my programming language.

278
00:15:22.360 --> 00:15:24.024
For whatever crazy reason,

279
00:15:24.024 --> 00:15:28.474
if you've chosen to make JavaScript
your programming language of choice.

280
00:15:28.474 --> 00:15:32.035
If you write that primarily or exclusively
on a day-to-day basis, is it so

281
00:15:32.035 --> 00:15:35.340
crazy to think that you actually
ought to understand it?

282
00:15:35.340 --> 00:15:36.890
That you ought to know it more deeply?

283
00:15:38.060 --> 00:15:40.540
Is that such a far-fetched concept?

284
00:15:40.540 --> 00:15:44.720
Is it something that you couldn't possibly
ever convince your boss it's worth doing?

285
00:15:44.720 --> 00:15:47.030
Because your boss is only
concerned with shipping the code.

286
00:15:48.180 --> 00:15:50.960
Could you possibly ever have
a conversation with your boss that

287
00:15:50.960 --> 00:15:54.180
starts like, hey, I need some more
time to make sure I do this right.

288
00:15:55.310 --> 00:15:57.950
I suggest that, but you may be thinking
to yourself, well, that's all well and

289
00:15:57.950 --> 00:15:59.310
good in your ivory tower.

290
00:15:59.310 --> 00:16:02.400
But where I work, we're understaffed, and

291
00:16:02.400 --> 00:16:06.440
we're behind budget, and we're behind
track, and we gotta ship this code.

292
00:16:06.440 --> 00:16:08.310
And nobody cares about
any of that other stuff,

293
00:16:08.310 --> 00:16:11.730
just like we don't care about tests,
we don't care about documentation.

294
00:16:11.730 --> 00:16:13.090
All we care about is getting
the code out the door.

295
00:16:13.090 --> 00:16:17.400
I couldn't possibly have this kind
of a conversation with my boss.

296
00:16:17.400 --> 00:16:18.453
And I push back on and then I say,

297
00:16:18.453 --> 00:16:20.330
it's cuz you're having
the wrong kinda conversation.

298
00:16:22.130 --> 00:16:26.820
When you frame this conversation as I
need to go spend some more of my time,

299
00:16:26.820 --> 00:16:31.900
AKA I need to go waste some more of
your dollars, Mr. Manager or Ms Manager.

300
00:16:31.900 --> 00:16:33.960
I need to go waste some
more of that time and

301
00:16:33.960 --> 00:16:37.520
that money on stuff that you
don't perceive as useful,

302
00:16:37.520 --> 00:16:40.990
is because you haven't properly
talked about the value proposition.

303
00:16:43.070 --> 00:16:47.421
Because if you think about how much
managers budget for code maintenance.

304
00:16:47.421 --> 00:16:50.643
Remember we said code
maintenance is 70% of our time.

305
00:16:50.643 --> 00:16:52.977
And you think about how
much of their budget,

306
00:16:52.977 --> 00:16:56.175
I've interviewed managers of
software development teams,

307
00:16:56.175 --> 00:17:00.189
they budget 60% of their annual budget
just to fix the crap that we mess up.

308
00:17:01.740 --> 00:17:03.620
The overhead of managing a code base.

309
00:17:05.670 --> 00:17:09.560
You're not having the right value
proposition discussion with that boss

310
00:17:09.560 --> 00:17:10.760
when you myopically think well,

311
00:17:10.760 --> 00:17:13.190
all I gotta worry about is
what's gonna happen right now.

312
00:17:13.190 --> 00:17:14.230
When you say, you know what?

313
00:17:15.970 --> 00:17:18.502
You want me to spend one day,
I could spend two days on it.

314
00:17:18.502 --> 00:17:23.057
And there's a fixed cost for that,
versus if I spend one day on that code,

315
00:17:23.057 --> 00:17:28.650
that code will actually cost us 10,
or 15, or 20 days in the long haul.

316
00:17:28.650 --> 00:17:32.040
So let's start having a broader discussion

317
00:17:32.040 --> 00:17:35.360
about timelines beyond
what's happening today.

318
00:17:35.360 --> 00:17:38.250
Why don't we talk about what's
happening over this quarter?

319
00:17:38.250 --> 00:17:41.850
How much is that line of code gonna
cost us over the course of this quarter?

320
00:17:43.910 --> 00:17:47.420
Then we start to put in prospective why
investing in that line of code, and

321
00:17:47.420 --> 00:17:48.950
I use that word on purpose.

322
00:17:48.950 --> 00:17:52.982
Investing in that line of code to make
sure that we communicate clearly what

323
00:17:52.982 --> 00:17:53.819
we're doing.

324
00:17:53.819 --> 00:17:57.580
And, by the way,
there's a little nuance here.

325
00:17:57.580 --> 00:18:01.190
I'm sort of almost philosophically
fascinated by this nuance.

326
00:18:01.190 --> 00:18:03.580
There's the code that we write, but

327
00:18:03.580 --> 00:18:06.920
there's also the code that we
intentionally didn't write.

328
00:18:08.430 --> 00:18:13.920
Have you ever wondered why some piece
of code didn't need to be there?

329
00:18:13.920 --> 00:18:15.390
Have you ever looked at
a piece of code and said,

330
00:18:15.390 --> 00:18:16.900
why don't they need an if statement?

331
00:18:18.320 --> 00:18:19.360
Right?

332
00:18:19.360 --> 00:18:20.611
Why is this working?

333
00:18:20.611 --> 00:18:22.070
Why doesn't it need an if statement?

334
00:18:22.070 --> 00:18:25.530
Because my intuition is to think it could
come in null and throw an exception.

335
00:18:25.530 --> 00:18:27.620
Why doesn't it need an if statement here?

336
00:18:27.620 --> 00:18:31.293
Or if you've ever seen an if statement
that doesn't have an else clause, and

337
00:18:31.293 --> 00:18:33.560
ever wondered why isn't
there an else clause?

338
00:18:35.905 --> 00:18:39.509
&gt;&gt; Kyle Simpson: I'm philosophically
fascinated by the idea that programming

339
00:18:39.509 --> 00:18:43.590
languages don't do a very good job
of describing the absence of stuff.

340
00:18:45.570 --> 00:18:48.580
That's one of the things that we need to
get better at if we wanna communicate.

341
00:18:48.580 --> 00:18:51.187
The best that we can do right
now is to put a code comment,

342
00:18:51.187 --> 00:18:53.254
no else necessary because dot, dot, dot.

343
00:18:53.254 --> 00:18:57.062
And fill in the blanks, but maybe we need
to get better at designing our systems,

344
00:18:57.062 --> 00:19:00.814
and our languages, and our frameworks and
our patterns to communicate not only

345
00:19:00.814 --> 00:19:04.463
the stuff we intentionally did, but
all the stuff that we don't want there.

346
00:19:04.463 --> 00:19:07.208
So that the future reader of that
code doesn't have to wonder why isn't

347
00:19:07.208 --> 00:19:07.720
back there?

348
00:19:08.880 --> 00:19:10.429
The future reader of that
code doesn't have to run, or

349
00:19:10.429 --> 00:19:11.789
why couldn't you just
have it done it this way?

350
00:19:11.789 --> 00:19:15.734
Because we can communicate clearly
why that would have not worked and

351
00:19:15.734 --> 00:19:17.580
why we left that part of, okay?

352
00:19:19.400 --> 00:19:24.560
So that's the bar that I set,
no big deal, right?

353
00:19:24.560 --> 00:19:25.880
This is pretty easy.

