WEBVTT

1
00:00:00.390 --> 00:00:02.370
&gt;&gt; Kyle Simpson: Let's
talk about exercise one.

2
00:00:02.370 --> 00:00:07.500
Hopefully you felt you had adequate time
to get yourself acquainted with that code

3
00:00:07.500 --> 00:00:13.628
and with what it is supposed to be doing,
and had a chance to dig through it.

4
00:00:13.628 --> 00:00:17.930
So I wanna point out a little resource
that may not have been obvious if you

5
00:00:17.930 --> 00:00:19.300
looked at the file system.

6
00:00:19.300 --> 00:00:23.945
But in the exercise folder, not only do
I provide the solution file for each of

7
00:00:23.945 --> 00:00:29.040
these exercises, which by the way, there's
not always only one right way, okay?

8
00:00:29.040 --> 00:00:33.530
So if yours differs from it,
don't feel weird or whatever.

9
00:00:33.530 --> 00:00:35.440
There's multiple ways to approach it.

10
00:00:35.440 --> 00:00:39.080
This just represents one
good way of going about it.

11
00:00:39.080 --> 00:00:44.026
But in addition to that, what I also
provided was a diff between the exercise

12
00:00:44.026 --> 00:00:49.451
file and the solution file in each of
those directories, it's called diff.txt.

13
00:00:49.451 --> 00:00:53.750
And that's just the side by side diff
output from comparing those two files.

14
00:00:53.750 --> 00:00:57.950
So for example,
if I open up the diff here,

15
00:00:59.660 --> 00:01:05.950
you'll notice, and of course,
I need to turn off my word graph here.

16
00:01:05.950 --> 00:01:08.390
You'll notice that I have
a side by side diff going.

17
00:01:08.390 --> 00:01:15.790
Might be easier to look at this in VI or
in the terminal or something like that.

18
00:01:15.790 --> 00:01:19.655
Seems like my spacing and
my editor is going weird here.

19
00:01:19.655 --> 00:01:22.170
I don't know why my editor's not
looking at things correctly.

20
00:01:22.170 --> 00:01:26.240
Look at it in your
console [COUGH] in VI or

21
00:01:26.240 --> 00:01:28.130
something like that or
count the output of it.

22
00:01:28.130 --> 00:01:30.480
But that should be a resource for
you to be able to look and

23
00:01:30.480 --> 00:01:33.440
check to make sure that you addressed
each of the things that I addressed.

24
00:01:33.440 --> 00:01:36.170
So we'll kind of walk through
a few of these things.

25
00:01:36.170 --> 00:01:40.963
The README said to check to see if
there were strings that should have

26
00:01:40.963 --> 00:01:43.160
become numbers or vice versa.

27
00:01:43.160 --> 00:01:46.110
There were a couple of places
where that ended up happening,

28
00:01:46.110 --> 00:01:48.040
so I wanted to point those out.

29
00:01:48.040 --> 00:01:54.620
The first is if we look in
this click handler right here,

30
00:01:54.620 --> 00:01:58.900
the one that starts on line ten, this
click handler is what happens when you

31
00:01:58.900 --> 00:02:02.780
click the button to add the entry
that you've put into the form.

32
00:02:02.780 --> 00:02:06.867
And you'll notice that we're pulling
those values directly out of the form and

33
00:02:06.867 --> 00:02:10.226
then passing them along to this
add to work function on line 23.

34
00:02:10.226 --> 00:02:12.760
We're just passing them along as is.

35
00:02:12.760 --> 00:02:18.141
Now the projectID and the minutes
are actually numbers, and there are places

36
00:02:18.141 --> 00:02:23.542
where we rely upon those to be numbers so
that they're matching correctly.

37
00:02:23.542 --> 00:02:30.320
In particular, the projectID, we hard code
the project in, like the project name.

38
00:02:30.320 --> 00:02:34.530
But the ID for the project,
when it's generated, if you come to

39
00:02:34.530 --> 00:02:40.640
the addProject function, you'll notice
that that's a randomly generated number.

40
00:02:40.640 --> 00:02:43.650
So whatever number is passed
in from the Select box,

41
00:02:43.650 --> 00:02:47.600
we need to make sure that's a number
because there's gonna be a check done.

42
00:02:47.600 --> 00:02:50.130
That check happens right here.

43
00:02:50.130 --> 00:02:54.482
To check to make sure that the projectID
that's passed in is the same as what's in

44
00:02:54.482 --> 00:02:55.765
the projects element.

45
00:02:55.765 --> 00:03:00.810
And you'll notice I'm using a === there
to make sure that it exactly matches.

46
00:03:00.810 --> 00:03:04.723
So one option would have been for
you to relax that with a ==.

47
00:03:04.723 --> 00:03:06.620
That's one way of approaching it.

48
00:03:06.620 --> 00:03:10.230
And typically speaking, I would generally
say, yeah, that's not a bad idea for

49
00:03:10.230 --> 00:03:11.900
there to be a == there.

50
00:03:11.900 --> 00:03:15.451
What difference does it make whether if
it's the string, or the number equivalent?

51
00:03:15.451 --> 00:03:18.281
But I'm actually gonna
do it the other way,

52
00:03:18.281 --> 00:03:21.210
because there's a bigger question at play.

53
00:03:21.210 --> 00:03:24.180
Because minutes definitely
needs to be a number.

54
00:03:24.180 --> 00:03:28.690
So as a rule of thumb,
I don't wanna pass around or

55
00:03:28.690 --> 00:03:32.360
propagate a piece of data
through a system if it's not yet

56
00:03:32.360 --> 00:03:36.200
in its appropriate type representation.

57
00:03:36.200 --> 00:03:38.880
So the first place for
me to fix that is right here.

58
00:03:38.880 --> 00:03:42.660
So I could fix that by explicitly
coercing both the projectID and

59
00:03:42.660 --> 00:03:45.020
the minutes to the number form.

60
00:03:45.020 --> 00:03:47.474
So I'm gonna use the Number
function to do that.

61
00:03:54.248 --> 00:03:59.245
&gt;&gt; Kyle Simpson: [COUGH] Now I don't to
change that === to a == because we're

62
00:03:59.245 --> 00:04:05.484
ensuring that in all places where
the projectID is compared, it's a number.

63
00:04:05.484 --> 00:04:07.535
So the === is fine.

64
00:04:07.535 --> 00:04:12.370
You could also simplify
it to a == based only on

65
00:04:12.370 --> 00:04:17.626
the notion that if they're both numbers,
there's no reason for the === here.

66
00:04:17.626 --> 00:04:19.960
The == suffices,
cuz they're of the same type.

67
00:04:19.960 --> 00:04:23.770
So either way you wanted to go about that,
you could set it as == or

68
00:04:23.770 --> 00:04:26.900
leave it as ===, okay?

69
00:04:26.900 --> 00:04:29.520
Now that we've made
the minutes into numbers,

70
00:04:29.520 --> 00:04:32.599
you might have then started to notice,
if you tried it,

71
00:04:32.599 --> 00:04:36.922
you might have then started to notice that
when it was printing out the time, it

72
00:04:36.922 --> 00:04:41.740
was clearly doing some concatenation with
an undefined value or something like that.

73
00:04:41.740 --> 00:04:47.130
That's because currently
the addition of those

74
00:04:47.130 --> 00:04:52.270
minutes is not happening with a value
that's already guaranteed to be zero.

75
00:04:52.270 --> 00:04:54.940
So for example, right here when
we keep track of the project,

76
00:04:54.940 --> 00:04:56.470
the total project time,

77
00:04:56.470 --> 00:05:00.282
we're just saying project time essentially
incrementing by that number of minutes.

78
00:05:00.282 --> 00:05:03.750
But if projects.time has not
already been set to some number,

79
00:05:03.750 --> 00:05:08.570
then now we're concatenating or
adding undefined with minutes and

80
00:05:08.570 --> 00:05:12.764
that's gonna end up as NaN, right,
because undefined coerces to NaN.

81
00:05:12.764 --> 00:05:14.540
So there's a couple of ways
you could have solved that.

82
00:05:14.540 --> 00:05:18.810
You could have, in the project entry,
you could have forcibly set,

83
00:05:19.810 --> 00:05:22.410
right here you could have
forcibly set time to 0.

84
00:05:22.410 --> 00:05:23.695
That's one way of doing it.

85
00:05:23.695 --> 00:05:25.530
You could initialize it to 0.

86
00:05:25.530 --> 00:05:28.850
The other way of doing it,
which was a little bit more coercive,

87
00:05:28.850 --> 00:05:33.480
is to coerce this thing to
definitely be a number, or

88
00:05:33.480 --> 00:05:37.060
to ensure that this is definitely a number
using what we know about coercion.

89
00:05:37.060 --> 00:05:39.590
Here the default value idiom
might have been appropriate.

90
00:05:39.590 --> 00:05:44.196
So we could have said, projects.time || 0.

91
00:05:44.196 --> 00:05:47.337
Cuz if it's not already set, or even
if it was set, but it was set to zero,

92
00:05:47.337 --> 00:05:48.270
it doesn't matter.

93
00:05:48.270 --> 00:05:52.330
We can use zero as the base point for
that numeric addition.

94
00:05:52.330 --> 00:05:56.530
So the default idiom seems to be
a little bit more appropriate here for

95
00:05:56.530 --> 00:05:58.350
encoding our intent, which is,

96
00:05:58.350 --> 00:06:02.490
our intent is if it's not already set,
just use zero as the base point.

97
00:06:03.600 --> 00:06:06.491
There's another place
where that happens and

98
00:06:06.491 --> 00:06:09.395
that is,
&gt;&gt; Kyle Simpson: Let's check where we add

99
00:06:09.395 --> 00:06:10.150
up the work.

100
00:06:14.235 --> 00:06:15.820
&gt;&gt; Kyle Simpson: That happens right here.

101
00:06:15.820 --> 00:06:20.084
Again if the project entry
doesn't already have the time, so

102
00:06:20.084 --> 00:06:23.375
we can default idiom,
the project entry to 0.

103
00:06:27.827 --> 00:06:28.343
&gt;&gt; Kyle Simpson: Okay, so

104
00:06:28.343 --> 00:06:32.160
that should take care of the items
unless I'm forgetting something.

105
00:06:32.160 --> 00:06:34.670
That should take care
several of these items.

106
00:06:34.670 --> 00:06:39.260
But there's a couple of other places where
things still wouldn't be working correct.

107
00:06:39.260 --> 00:06:42.069
In particular, and
you might have discovered that

108
00:06:42.069 --> 00:06:46.199
the output when we formatted the time,
the output seemed to be incorrect.

109
00:06:46.199 --> 00:06:51.005
And it's because I intentionally have
the order of operations here not saved to

110
00:06:51.005 --> 00:06:53.540
the type conversions that we're doing.

111
00:06:53.540 --> 00:06:56.440
This is something obviously that
TypeScript would have caught for you.

112
00:06:56.440 --> 00:06:59.677
So this is one of those examples of
places where people would say, well,

113
00:06:59.677 --> 00:07:04.760
TypeScript would have let me know
that my variable was changing types.

114
00:07:04.760 --> 00:07:11.920
But you'll notice that here I change
minutes to be a string and then I rely

115
00:07:11.920 --> 00:07:18.380
upon minutes to be checked to see whether
it's 0 to just return the empty string.

116
00:07:18.380 --> 00:07:22.410
You might not have caught that unless
you tried to enter in no time for

117
00:07:22.410 --> 00:07:26.130
an element and it should have printed out
as empty, and it might have been printing

118
00:07:26.130 --> 00:07:29.760
out as something different,
perhaps with a NaN or something.

119
00:07:29.760 --> 00:07:33.740
So [COUGH] here the order of those
two operations needs to be swapped.

120
00:07:35.250 --> 00:07:39.840
Because we can't rely upon,
now line 150, needs to

121
00:07:39.840 --> 00:07:44.180
rely upon minutes still being a number if
it's gonna do that comparison against 0.

122
00:07:44.180 --> 00:07:46.587
We can't change it to be a string and

123
00:07:46.587 --> 00:07:52.066
especially a string that would have other
stuff in it, or it wouldn't compare.

124
00:07:55.309 --> 00:07:56.205
&gt;&gt; Kyle Simpson: Okay?

125
00:07:59.736 --> 00:08:03.328
&gt;&gt; Kyle Simpson: Next we need to look
at the validateWorkEntry function and

126
00:08:03.328 --> 00:08:05.611
implement those validation rules.

127
00:08:05.611 --> 00:08:09.870
First, the rule is that the description
text needs to be at least five

128
00:08:09.870 --> 00:08:11.420
characters long.

129
00:08:11.420 --> 00:08:14.770
Rather than reimplement this function, I'm
simply gonna switch to the solution file,

130
00:08:14.770 --> 00:08:15.888
and show you how I did that.

131
00:08:15.888 --> 00:08:20.720
You'll notice that description.link,
if it's less than five, I return false.

132
00:08:22.940 --> 00:08:30.780
I have a bias here in my validate
functions to always return a boolean.

133
00:08:30.780 --> 00:08:32.400
A false or a true.

134
00:08:32.400 --> 00:08:37.409
Sometimes people just do an early return,
and then rely upon, the undefined

135
00:08:37.409 --> 00:08:42.265
that gets returned as coercing to
a false value, because you'll notice,

136
00:08:42.265 --> 00:08:47.140
we use the validateWorkEntry here,
we just do a boolean check against it.

137
00:08:47.140 --> 00:08:50.015
So you could just do a return
here without anything, but

138
00:08:50.015 --> 00:08:52.720
I think this more clearly
communicates the intent.

139
00:08:52.720 --> 00:08:58.267
I'm affirmatively saying, the validation
failed by saying return false,

140
00:08:58.267 --> 00:09:00.670
and the same down here with true.

141
00:09:00.670 --> 00:09:04.428
I'm saying, if we get to this point,
the validation clearly succeeded and

142
00:09:04.428 --> 00:09:05.150
I'm returning true.

143
00:09:06.590 --> 00:09:07.640
Make sense?

144
00:09:07.640 --> 00:09:13.260
So my description check, length check,
if it's less than five, that's a failure.

145
00:09:13.260 --> 00:09:17.900
The read me says to also make sure that
minutes has to be a non-empty value

146
00:09:17.900 --> 00:09:21.035
ignoring the leading and
trailing white space.

147
00:09:21.035 --> 00:09:25.444
So I kind of knew right of the bat,
okay I'm gonna need something like

148
00:09:25.444 --> 00:09:29.030
a regular expression or
something like that to ignore.

149
00:09:29.030 --> 00:09:33.820
So the first thing is,
if I enter in something

150
00:09:33.820 --> 00:09:38.900
consisting only of white space,
that's what this check is doing.

151
00:09:38.900 --> 00:09:42.215
If I have something consisting only
of white space, or if it's empty,

152
00:09:42.215 --> 00:09:47.070
cuz I use the star here, then that lets
me know that this was a failed entry.

153
00:09:47.070 --> 00:09:48.610
You'll notice in the read me it says,

154
00:09:49.890 --> 00:09:53.200
leaving minutes blank is not valid,
it's invalid.

155
00:09:54.340 --> 00:09:57.334
So I wanted to check to make sure
that I wasn't leaving minutes blank.

156
00:09:57.334 --> 00:10:01.580
[COUGH] I also wanted to check
to make sure that what was being

157
00:10:01.580 --> 00:10:05.930
put into minutes could validly
be coerced to a number.

158
00:10:05.930 --> 00:10:07.616
So I first coerced it to a number and

159
00:10:07.616 --> 00:10:11.237
then checked to make sure that it
wasn't NaN, and I used Number.isNaN.

160
00:10:11.237 --> 00:10:15.391
I could have also used Object.isThere if
you prefer, and then I checked to make

161
00:10:15.391 --> 00:10:19.049
sure that minutes, given that I knew
that it was in the correct range,

162
00:10:19.049 --> 00:10:23.017
I checked to make sure that minutes was
within the appropriate range where it

163
00:10:23.017 --> 00:10:27.420
wasn't less than 0, so it wasn't negative,
and it wasn't greater than 600.

164
00:10:27.420 --> 00:10:30.237
That allows me then to
set a minutes of zero,

165
00:10:30.237 --> 00:10:34.436
if I didn't wanna log any time
against a particular work action.

166
00:10:40.139 --> 00:10:41.109
&gt;&gt; Kyle Simpson: The less than and

167
00:10:41.109 --> 00:10:45.190
greater than here are taking
advantage of implicit coercion.

168
00:10:45.190 --> 00:10:47.803
I did not,
at the top of my validate function,

169
00:10:47.803 --> 00:10:52.300
explicitly coerce minutes to a number,
and then do my checks against numbers.

170
00:10:52.300 --> 00:10:53.950
Why didn't I do that?

171
00:10:53.950 --> 00:10:54.596
Anybody spot why?

172
00:11:01.169 --> 00:11:03.147
&gt;&gt; Speaker 2: Cuz you have-
&gt;&gt; Speaker 3: Is it the regex?

173
00:11:03.147 --> 00:11:03.771
&gt;&gt; Kyle Simpson: What's that?

174
00:11:03.771 --> 00:11:04.650
&gt;&gt; Speaker 3: The regex.

175
00:11:04.650 --> 00:11:06.620
&gt;&gt; Kyle Simpson: Yeah,
because I wanted to test,

176
00:11:06.620 --> 00:11:12.470
if I had coerced minutes to a number, like
if I had said minutes = Number(minutes),

177
00:11:12.470 --> 00:11:15.590
cuz the first time I was making this
exercise that was my first approach, and

178
00:11:15.590 --> 00:11:17.260
then I thought, well wait a minute.

179
00:11:17.260 --> 00:11:20.380
What happens if somebody leaves it blank?

180
00:11:20.380 --> 00:11:24.330
It's an empty string, and
what's that gonna coerce to?

181
00:11:24.330 --> 00:11:26.180
That's gonna coerce to zero.

182
00:11:26.180 --> 00:11:30.100
Zero is supposed to be an allowed value
here, according to the validation rules,

183
00:11:30.100 --> 00:11:33.370
that's an allowed value, but
empty is not an allowed value.

184
00:11:33.370 --> 00:11:36.430
So I can't coerce first
before I check whether or

185
00:11:36.430 --> 00:11:39.180
not it's been passed
in as an empty string.

186
00:11:39.180 --> 00:11:40.120
Make sense?

187
00:11:40.120 --> 00:11:43.100
So I needed to do my check first
against the string value, and

188
00:11:43.100 --> 00:11:45.270
then do my check against
the coerced value.

189
00:11:45.270 --> 00:11:50.239
I took advantage of the fact, on lines
35 and 36 here, that the less than and

190
00:11:50.239 --> 00:11:54.616
greater than operators will
automatically coerce those to numbers,

191
00:11:54.616 --> 00:11:57.744
since they're doing
a comparison with numbers.

192
00:12:02.560 --> 00:12:07.010
&gt;&gt; Kyle Simpson: And that represents
the work to do on the exercise.

193
00:12:07.010 --> 00:12:10.969
So, what questions can I
answer about exercise one?

194
00:12:10.969 --> 00:12:15.078
&gt;&gt; Speaker 4: Can you please explain
what happens if you remove the line

195
00:12:15.078 --> 00:12:16.367
Number.isNaN?

196
00:12:16.367 --> 00:12:17.579
&gt;&gt; Kyle Simpson: This one?

197
00:12:17.579 --> 00:12:20.140
&gt;&gt; Speaker 4: Yeah, I mean what case?

198
00:12:20.140 --> 00:12:24.530
I just don't quite get what case
that it won't work correctly.

199
00:12:24.530 --> 00:12:28.241
&gt;&gt; Kyle Simpson: So
if we compare a string with a number,

200
00:12:28.241 --> 00:12:31.727
like if minutes came in as a string and

201
00:12:31.727 --> 00:12:36.900
it was something other than
a number representation,

202
00:12:36.900 --> 00:12:40.511
then what would happen, let me just.

203
00:12:40.511 --> 00:12:43.948
I'll literally comment it out,
I got to remember to undo it, but

204
00:12:43.948 --> 00:12:45.833
I'll literally comment that out.

205
00:12:50.770 --> 00:12:55.863
&gt;&gt; Kyle Simpson: So, if I type in a,
&gt;&gt; Kyle Simpson: You

206
00:12:55.863 --> 00:12:57.290
notice that it allowed it through.

207
00:12:57.290 --> 00:13:00.370
Now, why did it allow it through?

208
00:13:00.370 --> 00:13:02.490
It obviously ended up
failing with this NaN thing.

209
00:13:02.490 --> 00:13:04.590
Why did that pass through
the validation function?

210
00:13:04.590 --> 00:13:08.210
Well first of all it failed this check,
right, but

211
00:13:08.210 --> 00:13:12.370
then we asked the question
is quote a less than zero?

212
00:13:12.370 --> 00:13:14.520
That's the first question, and

213
00:13:14.520 --> 00:13:19.742
when there's a string involved it's
gonna actually do a lexicographic check,

214
00:13:19.742 --> 00:13:23.246
which is alphabetic character
check in ASCII code.

215
00:13:23.246 --> 00:13:24.242
&gt;&gt; Speaker 4: So it changed,-
&gt;&gt; Kyle Simpson: And

216
00:13:24.242 --> 00:13:25.809
quote a is not less than zero.

217
00:13:25.809 --> 00:13:26.950
&gt;&gt; Speaker 4: Okay.

218
00:13:26.950 --> 00:13:30.440
&gt;&gt; Kyle Simpson: And
it's also not greater than 600, okay?

219
00:13:30.440 --> 00:13:35.300
So it failed both of those tests
because NaN, even though it was

220
00:13:35.300 --> 00:13:40.200
doing the number check, NaN is not less
than zero, nor is it greater than 600.

221
00:13:40.200 --> 00:13:42.815
So either lexicographically or

222
00:13:42.815 --> 00:13:48.830
numerically NaN would pass through
just fine, which is not what we want.

223
00:13:48.830 --> 00:13:50.650
So we need to test for the NaN.

224
00:13:50.650 --> 00:13:54.299
&gt;&gt; Speaker 4: So when in comparison,
it first converted to a number,

225
00:13:54.299 --> 00:13:57.650
which will make it a NaN,
and then automatically?

226
00:14:00.690 --> 00:14:03.879
&gt;&gt; Kyle Simpson: Well let me answer
that definitively by modeling for

227
00:14:03.879 --> 00:14:06.932
you how you should be
answering these questions.

228
00:14:06.932 --> 00:14:11.109
You don't have somebody's book handy,
which we could go and

229
00:14:11.109 --> 00:14:15.220
look at my book, but
let's just see what the spec has to say.

230
00:14:15.220 --> 00:14:22.479
It is section 7,
of the abstract operations.

231
00:14:25.349 --> 00:14:31.495
&gt;&gt; Kyle Simpson: And
operations on objects.

232
00:14:39.050 --> 00:14:41.360
&gt;&gt; Kyle Simpson: All right, so
these are those algorithms,

233
00:14:41.360 --> 00:14:43.990
you remember the abstract equality one,
right?

234
00:14:43.990 --> 00:14:48.322
We looked at that one already 7.2.13
Abstract relational comparison is the less

235
00:14:48.322 --> 00:14:50.140
than and greater than.

236
00:14:50.140 --> 00:14:52.070
So let's see what this algorithm says,

237
00:14:52.070 --> 00:14:55.664
let's see if I can figure out
what it's talking about here.

238
00:14:55.664 --> 00:15:02.050
The comparison x &lt; y, where x and y are
values, produces true, false or undefined.

239
00:15:02.050 --> 00:15:06.566
In addition, it takes a Boolean flag
named LeftFirst as a parameter.

240
00:15:06.566 --> 00:15:09.600
We're gonna assume LeftFirst.

241
00:15:09.600 --> 00:15:16.060
So we were asking if the string a was
less than zero, why would that fail?

242
00:15:16.060 --> 00:15:20.479
So it said, if the LeftFlag is true,
which it would be,

243
00:15:20.479 --> 00:15:25.945
then we wanna take primitive of x,
which it's already a primitive.

244
00:15:29.440 --> 00:15:32.841
&gt;&gt; Kyle Simpson: Okay, so here it says,
if both comparisons are already strings,

245
00:15:32.841 --> 00:15:37.450
then it's gonna do a lexicographic
comparison, that's what it's doing here.

246
00:15:37.450 --> 00:15:39.610
It's gonna look at
the string characters and

247
00:15:39.610 --> 00:15:43.210
do that comparison, otherwise it's
gonna make them both into numbers.

248
00:15:43.210 --> 00:15:45.889
So it would of taken that quote a,
and make it into a number, and

249
00:15:45.889 --> 00:15:48.790
then it had the zero, and
it would have said, is NaN less than zero?

250
00:15:48.790 --> 00:15:56.192
So then we have here,
&gt;&gt; Kyle Simpson: Let's see, nx.

251
00:15:58.410 --> 00:16:02.711
Nx would be NaN because it was the quote
a that got coerced through a number so

252
00:16:02.711 --> 00:16:05.251
now it's the number representation of it.

253
00:16:05.251 --> 00:16:09.121
It's saying if nx is NaN return undefined.

254
00:16:09.121 --> 00:16:12.798
So that less than operation
wouldn't have returned false

255
00:16:12.798 --> 00:16:18.280
it would have returned undefined, but
undefined is a False value, right?

256
00:16:18.280 --> 00:16:20.370
So that would have failed that condition.

257
00:16:20.370 --> 00:16:25.121
The exact same logic applies when we try
the quote a greater than 600 is that

258
00:16:25.121 --> 00:16:29.360
it's gonna make quote A into NaN and
NaN is not greater than 600 for

259
00:16:29.360 --> 00:16:30.838
the exact same reason.

260
00:16:30.838 --> 00:16:35.830
So both would have been undefined and
undefined and both of those are false,

261
00:16:35.830 --> 00:16:36.693
those test.

262
00:16:36.693 --> 00:16:38.070
&gt;&gt; Speaker 4: It's just my
approach was different.

263
00:16:38.070 --> 00:16:43.797
I used a return, and I actually
compared that this is greater or

264
00:16:43.797 --> 00:16:47.913
equals than 0, less than or equals 600.

265
00:16:47.913 --> 00:16:49.808
That's why it worked in my case.

266
00:16:49.808 --> 00:16:53.939
&gt;&gt; Kyle Simpson: Okay, so the greater
than or equals actually does something

267
00:16:53.939 --> 00:16:57.263
interesting, and
I won't get fully into that.

268
00:16:57.263 --> 00:16:59.170
This is covered in
the types of grammar book.

269
00:16:59.170 --> 00:17:00.620
But we think that greater than or

270
00:17:00.620 --> 00:17:06.620
equals does the same thing as doing
greater than or an equality comparison.

271
00:17:06.620 --> 00:17:10.060
Turns out greater than or equals,

272
00:17:10.060 --> 00:17:14.337
does the less than and negates the result.

273
00:17:14.337 --> 00:17:15.579
So what was the less than?

274
00:17:15.579 --> 00:17:16.680
The less than was undefined.

275
00:17:16.680 --> 00:17:17.648
&gt;&gt; Speaker 4: Was undefined.

276
00:17:17.648 --> 00:17:19.710
&gt;&gt; Kyle Simpson: And then it would
have negated that to make it true.

277
00:17:19.710 --> 00:17:20.300
&gt;&gt; Speaker 4: True, okay.

278
00:17:20.300 --> 00:17:21.543
&gt;&gt; Kyle Simpson: So that's why it worked.

279
00:17:21.543 --> 00:17:23.090
So one of those happy accidents for you.

280
00:17:24.410 --> 00:17:29.174
&gt;&gt; Speaker 5: So as for a bonus for this
exercise, you ask how would you go about

281
00:17:29.174 --> 00:17:34.040
writing simple tasks to test
the behaviour of this application.

282
00:17:34.040 --> 00:17:38.694
How would that be different from
the function validate work entry?

283
00:17:38.694 --> 00:17:43.630
Is the function validate work entry
just kind of a date validator?

284
00:17:43.630 --> 00:17:46.557
&gt;&gt; Kyle Simpson: It's an input validator
but that's not testing the application.

285
00:17:46.557 --> 00:17:50.733
I remember by testing the application is,

286
00:17:50.733 --> 00:17:57.030
if I call the add work entry or
whatever that function is called.

287
00:17:57.030 --> 00:18:01.340
Add work to project, if I called add work
to project from certain set of inputs

288
00:18:01.340 --> 00:18:05.180
Does it actually end up producing the dom
elements that I expect in exactly

289
00:18:05.180 --> 00:18:07.400
the right place with exactly
the right contents, right?

290
00:18:07.400 --> 00:18:09.640
That' kind of an integration level test.

291
00:18:09.640 --> 00:18:13.210
There are also unit level tests that can
be performed on several of these, like for

292
00:18:13.210 --> 00:18:17.160
example to find project entry, I can
validate that if I pass in a specific

293
00:18:17.160 --> 00:18:21.600
project ID I get the project entry, if I
pass in a non-existent one I get nothing.

294
00:18:21.600 --> 00:18:25.090
So there's both unit tests and
integration tests that you could do here.

295
00:18:25.090 --> 00:18:26.700
I wasn't actually
expecting you to do that,

296
00:18:26.700 --> 00:18:29.210
I just wanted you to think about
how would I test this project?

297
00:18:31.300 --> 00:18:35.920
I'm glad you brought that up though,
because as we get further along here,

298
00:18:35.920 --> 00:18:40.755
you may find it to be useful because this
is certainly what I did when I was writing

299
00:18:40.755 --> 00:18:41.424
the code.

300
00:18:41.424 --> 00:18:43.949
Did I go back and fix that thing?

301
00:18:43.949 --> 00:18:45.933
You might find this useful.

302
00:18:49.550 --> 00:18:50.665
&gt;&gt; Kyle Simpson: I didn't fix that.

303
00:19:06.778 --> 00:19:08.397
&gt;&gt; Kyle Simpson: That should
give us an error and it does.

304
00:19:08.397 --> 00:19:12.093
So what I did is, I was doing this
to make sure as I did each iteration

305
00:19:12.093 --> 00:19:15.129
of this project,
that it still did the correct thing,

306
00:19:15.129 --> 00:19:18.299
is I actually had sort of a unit test or
integration test.

307
00:19:18.299 --> 00:19:23.042
I guess, more integration test that I
just ran in the console of my browser.

308
00:19:23.042 --> 00:19:25.348
So I basically called a set of calls.

309
00:19:25.348 --> 00:19:28.684
I said addWorkToProject.

310
00:19:28.684 --> 00:19:33.363
And I said, since I knew projects
was a public array, I could get at

311
00:19:33.363 --> 00:19:38.391
whatever the ID was that was randomly
generated for the first project.

312
00:19:38.391 --> 00:19:41.720
And then give it a really long comment and
then some number.

313
00:19:41.720 --> 00:19:46.848
So this was basically my integration
test that when I ran that, I expected

314
00:19:46.848 --> 00:19:52.750
to see exactly this behavior where I had
114 as my output and 36 or whatever.

315
00:19:52.750 --> 00:19:57.532
So I just visually made sure that every
time I made all these to the code

316
00:19:57.532 --> 00:20:01.166
that this code ran,
gave me the exact same results.

317
00:20:01.166 --> 00:20:05.484
I didn't verify it fully as a test week,
but that was kinda my Ad hoc testing.

318
00:20:05.484 --> 00:20:09.511
Then may be useful to you as you go
through your exercises 2 through 8 to

319
00:20:09.511 --> 00:20:12.548
come up with some kind of
test like that for yourself.

320
00:20:12.548 --> 00:20:16.541
Okay, so that represents our first core.

321
00:20:16.541 --> 00:20:18.010
The types and coercion system.

322
00:20:19.310 --> 00:20:23.871
Again, the takeaway there is to hope
that you will look at types and

323
00:20:23.871 --> 00:20:26.245
coercion with a fresh set of eyes.

324
00:20:26.245 --> 00:20:31.283
And ask how can I use that appropriately,
as opposed to just ignoring that topic or

325
00:20:31.283 --> 00:20:33.994
make a link to remove
any possibility of it.

326
00:20:33.994 --> 00:20:37.577
Where are places that I can use
my knowledge correctly to make my

327
00:20:37.577 --> 00:20:40.290
code better,
more expressive more readable?

