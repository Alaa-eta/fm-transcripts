[00:00:00]
>> Kyle Simpson: So let's jump into primitive types. The JavaScript spec lists out the following primitive types: undefined, string, number, boolean, object. Now these five are there. And to be honest with you, there's a sixth one that's listed that I'm not putting here on the list because it's ES6 and beyond, and also because it's a primitive type that nobody even really cares about.

[00:00:22]
At least I don't have much use for the symbol. Primitive type, it was added as an actual primitive, and we're not gonna really cover that in this course, but there is a symbol there. But there's a couple of others that I'll put on the list. Function and null.

[00:00:35]
It is definitely true that null is a real primitive type, but what's interesting about function is that function, though we may think of it as a type, as a value type, it certainly has a set of expected behaviors. By that pragmatic definition, it is a type, right? Because the aesthetics of us working with the code, we can do something different with a function than we can with any other value type.

[00:00:58]
We can call it. But actually, function is not a real first class primitive type. Actually, it's a subtype of the object type. Matter of fact, it's referred to as a callable object. That's interesting. So, you could say this is 7 or 6 types. It's really officially 6 types, plus the symbol type that I've left off.

[00:01:18]
That's what we're gonna focus on with this primitive types. I've highlighted nulls specifically because there's a bug with that type that we'll look at in just a moment. But, as I was saying earlier, it is the values that have types. So values that are in these different classifications, they are the things that have, they adopt or inherit this expected behaviors, something we can do with a number that we can't do with a boolean, for example.

[00:01:41]
Okay? So when I use the typeof operator, for example, and I do typeof foo, that looks like I'm asking what is the type of the variable, but actually what I'm asking is what is the type of the value that is currently in that variable? That's what the typeof operator's doing, because a variable can hold any type at any time.

[00:02:00]
We have that freedom. You may like that freedom, you may not like that freedom, and if you don't, choose TypeScript. But JavaScript itself offers us that freedom, and some of us don't just do that because we like to write poorly constructed code, some of us prefer that freedom.

[00:02:16]
I prefer to have the freedom to choose what type I put into a variable. I don't prefer to do silly things like, if I have a value that's gonna go through three different conversions, I have to come up with three different variables and then come up with some kind of naming convention like, you know, lowercase b is the first character to say that it's a boolean, and lowercase i to say that it's an integer or whatever.

[00:02:38]
Those kinds of things, to me, are silly. I don't like those kinds of conventions, so I prefer if it's gonna go through multiple steps, use the same variable. Cuz I'm describing the same thing, just different representations. So that's my way of thinking about stuff. TypeScript is great. If you like that, go the TypeScript way.

[00:02:53]
They're going to enforce that a variable needs to hold the same value type at all times. But you know what's something interesting about this typeof foo here? There is no foo variable. I didn't declare a foo there. The typeof operator is special privileged, and to my knowledge, the only specially privileged mechanism in the entire language which is able to deal with a variable that is non-existent and not throw an error.

[00:03:21]
Every other mechanism, if you refer to a variable and it doesn't exist, you're gonna get some kind of an error. We're gonna talk about those later today when we get into scope enclosure, we're gonna talk about those later in the course. But here, the typeof operator we're referring to a variable that has not been declared, and yet we get undefined, which is interesting because this is definitely not an undefined variable.

[00:03:46]
This is an undeclared variable. We'll, again, come back to this later in the course. But there's a big difference between defined and declared. Declared means physically exists in some scope, defined means has some value. Have some useful, non-empty value in it, okay? And JavaScript is not doing us any favors by conflating these two because that just makes things more confusing.

[00:04:10]
So I wish the typeof foo here would give us undeclared, but unfortunately, it gives us undefined, exactly the same as if we had an existent variable with no value in it at that time we'd get the same value about quote undefined. This was designed to be more forgiving of us accessing variables, like, for example, global variables.

[00:04:31]
If we're doing feature checks or things and the variable has not been defined, we don't wanna throw errors. We don't have to wanna wrap that stuff and try to catch, so they try to be more forgiving about it. But what they failed to do is give it a different return value so that we could distinguish those two cases, cuz they very much are different.

[00:04:49]
Matter of fact, there will be error messages that we'd talk about later, we'd get into scope and closure. There's error messages that will say things like, foo is not defined. And you think, wow, okay then. Foo is undefined. Cuz is not defined and undefined sure sound like they're saying the same thing, right?

[00:05:04]
Nope, foo is not defined is the JavaScript speak for foo is not declared. So you see why there's a problem if we use undefined as a conflation of undeclared. All right, well, typeof quote foo is pretty straightforward. We get quote string, quote number, quote boolean, quote object. You notice that the typeof operator always returns one of these six values, the seventh value being the symbol type that we're not covering here.

[00:05:29]
So quote undefined, string, number, boolean, object, and function. They're always string values that come back from the typeof operator. This is an invariant of this operator. It can never actually return undefined. It always would return quote undefined. I've seen many, many blog posts and even books, somehow made it through editing, or somebody else say something like, typeof x equal equal equal undefined.

[00:05:50]
And that's nonsense, because the typeof operator will never actually return that value. It will always return a string, okay?
>> Kyle Simpson: But there's a notable omission from this list, and it's the null, why? Well, if we say typeof null, we get back quote object. Instead of this, we might expect quote null.

[00:06:11]
Now, I had this grand unified theory at one time of why this was that nulls,the history of null was that it was really designed to like zero out object pointer, so it's kind of like null is this special, global, constant, object, thing, or whatever. That's the theory that I used to espouse.

[00:06:28]
And one day, I was tweeting about that, and this is years back, but I was tweeting about that, and it's kind of funny because it's almost like if you tweet about JavaScript. It's kind of like the bat signal for Brendan Eich, because to my knowledge, he didn't follow me on Twitter at the time, but he just showed up in my Twitter mentions.

[00:06:44]
Here's me just off in random land, tweeting about JavaScript and he shows up and he's like no, no, no, that's crazy. It's just a bug. So it turns out typeof null returning quote object is a bug, but we have this grand tradition in JavaScript that as soon as we make a mistake, let's make sure that that's permanent, write it in stone, and never fix it, so we're stuck with that bug from I don't know, day seven, I'm guessing, of JavaScript.

[00:07:12]
All right, cuz he created it in ten days. So somewhere along those ten days, he made this mistake, and we're stuck with it, cuz there's an invariant in computing science. There's nothing more permanent than a temporary hack. We have this perception in JavaScript that if we were to change stuff, my god, the world would come crashing down.

[00:07:30]
30% of the web would break and everybody would give up on the web and we'd all go to Silverlight or something like that because we can't fix JavaScript. We gotta just leave it in place. We can't break the web. It's a great romantic notion, it's just not practical.

[00:07:44]
And I think I'm probably gonna be around long enough where it comes to a head where we realize the future of the language hangs in the balance of our decision making about how we deal with mistakes that we make. It's a good thing that we have a high bar to putting stuff in the language.

[00:08:00]
Because if they just put in what ever they wanted to put in, we'd be making a lot more mistakes. But there are mistakes like this that create these problems and unfortunately, there's a lot of code out there, like a couple percent of all code in the existence of the web that if we were to change that behavior, it'd break that code.

[00:08:19]
Now, I wish that we could declare, kind of like we did with Y2K. We knew, in the future, there was an impending thing, and so everybody rallied to fix the problems ahead of time. So why don't we just pick a date in the future and say, on this date, we're gonna fix all these bugs, and everybody has got until that day to fix it.

[00:08:37]
That's how I think we would be more responsible. I'm not just saying just break everybody's code, but I'm saying give us some time. Give a five-year window or a three year window or whatever and say, between now and then, any part of the web that people cares about needs to get fixed.

[00:08:49]
Cuz we're gonna get rid of all of our old baggage and junk and move forward. I wish we do that because I deeply care about JavaScript surviving long in the future. A lot of people are predicting that JavaScript is gonna go away, that it's gonna die. JavaScript is 22 years old.

[00:09:12]
It's not even at its halfway point, as far as I'm concerned. Not even close. I'm not worried in my career. I'm a little further along in my career than some of you watching, but I'm not worried about in my career that JavaScript gonna go away. I'm pretty set and pretty secure in it.

[00:09:29]
There's a question online.
>> Speaker 2: Yeah, they're just asking if you could clear up again the difference between undefined and undeclared.
>> Kyle Simpson: Yeah, we will go over this again, so if you've missed that, don't worry. But undefined and undeclared, undefined means the variable exists, but right now, it doesn't have any value, so it has the undefined value in its place.

[00:09:48]
Kinda like the vacuum of space, if you will. You take everything else out, it's undefined, okay? That is an actual value, and that's when a variable exists, but at the moment, has no value. Undeclared means you literally never declared it in any scope that that piece of code has access to.

[00:10:04]
So in that previous slide, when I said typeof foo and there was no var foo in scope, foo, in that case, was an undeclared variable. As opposed to a declared variable that, at the moment, has no value. So that's the difference between undefined and undeclared, okay?
>> Kyle Simpson: So here we have a var foo that has been declared.

[00:10:28]
And I say, typeof foo, what am I gonna get back?
>> Speaker 3: Undefined?
>> Kyle Simpson: Quote undefined. I'm gonna be super picky here, okay? The string value undefined. Quote undefined. That's what I'm gonna get back. Now what about line 4? Don't get tricked by line 4. var bar = typeof bar.

[00:10:46]
At the moment that we run typeof bar, does bar exist?
>> Kyle Simpson: We'll get into that when we talk about scope and the compiler and all that stuff. Yes, it absolutely exists. What is its current value? At that moment, it's still undefined, so when I say typeof bar, what's gonna go into the bar variable that we see on line 5?

[00:11:09]
What is the value in bar gonna be at that point? It's gonna be quote undefined. And so then, on line 6, when I say typeof bar, what am I gonna get? Quote string. Same thing with line 8. What's line 8 gonna return? Quote string. Because the typeof 2 is quote number, and the typeof quote number is quote string, okay?

