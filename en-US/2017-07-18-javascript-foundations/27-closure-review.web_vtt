WEBVTT

1
00:00:00.210 --> 00:00:04.190
&gt;&gt; Kyle: So lets review our information so
far, and then we will get to an exercise.

2
00:00:04.190 --> 00:00:06.670
What is a closure and how is it created?

3
00:00:06.670 --> 00:00:08.900
In other words, without cheating and
looking back at the slides,

4
00:00:08.900 --> 00:00:10.710
tell me that definition for closure again.

5
00:00:11.930 --> 00:00:13.256
&gt;&gt; Speaker 2: The ability for

6
00:00:13.256 --> 00:00:17.030
the function to remember its scopes
&gt;&gt; Kyle: That is

7
00:00:17.030 --> 00:00:19.780
one part of the definition,
what's the second part?

8
00:00:19.780 --> 00:00:21.450
&gt;&gt; Speaker 3: Even outside
the lexical scope.

9
00:00:21.450 --> 00:00:25.080
&gt;&gt; Kyle: Even when the function is
executed outside of that lexical scope.

10
00:00:25.080 --> 00:00:28.700
It's a two part definition,
if you only have one of the two parts,

11
00:00:28.700 --> 00:00:29.530
it's not closure.

12
00:00:30.650 --> 00:00:34.590
Just having a function access variables,
that's just called lexical scope.

13
00:00:34.590 --> 00:00:36.700
Just having a function
run in a different scope,

14
00:00:36.700 --> 00:00:40.465
but it doesn't access any variables,
that is just a function.

15
00:00:40.465 --> 00:00:44.917
Having a function access variables
when running in a different scope,

16
00:00:44.917 --> 00:00:46.557
that's closure, okay?

17
00:00:46.557 --> 00:00:47.975
How is it created?

18
00:00:47.975 --> 00:00:50.741
Well, you declare a function
inside of another scope and

19
00:00:50.741 --> 00:00:53.055
you reference a variable
from its outer scope.

20
00:00:54.765 --> 00:00:56.015
The closure is created for you.

21
00:00:59.570 --> 00:01:01.822
&gt;&gt; Kyle: How long does
the scope stay around?

22
00:01:01.822 --> 00:01:06.820
[COUGH]
&gt;&gt; Kyle: How long does

23
00:01:06.820 --> 00:01:08.820
a scope that's been
closed over stay around?

24
00:01:10.970 --> 00:01:11.840
&gt;&gt; Speaker 2: Until there's no references.

25
00:01:11.840 --> 00:01:14.410
&gt;&gt; Kyle: Until there's no
more closure over it, right?

26
00:01:14.410 --> 00:01:17.307
So if there's 1,000 closures over it,
and 999 of them go away, and

27
00:01:17.307 --> 00:01:20.200
one's hanging around,
that scope's still hanging around.

28
00:01:20.200 --> 00:01:23.030
Soon as that last closure goes away,

29
00:01:23.030 --> 00:01:24.995
the scope is then free
to be garbage collected.

30
00:01:28.355 --> 00:01:31.501
&gt;&gt; Kyle: What was wrong with our whole
loop with the function callback inside of

31
00:01:31.501 --> 00:01:32.040
the thing?

32
00:01:32.040 --> 00:01:35.299
What was the main issue,
not the surface issue, but the main issue?

33
00:01:41.028 --> 00:01:44.993
&gt;&gt; Speaker 4: Is that
we changed var to let?

34
00:01:44.993 --> 00:01:45.647
That-
&gt;&gt; Kyle: Well,

35
00:01:45.647 --> 00:01:50.089
that was one way that solved it, but the
main issue was that we needed a different

36
00:01:50.089 --> 00:01:52.560
i for each iteration,
but we only had one i.

37
00:01:53.690 --> 00:01:56.799
So we of course were closing a bunch
of times over the same variable.

38
00:01:58.450 --> 00:02:00.310
So there were multiple
ways that we fixed it.

39
00:02:00.310 --> 00:02:03.460
One was the IFFE,
remember we put the IFFE inside of the for

40
00:02:03.460 --> 00:02:05.360
loop, that created a new i.

41
00:02:06.510 --> 00:02:10.180
Then we did a let j inside of the for
loop, and that created a new j for

42
00:02:10.180 --> 00:02:11.300
each iteration.

43
00:02:11.300 --> 00:02:15.610
Finally, we put the let directly in the
for header, which created a new i for us.

44
00:02:15.610 --> 00:02:18.530
All three of those were valid ways
of creating a new variable for

45
00:02:18.530 --> 00:02:22.470
each iteration,
&gt;&gt; Kyle: Okay?

46
00:02:25.550 --> 00:02:26.142
&gt;&gt; Kyle: Finally,

47
00:02:26.142 --> 00:02:29.700
what are the two characteristics
that make the module pattern?

48
00:02:31.922 --> 00:02:32.730
&gt;&gt; Speaker 5: Has to run once.

49
00:02:32.730 --> 00:02:35.504
&gt;&gt; Kyle: There has to be an outer
enclosing function that runs once,

50
00:02:35.504 --> 00:02:37.230
that's the first characteristic.

51
00:02:38.780 --> 00:02:41.180
&gt;&gt; Speaker 5: Inner function
that gets returned.

52
00:02:41.180 --> 00:02:44.454
&gt;&gt; Kyle: An inner function with closure
over that internal scope that gets

53
00:02:44.454 --> 00:02:45.906
returned on the public API.

54
00:02:45.906 --> 00:02:49.230
So we didn't really talk about this,
but I wanna take a moment,

55
00:02:49.230 --> 00:02:52.140
what do you think are the benefits
to the module pattern?

56
00:02:52.140 --> 00:02:52.851
In your own words,

57
00:02:52.851 --> 00:02:55.659
how would you describe why the module
pattern might be beneficial to code?

58
00:02:55.659 --> 00:02:59.220
&gt;&gt; Speaker 5: Organizing
code in a meaningful way

59
00:02:59.220 --> 00:03:00.150
&gt;&gt; Kyle: Organizing code,

60
00:03:00.150 --> 00:03:03.860
yup, that's true, but
we can also organize code with namespaces.

61
00:03:03.860 --> 00:03:07.640
So organizing's good, what's another
benefit to the module pattern?

62
00:03:07.640 --> 00:03:09.520
&gt;&gt; Speaker 5: Access, give access.

63
00:03:09.520 --> 00:03:11.430
&gt;&gt; Kyle: Restricting access, right?

64
00:03:11.430 --> 00:03:13.020
So that we are defensive,

65
00:03:13.020 --> 00:03:15.890
we're not exposing something that's
somebody's gonna use in a way that we

66
00:03:15.890 --> 00:03:19.780
weren't expecting, which then
prevents us from refactoring later.

67
00:03:19.780 --> 00:03:23.500
Primarily the module pattern
benefit is the encapsulation,

68
00:03:23.500 --> 00:03:26.780
the hiding of things that
we don't want to expose.

69
00:03:27.800 --> 00:03:31.730
Now, what do you think the downsides
might be of the module pattern?

70
00:03:36.394 --> 00:03:44.390
&gt;&gt; Kyle: One downside, doesn't get
talked about a lot, testability.

71
00:03:46.260 --> 00:03:47.835
If you are of the persuasion,

72
00:03:47.835 --> 00:03:51.140
cuz there are different schools
of thought within testing.

73
00:03:51.140 --> 00:03:55.350
Within testing, you might have a black
box tester who's somebody who wants to

74
00:03:55.350 --> 00:03:59.170
test stuff from the outside,
doesn't care about the internal details.

75
00:03:59.170 --> 00:04:01.870
But you might have somebody
else who's a white box tester.

76
00:04:01.870 --> 00:04:04.850
They test every internal
detail that they know about.

77
00:04:06.790 --> 00:04:09.620
Those folks often, in terms of unit tests,

78
00:04:09.620 --> 00:04:14.950
they want a test for every single
function in a piece of software,

79
00:04:14.950 --> 00:04:17.649
even it it's normally just a hidden
internal private function.

80
00:04:19.230 --> 00:04:23.390
So they use as their definition,
for the word unit, function.

81
00:04:24.560 --> 00:04:26.760
And every function needs to be tested,

82
00:04:26.760 --> 00:04:28.910
cuz there needs to be a unit test for
everything.

83
00:04:28.910 --> 00:04:32.920
So then the question becomes, how are you
gonna test a function if it's hidden?

84
00:04:34.780 --> 00:04:37.620
And we have had people invent all kinds of

85
00:04:37.620 --> 00:04:41.080
interesting slash crazy
approaches to that.

86
00:04:41.080 --> 00:04:42.950
Like for example, dependency injection,

87
00:04:42.950 --> 00:04:47.200
where you inject the testing apparatus
into the internals of your module, so

88
00:04:47.200 --> 00:04:50.780
that it can test itself from the inside
out, or other things like that.

89
00:04:52.590 --> 00:04:56.030
Some people have had code rewriting,
which will take a module and

90
00:04:56.030 --> 00:04:59.050
rewrite it with public code so
that they're accessible.

91
00:04:59.050 --> 00:05:03.156
Or other kinds of crazy things, there's
lots of ways you might approach it.

92
00:05:03.156 --> 00:05:07.492
So the module pattern may have
an effect on your testing strategy.

93
00:05:07.492 --> 00:05:12.140
If you're of that persuasion, the module
pattern sort of actively fights against

94
00:05:12.140 --> 00:05:16.540
you, and you have to invent these other
more sophisticated ways to test stuff.

95
00:05:16.540 --> 00:05:20.640
I happen to be of the opposite,
the black box perspective,

96
00:05:20.640 --> 00:05:24.880
which says a unit is not a function,
a unit is the single

97
00:05:24.880 --> 00:05:29.800
indivisible piece of business logic,
whatever that happens to be.

98
00:05:29.800 --> 00:05:34.230
Which might just be a giant module
with thousands of internal details and

99
00:05:34.230 --> 00:05:35.410
one public API method.

100
00:05:36.680 --> 00:05:40.260
Well my unit test needs to
test the public API method.

101
00:05:40.260 --> 00:05:44.350
The rest of the details are private
because they're supposed to be private.

102
00:05:44.350 --> 00:05:46.170
That's the way I think about testing.

103
00:05:46.170 --> 00:05:47.890
So for me the module pattern fits, but

104
00:05:47.890 --> 00:05:50.890
if you think the other way,
the module pattern might get in your way.

105
00:05:52.290 --> 00:05:55.730
That's one set of downsides to consider
when choosing the module pattern.

