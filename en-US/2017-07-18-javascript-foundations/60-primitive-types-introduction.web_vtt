WEBVTT

1
00:00:00.130 --> 00:00:01.780
&gt;&gt; Kyle Simpson: So
let's jump into primitive types.

2
00:00:01.780 --> 00:00:06.290
The JavaScript spec lists out
the following primitive types: undefined,

3
00:00:06.290 --> 00:00:09.010
string, number, boolean, object.

4
00:00:09.010 --> 00:00:10.320
Now these five are there.

5
00:00:10.320 --> 00:00:14.630
And to be honest with you, there's a sixth
one that's listed that I'm not putting

6
00:00:14.630 --> 00:00:19.620
here on the list because it's ES6 and
beyond, and

7
00:00:19.620 --> 00:00:22.490
also because it's a primitive type
that nobody even really cares about.

8
00:00:22.490 --> 00:00:25.510
At least I don't have much use for
the symbol.

9
00:00:25.510 --> 00:00:28.090
Primitive type,
it was added as an actual primitive, and

10
00:00:28.090 --> 00:00:31.140
we're not gonna really cover that in this
course, but there is a symbol there.

11
00:00:31.140 --> 00:00:33.620
But there's a couple of others
that I'll put on the list.

12
00:00:33.620 --> 00:00:35.200
Function and null.

13
00:00:35.200 --> 00:00:40.015
It is definitely true that null is a real
primitive type, but what's interesting

14
00:00:40.015 --> 00:00:44.059
about function is that function,
though we may think of it as a type,

15
00:00:44.059 --> 00:00:47.798
as a value type, it certainly
has a set of expected behaviors.

16
00:00:47.798 --> 00:00:51.416
By that pragmatic definition,
it is a type, right?

17
00:00:51.416 --> 00:00:55.418
Because the aesthetics of us working with
the code, we can do something different

18
00:00:55.418 --> 00:00:58.039
with a function than we can
with any other value type.

19
00:00:58.039 --> 00:00:59.640
We can call it.

20
00:00:59.640 --> 00:01:02.720
But actually, function is not
a real first class primitive type.

21
00:01:02.720 --> 00:01:05.240
Actually, it's a subtype
of the object type.

22
00:01:05.240 --> 00:01:07.430
Matter of fact,
it's referred to as a callable object.

23
00:01:07.430 --> 00:01:08.630
That's interesting.

24
00:01:10.640 --> 00:01:13.494
So, you could say this is 7 or 6 types.

25
00:01:13.494 --> 00:01:16.800
It's really officially 6 types,
plus the symbol type that I've left off.

26
00:01:18.140 --> 00:01:20.796
That's what we're gonna focus
on with this primitive types.

27
00:01:20.796 --> 00:01:23.380
I've highlighted nulls
specifically because

28
00:01:23.380 --> 00:01:25.720
there's a bug with that type that
we'll look at in just a moment.

29
00:01:25.720 --> 00:01:30.020
But, as I was saying earlier,
it is the values that have types.

30
00:01:30.020 --> 00:01:33.090
So values that are in these
different classifications,

31
00:01:33.090 --> 00:01:37.960
they are the things that have, they adopt
or inherit this expected behaviors,

32
00:01:37.960 --> 00:01:41.910
something we can do with a number that
we can't do with a boolean, for example.

33
00:01:41.910 --> 00:01:43.080
Okay?

34
00:01:43.080 --> 00:01:47.840
So when I use the typeof operator,
for example, and I do typeof foo,

35
00:01:47.840 --> 00:01:50.980
that looks like I'm asking what is the
type of the variable, but actually what

36
00:01:50.980 --> 00:01:54.740
I'm asking is what is the type of the
value that is currently in that variable?

37
00:01:55.750 --> 00:01:58.240
That's what the typeof operator's doing,

38
00:01:58.240 --> 00:02:00.820
because a variable can
hold any type at any time.

39
00:02:00.820 --> 00:02:02.243
We have that freedom.

40
00:02:02.243 --> 00:02:05.458
You may like that freedom, you may not
like that freedom, and if you don't,

41
00:02:05.458 --> 00:02:07.280
choose TypeScript.

42
00:02:07.280 --> 00:02:10.520
But JavaScript itself
offers us that freedom, and

43
00:02:10.520 --> 00:02:14.970
some of us don't just do that because we
like to write poorly constructed code,

44
00:02:14.970 --> 00:02:16.950
some of us prefer that freedom.

45
00:02:16.950 --> 00:02:22.520
I prefer to have the freedom to choose
what type I put into a variable.

46
00:02:22.520 --> 00:02:27.000
I don't prefer to do silly things like,
if I have a value that's gonna go through

47
00:02:27.000 --> 00:02:30.250
three different conversions, I have to
come up with three different variables and

48
00:02:30.250 --> 00:02:33.160
then come up with some kind of
naming convention like, you know,

49
00:02:33.160 --> 00:02:36.370
lowercase b is the first character
to say that it's a boolean, and

50
00:02:36.370 --> 00:02:38.700
lowercase i to say that it's an integer or
whatever.

51
00:02:38.700 --> 00:02:40.670
Those kinds of things, to me, are silly.

52
00:02:40.670 --> 00:02:42.670
I don't like those kinds of conventions,
so

53
00:02:42.670 --> 00:02:45.490
I prefer if it's gonna go through
multiple steps, use the same variable.

54
00:02:45.490 --> 00:02:48.380
Cuz I'm describing the same thing,
just different representations.

55
00:02:48.380 --> 00:02:50.490
So that's my way of thinking about stuff.

56
00:02:50.490 --> 00:02:51.210
TypeScript is great.

57
00:02:51.210 --> 00:02:53.345
If you like that, go the TypeScript way.

58
00:02:53.345 --> 00:02:58.274
They're going to enforce that a variable
needs to hold the same value type at all

59
00:02:58.274 --> 00:02:58.797
times.

60
00:02:58.797 --> 00:03:03.560
But you know what's something
interesting about this typeof foo here?

61
00:03:03.560 --> 00:03:06.030
There is no foo variable.

62
00:03:06.030 --> 00:03:07.280
I didn't declare a foo there.

63
00:03:08.682 --> 00:03:12.900
The typeof operator is special privileged,
and to my knowledge,

64
00:03:12.900 --> 00:03:16.920
the only specially privileged
mechanism in the entire language which

65
00:03:16.920 --> 00:03:20.450
is able to deal with a variable that
is non-existent and not throw an error.

66
00:03:21.620 --> 00:03:24.860
Every other mechanism, if you refer
to a variable and it doesn't exist,

67
00:03:24.860 --> 00:03:26.670
you're gonna get some kind of an error.

68
00:03:27.810 --> 00:03:32.580
We're gonna talk about those later
today when we get into scope enclosure,

69
00:03:32.580 --> 00:03:35.220
we're gonna talk about
those later in the course.

70
00:03:35.220 --> 00:03:38.110
But here, the typeof operator
we're referring to a variable that

71
00:03:38.110 --> 00:03:41.720
has not been declared,
and yet we get undefined,

72
00:03:41.720 --> 00:03:46.180
which is interesting because this is
definitely not an undefined variable.

73
00:03:46.180 --> 00:03:48.670
This is an undeclared variable.

74
00:03:48.670 --> 00:03:50.430
We'll, again,
come back to this later in the course.

75
00:03:50.430 --> 00:03:53.110
But there's a big difference
between defined and declared.

76
00:03:54.450 --> 00:03:58.940
Declared means physically exists in some
scope, defined means has some value.

77
00:04:00.500 --> 00:04:04.160
Have some useful,
non-empty value in it, okay?

78
00:04:04.160 --> 00:04:07.520
And JavaScript is not doing
us any favors by conflating

79
00:04:07.520 --> 00:04:10.330
these two because that just
makes things more confusing.

80
00:04:10.330 --> 00:04:14.520
So I wish the typeof foo here would
give us undeclared, but unfortunately,

81
00:04:14.520 --> 00:04:19.320
it gives us undefined, exactly the same
as if we had an existent variable with

82
00:04:19.320 --> 00:04:24.120
no value in it at that time we'd get
the same value about quote undefined.

83
00:04:26.040 --> 00:04:30.360
This was designed to be more forgiving of
us accessing variables, like, for example,

84
00:04:30.360 --> 00:04:31.270
global variables.

85
00:04:31.270 --> 00:04:35.070
If we're doing feature checks or things
and the variable has not been defined,

86
00:04:35.070 --> 00:04:36.550
we don't wanna throw errors.

87
00:04:36.550 --> 00:04:38.960
We don't have to wanna wrap that stuff and
try to catch, so

88
00:04:38.960 --> 00:04:40.650
they try to be more forgiving about it.

89
00:04:40.650 --> 00:04:44.080
But what they failed to do is give
it a different return value so

90
00:04:44.080 --> 00:04:47.510
that we could distinguish those two cases,
cuz they very much are different.

91
00:04:49.050 --> 00:04:51.885
Matter of fact, there will be error
messages that we'd talk about later,

92
00:04:51.885 --> 00:04:53.490
we'd get into scope and closure.

93
00:04:53.490 --> 00:04:57.990
There's error messages that will say
things like, foo is not defined.

94
00:04:57.990 --> 00:04:59.159
And you think, wow, okay then.

95
00:04:59.159 --> 00:05:00.410
Foo is undefined.

96
00:05:00.410 --> 00:05:01.590
Cuz is not defined and

97
00:05:01.590 --> 00:05:04.660
undefined sure sound like they're
saying the same thing, right?

98
00:05:04.660 --> 00:05:09.560
Nope, foo is not defined is the JavaScript
speak for foo is not declared.

99
00:05:10.910 --> 00:05:15.510
So you see why there's a problem if we use
undefined as a conflation of undeclared.

100
00:05:16.650 --> 00:05:18.980
All right, well, typeof quote
foo is pretty straightforward.

101
00:05:18.980 --> 00:05:21.780
We get quote string, quote number,
quote boolean, quote object.

102
00:05:21.780 --> 00:05:26.390
You notice that the typeof operator
always returns one of these six values,

103
00:05:26.390 --> 00:05:29.420
the seventh value being the symbol
type that we're not covering here.

104
00:05:29.420 --> 00:05:32.560
So quote undefined, string, number,
boolean, object, and function.

105
00:05:32.560 --> 00:05:35.720
They're always string values that
come back from the typeof operator.

106
00:05:35.720 --> 00:05:37.500
This is an invariant of this operator.

107
00:05:37.500 --> 00:05:40.840
It can never actually return undefined.

108
00:05:40.840 --> 00:05:42.970
It always would return quote undefined.

109
00:05:42.970 --> 00:05:46.490
I've seen many, many blog posts and even
books, somehow made it through editing,

110
00:05:46.490 --> 00:05:50.910
or somebody else say something like,
typeof x equal equal equal undefined.

111
00:05:50.910 --> 00:05:51.630
And that's nonsense,

112
00:05:51.630 --> 00:05:54.230
because the typeof operator will
never actually return that value.

113
00:05:55.260 --> 00:05:59.302
It will always return a string, okay?
&gt;&gt; Kyle Simpson: But

114
00:05:59.302 --> 00:06:03.670
there's a notable omission from this list,
and it's the null, why?

115
00:06:03.670 --> 00:06:06.890
Well, if we say typeof null,
we get back quote object.

116
00:06:06.890 --> 00:06:09.570
Instead of this,
we might expect quote null.

117
00:06:11.140 --> 00:06:16.450
Now, I had this grand unified theory at
one time of why this was that nulls,the

118
00:06:16.450 --> 00:06:20.120
history of null was that it was really
designed to like zero out object pointer,

119
00:06:20.120 --> 00:06:24.700
so it's kind of like null is this special,
global, constant, object, thing, or

120
00:06:24.700 --> 00:06:25.510
whatever.

121
00:06:25.510 --> 00:06:28.490
That's the theory that I used to espouse.

122
00:06:28.490 --> 00:06:31.400
And one day, I was tweeting about that,
and this is years back, but

123
00:06:31.400 --> 00:06:32.210
I was tweeting about that, and

124
00:06:32.210 --> 00:06:36.240
it's kind of funny because it's almost
like if you tweet about JavaScript.

125
00:06:36.240 --> 00:06:40.700
It's kind of like the bat signal for
Brendan Eich, because to my knowledge,

126
00:06:40.700 --> 00:06:42.180
he didn't follow me on
Twitter at the time, but

127
00:06:42.180 --> 00:06:44.240
he just showed up in my Twitter mentions.

128
00:06:44.240 --> 00:06:47.720
Here's me just off in random land,
tweeting about JavaScript and

129
00:06:47.720 --> 00:06:50.550
he shows up and he's like no,
no, no, that's crazy.

130
00:06:50.550 --> 00:06:51.180
It's just a bug.

131
00:06:52.230 --> 00:06:56.314
So it turns out typeof null
returning quote object is a bug, but

132
00:06:56.314 --> 00:07:01.245
we have this grand tradition in JavaScript
that as soon as we make a mistake,

133
00:07:01.245 --> 00:07:05.483
let's make sure that that's permanent,
write it in stone, and

134
00:07:05.483 --> 00:07:10.336
never fix it, so we're stuck with that
bug from I don't know, day seven,

135
00:07:10.336 --> 00:07:12.530
I'm guessing, of JavaScript.

136
00:07:12.530 --> 00:07:14.090
All right, cuz he created it in ten days.

137
00:07:14.090 --> 00:07:17.764
So somewhere along those ten days, he made
this mistake, and we're stuck with it,

138
00:07:17.764 --> 00:07:19.963
cuz there's an invariant
in computing science.

139
00:07:19.963 --> 00:07:22.360
There's nothing more permanent
than a temporary hack.

140
00:07:24.500 --> 00:07:28.801
We have this perception in JavaScript
that if we were to change stuff, my god,

141
00:07:28.801 --> 00:07:30.786
the world would come crashing down.

142
00:07:30.786 --> 00:07:33.902
30% of the web would break and
everybody would give up on the web and

143
00:07:33.902 --> 00:07:37.790
we'd all go to Silverlight or something
like that because we can't fix JavaScript.

144
00:07:37.790 --> 00:07:39.320
We gotta just leave it in place.

145
00:07:39.320 --> 00:07:41.400
We can't break the web.

146
00:07:41.400 --> 00:07:43.560
It's a great romantic notion,
it's just not practical.

147
00:07:44.840 --> 00:07:47.930
And I think I'm probably gonna
be around long enough where

148
00:07:47.930 --> 00:07:52.250
it comes to a head where we realize
the future of the language hangs in

149
00:07:52.250 --> 00:07:56.650
the balance of our decision making about
how we deal with mistakes that we make.

150
00:07:56.650 --> 00:08:00.860
It's a good thing that we have a high
bar to putting stuff in the language.

151
00:08:00.860 --> 00:08:03.506
Because if they just put in what
ever they wanted to put in,

152
00:08:03.506 --> 00:08:05.183
we'd be making a lot more mistakes.

153
00:08:05.183 --> 00:08:09.780
But there are mistakes like this that
create these problems and unfortunately,

154
00:08:09.780 --> 00:08:13.496
there's a lot of code out there,
like a couple percent of all code

155
00:08:13.496 --> 00:08:17.281
in the existence of the web that if
we were to change that behavior,

156
00:08:17.281 --> 00:08:18.650
it'd break that code.

157
00:08:19.960 --> 00:08:23.400
Now, I wish that we could declare,
kind of like we did with Y2K.

158
00:08:23.400 --> 00:08:27.240
We knew, in the future,
there was an impending thing, and so

159
00:08:27.240 --> 00:08:29.530
everybody rallied to fix
the problems ahead of time.

160
00:08:29.530 --> 00:08:32.910
So why don't we just pick a date in
the future and say, on this date, we're

161
00:08:32.910 --> 00:08:36.200
gonna fix all these bugs, and everybody
has got until that day to fix it.

162
00:08:37.220 --> 00:08:39.200
That's how I think we
would be more responsible.

163
00:08:39.200 --> 00:08:42.453
I'm not just saying just break everybody's
code, but I'm saying give us some time.

164
00:08:42.453 --> 00:08:46.040
Give a five-year window or a three year
window or whatever and say, between now

165
00:08:46.040 --> 00:08:49.610
and then, any part of the web that
people cares about needs to get fixed.

166
00:08:49.610 --> 00:08:56.320
Cuz we're gonna get rid of all of our
old baggage and junk and move forward.

167
00:08:56.320 --> 00:08:58.980
I wish we do that because
I deeply care about

168
00:09:00.480 --> 00:09:04.670
JavaScript surviving long in the future.

169
00:09:04.670 --> 00:09:08.520
A lot of people are predicting
that JavaScript is gonna go away,

170
00:09:08.520 --> 00:09:09.284
that it's gonna die.

171
00:09:10.450 --> 00:09:12.420
JavaScript is 22 years old.

172
00:09:12.420 --> 00:09:15.960
It's not even at its halfway point,
as far as I'm concerned.

173
00:09:15.960 --> 00:09:17.580
Not even close.

174
00:09:17.580 --> 00:09:18.980
I'm not worried in my career.

175
00:09:20.200 --> 00:09:23.060
I'm a little further along in my
career than some of you watching, but

176
00:09:23.060 --> 00:09:27.020
I'm not worried about in my career
that JavaScript gonna go away.

177
00:09:27.020 --> 00:09:28.530
I'm pretty set and pretty secure in it.

178
00:09:29.550 --> 00:09:30.840
There's a question online.
&gt;&gt; Speaker 2: Yeah,

179
00:09:30.840 --> 00:09:34.500
they're just asking if you could clear up
again the difference between undefined and

180
00:09:34.500 --> 00:09:36.038
undeclared.
&gt;&gt; Kyle Simpson: Yeah,

181
00:09:36.038 --> 00:09:38.650
we will go over this again, so
if you've missed that, don't worry.

182
00:09:38.650 --> 00:09:44.210
But undefined and undeclared,
undefined means the variable exists, but

183
00:09:44.210 --> 00:09:48.200
right now, it doesn't have any value, so
it has the undefined value in its place.

184
00:09:48.200 --> 00:09:50.182
Kinda like the vacuum of space,
if you will.

185
00:09:50.182 --> 00:09:53.350
You take everything else out,
it's undefined, okay?

186
00:09:53.350 --> 00:09:56.750
That is an actual value, and that's when
a variable exists, but at the moment,

187
00:09:56.750 --> 00:09:57.280
has no value.

188
00:09:58.490 --> 00:10:02.210
Undeclared means you literally never
declared it in any scope that that piece

189
00:10:02.210 --> 00:10:04.090
of code has access to.

190
00:10:04.090 --> 00:10:06.996
So in that previous slide,
when I said typeof foo and

191
00:10:06.996 --> 00:10:11.420
there was no var foo in scope, foo,
in that case, was an undeclared variable.

192
00:10:11.420 --> 00:10:15.343
As opposed to a declared variable that,
at the moment, has no value.

193
00:10:15.343 --> 00:10:18.592
So that's the difference between
undefined and undeclared,

194
00:10:18.592 --> 00:10:25.382
okay?
&gt;&gt; Kyle Simpson: So

195
00:10:25.382 --> 00:10:28.370
here we have a var foo
that has been declared.

196
00:10:28.370 --> 00:10:30.535
And I say, typeof foo,
what am I gonna get back?

197
00:10:30.535 --> 00:10:33.320
&gt;&gt; Speaker 3: Undefined?

198
00:10:33.320 --> 00:10:34.070
&gt;&gt; Kyle Simpson: Quote undefined.

199
00:10:34.070 --> 00:10:36.530
I'm gonna be super picky here, okay?

200
00:10:36.530 --> 00:10:37.900
The string value undefined.

201
00:10:37.900 --> 00:10:38.880
Quote undefined.

202
00:10:38.880 --> 00:10:40.500
That's what I'm gonna get back.

203
00:10:40.500 --> 00:10:41.240
Now what about line 4?

204
00:10:41.240 --> 00:10:42.741
Don't get tricked by line 4.

205
00:10:42.741 --> 00:10:46.040
var bar = typeof bar.

206
00:10:46.040 --> 00:10:49.438
At the moment that we run typeof bar,

207
00:10:49.438 --> 00:10:54.207
does bar exist?
&gt;&gt; Kyle Simpson: We'll get into

208
00:10:54.207 --> 00:10:57.800
that when we talk about scope and
the compiler and all that stuff.

209
00:10:57.800 --> 00:10:59.850
Yes, it absolutely exists.

210
00:10:59.850 --> 00:11:01.090
What is its current value?

211
00:11:02.550 --> 00:11:05.974
At that moment, it's still undefined,
so when I say typeof bar,

212
00:11:05.974 --> 00:11:09.260
what's gonna go into the bar
variable that we see on line 5?

213
00:11:09.260 --> 00:11:12.489
What is the value in bar
gonna be at that point?

214
00:11:12.489 --> 00:11:13.699
It's gonna be quote undefined.

215
00:11:13.699 --> 00:11:16.750
And so then, on line 6, when I say
typeof bar, what am I gonna get?

216
00:11:17.770 --> 00:11:19.240
Quote string.

217
00:11:19.240 --> 00:11:20.211
Same thing with line 8.

218
00:11:20.211 --> 00:11:21.350
What's line 8 gonna return?

219
00:11:22.650 --> 00:11:23.593
Quote string.

220
00:11:23.593 --> 00:11:26.572
Because the typeof 2 is quote number, and

221
00:11:26.572 --> 00:11:29.980
the typeof quote number is quote string,
okay?

