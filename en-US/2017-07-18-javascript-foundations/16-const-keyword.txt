[00:00:00]
>> Kyle Simpson: Quick little note on the Const Keyword. A lot of people have actually taken to now. Now they don't even say, let instead of var. Now they say, use const everywhere. Every once in a while use let and never use var. So the cult wisdom at this point is, always use const.

[00:00:16]
If you have to switch back to let, never use var. My advice is literally the opposite. Startup by using var, if you're gonna block scope, use let. Maybe every once in a while there's gonna be a need for a const. But let me explain why my advice is the inverse of the community common standard.

[00:00:34]
The const keyword implies a constant, and when I ask people, what is a constant? I typically get answers like this, it's a value that doesn't change. That's the general dictionary definition for it, a variable that doesn't change. Well that sounds all well and good except that's not what we mean in programming by a constant.

[00:00:56]
As a matter of fact, the constant in any language in existence, const does not have anything to do with the value. Const has to do with the assignment. A constant is not a value that doesn't change. A constant is a variable that cannot be reassigned. That might sound like an unimportant nuance.

[00:01:16]
But actually, It's a big, giant, huge deal. And my evidence for that is, go do some searches on stack overflow and see how many tens of thousands of questions in all languages, not just JavaScript have been asked over the years, of people frustrated about this const keyword in their language.

[00:01:32]
And why does it work this way and what does it mean and what does it do because they think that it's implying that we create a value that doesn't change and that's not what it does. That history, that precedent has been around for a really long time. We have adopted that history by bringing const into the JavaScript language.

[00:01:48]
And we have people today, right now, probably right at this moment, writing on stack overflow, I don't know why const isn't doing what I think it should? It's mostly because they use stuff like line 7. They declare const and make it reference something where the value itself is already a mutable value.

[00:02:04]
Like for example, an array or an object. What that means to the writer of that code is they're thinking to themselves, well c is never going to get reassigned. But the reader of the code thinks c is never gonna change. Do you see how those are different? Cuz if somebody changes c, hey now, wait a minute, I thought it was a const, why is it changing?

[00:02:25]
You've created a foot gun for people to get tripped up on. The usage of the const keyword in my book already starts out in the negative column. Because it already has this confusing precedent for 30 or more years that it's been in programming languages. It already starts out with that.

[00:02:44]
So for the const keyword to actually be useful, we would have to somehow overcome that. It would have to be not only good enough to overcome that negativity but be significantly better. So that it would really encourage the usage of it, it would carry its own weight. This is one more declarer that I have to learn.

[00:03:05]
And I don't think the const keyword really does that. I don't think it carries its own weight. Does it have any benefit whatsoever? It has a tiny amount of benefit. It might signal to a person, I'm not gonna reassign this thing. But if you're using the const as a block scoping declarator, which is what it is and what it's supposed to be used for.

[00:03:25]
If you use it in a block scope, your blocks are typically gonna be shorter in nature anyway or at least that's best practice to have your blocks at 5 or 10 or 15 lines, instead of thousands of lines. If you declare the const at the top of a block, say it's ten lines long.

[00:03:40]
You say, const x = 2 and then you have nine other lines within that block and you don't reassign it obviously cuz it can't be reassigned. Supposedly the benefit here is that you've told the reader of the code on line one, I'm not going to reassign it in any of the following 9 lines.

[00:04:01]
Cuz by the way, those ten lines are the only ten lines in the entire program that can reassign that variable. Nowhere else can it reassign it except for the block that it exists in. We know that cuz we know how lexical scope works now. So you're saying, I'm not gonna reassign it in any of the following nine lines.

[00:04:21]
If you've done a good job of writing your blocks in a short enough way where they can be all seen at one time on the page, visually on your screen. The other way to signal to people that you're not going to reassign it is to just not reassign it.

[00:04:35]
So, is the const really providing that much benefit there? It's a tiny amount of benefit at best. And it comes with this giant caveat of, people are gonna get confused about value versus assignment semantic. So, I don't think the const keyword carries its own weight. It has only a tiny amount of benefit.

[00:04:52]
I like to describe it kind of like a night light in child's bedroom. Because the night light in your child's bedroom does make your child feel better that there aren't any monsters in the closet. But we adults know, there aren't any monsters in the closet. So it's a reassuring thing but is it really helping?

[00:05:10]
I'm not so sure.
>> Kyle Simpson: So I still use const every once in a while. But I only use it for a value that's already immutable for example line four. If I was declaring a variable like var pi equals 3.14 or something like that, I'd do it with a const.

[00:05:29]
Makes complete sense, right? But I don't use const to declare my arrays, for sure. I don't use consts to declare my functions of any of that stuff, because I think I'm setting traps for people to fall into later.
>> Speaker 2: Can you elaborate on function expression? Why wouldn't you make a function expression a const?

[00:05:55]

>> Kyle Simpson: Why would I not make a function expression a const? Well, as I said earlier, my stylistic preference is that function declarations are more readable than function expressions assigned to variables. So I guess, in general, I would like to say that there's another reason, which we'll get to later in the course when we get to hoisting.

[00:06:12]
Function declarations behave differently than function expressions. And I tend to prefer the behavior of a function declaration over a function expression.
>> Kyle Simpson: But in a more narrow sense, I wouldn't do it because it doesn't offer any benefit.

