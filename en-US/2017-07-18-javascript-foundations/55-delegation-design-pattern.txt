[00:00:00]
>> Kyle Simpson: One last point to make about delegation, we'll wrap up and do our final exercise. Delegation is not just a simpler style of code. It's not just what I claim as a simpler mental model. It's actually a very different way of designing software. It's a different design pattern.

[00:00:18]
If functional programming is a design pattern. If class-oriented coding is a design pattern. Delegation is a third style of designing software. It doesn't get a lot of attention, because we've been using the system on prototypes to do classes instead of using it for what its really good at, which is delegation.

[00:00:41]
So I wanna point out that to begin to change your brain about how you design software using this system, you have to move away from the thought process of parent and child. And instead embrace objects that are peers of each other. You have to think about peer to peer instead of parent to child.

[00:00:59]
And I wanna give you a scenario to demonstrate that. Imagine I have a log in page in my application, and I have two different controllers. I have the Authcontroller, which handles communications with the server and I have the LoginFormController, which handles dealing with the webpage. Dealing with the input form and buttons, and displaying of error messages and all that.

[00:01:22]
I've only partially implemented these, so obviously there's missing functionality. But what I wanna point out is what's going on online 13 and 14. I make the LoginFormController, it's a real concrete object. I make it delegate to the AuthController object. It's not that that's it's parent, it's just there's two peers of each other.

[00:01:43]
And then this is how I let them work together. On line 16, I grabbed the username from the form and I set it into a property on my LoginFormController object. So I saved this .username equals and this .password equals, and then look at line 18. I call this .authenticate.

[00:02:07]
I'm calling a method that does not exist on LoginFormController.
>> Kyle Simpson: Where does it exists? Line 2, under AuthController. So I am intentionally delegating to a different object. Now authenticate, when it runs, what's the very first thing it does on line 4? It references this.username and this.password. But wait a minute, AuthController doesn't have a username and password property, does it?

[00:02:40]
But what is the this.keyword point at?
>> Kyle Simpson: Where's the call site?
>> Students: LoginForm?
>> Kyle Simpson: The call site is line 18, which is gonna be the LoginFormController. So when we are running line four, we're actually running in the context of the LoginFormController. And we're able to implicitly get the username and password property.

[00:03:04]
That context has been shared with that method. And here's where it really starts to get interesting. The callback that use for server.authenticate, I make it the handleResponse on my list object, but wait a minute, AuthController doesn't have a handleResponse method. Who has the handleResponse method?
>> Kyle Simpson: LoginFormController has handleResponse, okay?

[00:03:35]
Sorry, I call it handleResponse when I meant displayError and that's a mistake.
>> Kyle Simpson: Sorry about that, yeah. Okay, so I'm binding the handleResponse to call displayError. You see that?
>> Kyle Simpson: So what's really happening? Is that my LoginFormController object and my AuthController object are independent objects, but during the call context they virtually compose themselves into one context.

[00:04:12]
And one of them can share properties and the other one can share methods. And then when the call is done, they go back to being independent. That's the real power of delegation. That's what I call virtual composition.
>> Kyle Simpson: That at the call site, we decide to mix these two objects together.

[00:04:38]

>> Kyle Simpson: You might be wondering, why would this be beneficial? This is a different way of thinking than I've ever done before. I haven't needed it, why would I need it here? One of many benefits that I could point out in addition to all the questions that we might ask about simplicity of code and all that other stuff.

[00:04:57]
But one of the more concrete benefits to delegation is that now LoginFormController and AuthController are more easily testable. For example, if I wanted to test LoginFormController, all I need to do is make LoginFormController delegate to a mock off object, off controller object. I just make a fake AuthController, a mock, and I delegate to it.

[00:05:24]
And now I can fully test LoginFormController. If I wanna test AuthController, all I need to do is make a mock login form controller that delegates to it. These two pieces stay independent, which makes them easier to independently test. And they only sit together at the call site time through virtual composition.

[00:05:49]
Try independently testing two modules that are hard coded to each other. Try independently testing two classes, which are, one is instantiating the other or one is inheriting from the other. And you'll find out that testing pieces like that gets a lot harder. These pieces are much easier to test because they are independent.

[00:06:15]

>> Kyle Simpson: It has been claimed, and this is not unique to me, I'm simply repeating it. It has been claimed that if you compare a class oriented system to a delegation oriented system, that the delegation oriented system is actually more powerful than a class oriented system. And the reason for that claim is this, you can implement classes or fake classes with the delegation system, but you cannot implement delegation with the class system

[00:06:52]

>> Kyle Simpson: We've proven that, haven't we? Haven't we implemented classes on top of JavaScript's delegation system? But you can't do the reverse, you can't go into something like Java and implement this graceful style of dynamic context sharing of delegation. [COUGH]

