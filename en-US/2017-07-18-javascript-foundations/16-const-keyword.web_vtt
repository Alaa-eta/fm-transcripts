WEBVTT

1
00:00:00.050 --> 00:00:02.410
&gt;&gt; Kyle Simpson: Quick little
note on the Const Keyword.

2
00:00:02.410 --> 00:00:04.720
A lot of people have
actually taken to now.

3
00:00:04.720 --> 00:00:06.660
Now they don't even say,
let instead of var.

4
00:00:06.660 --> 00:00:08.390
Now they say, use const everywhere.

5
00:00:09.650 --> 00:00:11.600
Every once in a while use let and
never use var.

6
00:00:11.600 --> 00:00:16.220
So the cult wisdom at this point is,
always use const.

7
00:00:16.220 --> 00:00:19.290
If you have to switch back to let,
never use var.

8
00:00:19.290 --> 00:00:21.490
My advice is literally the opposite.

9
00:00:21.490 --> 00:00:25.250
Startup by using var,
if you're gonna block scope, use let.

10
00:00:25.250 --> 00:00:27.900
Maybe every once in a while there's
gonna be a need for a const.

11
00:00:27.900 --> 00:00:34.990
But let me explain why my advice is the
inverse of the community common standard.

12
00:00:34.990 --> 00:00:41.350
The const keyword implies a constant, and
when I ask people, what is a constant?

13
00:00:41.350 --> 00:00:44.620
I typically get answers like this,
it's a value that doesn't change.

14
00:00:45.770 --> 00:00:51.500
That's the general dictionary definition
for it, a variable that doesn't change.

15
00:00:51.500 --> 00:00:52.490
Well that sounds all well and

16
00:00:52.490 --> 00:00:54.970
good except that's not what we
mean in programming by a constant.

17
00:00:56.240 --> 00:00:59.180
As a matter of fact,
the constant in any language in existence,

18
00:00:59.180 --> 00:01:01.870
const does not have anything
to do with the value.

19
00:01:02.990 --> 00:01:06.220
Const has to do with the assignment.

20
00:01:06.220 --> 00:01:09.120
A constant is not a value
that doesn't change.

21
00:01:09.120 --> 00:01:11.980
A constant is a variable
that cannot be reassigned.

22
00:01:13.450 --> 00:01:16.290
That might sound like
an unimportant nuance.

23
00:01:16.290 --> 00:01:18.890
But actually, It's a big,
giant, huge deal.

24
00:01:20.180 --> 00:01:23.670
And my evidence for that is,
go do some searches on stack overflow and

25
00:01:23.670 --> 00:01:27.020
see how many tens of thousands
of questions in all languages,

26
00:01:27.020 --> 00:01:29.330
not just JavaScript have
been asked over the years,

27
00:01:29.330 --> 00:01:32.610
of people frustrated about this
const keyword in their language.

28
00:01:32.610 --> 00:01:36.370
And why does it work this way and what
does it mean and what does it do because

29
00:01:36.370 --> 00:01:39.250
they think that it's implying that we
create a value that doesn't change and

30
00:01:39.250 --> 00:01:39.920
that's not what it does.

31
00:01:40.960 --> 00:01:44.020
That history, that precedent has
been around for a really long time.

32
00:01:44.020 --> 00:01:48.260
We have adopted that history by bringing
const into the JavaScript language.

33
00:01:48.260 --> 00:01:51.970
And we have people today, right now,
probably right at this moment, writing on

34
00:01:51.970 --> 00:01:55.540
stack overflow, I don't know why const
isn't doing what I think it should?

35
00:01:55.540 --> 00:01:58.310
It's mostly because they
use stuff like line 7.

36
00:01:58.310 --> 00:01:59.670
They declare const and

37
00:01:59.670 --> 00:02:04.720
make it reference something where the
value itself is already a mutable value.

38
00:02:04.720 --> 00:02:06.550
Like for example, an array or an object.

39
00:02:08.080 --> 00:02:12.180
What that means to the writer of that
code is they're thinking to themselves,

40
00:02:12.180 --> 00:02:14.500
well c is never going to get reassigned.

41
00:02:14.500 --> 00:02:18.669
But the reader of the code
thinks c is never gonna change.

42
00:02:18.669 --> 00:02:20.720
Do you see how those are different?

43
00:02:20.720 --> 00:02:24.270
Cuz if somebody changes c, hey now,
wait a minute, I thought it was a const,

44
00:02:24.270 --> 00:02:25.980
why is it changing?

45
00:02:25.980 --> 00:02:29.240
You've created a foot gun for
people to get tripped up on.

46
00:02:30.450 --> 00:02:35.820
The usage of the const keyword in my book
already starts out in the negative column.

47
00:02:35.820 --> 00:02:39.320
Because it already has this
confusing precedent for 30 or

48
00:02:39.320 --> 00:02:42.546
more years that it's been
in programming languages.

49
00:02:42.546 --> 00:02:44.000
It already starts out with that.

50
00:02:44.000 --> 00:02:46.740
So for
the const keyword to actually be useful,

51
00:02:46.740 --> 00:02:50.150
we would have to somehow overcome that.

52
00:02:50.150 --> 00:02:54.190
It would have to be not only good
enough to overcome that negativity but

53
00:02:54.190 --> 00:02:56.460
be significantly better.

54
00:02:56.460 --> 00:02:59.590
So that it would really
encourage the usage of it,

55
00:02:59.590 --> 00:03:01.570
it would carry its own weight.

56
00:03:01.570 --> 00:03:03.540
This is one more declarer
that I have to learn.

57
00:03:05.140 --> 00:03:07.000
And I don't think the const
keyword really does that.

58
00:03:08.000 --> 00:03:10.370
I don't think it carries its own weight.

59
00:03:10.370 --> 00:03:12.540
Does it have any benefit whatsoever?

60
00:03:12.540 --> 00:03:14.760
It has a tiny amount of benefit.

61
00:03:14.760 --> 00:03:19.110
It might signal to a person,
I'm not gonna reassign this thing.

62
00:03:19.110 --> 00:03:22.090
But if you're using the const
as a block scoping declarator,

63
00:03:22.090 --> 00:03:25.000
which is what it is and
what it's supposed to be used for.

64
00:03:25.000 --> 00:03:29.380
If you use it in a block scope, your
blocks are typically gonna be shorter in

65
00:03:29.380 --> 00:03:33.180
nature anyway or at least that's best
practice to have your blocks at 5 or 10 or

66
00:03:33.180 --> 00:03:36.580
15 lines, instead of thousands of lines.

67
00:03:36.580 --> 00:03:40.615
If you declare the const at the top
of a block, say it's ten lines long.

68
00:03:40.615 --> 00:03:47.527
You say, const x = 2 and then you have
nine other lines within that block and

69
00:03:47.527 --> 00:03:53.970
you don't reassign it obviously
cuz it can't be reassigned.

70
00:03:53.970 --> 00:03:58.290
Supposedly the benefit here is that you've
told the reader of the code on line one,

71
00:03:58.290 --> 00:04:01.940
I'm not going to reassign it in
any of the following 9 lines.

72
00:04:01.940 --> 00:04:04.710
Cuz by the way,
those ten lines are the only ten

73
00:04:04.710 --> 00:04:07.089
lines in the entire program that
can reassign that variable.

74
00:04:08.640 --> 00:04:13.240
Nowhere else can it reassign it except for
the block that it exists in.

75
00:04:13.240 --> 00:04:15.200
We know that cuz we know how
lexical scope works now.

76
00:04:16.310 --> 00:04:21.010
So you're saying, I'm not gonna reassign
it in any of the following nine lines.

77
00:04:21.010 --> 00:04:24.150
If you've done a good job of writing
your blocks in a short enough way

78
00:04:24.150 --> 00:04:29.630
where they can be all seen at one time
on the page, visually on your screen.

79
00:04:29.630 --> 00:04:33.100
The other way to signal to people that
you're not going to reassign it is to just

80
00:04:33.100 --> 00:04:33.860
not reassign it.

81
00:04:35.060 --> 00:04:37.610
So, is the const really providing
that much benefit there?

82
00:04:38.690 --> 00:04:41.190
It's a tiny amount of benefit at best.

83
00:04:41.190 --> 00:04:43.490
And it comes with this giant caveat of,

84
00:04:43.490 --> 00:04:46.940
people are gonna get confused about
value versus assignment semantic.

85
00:04:46.940 --> 00:04:49.129
So, I don't think the const
keyword carries its own weight.

86
00:04:50.580 --> 00:04:52.060
It has only a tiny amount of benefit.

87
00:04:52.060 --> 00:04:55.670
I like to describe it kind of like
a night light in child's bedroom.

88
00:04:56.670 --> 00:05:00.190
Because the night light in your child's
bedroom does make your child feel better

89
00:05:00.190 --> 00:05:02.940
that there aren't any
monsters in the closet.

90
00:05:02.940 --> 00:05:05.890
But we adults know,
there aren't any monsters in the closet.

91
00:05:07.670 --> 00:05:10.720
So it's a reassuring thing but
is it really helping?

92
00:05:10.720 --> 00:05:11.310
I'm not so sure.

93
00:05:15.379 --> 00:05:18.420
&gt;&gt; Kyle Simpson: So
I still use const every once in a while.

94
00:05:18.420 --> 00:05:23.520
But I only use it for a value that's
already immutable for example line four.

95
00:05:23.520 --> 00:05:28.240
If I was declaring a variable like var
pi equals 3.14 or something like that,

96
00:05:28.240 --> 00:05:29.980
I'd do it with a const.

97
00:05:29.980 --> 00:05:32.350
Makes complete sense, right?

98
00:05:32.350 --> 00:05:35.820
But I don't use const to
declare my arrays, for sure.

99
00:05:35.820 --> 00:05:38.970
I don't use consts to declare my
functions of any of that stuff,

100
00:05:38.970 --> 00:05:41.730
because I think I'm setting traps for
people to fall into later.

101
00:05:44.734 --> 00:05:47.790
&gt;&gt; Speaker 2: Can you elaborate
on function expression?

102
00:05:48.950 --> 00:05:52.340
Why wouldn't you make
a function expression a const?

103
00:05:55.180 --> 00:05:57.320
&gt;&gt; Kyle Simpson: Why would I not
make a function expression a const?

104
00:05:57.320 --> 00:06:02.460
Well, as I said earlier, my stylistic
preference is that function declarations

105
00:06:02.460 --> 00:06:05.410
are more readable than function
expressions assigned to variables.

106
00:06:06.730 --> 00:06:10.250
So I guess, in general, I would like
to say that there's another reason,

107
00:06:10.250 --> 00:06:12.670
which we'll get to later in
the course when we get to hoisting.

108
00:06:12.670 --> 00:06:16.770
Function declarations behave
differently than function expressions.

109
00:06:16.770 --> 00:06:20.590
And I tend to prefer the behavior
of a function declaration over

110
00:06:20.590 --> 00:06:21.440
a function expression.

111
00:06:25.067 --> 00:06:26.723
&gt;&gt; Kyle Simpson: But
in a more narrow sense,

112
00:06:26.723 --> 00:06:30.190
I wouldn't do it because it
doesn't offer any benefit.

