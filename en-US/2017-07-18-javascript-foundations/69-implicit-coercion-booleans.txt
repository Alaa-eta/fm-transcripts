[00:00:00]
>> Kyle Simpson: What about Booleans? Anybody ever done an if statement before where you just passed in something that wasn't already a Boolean, whoever that done before? You might not have thought, I'm doing an implicit coercion. You might have done so well writing a blog post saying, implicit coercion is bad, that's implicit coercion.

[00:00:17]
The if statement requires a Boolean and if you don't give it a Boolean, guess what's gonna happen? It's gonna implicitly coerce it. Does that mean it's bad? Absolutely not, I think this is one of my favorite parts of JavaScript that it implicitly coerces those things to Boolean, so I don't have to worry about that detail.

[00:00:31]
You know why? Cuz that is not an important detail on that line of code. What I'm communicating here is that if it is truthy, make this thing happen. I don't need to clutter up that code by explicitly coercing it to a Boolean, so that I can do an if check.

[00:00:48]
The implicit system here is helpful because it hides the unnecessary noise.
>> Kyle Simpson: I'm a big fan of line two, but I don't see how you can be consistent in your world view point. To talk bad about implicit coercion and then code about that, there are people who do so.

[00:01:08]
Go look at Doug Crockford's code and compare that to what he says about coercion, compared to what he writes in his codes. I didn't mean it as an insult, but this is one those do as I say not as I do moments.
>> Kyle Simpson: I think we should be more consistent.

[00:01:25]

>> Kyle Simpson: So string 123, it's truthy, right? Cuz it's not on the falsy list, so we pass the if statement. The 0 on line 6 is that truthy or falsy? So on the falsy list, so it's false. So we're gonna print the right. Now what about line 10? Line 10's where things start to get a little bit strange here.

[00:01:46]
Cuz it works, we compare 0 to false with that dreaded ==, which we're gonna get lots into I promise. We compare 0 to false and it turns out that the check passes. So what's going on? Here's why I said earlier, I made you write down in your notes that the rules for Boolean coercion only happen if the rules for Boolean coercion are actually happening.

[00:02:14]
Remember that whole no op that I said? Sounded like a Buddhist monk saying something weird or whatever, like it only works when it works, right? Okay, gee, thanks. Here's what's happening. When you look at foo == false, 0 == false, I'm willing to bet that most if not all of you think to yourselves well, 0 is falsy, so it's gonna be false.

[00:02:39]
And then I compare false to false, and of course they're the same, so we pass the check, that's not what happens at all. As a matter of fact, line 10 only works because of a happy accident. I don't like relying on happy accidents in my code, I don't know about you.

[00:02:58]
Line 10 only works because of a happy accident. Here's what actually happens. We're gonna get into == in a minute, but I'll just tell you right now that what actually happens is that the == prefers to compare numbers. So what it's actually gonna do instead of making 0 into false and comparing the two falses.

[00:03:17]
It's gonna make false into 0 and compare the two 0s. Why? I don't know, probably cuz number of comparison is a lot more efficient in the internals of the CPU.
>> Kyle Simpson: But that's the way the algorithm was written. It prefers to compare numbers.
>> Kyle Simpson: I bet that's another one of those ones you could trip people on in an interview question.

[00:03:42]
Cuz most people never stop to think, how does that work? You just assume that is a Boolean coercion. Nope, it's not, and here it works. Your assumption works out okay for you, but it's a happy accident. On the next screen, I'm gonna show you something where that does not work so well, okay?

[00:03:58]

>> Kyle Simpson: Line 14, that OR operator, that pipe that we have there. Everybody recognizes that as the OR operator, the && being the AND operator. What do those things do? Well those things are often called logical operators, that's how they're labeled. That's how they're labeled in the official spec in the documentation.

[00:04:22]
They're called logical operators, why do you think they're called that? Well because in their original design, they produced a logical value aka true or false, that was their purpose. Their purpose was to produce a true or false. That is not how these operators work in JavaScript or Ruby or Python.

[00:04:45]
The difference is subtle, but actually pretty important. The OR operator here is not producing a true or a false. Baz is not going to be true or false. Baz is going to be quote foo. Woah, woah, wait a minute. The end result is not a logical result. The end result is that we actually just picked one of the operands.

[00:05:08]
The OR operator and the AND operator, these so called logical operators, actually are more like selection operators. They take two operands, they do a Boolean coercion test against the first one. And based upon that end result, pick one of the two. They select one of the two operands, that's what they do.

[00:05:30]
That's why we have this default value idiom that we've all probably seen. Where I can say, make baz equal to either foo or backup to quote foo as a default, if the variable foo wasn't already set. Cuz we're gonna do a Boolean check against foo and if it passes, we're gonna use foo.

[00:05:49]
Otherwise we're gonna use the thing on the other side, the other operand. So this thing is selecting one of the two operands, aame thing with the ampersand. Here, we call it the default value idiom with the ampersand. I don't know if any of you have ever seen this before, but elite JavaScript programmers like to show off their skills and how clever they are.

[00:06:10]
And they'll write cb&&cb(), which is a shorthand way of saying if the callback has been set then invoke the callback. Why? Because we're checking the value of the cb, and it only goes to the second operand if it passes as true. If it fails as false, we short circuit out and don't try to execute it.

[00:06:36]
So we're showing off our skills, relying upon, not only this implicit coercion happening, but also we're relying upon short circuiting of these operators. I'm not negative on that, I think those are great features, but we have to be honest that they're implicit features. How many of you have every written something like if A or B, or if A and B, and in all of those cases were those things already Booleans?

[00:07:08]

>> Kyle Simpson: So you're already relying upon implicit coercion. Does that create an identity crisis for you that you should go back and fix all your code and put in all those double negates all over the place? I would argue this is a place for the implicit coercion is helping the readability of your code.

[00:07:27]
Are we following that reasoning? Here's where the == stuff starts to get crazy for us because here, we have the string 1, 2, 3. Now the string 1,2,3 we've already established that it's truthy, right? So when I == it to true and that fails, my whole world starts to fall apart.

[00:07:48]
How can something be truthy, but not == to true?
>> Kyle Simpson: Well it's cuz the == isn't doing a Boolean coercion at all, just like I said before. The == prefers to compare numbers, so if I give it a string and a Boolean, guess what's gonna happen? Both of them are gonna get coerced to numbers.

[00:08:10]
The string is gonna coerce to the number 1, 2, 3. The true is gonna coerce to the number 1, and the number 1, 2, 3 and the number 1 are most definitely not equal to each other.
>> Kyle Simpson: Now you may be thinking at this point, I promise we're getting to == in a minute.

[00:08:26]
But you may be thinking at this point, well jeez, this == just seems hopelessly complicated. I'm never gonna be able to fully understand this == thing. Not true, it's actually a very simple algorithm. Here's the one key take away, we'll come back to this. If you just know, the == prefers to compare numbers, most of the behavior simplifies itself.

[00:08:49]
That's just something nobody's ever taught you before, == prefers to compare numbers. Just that one fact eliminates most of the confusion of the ==, okay? We'll get into more of that. So here, it's not doing a Boolean coercion. So let me give you a take away, you're looking for like I don't wanna talk about abstract.

[00:09:10]
Give me practical stuff, here's a take away. Don't ever under any circumstances and I don't very often use absolutes, but this is one of them. Don't ever under any circumstances compare with == true or == false. Just never, ever, ever, ever, ever do it. Because most likely it's only gonna work as a happy accident, and in the worst case, it's gonna confuse people and create bugs.

[00:09:38]
Just don't do it. We've already talked about multiple other ways for you to either let it do the implicit coercion for you or be explicit about it. But don't rely upon == to true or == to false, cuz they aren't gonna do what you're expecting them to do.

[00:09:57]

>> Kyle Simpson: And more importantly they're not gonna do what the future reader of your code is expecting it to do.
>> Kyle Simpson: Same thing down on line 7, we got an array. We know the array, even though it's an empty array, it's truthy. Why is it truthy?
>> Kyle Simpson: It's not on the falsy list, right?

[00:10:19]
Even though an empty array seems like it ought to be, it's not on the falsy list so it's gotta be truthy. So we do an if test for it, and sure enough it passes as true. So we've established that it's truthy, but on line 10 we ==it to false, and that also passes.

[00:10:34]
How can something be both truthy and == to false?
>> Kyle Simpson: Well maybe it's cuz the == doesn't do a Boolean coercion. Maybe it's cuz that == is gonna try and do a numeric coercion. So we're gonna take the empty array. Remember, primitives need to be, I mean non primitives need to become primitives.

[00:10:53]
So what is the two primitives of an empty array gonna produce?
>> Speaker 2: String zero.
>> Kyle Simpson: An empty string. First before getting there, right? You're right. We're gonna produce an empty string. So now what we really have is empty string == to false. Now we still prefer numbers, right?

[00:11:12]
So we're gonna turn the empty string into a number. Which one does that become?
>> Speaker 2: 0.
>> Kyle Simpson: 0. We're gonna turn false into a number which one does that become? So now we have these 0s. There's our root of all evil again. I told you, it could be coming back to that around.

[00:11:31]
The gateway drug here is the == comparison with the Boolean, just don't do it

