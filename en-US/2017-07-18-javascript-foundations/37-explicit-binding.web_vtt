WEBVTT

1
00:00:00.570 --> 00:00:03.931
&gt;&gt; Kyle: A third way for a function
to be called is with a .call, or

2
00:00:03.931 --> 00:00:05.700
the .apply method.

3
00:00:05.700 --> 00:00:06.630
Look at line 9.

4
00:00:06.630 --> 00:00:10.277
I'm calling foo, but
I'm actually calling it using foo.call.

5
00:00:10.277 --> 00:00:12.610
I could have said, foo.apply as well.

6
00:00:12.610 --> 00:00:16.780
You'll notice that the first
argument passed to both call and

7
00:00:16.780 --> 00:00:21.370
apply is used as the this binding for
that function.

8
00:00:22.830 --> 00:00:28.570
So, here we are explicitly saying, call
foo, and use obj as it's this context.

9
00:00:31.660 --> 00:00:36.952
Which is why we get bar2
&gt;&gt; Kyle: That's a third way for

10
00:00:36.952 --> 00:00:38.180
a function to be called.

11
00:00:39.880 --> 00:00:40.900
So, three rules down,

12
00:00:40.900 --> 00:00:44.420
default rule, implicitly binding rule,
explicit binding rule.

13
00:00:45.610 --> 00:00:50.320
We're gonna take a slight detour and talk
about a variation of explicit binding,

14
00:00:50.320 --> 00:00:54.590
which is a problem that we often run into,
you may have run into this before.

15
00:00:54.590 --> 00:00:59.320
It's often referred to informally
as losing the this binding, or

16
00:00:59.320 --> 00:01:01.560
having this unbound.

17
00:01:01.560 --> 00:01:05.370
What happens is the function
call site is the important part.

18
00:01:05.370 --> 00:01:11.290
So, let's say you take a function like,
for example, the one from line 10.

19
00:01:11.290 --> 00:01:15.380
And you pass in 02.foo as
a callback to some other utility.

20
00:01:16.740 --> 00:01:21.170
And when that utility invokes
the function, what is it's call site gonna

21
00:01:21.170 --> 00:01:26.390
look like, it's gonna override,
or throw away the 02 this binding

22
00:01:26.390 --> 00:01:31.340
that you otherwise normally would have,
because it's the call site that matters.

23
00:01:31.340 --> 00:01:35.810
So, one of the problems that we have is
when we make this this aware functions,

24
00:01:35.810 --> 00:01:39.089
we are not in control of how
they're going to be invoked.

25
00:01:39.089 --> 00:01:42.376
And if we're not in control
of how they're being invoked,

26
00:01:42.376 --> 00:01:45.807
then we cannot predict what this
keyword is going to point to.

27
00:01:45.807 --> 00:01:49.300
It's called losing your this binding,
everybody follwoing that?

28
00:01:50.690 --> 00:01:55.200
So, let's imagine this scenario where I
could do something called hard binding.

29
00:01:55.200 --> 00:01:59.720
If I wanted to pass in a function,
or if I wanted to make

30
00:01:59.720 --> 00:02:04.600
a function that no matter how it was
called and had a predict of all this.

31
00:02:04.600 --> 00:02:10.290
On line 11, I have made, I am calling what
is referred to as a hard bound function.

32
00:02:10.290 --> 00:02:12.850
Look at how foo is defined on line 9.

33
00:02:12.850 --> 00:02:19.950
Foo is defined on line 9 to
hard-code the .call into it,

34
00:02:19.950 --> 00:02:23.630
so that it forcibly says,
use obj no matter how you're called.

35
00:02:25.190 --> 00:02:28.240
Which is why on line 12 if
we try to overwrite it,

36
00:02:28.240 --> 00:02:32.160
it just silently ignores that and says,
thanks very much I'm going to use obj.

37
00:02:34.010 --> 00:02:36.427
So, line 12 would actually
still print out bar,

38
00:02:36.427 --> 00:02:42.204
not bar2.
&gt;&gt; Kyle: Now, that pattern of

39
00:02:42.204 --> 00:02:47.713
making a function that hard binds it, that
explicitly says, using .call, or .apply,

40
00:02:47.713 --> 00:02:52.857
the reason why this is not a new rule, but
a variation is, because under the covers,

41
00:02:52.857 --> 00:02:56.869
it's using a .call, or a .apply,
which is explicit binding.

42
00:02:58.920 --> 00:03:01.490
But we don't want to go making
these functions ourselves.

43
00:03:01.490 --> 00:03:04.780
That's ugly to have to make
a function like we do on line 9.

44
00:03:04.780 --> 00:03:07.950
We could make the utility for that, and
it turns out that there's a utility built

45
00:03:07.950 --> 00:03:14.526
into JavaScript to make these hard
bound functions and it's called .bind.

46
00:03:14.526 --> 00:03:19.560
On line 7 I make a hard bound
version of foo by calling .bind, and

47
00:03:19.560 --> 00:03:24.580
the first argument that I passed in obj is
the this that it will be hard bound too.

48
00:03:26.720 --> 00:03:31.619
So, now, on line 9 when I call it, it
doesn't matter how I call it, it's always

49
00:03:31.619 --> 00:03:38.093
gonna use the obj as it's this.
&gt;&gt; Kyle: That's

50
00:03:38.093 --> 00:03:39.350
called a hard bound function.

51
00:03:40.590 --> 00:03:44.470
So, any time you've got a function
that is this sensitive, or

52
00:03:44.470 --> 00:03:49.370
this aware, and you reference it and pass
it in somewhere, and you're not going to

53
00:03:49.370 --> 00:03:53.530
be in control of the call site, the way
to solve that problem is to instead of

54
00:03:53.530 --> 00:03:57.700
passing in the function itself, pass in
a hard bound version of the function.

55
00:03:58.752 --> 00:04:01.340
And then you know it's always going

56
00:04:01.340 --> 00:04:05.110
to be used calling the this
that I want it to be called.

57
00:04:06.110 --> 00:04:07.751
Okay?

58
00:04:07.751 --> 00:04:11.468
Now, I want to stop for a moment and
ask you to analyze, think critically for

59
00:04:11.468 --> 00:04:12.000
a moment.

60
00:04:13.540 --> 00:04:19.990
Do we see the benefit to gaining some
predictability here with these functions

61
00:04:19.990 --> 00:04:24.610
when you say, I want it to always use,
I want to lock it to this specific this?

62
00:04:24.610 --> 00:04:28.350
Do we see the benefit that allows us
to pass those functions around and

63
00:04:28.350 --> 00:04:30.670
not worry about them losing a this?

64
00:04:30.670 --> 00:04:31.174
What's the downside?

65
00:04:41.674 --> 00:04:43.330
&gt;&gt; Speaker 2: You lose flexibility.

66
00:04:43.330 --> 00:04:44.930
&gt;&gt; Kyle: You lose the flexibility, right?

67
00:04:44.930 --> 00:04:49.460
Isn't the whole reason for
that this keyword to have flexibility?

68
00:04:50.520 --> 00:04:53.358
What other system have already learned
about in this workshop where we get

69
00:04:53.358 --> 00:04:59.680
predictability?
&gt;&gt; Kyle: Lexical scope?

70
00:04:59.680 --> 00:05:01.680
Remember that?

71
00:05:01.680 --> 00:05:04.350
Lexical scope is all about being
fixed at all through time,

72
00:05:04.350 --> 00:05:06.350
it's all about predictability.

73
00:05:06.350 --> 00:05:09.180
That this keyword is
all about flexibility,

74
00:05:09.180 --> 00:05:11.760
using a function in multiple
different contexts.

75
00:05:12.820 --> 00:05:17.010
So, wait a minute, we've just created a
pattern which shoots ourself in the foot.

76
00:05:17.010 --> 00:05:20.330
Hard binding takes this
whole dynamic system and

77
00:05:20.330 --> 00:05:23.110
throws away all the dynamicism and
makes it predictable again.

78
00:05:24.150 --> 00:05:25.270
Why would we want to do that?

79
00:05:27.090 --> 00:05:32.150
What I'm getting at here is that there
is a tension between flexibility and

80
00:05:32.150 --> 00:05:33.820
predictability.

81
00:05:33.820 --> 00:05:36.900
There's no one right answer here,
there's a tension.

82
00:05:36.900 --> 00:05:38.490
And, because there's a tension,

83
00:05:38.490 --> 00:05:44.240
you have to make subjective judgment calls
as to which is the appropriate mechanism.

84
00:05:44.240 --> 00:05:47.930
So, let me share with you
a heuristic that I use to determine,

85
00:05:47.930 --> 00:05:50.340
am I doing things the appropriate way?

86
00:05:50.340 --> 00:05:52.290
Is this best practice?

87
00:05:52.290 --> 00:05:57.020
Say I architect my code and
I've got all these this aware functions

88
00:05:57.020 --> 00:05:59.840
defined on some object
named space somewhere.

89
00:05:59.840 --> 00:06:01.760
And let's look at all of my call sites,
and

90
00:06:01.760 --> 00:06:07.630
let's imagine that on all of my call
sites, they all look like maybe this one.

91
00:06:09.180 --> 00:06:13.020
They all look like o2.foo, okay, great.

92
00:06:13.020 --> 00:06:19.470
No big deal, because I'm using the system
the way it's appropriately designed.

93
00:06:19.470 --> 00:06:24.280
And let's say every once in a while I have
to make one of these hard bound versions

94
00:06:24.280 --> 00:06:27.210
like we see here on line 7 of this slide.

95
00:06:27.210 --> 00:06:30.111
Every once in a while I have to
make a hard bound version, but

96
00:06:30.111 --> 00:06:31.978
most of the time it just say o2.foo.

97
00:06:31.978 --> 00:06:36.355
In that scenario I am taking full
advantage of the dynamicism and

98
00:06:36.355 --> 00:06:41.450
every once in a while inserting
back in some predictability.

99
00:06:41.450 --> 00:06:44.340
I would say that is a reasonable
usage of this mechanism.

100
00:06:45.810 --> 00:06:50.260
On the other hand, if I went to all the
trouble to put this dot in front of every

101
00:06:50.260 --> 00:06:52.249
single property and method reference.

102
00:06:53.260 --> 00:06:58.090
And then, I find myself having to do
hard binding everywhere, I might then

103
00:06:58.090 --> 00:07:02.210
step back and say, [SOUND] maybe I
should just switch the Lexical Scope,

104
00:07:02.210 --> 00:07:06.720
because it appears that the flexibility
isn't actually that important

105
00:07:06.720 --> 00:07:09.629
in this piece of code, it appears that
predictability is more important.

106
00:07:12.128 --> 00:07:12.891
&gt;&gt; Kyle: The truth is,

107
00:07:12.891 --> 00:07:17.260
different parts of your code will
answer that tension differently.

108
00:07:17.260 --> 00:07:20.600
Some parts of your code,
the predictability will be more important,

109
00:07:20.600 --> 00:07:23.530
some parts,
the flexibility will be more important.

110
00:07:23.530 --> 00:07:27.530
You are a better JavaScript developer,
if you can use both of those techniques

111
00:07:27.530 --> 00:07:29.709
appropriately in your code,
not one, or the other.

112
00:07:31.105 --> 00:07:35.513
JavaScript is great in part,
because it has both available to you.

113
00:07:35.513 --> 00:07:40.486
Using one all the time is not appropriate,
I know that's our instinct, we want just

114
00:07:40.486 --> 00:07:45.317
give me that one pattern to rule them all,
give me the one ring to rule them all, but

115
00:07:45.317 --> 00:07:49.263
what I'm really saying is,
you need to learn to use both systems.

116
00:07:50.450 --> 00:07:52.160
For what they're better at.

117
00:07:52.160 --> 00:07:56.560
If flexibility is important, if reuse of
a function across multiple contexts is

118
00:07:56.560 --> 00:07:58.670
important, use this aware programming.

119
00:07:59.740 --> 00:08:04.200
If predictability is more important,
the lexical system is better at that.

