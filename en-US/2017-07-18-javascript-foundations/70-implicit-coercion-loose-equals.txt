[00:00:00]
>> Kyle Simpson: I've been promising that we wanna talk about this double equals thing, cuz it's the elephant in the room. This is the most obvious place where implicit coercion, not only enters our programs, but also can bite us. But it only bites us not because this is a confusing topic that can't be learned, it only bites us because it's unlearned.

[00:00:17]
We just haven't chosen to learn what double equals is about. Guess where the best place to learn what double equals is about is? Trying it out, reading the spec, that's all I did, okay? There's no magical formula here. What I chose to do was say if the double equals is so bad, let's test all of the corner cases and see which ones of them are really bad versus not actually bad.

[00:00:40]
So I came up, I programmatically generated this list, but I came up with 24 corner case coercions with double equals. As far as I'm aware, these are all the corner cases that we can express. And I went down the list and I said, which ones of these are crazy and which ones of these make sense?

[00:01:01]
And I chose to mark the ones that I thought were strange. This is subjective, but I said "0" == false, line 3. That seems strange to me. Cuz the string 0 and the value false are most definitely different values. So that result where they end up both becoming numbers and comparing to each other, that result is strange.

[00:01:25]
Should not be, okay? But by comparison line 8, false == null, that fails. And that makes a lot of sense to fail, because false and null are distinctly different values. And so they aren't equal to each other, do you follow me? So if we do the math here, there are 7 of these 24 which are kind of outliers, they are genuinely WTFs, and there's another 17 of them that actually are pretty reasonable.

[00:01:56]
Your numbers might be slightly different, but the point that I'm trying to get at is,
>> Kyle Simpson: Supposedly, all of coercion is bad, and it's okay to just get rid of all of this implicit coercion, but I kinda think that would be sort of baby with the bath water here.

[00:02:14]
Cuz it actually looks like most of coercion's pretty good, and there's only a few cornered cases that we should be worried about. Because there's an infinite number of double equals coercion comparisons that aren't corner cases and they're all completely reasonable.
>> Kyle Simpson: So out of the infinite space of reasonable ones, there's only seven which are problematic.

[00:02:39]
That's the point, okay? Let's zero in on those 7, here they are.
>> Kyle Simpson: What do you notice about the first four in that list?
>> Kyle Simpson: They're all doing a double equals comparison with false, right? And I already told you to eliminate those 4. So that was pretty easy.

[00:03:01]
We just went from 7 down to 3. Eliminate those 4 and focus on these 3 in particular. And now, let's look at those 3. When do those kinds of thing happen in code? Let's look at the line 6 and line 7 specifically. When it is it that we end up doing a double equals comparison with a empty string and an empty array?

[00:03:23]
When can that happen? Or, when can we compare a zero to an empty array? I decided to test this against my own history of my code, all the code that I've ever written. I decided to go and try to do some analysis of my code and figure out, are there any places where I do the double equals and this can happen?

[00:03:40]
And I found very few examples where that's even remotely possible. Now your code may be different. The point I'm trying to get at is, it's not terribly common that we end up with these logic cases, where we could end up comparing an empty string to and empty array.

[00:03:54]
There's a few places, but it's not like every line of code that this happens. So even line 6 and line 7, they are corner cases but they're not common corner cases, they're rare corner cases. So we really just end up back in line 5, the root of all evil, that one empty string double equaling to 0.

[00:04:14]
They all sort of devolve to it. As a matter of fact, line 6 devolves to it, and line 7 devolves to it. Line 6 and line 7 happen because of line 5. It really is the root of all evil. And some of you may have seen the video before.

[00:04:30]
Came out several years back, and it was making fun of, in particular, this case. Where the empty array is somehow coercively equal to the negation of the empty array. And you're like, that's crazy. People that design JavaScript, I don't know what they're smoking, right? So I got a lot of traction from making fun of JavaScript.

[00:04:49]
There is lots of opportunity to make fun of JavaScript when you are ignorant about JavaScript.
>> Kyle Simpson: It's easy. The hard part is to say, hey, wait a minute, why is JavaScript doing that? Well, part of my understanding is different. You know what might be different between me and you?

[00:05:07]
And I mean you metaphorically like the industry as a whole. What might be different between me and you is that when I see something that doesn't make sense, I don't blame the design of the language first. There's a lot of developers that when they see something in JavaScript that doesn't make sense, you know what they do?

[00:05:24]
All those idiot designers of the JavaScript language. Because we assume somehow, that we should be able to look at something and immediately intuit exactly what it's doing without any learning at all. And if it takes any effort on our part or if it's confusing in the slightest, we immediately jump to the conclusion, those people don't know what they're doing, designing languages.

[00:05:46]
Because my Python, or my Ruby, or my .NET, or fill in the blank of my favorite language doesn't do that. We immediately assume the designers of the language were poor. You know what I assume? There's something wrong with my understanding. I mean when you come down to it, the source of every bug in every program ever written is actually a lack of understanding.

[00:06:11]
This is how I like to say it. At the point where your brain diverges from the way the computer works. It is at that junction point that bugs enter your code, because if you understood it, you wouldn't write a bug, right? I mean if you fully understood a piece of code, you'd write it correct.

[00:06:30]
So if there was a bug, there must be a lack of understanding, and all I've done is embrace that as a core philosophy of mine. If there's something I don't understand, the problem is on me. Now, I've made plenty of critiques even today about design decisions of language, but I'm not doing that from a place of ignorance.

[00:06:48]
I'm doing that from a place of I've studied it deeply, and I've worked with people, and I've become frustrated by it. And by the way, those opinions have changed. There are things that I used to complain about that I no longer complain about cuz now I understand them.

[00:07:01]
And because that was true for myself, I thought I wonder if I shared with other people and they learned, maybe they'd complain less. Food for thought. So this double, I mean this empty array equal to the negation of the empty array. First off, the problem of how absurd that looks comes from a misunderstanding about how operators work.

[00:07:26]
There's a misunderstanding here that the operators are gonna happen all at once, which isn't the case. There is an operator precedence, the negate's gonna happen before the comparison, okay? It's not as obvious but it's a fact. So, what's gonna happen when we negate an empty array? That's a non-primitive, so first, we're gonna call the two primitive on it.

[00:07:48]
What's the two primitive of an empty array?
>> Speaker 2: String.
>> Kyle Simpson: Unfortunately, it's the empty string. It oughta be the string with brackets in it, but unfortunately it's the empty string. So we have turned it into the empty string as its primitive. And now, the negate operator says, well, wait, I don't have a boolean yet.

[00:08:07]
So I need to take that empty string and turn it into a boolean. So, what is the empty string's boolean equivalent?
>> Speaker 2: False.
>> Kyle Simpson: It's false, right? But now, we're in the negate operator, so we're gonna flip it around to true. So now, what we're actually saying is the empty array double equal to true.

[00:08:29]
That's the real comparison that's happening here. Are you with me on that? Now, the empty array, I'm sorry, I must have gotten that flipped backwards. The empty array became,
>> Kyle Simpson: Hold on just a moment. I know what's wrong. So the empty array is gonna become the string, and that's gonna become the number 0.

[00:08:58]
And then we have the array on the other side, which becomes a string and it becomes a number zero. So now, we compare 0 to 0. We have two occurrences of the root of all evil here, string became 0. If empty string had just become NaN, that wouldn't have happened, okay?

[00:09:17]
So all it takes is to actually dig into, understand the operations that occur. Yes.
>> Speaker 2: There was a question on, can you explain why false double equals to null is false? You're saying if double equals does a number coercion and both null and false coerce to 0, should the result not be true?

[00:09:37]

>> Kyle Simpson: Yes, except for the fact that there is special case which we're gonna look at the spec in a minute. There is a special case in the spec, which deals with null and undefined. They are treated specially and importantly, null and undefined are treated as coercively equal to each other, and to know other values in the language.

[00:10:00]
So if it was only a numeric coercion, that assertion would be true, that would be correct, but there's more to the spec than that.

