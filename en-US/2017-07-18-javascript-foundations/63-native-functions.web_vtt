WEBVTT

1
00:00:00.440 --> 00:00:01.903
&gt;&gt; Kyle: Let's turn our
attention to natives.

2
00:00:01.903 --> 00:00:05.747
I've listed out for you, and you notice
that they all have capital letters here.

3
00:00:05.747 --> 00:00:07.347
I've listed out for
you the built-in natives.

4
00:00:07.347 --> 00:00:11.277
There are actually more than these, but
these are the ones we'll pay attention to.

5
00:00:11.277 --> 00:00:15.153
These might look familiar because
these might look to you like these

6
00:00:15.153 --> 00:00:17.743
are the built-in types
that you see in Java.

7
00:00:17.743 --> 00:00:22.408
For example, like capital String, it looks
like the capital String class that's built

8
00:00:22.408 --> 00:00:25.965
into Java, so it'll be tempting to
think of these as native types.

9
00:00:25.965 --> 00:00:29.919
Many people will refer
to them as native types.

10
00:00:29.919 --> 00:00:34.504
They're not actually dealt with as types
in from the perspective of the spec,

11
00:00:34.504 --> 00:00:38.823
if you read the specification for
JavaScript, it does talk about these.

12
00:00:38.823 --> 00:00:42.610
And as a matter of fact, calling them
natives is not even fully agreed upon,

13
00:00:42.610 --> 00:00:46.179
that's just kind of a term of art that
people seem to have settled upon.

14
00:00:46.179 --> 00:00:49.467
But I've heard people have different
answers as to what these should even

15
00:00:49.467 --> 00:00:50.006
be called.

16
00:00:50.006 --> 00:00:53.618
So they're not really types,
they're not really objects,

17
00:00:53.618 --> 00:00:58.279
although in a sense, all functions
are objects, so they're kind of objects.

18
00:00:58.279 --> 00:01:01.303
But calling them native objects
can sound a little bit strange.

19
00:01:01.303 --> 00:01:05.142
The capital Object is definitely used
more like an object than a function, but

20
00:01:05.142 --> 00:01:07.294
it's not really appropriate to call them,

21
00:01:07.294 --> 00:01:10.899
you would typically think of them in
the context of what you did with Java,

22
00:01:10.899 --> 00:01:14.763
where you put the new keyword in front of
them and called them as a constructor.

23
00:01:14.763 --> 00:01:17.701
So you might think of these
as native constructors.

24
00:01:17.701 --> 00:01:21.821
But I really think the most appropriate
way to approach these is that you

25
00:01:21.821 --> 00:01:24.291
virtually, in almost all of these cases,

26
00:01:24.291 --> 00:01:27.397
you will never want to call
them with the new keyword.

27
00:01:27.397 --> 00:01:29.166
As a matter of fact, most of these cases,

28
00:01:29.166 --> 00:01:31.203
you'll wanna call them
as regular functions.

29
00:01:31.203 --> 00:01:34.413
So I think maybe we should just
call them the native functions.

30
00:01:34.413 --> 00:01:38.502
And capital Native,
we don't mean native like built-in,

31
00:01:38.502 --> 00:01:43.328
that's a special thing to distinguish
it from the primitives, okay?

32
00:01:43.328 --> 00:01:44.912
So what are these things?

33
00:01:44.912 --> 00:01:49.812
Well used as constructors, they definitely
produce a representation of the value

34
00:01:49.812 --> 00:01:52.543
that is similar to
the primitive equivalent.

35
00:01:52.543 --> 00:01:54.370
So if I called new capital String,

36
00:01:54.370 --> 00:01:58.849
I'm gonna get a thing that seems like it's
related to the actual primitive string.

37
00:01:58.849 --> 00:02:02.996
But they're not really the same,
they're just a different representation.

38
00:02:02.996 --> 00:02:05.096
As a matter of fact,
kind of an object wrap around.

39
00:02:05.096 --> 00:02:06.969
Same thing with numbers,
same thing with boolean.

40
00:02:06.969 --> 00:02:10.026
Now some of these act as,
there are differences here,

41
00:02:10.026 --> 00:02:12.162
there's not a lot of consistencies.

42
00:02:12.162 --> 00:02:17.134
So some of these will act as constructors,
meaning you have to call them with new or

43
00:02:17.134 --> 00:02:20.032
if you don't, they'll behave differently.

44
00:02:20.032 --> 00:02:22.609
Some of them will act as
constructors regardless of whether

45
00:02:22.609 --> 00:02:23.647
you call them with new.

46
00:02:23.647 --> 00:02:27.601
Like the function will produce a dynamic
function regardless of whether you use

47
00:02:27.601 --> 00:02:28.849
the new keyword with it.

48
00:02:28.849 --> 00:02:33.469
Object will do a different thing,
array doesn't need the new keyword,

49
00:02:33.469 --> 00:02:35.904
regex doesn't need the new keyword.

50
00:02:35.904 --> 00:02:38.932
So some of these require the new
keyword and some of them don't, so

51
00:02:38.932 --> 00:02:40.664
there's some weird inconsistency,

52
00:02:40.664 --> 00:02:43.927
but I think it's more appropriate to
think of using them as functions.

53
00:02:43.927 --> 00:02:48.784
So if we compare, for example,
what happens when we call new capital

54
00:02:48.784 --> 00:02:53.741
String and pass in some value when we ask,
what is foo there on line 2?

55
00:02:53.741 --> 00:02:57.584
Turns out that foo, if we represent it,
if you tried that in your console,

56
00:02:57.584 --> 00:03:00.210
it's actually gonna be
represented as an object.

57
00:03:00.210 --> 00:03:04.894
It'll be represented as an object
that has properties like 0,

58
00:03:04.894 --> 00:03:09.746
the value f, and 1, with the value o,
and 2 with the value of, so

59
00:03:09.746 --> 00:03:13.670
it presents itself almost
like an array like object.

60
00:03:13.670 --> 00:03:17.791
And it has these weird special built-in
properties like bracket, bracket,

61
00:03:17.791 --> 00:03:20.736
primitive value, and
other strange things like that.

62
00:03:20.736 --> 00:03:24.018
Another battle that I fought with
the browser vendors by the way,

63
00:03:24.018 --> 00:03:27.598
because the way they represent these
values in the developer console,

64
00:03:27.598 --> 00:03:30.162
is in large part,
going to contribute to whether or

65
00:03:30.162 --> 00:03:34.480
not you understand what you're doing, or
whether you're confused as a developer.

66
00:03:34.480 --> 00:03:37.151
And Firefox used to be
the worst offender of this.

67
00:03:37.151 --> 00:03:41.834
They would represent the String object as
almost identical to the String primitive,

68
00:03:41.834 --> 00:03:45.945
the only difference being that the String
object they printed in italics.

69
00:03:45.945 --> 00:03:48.074
And I'm like, are you kidding me?

70
00:03:48.074 --> 00:03:51.787
You expect developers to distinguish in
the font between italic and non-italic,

71
00:03:51.787 --> 00:03:54.715
and that's how they know whether
it's an object or a primitive?

72
00:03:54.715 --> 00:03:57.883
That is just deliberately asking for
people to be confused.

73
00:03:57.883 --> 00:04:00.367
Finally they changed that, and

74
00:04:00.367 --> 00:04:05.067
they actually changed it
according to my recommendations.

75
00:04:05.067 --> 00:04:07.512
I'm still waiting on Chrome
to catch up with it,

76
00:04:07.512 --> 00:04:10.746
cuz Chrome's representation is
bad in a different sort of way.

77
00:04:10.746 --> 00:04:14.541
Okay but these are objects, they're not
primitives, that's the takeaway here.

78
00:04:14.541 --> 00:04:18.951
And if you do typeof foo, you're gonna get
quote object because it's a real object,

79
00:04:18.951 --> 00:04:21.288
it's not some special
kind of string thing.

80
00:04:21.288 --> 00:04:25.552
The way to think about that is it's a
wrapper object around the primitive string

81
00:04:25.552 --> 00:04:27.918
value, the one that we
passed in quote foo.

82
00:04:27.918 --> 00:04:32.581
[COUGH] Now you'll notice on
line 7 I called the string

83
00:04:32.581 --> 00:04:35.699
function without the new keyword.

84
00:04:35.699 --> 00:04:39.171
The string function when used as
a function rather than used as

85
00:04:39.171 --> 00:04:42.128
a constructor,
it does something very different.

86
00:04:42.128 --> 00:04:47.460
Instead of constructing an object
wrapper around a value,

87
00:04:47.460 --> 00:04:53.868
it actually coerces whatever you pass
in to that primitive value type.

88
00:04:53.868 --> 00:04:57.606
Capital String used as a function without
the new keyword will take whatever you

89
00:04:57.606 --> 00:05:01.583
pass in, even something like the number
42, and coerce it to a primitive string.

90
00:05:01.583 --> 00:05:04.219
So it would say quote 42,
would be the output.

91
00:05:04.219 --> 00:05:09.067
That is a vastly more useful mechanism to
us than creating these weird string object

92
00:05:09.067 --> 00:05:13.168
things that nobody actually wants
to deal with in JavaScript anyway.

93
00:05:13.168 --> 00:05:17.448
So my recommendations specifically for
string, number, and boolean,

94
00:05:17.448 --> 00:05:19.865
use them as functions, specifically for

95
00:05:19.865 --> 00:05:23.743
coercion, don't use them as
constructors with the new keyword.

96
00:05:27.835 --> 00:05:33.671
&gt;&gt; Kyle: Line 10 would produce a number
object wrapped around the 37 value,

97
00:05:33.671 --> 00:05:35.820
that's strange, okay?

98
00:05:35.820 --> 00:05:39.997
Examples of the strangeness that you
might get if you represent these things

99
00:05:39.997 --> 00:05:42.942
as objects like a Java
developer would typically do.

100
00:05:42.942 --> 00:05:45.190
If you said number of zero.

101
00:05:45.190 --> 00:05:48.394
Zero as a primitive value is falsy.

102
00:05:48.394 --> 00:05:55.241
Zero as a number object is truthy, you're
setting yourself up for failure then.

103
00:05:55.241 --> 00:05:56.474
Same thing with boolean.

104
00:05:56.474 --> 00:06:01.564
False as a boolean primitive is falsy.

105
00:06:01.564 --> 00:06:05.904
False as a boolean object is truthy, okay?

106
00:06:05.904 --> 00:06:09.429
Don't construct these objects,
there's just no reason for them.

107
00:06:09.429 --> 00:06:13.983
They will set landmines not only for
yourself, for your future self, but

108
00:06:13.983 --> 00:06:16.195
also your other teammates, okay?

109
00:06:19.995 --> 00:06:25.254
&gt;&gt; Kyle: Array, the array constructor
has its own set of problems.

110
00:06:25.254 --> 00:06:29.570
But the nice thing about array is that
there is a literal syntax that we can use

111
00:06:29.570 --> 00:06:32.621
instead, the square brackets
that we see on line 5.

112
00:06:32.621 --> 00:06:36.793
The literal syntax is vastly
preferred to the constructor form.

113
00:06:36.793 --> 00:06:40.840
Use the literal form wherever possible,
don't use the constructor form.

114
00:06:40.840 --> 00:06:46.240
There's a got you with this particular
constructor, which is if I said new

115
00:06:46.240 --> 00:06:52.513
array 42, many people would assume that I
would then get an array that was presized.

116
00:06:52.513 --> 00:06:57.412
I mean that was set with the value 42 in
it because I passed in array 1, 2, 3 and

117
00:06:57.412 --> 00:07:02.108
I got an array of 1, 2, 3, so they would
think if I passed in a single value.

118
00:07:02.108 --> 00:07:04.443
Unfortunately, the array
constructor is overloaded.

119
00:07:04.443 --> 00:07:08.160
Overloading is never a good idea in
software design, but it's overloaded here.

120
00:07:08.160 --> 00:07:13.371
To say if you pass in a number and
there's only one of them, then that number

121
00:07:13.371 --> 00:07:18.196
is considered to be the length of
the new array that you wanna create.

122
00:07:18.196 --> 00:07:21.882
So we'd actually get an empty
array presized to length 42.

123
00:07:21.882 --> 00:07:24.953
But that's not even the craziest part.

124
00:07:24.953 --> 00:07:32.462
The craziest part, the part that is
really legitimately a WTF of JavaScript,

125
00:07:32.462 --> 00:07:38.287
is that we have this notion of
what's called a sparse array.

126
00:07:38.287 --> 00:07:42.262
If I create an array that is empty,
and then I set it's length,

127
00:07:42.262 --> 00:07:45.864
I literally say array dot length equals,
and I say 42.

128
00:07:45.864 --> 00:07:50.124
It will present itself as being
an array that has 42 slots in it, but

129
00:07:50.124 --> 00:07:53.807
only from the perspective of
how the console deals with it.

130
00:07:53.807 --> 00:07:57.938
If you try to loop over its
values with something like .map,

131
00:07:57.938 --> 00:08:01.024
it's not gonna have any
values to loop over.

132
00:08:01.024 --> 00:08:06.627
They're like phantom fake slots,
or so called empty slots.

133
00:08:06.627 --> 00:08:11.542
This literally, the worst design
I've ever seen in any programming.

134
00:08:11.542 --> 00:08:15.189
I've seen a lot of crazy, crappy stuff,

135
00:08:15.189 --> 00:08:19.984
but to create a value that
has phantom locations in it,

136
00:08:19.984 --> 00:08:25.633
it's like a giant neon sign that
says I am trying to confuse you.

137
00:08:25.633 --> 00:08:29.650
I'm trying to make you trip up, I'm trying
to create a pit of failures on you.

138
00:08:29.650 --> 00:08:34.743
Never, ever, ever, design an array and
intentionally create empty slots,

139
00:08:34.743 --> 00:08:39.307
and that's what you do when you do
array parenthesis and some number.

140
00:08:39.307 --> 00:08:44.820
Our notion is for performance,
I wanna pre-size my array, right?

141
00:08:44.820 --> 00:08:49.791
That's nonsense, JavaScript does not
preallocate 42 units of memory for

142
00:08:49.791 --> 00:08:50.638
your array.

143
00:08:50.638 --> 00:08:55.139
It literally creates an empty array, which
JavaScript typically represents as linked

144
00:08:55.139 --> 00:08:58.994
list by the way, and it just arbitrarily
sets the length property to 42.

145
00:08:58.994 --> 00:09:02.247
Thereby making these phantom slots
appear that they're there, and

146
00:09:02.247 --> 00:09:03.602
they're not really there.

147
00:09:03.602 --> 00:09:07.476
So don't ever do it under any
circumstances cuz there's no performance

148
00:09:07.476 --> 00:09:10.662
benefit, and there is a ton of
confusion coming around it.

149
00:09:10.662 --> 00:09:15.128
So just don't use the constructor form for
array, use the literal,

150
00:09:15.128 --> 00:09:17.210
it's always more preferable.

151
00:09:17.210 --> 00:09:22.294
Object, Object as a function
will take a value,

152
00:09:22.294 --> 00:09:27.634
and try to coerce it to
its object representation.

153
00:09:27.634 --> 00:09:31.343
There are some nuances around it,
I don't recommend using Object very often.

154
00:09:31.343 --> 00:09:34.238
But new Object() creates
an Object instance,

155
00:09:34.238 --> 00:09:38.834
exactly the same as the curly brace
instance, the curly brace literal form.

156
00:09:38.834 --> 00:09:43.057
The literal form is shorter,
more straightforward, and technically,

157
00:09:43.057 --> 00:09:47.759
slightly more efficient, cuz it's
statically analyzable where the imperative

158
00:09:47.759 --> 00:09:50.906
property assignment of line 8,
9, and 10 is not.

159
00:09:50.906 --> 00:09:53.018
So the literal form here, yet again,

160
00:09:53.018 --> 00:09:57.442
is gonna be more optimizable by the engine
because it's the declarative form as

161
00:09:57.442 --> 00:10:00.561
opposed to the imperative
form on line 7 through 10.

162
00:10:00.561 --> 00:10:09.270
So again, prefer the literal syntax over
the imperative syntax of the constructor.

163
00:10:09.270 --> 00:10:11.278
&gt;&gt; Speaker 2: So
the benefit here is really statics and

164
00:10:11.278 --> 00:10:13.292
not necessarily performance, right?

165
00:10:13.292 --> 00:10:17.196
It's just being a little bit
more better in communication.

166
00:10:17.196 --> 00:10:22.042
&gt;&gt; Kyle: I mean there is a performance
issue to be gained because we can

167
00:10:22.042 --> 00:10:23.569
say okay, great.

168
00:10:23.569 --> 00:10:27.168
I know that the engine either already,
or eventually,

169
00:10:27.168 --> 00:10:31.390
can more statically analyze a literal and
know what to do with it.

170
00:10:31.390 --> 00:10:33.541
For example, the array literal,

171
00:10:33.541 --> 00:10:38.228
it literally can see at the parsing
stage how many elements you've added.

172
00:10:38.228 --> 00:10:41.236
So it goes ahead and pre-reserves that
amount, it doesn't have to add it or

173
00:10:41.236 --> 00:10:43.492
whatever, it just knows I'm
gonna need these many, and

174
00:10:43.492 --> 00:10:44.579
then it puts all of them in.

175
00:10:44.579 --> 00:10:48.968
So because it's statically analyzable,
it's more efficient that way.

176
00:10:48.968 --> 00:10:50.423
Now we're talking about microseconds.

177
00:10:50.423 --> 00:10:54.344
But it is more efficient because it's
a declarative syntax the compiler can

178
00:10:54.344 --> 00:10:59.057
recognize as opposed to line 8, 9, and 10,
it's just figuring that out line by line,

179
00:10:59.057 --> 00:11:02.020
by line, so it has to keep
growing the object every time.

180
00:11:02.020 --> 00:11:03.945
&gt;&gt; Speaker 2: Yeah.

181
00:11:03.945 --> 00:11:06.075
&gt;&gt; Kyle: Right, so
there is a performance aspect, but

182
00:11:06.075 --> 00:11:09.311
really this is more about code
communication even than performance.

183
00:11:09.311 --> 00:11:14.223
The literal on line 10, and the literal on
line 5 communicate more clearly my intent.

184
00:11:14.223 --> 00:11:16.926
They're declarative as
opposed to imperative.

185
00:11:21.578 --> 00:11:26.568
&gt;&gt; Kyle: There are some where you're gonna
want the new keyword specifically for

186
00:11:26.568 --> 00:11:30.818
regex, you're gonna need to use
the new keyword if you want to

187
00:11:30.818 --> 00:11:33.877
dynamically create a regular expression.

188
00:11:33.877 --> 00:11:38.111
Now you should prefer the literal
syntax if at all possible,

189
00:11:38.111 --> 00:11:41.525
because the literal syntax
gets compiled once.

190
00:11:41.525 --> 00:11:46.390
It doesn't get re-run at run time whereas
the dynamic regular expression has

191
00:11:46.390 --> 00:11:48.984
to get re-run every time that code runs.

192
00:11:48.984 --> 00:11:52.042
So you should prefer
the literal from performance,

193
00:11:52.042 --> 00:11:54.067
and declarative coding reasons.

194
00:11:54.067 --> 00:11:57.166
But there are some times when
your pattern needs to be dynamic.

195
00:11:57.166 --> 00:12:01.360
Part of the pattern is a value in your
program that you've programmatically,

196
00:12:01.360 --> 00:12:02.513
logically decided.

197
00:12:02.513 --> 00:12:06.718
Then you're gonna need the regular
expression constructor form, okay?

198
00:12:06.718 --> 00:12:09.516
So it's entirely okay to
use that if you have to,

199
00:12:09.516 --> 00:12:11.851
prefer the literal syntax if possible.

200
00:12:11.851 --> 00:12:14.621
Dates on the other hand, have no literal.

201
00:12:14.621 --> 00:12:19.670
This I think is a huge mistake, it's
a missing gap in the design of JavaScript.

202
00:12:19.670 --> 00:12:22.109
We should have a date literal,
dates are pretty important.

203
00:12:22.109 --> 00:12:26.139
And we should come up with a good date
literal that everybody can agree on,

204
00:12:26.139 --> 00:12:30.378
make it the UTC, one of those ISO
standards or whatever, just agree upon it.

205
00:12:30.378 --> 00:12:31.642
But we don't have that right now.

206
00:12:31.642 --> 00:12:33.925
[COUGH] There are some people that
are talking about adding it, but

207
00:12:33.925 --> 00:12:35.013
we don't have that right now.

208
00:12:35.013 --> 00:12:37.490
So if you wanna construct
the date timestamp,

209
00:12:37.490 --> 00:12:40.804
you have to use the constructor
form of the date constructor.

210
00:12:40.804 --> 00:12:44.918
You have to say new date, that's gonna
construct a new, by default, with no

211
00:12:44.918 --> 00:12:49.118
arguments going to construct a timestamp
that represents this exact moment.

212
00:12:49.118 --> 00:12:52.693
It's kinda the Unix timestamp
milliseconds thing, right?

213
00:12:52.693 --> 00:12:57.519
Now [COUGH] I will say most of the time
that you construct the date object,

214
00:12:57.519 --> 00:13:01.874
it's because you wanna get
the current timestamp of right now.

215
00:13:01.874 --> 00:13:06.667
And if you get a date object, you then
have to extract that number timestamp

216
00:13:06.667 --> 00:13:11.557
from it by calling a function or
coercing it, we'll talk about that later.

217
00:13:11.557 --> 00:13:15.809
There's a much better way of getting
that and it's called Date.now().

218
00:13:15.809 --> 00:13:18.969
It's a static function,
it gives you that timestamp.

219
00:13:18.969 --> 00:13:23.441
So you really should prefer not to ever
construct data instances if possible.

220
00:13:23.441 --> 00:13:27.310
Most of the time you can get away with not
needing the constructed data instance.

221
00:13:27.310 --> 00:13:30.644
But if you do need to, you're gonna have
to use the new constructor to do it.

222
00:13:36.532 --> 00:13:41.593
&gt;&gt; Kyle: Pause right there with
our literals, and see if there's

223
00:13:41.593 --> 00:13:47.188
any questions about literals and
natives before we move on to.

224
00:13:49.719 --> 00:13:50.231
&gt;&gt; Kyle: Yeah?

225
00:13:50.231 --> 00:13:52.866
&gt;&gt; Speaker 3: So that example on
the previous slide with the curly braces

226
00:13:52.866 --> 00:13:53.735
declaring array.

227
00:13:53.735 --> 00:13:58.967
If you tried to for some reason it doesn't
come back as an array in the console,

228
00:13:58.967 --> 00:14:00.646
it's more of an object.

229
00:14:00.646 --> 00:14:01.237
&gt;&gt; Kyle: Which one?

230
00:14:01.237 --> 00:14:05.268
The curly braces do an object,
the square brackets do an array.

231
00:14:05.268 --> 00:14:06.593
&gt;&gt; Speaker 3: Okay that's what I thought.

232
00:14:06.593 --> 00:14:09.500
&gt;&gt; Kyle: So if you do curly braces that's
an object, square brackets, array.

233
00:14:09.500 --> 00:14:14.492
So question here from Cray, what advantage
is a date library like moment in JS?

234
00:14:14.492 --> 00:14:18.708
I wouldn't do any date stuff in
JavaScript without a good date library.

235
00:14:18.708 --> 00:14:21.498
At the moment,
JS just happens to be a really good one.

236
00:14:21.498 --> 00:14:23.399
I know one of the
&gt;&gt; [CROSSTALK]

237
00:14:23.399 --> 00:14:24.977
&gt;&gt; Speaker 2: It's pretty big though, so

238
00:14:24.977 --> 00:14:28.806
there's micro libraries that won't
bloat up your project so much.

239
00:14:28.806 --> 00:14:32.919
But moments great because it's robust,
you can do timezones.

240
00:14:32.919 --> 00:14:34.007
You can do timezone math.

241
00:14:34.007 --> 00:14:38.397
You can add a few days,
you can subtract, you can compare.

242
00:14:38.397 --> 00:14:40.636
&gt;&gt; Kyle: Stream moment has
a lot if capability to it.

243
00:14:40.636 --> 00:14:44.314
I know one of the maintainers of moment is
actually working on getting some of that

244
00:14:44.314 --> 00:14:48.115
stuff just built into JavaScript, so we
don't need such heavy libraries to do it.

245
00:14:48.115 --> 00:14:54.707
Dates are a big gap in
behavior of JavaScript stuff.

246
00:14:54.707 --> 00:14:57.410
We need the standard library
to just grow that capability.

