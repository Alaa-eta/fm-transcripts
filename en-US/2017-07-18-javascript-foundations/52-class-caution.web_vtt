WEBVTT

1
00:00:00.300 --> 00:00:03.030
&gt;&gt; Kyle Simpson: So
I wanna point out just a few things

2
00:00:03.030 --> 00:00:05.990
that you should be aware of if you start
trying to color outside the lines.

3
00:00:05.990 --> 00:00:11.190
Let me show you a few of those places
where the class, you should be cautious.

4
00:00:13.040 --> 00:00:16.130
First off, you cannot extend an object.

5
00:00:16.130 --> 00:00:20.850
This actually, I think,
my biggest frustration or objection.

6
00:00:20.850 --> 00:00:22.980
Maybe my second biggest.

7
00:00:22.980 --> 00:00:26.200
You can't mix classes and
objects together.

8
00:00:26.200 --> 00:00:28.410
It's all classes or no classes.

9
00:00:28.410 --> 00:00:30.020
You can't just extend an object.

10
00:00:31.390 --> 00:00:33.720
Why?
I don't know.

11
00:00:33.720 --> 00:00:37.260
I have yelled and scream and thrown a fit.

12
00:00:37.260 --> 00:00:41.980
They didn't pay any attention to
me that'll cause a syntax error.

13
00:00:41.980 --> 00:00:42.950
I'm sorry, a runtime error.

14
00:00:42.950 --> 00:00:46.155
You're not allowed to extend an object.

15
00:00:49.825 --> 00:00:53.843
&gt;&gt; Kyle Simpson: Even though this
is supposedly just syntax sugar, so

16
00:00:53.843 --> 00:00:59.130
theoretically foo and bar are actual
functions you can't call them.

17
00:01:00.790 --> 00:01:04.401
You can't just call the foo and
more importantly, to my problem,

18
00:01:04.401 --> 00:01:08.929
you can't call bar and override its this,
or do any kind of the this binding stuff.

19
00:01:08.929 --> 00:01:10.474
You can't do anything dynamic with them.

20
00:01:10.474 --> 00:01:13.804
You're not allowed to use those
classes as actual functions.

21
00:01:13.804 --> 00:01:16.658
You're only allowed to use
them with the new keyword.

22
00:01:16.658 --> 00:01:21.578
So it's a full lock in to,
it's all classes or no classes.

23
00:01:25.127 --> 00:01:32.500
&gt;&gt; Kyle Simpson: [COUGH]
&gt;&gt; Kyle Simpson: You're

24
00:01:32.500 --> 00:01:36.055
not allowed to reference this keyword
until after you've called the super

25
00:01:36.055 --> 00:01:38.040
function in the constructor.

26
00:01:38.040 --> 00:01:41.780
So it's very common for people to want to
when they're overwriting a constructor and

27
00:01:41.780 --> 00:01:44.940
extending behavior,
set up some stuff in a specific way and

28
00:01:44.940 --> 00:01:47.260
then call to the parent constructor.

29
00:01:47.260 --> 00:01:50.450
So you'd wanna do something like set up
a this, or set up some kind of thing, and

30
00:01:50.450 --> 00:01:51.860
then call the constructor.

31
00:01:51.860 --> 00:01:53.667
That's not allowed,
you have to call the super first.

32
00:01:55.789 --> 00:01:59.709
&gt;&gt; Kyle Simpson: That's an unusual
deviation from typical class oriented

33
00:01:59.709 --> 00:02:04.509
languages because in typical class
oriented languages the end class,

34
00:02:04.509 --> 00:02:06.349
the lowest derived class,

35
00:02:06.349 --> 00:02:12.150
the furthest down in the chain is the one
that creates and initializes the object.

36
00:02:12.150 --> 00:02:14.170
In JavaScript it's the reverse.

37
00:02:14.170 --> 00:02:18.710
The most parent class is the one
that creates and initializes.

38
00:02:18.710 --> 00:02:21.150
So, its kind of like a tdzer.

39
00:02:21.150 --> 00:02:24.360
This key word is in
it's tdz at this point.

40
00:02:24.360 --> 00:02:27.944
You can't use it until you've
called the super all the way up,

41
00:02:27.944 --> 00:02:29.303
and then you can use it.

42
00:02:29.303 --> 00:02:32.941
I've seen a number of people
run across that gotcha before.

43
00:02:36.108 --> 00:02:40.988
&gt;&gt; Kyle Simpson: [COUGH] This one is hard
to explain, but you gotta stick with me.

44
00:02:40.988 --> 00:02:47.030
I have an A class and a C class.

45
00:02:47.030 --> 00:02:50.910
And the C class extends A,
so look at A and C.

46
00:02:50.910 --> 00:02:55.590
And you'll notice that I over, I declare
this foo(); which is this.one(); which is

47
00:02:55.590 --> 00:02:58.950
gonna call that, and it calls super.two();
which is also gonna call that.

48
00:02:58.950 --> 00:03:02.304
So when I call,
when I instantiate C(); and

49
00:03:02.304 --> 00:03:07.551
I call x.foo(); I get one:A two:A,
exactly the way we'd expect.

50
00:03:10.272 --> 00:03:14.062
&gt;&gt; Kyle Simpson: But now,
what if I wanna take that foo function,

51
00:03:14.062 --> 00:03:16.230
this one right here.

52
00:03:16.230 --> 00:03:20.100
And I wanna dynamically rebind it
to a different context, like for

53
00:03:20.100 --> 00:03:21.670
example to the B context.

54
00:03:22.830 --> 00:03:28.096
If I say x.foo.call(B); we
might expect it to say one:B

55
00:03:28.096 --> 00:03:33.480
two:B because now we're saying
this.one and super.two.

56
00:03:33.480 --> 00:03:36.612
Here's one of the crazy gotchas.

57
00:03:36.612 --> 00:03:41.110
With .call and .apply it overrides or

58
00:03:41.110 --> 00:03:46.290
dynamically binds the this keyword but
the super keyword is static.

59
00:03:46.290 --> 00:03:52.280
The super keyword stays fixed at
the time you declare the class and

60
00:03:52.280 --> 00:03:56.720
it can't be overridden by a .bind or
.call or .apply.

61
00:03:56.720 --> 00:03:59.020
So, if you have a mix and
match between a this and

62
00:03:59.020 --> 00:04:03.710
a super in your function, your this
keyword will be dynamic sensitive.

63
00:04:03.710 --> 00:04:07.300
Your super won't and
I've seen people run into that bug before.

64
00:04:10.240 --> 00:04:14.723
The reason they did not make super
dynamically dispatched as opposed to

65
00:04:14.723 --> 00:04:17.197
statically fixed is for performance.

66
00:04:17.197 --> 00:04:19.610
That's literally it.

67
00:04:19.610 --> 00:04:24.040
They said, well it'll be slower for
us to figure out super at run time.

68
00:04:25.480 --> 00:04:27.053
So let's statically fix it and

69
00:04:27.053 --> 00:04:29.968
then tell people don't try to
call it outside the lines.

70
00:04:29.968 --> 00:04:35.188
[COUGH] The super keyword is only

71
00:04:35.188 --> 00:04:40.409
valid inside of functions that

72
00:04:40.409 --> 00:04:48.040
are there as part of the class definition.

73
00:04:48.040 --> 00:04:52.190
You cannot add to the class def-,
you can add to a class definition.

74
00:04:52.190 --> 00:04:56.240
It is legal to say, B.prototype.foo,
and add a new function in.

75
00:04:56.240 --> 00:04:59.360
But, that newly added function
cannot use the super keyword.

76
00:05:00.560 --> 00:05:03.642
The super keyword is only
syntactically valid if the function is

77
00:05:03.642 --> 00:05:05.591
there at the time the class is declared.

78
00:05:05.591 --> 00:05:06.166
Why?

79
00:05:06.166 --> 00:05:08.550
Because the super is statically bound.

80
00:05:11.200 --> 00:05:13.430
So, you can't add to your
class definitions and

81
00:05:13.430 --> 00:05:14.710
still use the super keyword.

82
00:05:17.740 --> 00:05:21.710
You also can't use
the super keyword inside of

83
00:05:21.710 --> 00:05:25.770
objects that delegate up the prototype.

84
00:05:25.770 --> 00:05:28.880
I'm sorry, you can use them in.

85
00:05:28.880 --> 00:05:33.670
objects and methods, but
you have to use the concise method syntax.

86
00:05:33.670 --> 00:05:36.560
So, here, I'm using concise,
ES6 concise methods,

87
00:05:36.560 --> 00:05:38.550
I'm able to use the super keyword.

88
00:05:38.550 --> 00:05:42.660
Here, if I do bar function,
I'm not able to use the super keyword.

89
00:05:44.370 --> 00:05:46.824
So, you've got to stick with
the concise method syntax.

90
00:05:46.824 --> 00:05:49.401
&gt;&gt; Speaker 2: Is that for
backwards compatibility?

91
00:05:49.401 --> 00:05:53.896
&gt;&gt; Kyle Simpson: It is because people used
to use the word super as a variable in old

92
00:05:53.896 --> 00:05:58.724
functions and so they wanted to add
the super as a keyword only in brand

93
00:05:58.724 --> 00:06:02.410
new function types that
nobody would've written.

94
00:06:04.330 --> 00:06:06.083
So it's that old backwards
compatibility question.

95
00:06:06.083 --> 00:06:08.706
&gt;&gt; Speaker 2: There's a question in chat.

96
00:06:11.320 --> 00:06:15.353
&gt;&gt; Speaker 2: Is this AB example,
why does super goes second?

97
00:06:15.353 --> 00:06:16.320
I don't know.

98
00:06:16.320 --> 00:06:18.970
&gt;&gt; Kyle Simpson: In this AB example,
why does super goes second?

99
00:06:18.970 --> 00:06:22.470
I think they're asking several back.

100
00:06:22.470 --> 00:06:24.250
Why does super have to be second here?

101
00:06:24.250 --> 00:06:26.910
I don't know if this is
the slide they're asking about.

102
00:06:26.910 --> 00:06:28.810
But super has to go second,

103
00:06:28.810 --> 00:06:33.870
because there super has to go second
because this keyword isn't usable.

104
00:06:34.940 --> 00:06:39.260
Are asking here, why the super go second.

105
00:06:41.400 --> 00:06:45.040
Super only has to go
first in the constructor.

106
00:06:46.090 --> 00:06:47.270
This isn't a constructor.

107
00:06:47.270 --> 00:06:48.470
This is just a regular method.

108
00:06:48.470 --> 00:06:51.676
By the time that method's called,
this keyword's already been initialized.

109
00:06:51.676 --> 00:06:53.580
It's not in its tdz anymore.

110
00:06:53.580 --> 00:06:54.540
You can use it.

111
00:06:54.540 --> 00:06:56.940
So I think that was probably the question.

112
00:07:02.499 --> 00:07:05.050
&gt;&gt; Kyle Simpson: All right, so we can
only use super inside of concise methods.

113
00:07:07.178 --> 00:07:10.330
&gt;&gt; Kyle Simpson: And
there's a pattern that I like to use,

114
00:07:10.330 --> 00:07:13.790
because I still like using Object.create.

115
00:07:13.790 --> 00:07:17.400
If I want to inherit from
a class into an object.

116
00:07:17.400 --> 00:07:22.835
I might do an object.create of A.prototype
which is gonna make me a thing and this

117
00:07:22.835 --> 00:07:28.180
object.assign that I'm using here on line
6 its trying to copy over from an object.

118
00:07:28.180 --> 00:07:31.192
So I have an object literal
that's designed here and

119
00:07:31.192 --> 00:07:32.636
I want to copy over to it.

120
00:07:32.636 --> 00:07:34.500
Should work, right?

121
00:07:34.500 --> 00:07:39.400
I would copy my foo method
from the object literal

122
00:07:39.400 --> 00:07:43.710
over into the B object which
is now linked to A prototype.

123
00:07:43.710 --> 00:07:48.230
And I ought to be able to call B.foo and
get a one:A, two:A printout.

124
00:07:48.230 --> 00:07:53.170
The problem is that the this.one will
work because the this is dynamic but

125
00:07:53.170 --> 00:07:59.860
that super keyword is statically bound
to the object literal on line six

126
00:08:00.950 --> 00:08:06.480
and the object literal, the super keyword
is going to reference object.prototype.

127
00:08:06.480 --> 00:08:11.042
So, it doesn't dynamically switch
over to the A.prototype context.

128
00:08:14.554 --> 00:08:19.465
&gt;&gt; Kyle Simpson: The takeaway here is that
while class does have some nice syntactic

129
00:08:19.465 --> 00:08:25.426
affordances, there are more than enough
corner cases that my caution to you is,

130
00:08:25.426 --> 00:08:29.739
stay within the lines if you're
gonna play with classes.

131
00:08:31.900 --> 00:08:33.420
Don't try to do dynamic stuff.

