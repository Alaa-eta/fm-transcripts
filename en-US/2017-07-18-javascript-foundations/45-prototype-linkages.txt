[00:00:00]
>> Kyle: Now, let me throw a wrench into the mix. What happens if I were to add an identify right here, and then I called a1.identifying? Where is it gonna find it?
>> Speaker 2: On a1.
>> Kyle: It's gonna find it right here. So we're gonna be calling line 13. What is the this key we're gonna be pointing at on line 13?

[00:00:21]

>> Speaker 3: a1.
>> Kyle: Still a1, do you see the problem? We're gonna have this circular recursion thing where we keep calling this thing. Because we want to, like class-oriented coding, relatively, polymorphically, refer to that one. But because we are using this keyword, it's just gonna infinitely recurse on itself.

[00:00:42]
So, what do you think we should do to get from this function to that function?
>> Kyle: Well, we could try calling the, oops, calling the,
>> Kyle: this.__proto__.identify, right? We could say this.__proto__.identify but there's a problem here. That isn't gonna work. It's not gonna print out the Hello, I am a1.

[00:01:11]
Can you spot why?
>> Speaker 2: The this context.
>> Kyle: The this context. When we call that identify up on line 6, what is the this keyword gonna point at?
>> Speaker 4: On the proto?
>> Kyle: It's gonna point at the Foo.prototype object, not at a1. So that's not gonna work. We can't say this.__proto__.identify, we'd actually have to say this.__proto__.identify.call(this), which sucks.

[00:01:39]
But there's a bigger reason why it sucks. Because we use one __proto there, but guess what happens if some day later we come along and we add another x object into the chain and then we call x.identify. Does x have an identify? So, where are we gonna go?

[00:02:00]

>> Speaker 2: a1.identify.
>> Kyle: Now, we're gonna be calling that identify function, the line 14, if you will. What is the this keyword gonna be pointing out on line 14?
>> Speaker 4: x.
>> Kyle: x, so we're gonna go x.__proto and get back to here and have our infinite recursion. How many __protos do we need now?

[00:02:19]

>> Speaker 2: Two.
>> Kyle: We need two. If you add another object, now you need three. So every time you extend your inheritance chain, you're gonna have to go back and fix all those references and add more __protos. But that's not even the worst part. Let's say we did change that line 14 to have two __protos in it, then you call a1.identify, what's gonna happen?

[00:02:42]

>> Speaker 2: It's gonna break.
>> Kyle: It's gonna go from here to here, and then from here to here. Does this one have an identify? Not gonna work. The point I'm trying to make is it's impossible to know how many __protos you need.
>> Kyle: Because the this and __proto system is not relative.

[00:03:01]
The way class-oriented coding gives us relative polymorphism, that mechanism is not relative, it's always absolute to the bottom of the chain. So you can't do relative polymorphism, you can't override a function. Which is what you do in polymorphism, you make a child class with the method and override it and call super.

[00:03:20]
You don't have that with the prototype system. So, you know what you end up having to do to make a reliable reference? You have to skip the prototype chain entirely and just do it like that, Foo.prototype.identify.call(this).
>> Kyle: Which completely skips out on the whole prototype chain and totally shoots all of the dynamism in the foot.

[00:03:45]

>> Kyle: I have a term for that Foo.prototype.identify.call(this), which is such a mouthful. Mostly I just made this term up to make myself feel smarter. Here's the term, explicit pseudopolymorphism. I just sound smart when I say it, don't I? That's trademarked by the way, don't steal that. Explicit pseudopolymorphism.

[00:04:07]
Because it's not really polymorphic, it's not using the prototype chain. And we have to explicitly tell it which method to call. We can't relatively figure it out.
>> Kyle: Takeaway here is, you opt into these problems, these problems of explicit pseudopolymorphism, when you choose to do shadowing. Because you called identify and identify, you opt into that problem.

[00:04:36]
Now you might just say, well, that's cool, I just won't opt into that problem. I just won't shadow. I agree, you should not shadow. But if you don't shadow, you lose one of the most important parts of all of class-oriented design, which is method overriding and polymorphism.
>> Kyle: In class-oriented design, they tell you, make a method in the child class, override it, call the base parent with super.

[00:04:59]
You lose that if you do shadowing.
>> Kyle: So maybe this system is great, but maybe it's not so great at representing classes.
>> Kyle: On the other hand, if we have methods of different names, like I have here. I have both a speak and an identify. If I say this.identify on line 11, what is the this keyword gonna point at?

[00:05:31]

>> Speaker 2: a1.
>> Kyle: a1, so I started out at a1.speak on line 16, went up to find speak on the prototype. Then I came back to a1, and now I walk back up and find it on identify. And what's the this keyword on line 6 gonna point at?
>> Speaker 2: a1.

[00:05:47]

>> Kyle: Still a1, no matter how many times I have to walk up the prototype chain, and no matter how far up the prototype chain I need to look, we always stay rooted at the call site which is the object that we care about. I call this super unicorn magic.

[00:06:01]
It's a beautifully designed system. It only falls apart when you try to do shadowing, AKA, when you try to put classes on top of it. It's a great system, it's just not a great class system.

