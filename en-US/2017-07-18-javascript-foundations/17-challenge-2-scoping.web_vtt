WEBVTT

1
00:00:00.240 --> 00:00:01.690
&gt;&gt; Kyle: Let's check some understanding.

2
00:00:01.690 --> 00:00:06.010
What type of scoping rule, or
rules, does JavaScript have?

3
00:00:06.010 --> 00:00:07.830
&gt;&gt; Speaker 2: Function scope and
lexical scope, right?

4
00:00:07.830 --> 00:00:09.235
&gt;&gt; Kyle: Lexical scope, that's the model,

5
00:00:09.235 --> 00:00:12.740
there's only one, function scope is
the same thing as lexical scope.

6
00:00:12.740 --> 00:00:15.210
Dynamic scope doesn't actually
exist in JavaScript, but

7
00:00:15.210 --> 00:00:17.940
it does exist in a few esoteric languages.

8
00:00:17.940 --> 00:00:20.490
Okay, so there's just lexical scope.

9
00:00:20.490 --> 00:00:23.546
What are three different ways that
you can create a new scoped variable?

10
00:00:31.380 --> 00:00:32.730
&gt;&gt; Speaker 2: Would a let do?

11
00:00:32.730 --> 00:00:36.290
&gt;&gt; Kyle: You can do a let, that would
create a new variable inside of some scope

12
00:00:37.336 --> 00:00:38.779
&gt;&gt; Speaker 3: Var.

13
00:00:38.779 --> 00:00:42.238
&gt;&gt; Kyle: Var inside of a function,
like we can make an if e or a function and

14
00:00:42.238 --> 00:00:43.529
make a var inside of it.

15
00:00:46.129 --> 00:00:47.647
&gt;&gt; Speaker 2: [CROSSTALK]
&gt;&gt; Kyle: Third one is tricky.

16
00:00:47.647 --> 00:00:51.512
That's the same thing passing
in an argument to an if e.

17
00:00:51.512 --> 00:00:53.130
&gt;&gt; Speaker 4: Function declaration.

18
00:00:53.130 --> 00:00:54.990
&gt;&gt; Kyle: Same thing,
we have a parameter list,

19
00:00:54.990 --> 00:00:56.400
that's the same thing
as a var declaration.

20
00:00:56.400 --> 00:00:59.960
How about the catch clause?

21
00:00:59.960 --> 00:01:01.040
&gt;&gt; Speaker 4: Would the, okay.

22
00:01:01.040 --> 00:01:03.720
&gt;&gt; Kyle: The error in a catch
clause creates a new variable.

23
00:01:07.440 --> 00:01:10.960
Let's review from earlier in the course,
what is the difference between undeclared

24
00:01:10.960 --> 00:01:14.280
and undefined now that we fully
understand lexical scope?

25
00:01:14.280 --> 00:01:16.270
What's the difference between
undeclared and undefined?

26
00:01:21.340 --> 00:01:23.220
&gt;&gt; Speaker 5: Undeclared
it's never been declared.

27
00:01:23.220 --> 00:01:26.670
&gt;&gt; Kyle: It's never been declared in
any scope we have access too, exactly.

28
00:01:26.670 --> 00:01:27.475
What about undefined?

29
00:01:27.475 --> 00:01:29.234
&gt;&gt; Speaker 5: [CROSSTALK]
It's been declared.

30
00:01:29.234 --> 00:01:33.775
&gt;&gt; Kyle: It has been declared in a scope,
but does not currently have a value,

31
00:01:33.775 --> 00:01:36.530
right, does not currently have a value.

32
00:01:36.530 --> 00:01:40.920
All right, exercise 2,

33
00:01:40.920 --> 00:01:46.080
it's the same one we did earlier when we
worked on that work logging application.

34
00:01:46.080 --> 00:01:49.330
But now read the Read Me cuz it
describes to exactly what to do,

35
00:01:49.330 --> 00:01:50.870
don't skip over that detail.

36
00:01:50.870 --> 00:01:54.450
But in exercise 2 your task is
to take what we've learned about

37
00:01:54.450 --> 00:01:57.880
naming our function expressions and
using block scoping,

38
00:01:57.880 --> 00:02:00.650
take what you know now about
lexical scope and improve the code.

39
00:02:00.650 --> 00:02:05.390
So we're not adding any new features,
we're just improving the code by usage of

40
00:02:06.420 --> 00:02:10.220
block scoping, creating explicit scopes,
that sort of stuff, okay.

41
00:02:10.220 --> 00:02:13.880
Shouldn't be more than about five or
eight lines of code that you;ll write or

42
00:02:13.880 --> 00:02:14.760
change to do this.

43
00:02:14.760 --> 00:02:17.450
So we'll give you about five
minutes to work on the exercise and

44
00:02:17.450 --> 00:02:18.324
then talk through the solution.

