[00:00:00]
>> Kyle Simpson: So I wanna point out just a few things that you should be aware of if you start trying to color outside the lines. Let me show you a few of those places where the class, you should be cautious. First off, you cannot extend an object. This actually, I think, my biggest frustration or objection.

[00:00:20]
Maybe my second biggest. You can't mix classes and objects together. It's all classes or no classes. You can't just extend an object. Why? I don't know. I have yelled and scream and thrown a fit. They didn't pay any attention to me that'll cause a syntax error. I'm sorry, a runtime error.

[00:00:42]
You're not allowed to extend an object.
>> Kyle Simpson: Even though this is supposedly just syntax sugar, so theoretically foo and bar are actual functions you can't call them. You can't just call the foo and more importantly, to my problem, you can't call bar and override its this, or do any kind of the this binding stuff.

[00:01:08]
You can't do anything dynamic with them. You're not allowed to use those classes as actual functions. You're only allowed to use them with the new keyword. So it's a full lock in to, it's all classes or no classes.
>> Kyle Simpson: [COUGH]
>> Kyle Simpson: You're not allowed to reference this keyword until after you've called the super function in the constructor.

[00:01:38]
So it's very common for people to want to when they're overwriting a constructor and extending behavior, set up some stuff in a specific way and then call to the parent constructor. So you'd wanna do something like set up a this, or set up some kind of thing, and then call the constructor.

[00:01:51]
That's not allowed, you have to call the super first.
>> Kyle Simpson: That's an unusual deviation from typical class oriented languages because in typical class oriented languages the end class, the lowest derived class, the furthest down in the chain is the one that creates and initializes the object. In JavaScript it's the reverse.

[00:02:14]
The most parent class is the one that creates and initializes. So, its kind of like a tdzer. This key word is in it's tdz at this point. You can't use it until you've called the super all the way up, and then you can use it. I've seen a number of people run across that gotcha before.

[00:02:36]

>> Kyle Simpson: [COUGH] This one is hard to explain, but you gotta stick with me. I have an A class and a C class. And the C class extends A, so look at A and C. And you'll notice that I over, I declare this foo(); which is this.one(); which is gonna call that, and it calls super.two(); which is also gonna call that.

[00:02:58]
So when I call, when I instantiate C(); and I call x.foo(); I get one:A two:A, exactly the way we'd expect.
>> Kyle Simpson: But now, what if I wanna take that foo function, this one right here. And I wanna dynamically rebind it to a different context, like for example to the B context.

[00:03:22]
If I say x.foo.call(B); we might expect it to say one:B two:B because now we're saying this.one and super.two. Here's one of the crazy gotchas. With .call and .apply it overrides or dynamically binds the this keyword but the super keyword is static. The super keyword stays fixed at the time you declare the class and it can't be overridden by a .bind or .call or .apply.

[00:03:56]
So, if you have a mix and match between a this and a super in your function, your this keyword will be dynamic sensitive. Your super won't and I've seen people run into that bug before. The reason they did not make super dynamically dispatched as opposed to statically fixed is for performance.

[00:04:17]
That's literally it. They said, well it'll be slower for us to figure out super at run time. So let's statically fix it and then tell people don't try to call it outside the lines. [COUGH] The super keyword is only valid inside of functions that are there as part of the class definition.

[00:04:48]
You cannot add to the class def-, you can add to a class definition. It is legal to say, B.prototype.foo, and add a new function in. But, that newly added function cannot use the super keyword. The super keyword is only syntactically valid if the function is there at the time the class is declared.

[00:05:05]
Why? Because the super is statically bound. So, you can't add to your class definitions and still use the super keyword. You also can't use the super keyword inside of objects that delegate up the prototype. I'm sorry, you can use them in. objects and methods, but you have to use the concise method syntax.

[00:05:33]
So, here, I'm using concise, ES6 concise methods, I'm able to use the super keyword. Here, if I do bar function, I'm not able to use the super keyword. So, you've got to stick with the concise method syntax.
>> Speaker 2: Is that for backwards compatibility?
>> Kyle Simpson: It is because people used to use the word super as a variable in old functions and so they wanted to add the super as a keyword only in brand new function types that nobody would've written.

[00:06:04]
So it's that old backwards compatibility question.
>> Speaker 2: There's a question in chat.
>> Speaker 2: Is this AB example, why does super goes second? I don't know.
>> Kyle Simpson: In this AB example, why does super goes second? I think they're asking several back. Why does super have to be second here?

[00:06:24]
I don't know if this is the slide they're asking about. But super has to go second, because there super has to go second because this keyword isn't usable. Are asking here, why the super go second. Super only has to go first in the constructor. This isn't a constructor.

[00:06:47]
This is just a regular method. By the time that method's called, this keyword's already been initialized. It's not in its tdz anymore. You can use it. So I think that was probably the question.
>> Kyle Simpson: All right, so we can only use super inside of concise methods.
>> Kyle Simpson: And there's a pattern that I like to use, because I still like using Object.create.

[00:07:13]
If I want to inherit from a class into an object. I might do an object.create of A.prototype which is gonna make me a thing and this object.assign that I'm using here on line 6 its trying to copy over from an object. So I have an object literal that's designed here and I want to copy over to it.

[00:07:32]
Should work, right? I would copy my foo method from the object literal over into the B object which is now linked to A prototype. And I ought to be able to call B.foo and get a one:A, two:A printout. The problem is that the this.one will work because the this is dynamic but that super keyword is statically bound to the object literal on line six and the object literal, the super keyword is going to reference object.prototype.

[00:08:06]
So, it doesn't dynamically switch over to the A.prototype context.
>> Kyle Simpson: The takeaway here is that while class does have some nice syntactic affordances, there are more than enough corner cases that my caution to you is, stay within the lines if you're gonna play with classes. Don't try to do dynamic stuff.

