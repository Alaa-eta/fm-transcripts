[00:00:00]
>> Mike North: So we're going to create some familiar looking utilities built around a dictionary type. Has anyone here used map and reduce on arrays? Show of hands? Awesome, everybody. So we're gonna build map and reduce for dictionaries and we're gonna define a dictionary type. So here's the example. We have a file extensions dictionary on the right, we would say this is a dictionary of string arrays.

[00:00:30]
And we want to iterate over the values for talking about mapping. We wanna produce a dictionary with the same keys, but with transformed values. So we would get something like what we see in the bottom right. So maybe we're building a open file dialog where we wanna list all of the extensions.

[00:00:52]
And it looks like JPEGs and HTML files have multiple extensions that are valid. And we're going to use our knowledge of type parameters so that this should work neatly With an arbitrary dictionary where we can operate on things that have types that we don't know the details about.

[00:01:15]
But using type parameters, we can still abstract all of that away, operate on these data structures, and given our consumers back the high fidelity types that they can then carry on and use. So this is in the challenges/dict folder.
>> Mike North: So the first thing I want us to think about is defining a dictionary.

[00:01:48]
So, can someone help me flesh this out? I know this is not a dictionary. Help me create a dictionary that uses a type parameter, so I could make a dictionary of numbers, or strings, or string arrays. What would I need to change here?
>> Mike North: So we've just been talking about generics and type parameters.

[00:02:17]
I probably need something up here.
>> Mike North: What makes a dictionary a dictionary? How is it different from an array?
>> Speaker 1: All the values are the same type?
>> Mike North: All of the values are of the same type. So we're gonna have something and then T. And how are the values organized within the dictionary?

[00:02:45]

>> Speaker 1: Key value pairs?
>> Mike North: Key value pairs. And how do we type an arbitrary key access in typescript where I can pass in a home or Office or iPhone and get a phone number back?
>> Speaker 1: So you have that array where k then a colon and then a type.

[00:03:07]

>> Mike North: Perfectly described.
>> Speaker 1: Is the k special or can that be anything?
>> Mike North: It can be whatever we want.
>> Speaker 1: Is that convention?
>> Mike North: So, I call it k because of key It's the equivalent of naming a function argument and this is just the type that goes with it.

[00:03:32]
There we go, and I'm gonna follow the convention of acknowledging that if I pass in a key, I might get nothing back. How would I add that to this type?
>> Speaker 1: Or undefined, question mark.
>> Mike North: That's good. Actually we've got two good answers. So I can do it this way and I'm gonna go out on a limb here,

[00:04:12]

>> Mike North: Oops,
>> Mike North: Yep, looks like the optional is not gonna work. That's a very good guess though. I would expect that to be something they'd introduce in the future, there's really no
>> Mike North: Nothing's stopping them. In fact, I don't wanna get too deep into more advanced things here.

[00:04:36]
There is a way that you can specify it with the question mark. But you're both right in that either will introduce the possibility of the value being undefined, great. So according to the use of these things, if these are gonna be free standing functions, the first thing we're gonna pass in is a dictionary.

[00:05:03]

>> Mike North: We're gonna make it a Dict T. And saying, cannot find name T. Anyone have an idea of what's missing here?
>> Speaker 1: [INAUDIBLE]
>> Mike North: A constraint? I don't think we need a contraint right now.
>> Speaker 2: Function should have a generic T?
>> Mike North: Function should have a generic T, right.

[00:05:23]
We have to state kinda upfront that this function, T, is not a reference to an interface called T. There is a typed parameter, that this function uses, and it is called T, great. And I'm gonna add the mapping function here. So, conceptually when we use Array.map(), how would you describe the function that we pass in?

[00:05:49]
What's its purpose?
>> Speaker 1: To loop through whatever array you have?
>> Mike North: Sure, we iteratively invoke that function. And what does the function do?
>> Speaker 2: Transforming it.
>> Mike North: It transforms it, potentially from one type to another type. Right, so in this case we should probably take an argument of T, cuz we're iterating over a data structure that has values of T, and we're spitting out something else.

[00:06:19]
I'm gonna introduce another type parameter because that's what we're transforming to, and I'll fill in the function in a second. But
>> Mike North: We're gonna return a dictionary of these transformed values. Now, all that's left is for us to define the function itself.
>> Mike North: arg is a T and it returns,

[00:06:47]

>> Mike North: An S.
>> Speaker 1: Can you ignore the index argument?
>> Mike North: Can I ignore the index argument?
>> Speaker 1: The second argument in a map function.
>> Mike North: You could. In terms of using a rand out map, that would sort of defeat the purpose. The function is the definition of the work to be done.

[00:07:12]
We could make it optional, and then just return the same dictionary again. But to me, that would be a sign of misuse, right? It's like all we could do is iterate over the array, and do nothing. So, without instructions as to how to transform from one type to another, I would say, there is no point in this.

[00:07:36]
So I would keep it mandatory in this case.
>> Speaker 1: I mean like for the function type arg is T but then as a second argument of that function Is an index of type number.
>> Mike North: Sorry, thank you, absolutely. Yeah, we could totally do that, and we don't need to make it optional.

[00:07:59]
Because the way that the type equivalent works, if a function chooses to not receive that argument, that's fine. If we made it optional, we're indicating that we may be providing it but it could come through as under find, which is not what's likely to happen. So let's implement this.

[00:08:20]
Conveniently, it's easy to create an empty dictionary, right? We're going to create an empty dictionary, we're going to loop over the existing dictionary. And populate the thing that we're gonna return. And then we'll return it.
>> Mike North: So there you go. That's the easy part. And now, how do we iterate over an objects keys?

[00:08:49]

>> Speaker 1: Object.keys.
>> Mike North: Good, object.keys(dict). And I'll just use forEach and this receives a value and an index. And that'll be useful to pass along. And we'll say we're gonna place in the output dictionary under, sorry this is not, I'm gonna rename this for clarity. Under the same dictionary key, what do we do next?

[00:09:33]

>> Mike North: Gotta use that function, right? I'm almost done, and I haven't used it yet.
>> Mike North: So this function is made to take in a T and an index and return S.
>> Mike North: Dict and d key. Right, thank you. And this is of type t or undefined, right? Cuz in theory, there could be something missing in this dictionary.

[00:10:09]
It could be someone who's deliberately placed an undefined value in there, trolling us.
>> Mike North: If,
>> Mike North: (ThisItem),
>> Mike North: Will only place the output item in this dictionary, If it's defined. I got to be careful here. I just realized like what about zeroes and empty strings and other falsey things?

[00:10:46]
There we go. That's more thorough, right? So we are looping over all of the keys in the dictionary. We're grabbing each value. If it's defined, transform it, pass along that, by transforming using this function by passing along the original value and the index we get the transformed value out, and now we return this thing.

[00:11:05]
This is the place where we're we can point to the places were using the type parameters and it's quite necessary, right? So we take a dictionary type T, T helps us function were using to transform. And the function we receive return something and that's how we'll be able to infer what it should be and that determines our output type.

[00:11:32]
So, check out how I can use this. mapDict, do I have one already created, no. So, we'll create a with the strings.
>> Mike North: And now to the function here that'll take the string as an argument,
>> Mike North: And if I return an array of strings, map dict will return a dictionary of string arrays If I were to wrap it in an object like this, that's error functions regarding that as a function body.

[00:12:17]
Now it's a dictionary of sort of wrapped values. Notice I had to use type parameters to define what this thing does. But where I'm calling it, this looks relatively simple, the types kinda just work, the blanks are filled in and they are inferred by the arguments that I'm passing to this function.

[00:12:37]
They don't have to be explicitly specified. So this would be like a well chosen use of generics and that it's a really flexible piece of code, the type that it returns. Like you have as much level of specificity and detail that you need in order to carry it forward.

[00:12:59]
And I don't have to provide anything explicit. Cool stuff. Okay.
>> Speaker 3: Mike, can you just mention, before we break, that the solutionary duties will be rebuilt or something like that?
>> Mike North: Yep. So th-
>> Speaker 3: And be transitioned?
>> Mike North: We'll make sure that the solution to the reduce exercise here will be in the repo.

[00:13:27]
And it follows a similar pattern.

