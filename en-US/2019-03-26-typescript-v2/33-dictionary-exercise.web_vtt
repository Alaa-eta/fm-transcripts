WEBVTT

1
00:00:00.280 --> 00:00:05.100
&gt;&gt; Mike North: So we're going
to create some familiar looking

2
00:00:05.100 --> 00:00:08.920
utilities built around a dictionary type.

3
00:00:09.930 --> 00:00:13.090
Has anyone here used map and
reduce on arrays?

4
00:00:13.090 --> 00:00:13.980
Show of hands?

5
00:00:13.980 --> 00:00:15.080
Awesome, everybody.

6
00:00:15.080 --> 00:00:19.010
So we're gonna build map and
reduce for dictionaries and

7
00:00:19.010 --> 00:00:21.046
we're gonna define a dictionary type.

8
00:00:21.046 --> 00:00:23.710
So here's the example.

9
00:00:23.710 --> 00:00:26.710
We have a file extensions
dictionary on the right,

10
00:00:26.710 --> 00:00:30.340
we would say this is
a dictionary of string arrays.

11
00:00:30.340 --> 00:00:36.424
And we want to iterate over the values for
talking about mapping.

12
00:00:36.424 --> 00:00:42.600
We wanna produce a dictionary with the
same keys, but with transformed values.

13
00:00:42.600 --> 00:00:46.390
So we would get something like
what we see in the bottom right.

14
00:00:46.390 --> 00:00:52.809
So maybe we're building a open file dialog
where we wanna list all of the extensions.

15
00:00:52.809 --> 00:00:59.915
And it looks like JPEGs and HTML files
have multiple extensions that are valid.

16
00:00:59.915 --> 00:01:04.096
And we're going to use our
knowledge of type parameters so

17
00:01:04.096 --> 00:01:09.130
that this should work neatly With
an arbitrary dictionary where we can

18
00:01:09.130 --> 00:01:14.360
operate on things that have types
that we don't know the details about.

19
00:01:15.630 --> 00:01:20.670
But using type parameters,
we can still abstract all of that away,

20
00:01:20.670 --> 00:01:26.050
operate on these data structures,
and given our consumers back

21
00:01:26.050 --> 00:01:29.670
the high fidelity types that
they can then carry on and use.

22
00:01:31.360 --> 00:01:35.085
So this is in the challenges/dict folder.

23
00:01:42.365 --> 00:01:45.255
&gt;&gt; Mike North: So
the first thing I want us to think about

24
00:01:45.255 --> 00:01:47.210
is defining a dictionary.

25
00:01:48.450 --> 00:01:51.000
So, can someone help me flesh this out?

26
00:01:51.000 --> 00:01:53.120
I know this is not a dictionary.

27
00:01:53.120 --> 00:01:57.860
Help me create a dictionary
that uses a type parameter, so

28
00:01:57.860 --> 00:02:00.880
I could make a dictionary of numbers,
or strings, or string arrays.

29
00:02:00.880 --> 00:02:02.837
What would I need to change here?

30
00:02:13.837 --> 00:02:17.300
&gt;&gt; Mike North: So we've just been talking
about generics and type parameters.

31
00:02:17.300 --> 00:02:19.695
I probably need something up here.

32
00:02:25.536 --> 00:02:28.141
&gt;&gt; Mike North: What makes
a dictionary a dictionary?

33
00:02:28.141 --> 00:02:31.762
How is it different from an array?

34
00:02:31.762 --> 00:02:33.332
&gt;&gt; Speaker 1: All the values
are the same type?

35
00:02:33.332 --> 00:02:35.070
&gt;&gt; Mike North: All of the values
are of the same type.

36
00:02:35.070 --> 00:02:40.329
So we're gonna have something and then T.

37
00:02:42.200 --> 00:02:45.962
And how are the values organized
within the dictionary?

38
00:02:45.962 --> 00:02:47.683
&gt;&gt; Speaker 1: Key value pairs?

39
00:02:47.683 --> 00:02:48.850
&gt;&gt; Mike North: Key value pairs.

40
00:02:48.850 --> 00:02:53.746
And how do we type
an arbitrary key access in

41
00:02:53.746 --> 00:02:58.098
typescript where I can pass in a home or

42
00:02:58.098 --> 00:03:03.590
Office or iPhone and
get a phone number back?

43
00:03:03.590 --> 00:03:07.240
&gt;&gt; Speaker 1: So you have that array
where k then a colon and then a type.

44
00:03:07.240 --> 00:03:08.650
&gt;&gt; Mike North: Perfectly described.

45
00:03:08.650 --> 00:03:13.130
&gt;&gt; Speaker 1: Is the k special or
can that be anything?

46
00:03:13.130 --> 00:03:14.150
&gt;&gt; Mike North: It can be whatever we want.

47
00:03:15.930 --> 00:03:16.660
&gt;&gt; Speaker 1: Is that convention?

48
00:03:20.080 --> 00:03:25.448
&gt;&gt; Mike North: So, I call it k
because of key It's the equivalent

49
00:03:25.448 --> 00:03:32.324
of naming a function argument and
this is just the type that goes with it.

50
00:03:32.324 --> 00:03:37.190
There we go, and
I'm gonna follow the convention of

51
00:03:37.190 --> 00:03:43.170
acknowledging that if I pass in a key,
I might get nothing back.

52
00:03:44.570 --> 00:03:46.430
How would I add that to this type?

53
00:03:49.650 --> 00:03:52.066
&gt;&gt; Speaker 1: Or undefined, question mark.

54
00:03:52.066 --> 00:03:53.195
&gt;&gt; Mike North: That's good.

55
00:03:53.195 --> 00:03:56.276
Actually we've got two good answers.

56
00:03:56.276 --> 00:04:00.460
So I can do it this way and

57
00:04:00.460 --> 00:04:06.115
I'm gonna go out on a limb here,

58
00:04:12.655 --> 00:04:16.993
&gt;&gt; Mike North: Oops,
&gt;&gt; Mike North: Yep,

59
00:04:16.993 --> 00:04:19.140
looks like the optional is not gonna work.

60
00:04:19.140 --> 00:04:21.610
That's a very good guess though.

61
00:04:21.610 --> 00:04:25.438
I would expect that to be something
they'd introduce in the future,

62
00:04:25.438 --> 00:04:29.871
there's really no
&gt;&gt; Mike North: Nothing's stopping them.

63
00:04:29.871 --> 00:04:36.610
In fact, I don't wanna get too deep
into more advanced things here.

64
00:04:36.610 --> 00:04:39.850
There is a way that you can
specify it with the question mark.

65
00:04:39.850 --> 00:04:44.460
But you're both right in that either
will introduce the possibility of

66
00:04:44.460 --> 00:04:46.890
the value being undefined, great.

67
00:04:46.890 --> 00:04:51.054
So according to the use of these things,
if these are gonna be free

68
00:04:51.054 --> 00:04:55.916
standing functions, the first thing
we're gonna pass in is a dictionary.

69
00:05:03.219 --> 00:05:06.587
&gt;&gt; Mike North: We're
gonna make it a Dict T.

70
00:05:06.587 --> 00:05:08.555
And saying, cannot find name T.

71
00:05:08.555 --> 00:05:10.935
Anyone have an idea of
what's missing here?

72
00:05:10.935 --> 00:05:16.220
&gt;&gt; Speaker 1: [INAUDIBLE]
&gt;&gt; Mike North: A constraint?

73
00:05:16.220 --> 00:05:20.313
I don't think we need
a contraint right now.

74
00:05:20.313 --> 00:05:21.531
&gt;&gt; Speaker 2: Function
should have a generic T?

75
00:05:21.531 --> 00:05:23.338
&gt;&gt; Mike North: Function should
have a generic T, right.

76
00:05:23.338 --> 00:05:27.583
We have to state kinda upfront
that this function, T,

77
00:05:27.583 --> 00:05:31.330
is not a reference to
an interface called T.

78
00:05:31.330 --> 00:05:37.000
There is a typed parameter, that this
function uses, and it is called T, great.

79
00:05:38.300 --> 00:05:42.010
And I'm gonna add
the mapping function here.

80
00:05:42.010 --> 00:05:45.580
So, conceptually when we use Array.map(),

81
00:05:45.580 --> 00:05:49.340
how would you describe
the function that we pass in?

82
00:05:49.340 --> 00:05:50.210
What's its purpose?

83
00:05:51.830 --> 00:05:55.250
&gt;&gt; Speaker 1: To loop through
whatever array you have?

84
00:05:55.250 --> 00:05:58.490
&gt;&gt; Mike North: Sure,
we iteratively invoke that function.

85
00:05:58.490 --> 00:06:01.095
And what does the function do?

86
00:06:01.095 --> 00:06:02.183
&gt;&gt; Speaker 2: Transforming it.

87
00:06:02.183 --> 00:06:06.520
&gt;&gt; Mike North: It transforms it,
potentially from one type to another type.

88
00:06:06.520 --> 00:06:11.390
Right, so in this case we should
probably take an argument of T,

89
00:06:12.450 --> 00:06:17.130
cuz we're iterating over a data
structure that has values of T, and

90
00:06:17.130 --> 00:06:18.710
we're spitting out something else.

91
00:06:19.710 --> 00:06:24.230
I'm gonna introduce another type parameter
because that's what we're transforming to,

92
00:06:25.940 --> 00:06:28.480
and I'll fill in the function in a second.

93
00:06:28.480 --> 00:06:32.707
But
&gt;&gt; Mike North: We're gonna return

94
00:06:32.707 --> 00:06:36.200
a dictionary of these transformed values.

95
00:06:36.200 --> 00:06:39.187
Now, all that's left is for
us to define the function itself.

96
00:06:41.413 --> 00:06:47.985
&gt;&gt; Mike North: arg is a T and it returns,
&gt;&gt; Mike North: An S.

97
00:06:47.985 --> 00:06:52.870
&gt;&gt; Speaker 1: Can you
ignore the index argument?

98
00:06:54.020 --> 00:06:56.120
&gt;&gt; Mike North: Can I
ignore the index argument?

99
00:06:56.120 --> 00:06:58.150
&gt;&gt; Speaker 1: The second
argument in a map function.

100
00:07:00.130 --> 00:07:01.500
&gt;&gt; Mike North: You could.

101
00:07:04.060 --> 00:07:09.010
In terms of using a rand out map,
that would sort of defeat the purpose.

102
00:07:09.010 --> 00:07:12.740
The function is the definition
of the work to be done.

103
00:07:12.740 --> 00:07:17.460
We could make it optional, and then
just return the same dictionary again.

104
00:07:17.460 --> 00:07:22.071
But to me,
that would be a sign of misuse, right?

105
00:07:22.071 --> 00:07:28.440
It's like all we could do is iterate
over the array, and do nothing.

106
00:07:28.440 --> 00:07:33.120
So, without instructions as to how to
transform from one type to another,

107
00:07:33.120 --> 00:07:36.340
I would say, there is no point in this.

108
00:07:36.340 --> 00:07:40.280
So I would keep it mandatory in this case.

109
00:07:40.280 --> 00:07:45.480
&gt;&gt; Speaker 1: I mean like for
the function type arg is T but

110
00:07:45.480 --> 00:07:50.140
then as a second argument of that
function Is an index of type number.

111
00:07:50.140 --> 00:07:52.000
&gt;&gt; Mike North: Sorry,
thank you, absolutely.

112
00:07:55.570 --> 00:07:59.290
Yeah, we could totally do that, and
we don't need to make it optional.

113
00:07:59.290 --> 00:08:04.050
Because the way that
the type equivalent works,

114
00:08:04.050 --> 00:08:08.800
if a function chooses to not
receive that argument, that's fine.

115
00:08:08.800 --> 00:08:12.360
If we made it optional, we're indicating
that we may be providing it but

116
00:08:12.360 --> 00:08:15.480
it could come through as under find,
which is not what's likely to happen.

117
00:08:16.520 --> 00:08:18.230
So let's implement this.

118
00:08:20.860 --> 00:08:24.010
Conveniently, it's easy to create
an empty dictionary, right?

119
00:08:24.010 --> 00:08:25.450
We're going to create an empty dictionary,

120
00:08:25.450 --> 00:08:28.760
we're going to loop over
the existing dictionary.

121
00:08:28.760 --> 00:08:32.940
And populate the thing
that we're gonna return.

122
00:08:32.940 --> 00:08:34.551
And then we'll return it.

123
00:08:42.203 --> 00:08:43.097
&gt;&gt; Mike North: So there you go.

124
00:08:43.097 --> 00:08:44.690
That's the easy part.

125
00:08:44.690 --> 00:08:49.091
And now,
how do we iterate over an objects keys?

126
00:08:49.091 --> 00:08:54.305
&gt;&gt; Speaker 1: Object.keys.

127
00:08:54.305 --> 00:08:57.243
&gt;&gt; Mike North: Good, object.keys(dict).

128
00:08:57.243 --> 00:09:02.227
And I'll just use forEach and

129
00:09:02.227 --> 00:09:08.212
this receives a value and an index.

130
00:09:08.212 --> 00:09:10.549
And that'll be useful to pass along.

131
00:09:10.549 --> 00:09:17.249
And we'll say we're gonna place
in the output dictionary under,

132
00:09:17.249 --> 00:09:23.400
sorry this is not,
I'm gonna rename this for clarity.

133
00:09:23.400 --> 00:09:28.837
Under the same dictionary key,
what do we do next?

134
00:09:33.762 --> 00:09:35.049
&gt;&gt; Mike North: Gotta use that function,
right?

135
00:09:35.049 --> 00:09:37.148
I'm almost done, and
I haven't used it yet.

136
00:09:39.724 --> 00:09:45.099
&gt;&gt; Mike North: So this function is made
to take in a T and an index and return S.

137
00:09:55.301 --> 00:09:58.280
&gt;&gt; Mike North: Dict and d key.

138
00:09:58.280 --> 00:09:59.020
Right, thank you.

139
00:10:01.140 --> 00:10:05.100
And this is of type t or undefined, right?

140
00:10:05.100 --> 00:10:09.680
Cuz in theory, there could be
something missing in this dictionary.

141
00:10:09.680 --> 00:10:13.852
It could be someone who's deliberately
placed an undefined value in there,

142
00:10:13.852 --> 00:10:14.630
trolling us.

143
00:10:17.921 --> 00:10:22.657
&gt;&gt; Mike North: If,
&gt;&gt; Mike North: (ThisItem),

144
00:10:24.289 --> 00:10:27.706
&gt;&gt; Mike North: Will only place the output

145
00:10:27.706 --> 00:10:33.966
item in this dictionary, If it's defined.

146
00:10:33.966 --> 00:10:36.610
I got to be careful here.

147
00:10:36.610 --> 00:10:40.760
I just realized like what about zeroes and
empty strings and other falsey things?

148
00:10:46.450 --> 00:10:46.970
There we go.

149
00:10:46.970 --> 00:10:49.210
That's more thorough, right?

150
00:10:49.210 --> 00:10:52.559
So we are looping over all of
the keys in the dictionary.

151
00:10:52.559 --> 00:10:53.905
We're grabbing each value.

152
00:10:53.905 --> 00:10:56.741
If it's defined, transform it,
pass along that,

153
00:10:56.741 --> 00:11:00.866
by transforming using this function by
passing along the original value and

154
00:11:00.866 --> 00:11:05.580
the index we get the transformed value
out, and now we return this thing.

155
00:11:05.580 --> 00:11:10.010
This is the place where we're
we can point to the places were

156
00:11:10.010 --> 00:11:15.000
using the type parameters and
it's quite necessary, right?

157
00:11:15.000 --> 00:11:20.880
So we take a dictionary type T, T helps
us function were using to transform.

158
00:11:22.230 --> 00:11:27.620
And the function we receive
return something and that's

159
00:11:27.620 --> 00:11:32.390
how we'll be able to infer what it should
be and that determines our output type.

160
00:11:32.390 --> 00:11:34.340
So, check out how I can use this.

161
00:11:36.880 --> 00:11:41.790
mapDict, do I have one already created,
no.

162
00:11:41.790 --> 00:11:44.770
So, we'll create a with the strings.

163
00:11:50.289 --> 00:11:53.787
&gt;&gt; Mike North: And now to the function
here that'll take the string as

164
00:11:53.787 --> 00:11:57.574
an argument,
&gt;&gt; Mike North: And

165
00:11:57.574 --> 00:12:00.934
if I return an array of strings,

166
00:12:00.934 --> 00:12:05.415
map dict will return
a dictionary of string

167
00:12:05.415 --> 00:12:10.519
arrays If I were to wrap
it in an object like this,

168
00:12:10.519 --> 00:12:17.270
that's error functions regarding
that as a function body.

169
00:12:17.270 --> 00:12:20.530
Now it's a dictionary of
sort of wrapped values.

170
00:12:20.530 --> 00:12:25.040
Notice I had to use type parameters
to define what this thing does.

171
00:12:25.040 --> 00:12:29.150
But where I'm calling it,
this looks relatively simple,

172
00:12:29.150 --> 00:12:33.450
the types kinda just work,
the blanks are filled in and

173
00:12:33.450 --> 00:12:37.910
they are inferred by the arguments
that I'm passing to this function.

174
00:12:37.910 --> 00:12:41.300
They don't have to be
explicitly specified.

175
00:12:42.450 --> 00:12:47.080
So this would be like a well
chosen use of generics and

176
00:12:47.080 --> 00:12:52.650
that it's a really flexible piece of code,
the type that it returns.

177
00:12:52.650 --> 00:12:57.010
Like you have as much
level of specificity and

178
00:12:57.010 --> 00:12:59.750
detail that you need in
order to carry it forward.

179
00:12:59.750 --> 00:13:01.460
And I don't have to
provide anything explicit.

180
00:13:04.990 --> 00:13:06.740
Cool stuff.

181
00:13:06.740 --> 00:13:08.004
Okay.

182
00:13:08.004 --> 00:13:11.284
&gt;&gt; Speaker 3: Mike,
can you just mention, before we break,

183
00:13:11.284 --> 00:13:16.050
that the solutionary duties will
be rebuilt or something like that?

184
00:13:16.050 --> 00:13:17.687
&gt;&gt; Mike North: Yep.

185
00:13:17.687 --> 00:13:21.671
So th-
&gt;&gt; Speaker 3: And be transitioned?

186
00:13:21.671 --> 00:13:26.095
&gt;&gt; Mike North: We'll make sure that the
solution to the reduce exercise here will

187
00:13:26.095 --> 00:13:27.450
be in the repo.

188
00:13:27.450 --> 00:13:29.920
And it follows a similar pattern.

