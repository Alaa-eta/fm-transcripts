WEBVTT

1
00:00:00.170 --> 00:00:03.790
&gt;&gt; Will Sentance: So before we get
into how high order functions work,

2
00:00:03.790 --> 00:00:07.690
we are going to see a metaphor.

3
00:00:07.690 --> 00:00:11.480
A metaphor for why we have our high
order function in the first place.

4
00:00:11.480 --> 00:00:15.440
So function ten squared,
no input return ten by ten.

5
00:00:15.440 --> 00:00:17.860
Sounds like a very useful function,
I'm sure you can already agree.

6
00:00:17.860 --> 00:00:20.560
What is the syntax of this function, Cara?

7
00:00:22.240 --> 00:00:23.917
What is the wording of this function?

8
00:00:23.917 --> 00:00:27.972
There's a function ten squared,
no input, and returns ten by ten.

9
00:00:27.972 --> 00:00:30.470
How would we declare the function?

10
00:00:30.470 --> 00:00:32.550
What was the first word to
declare a function, Cara?

11
00:00:34.620 --> 00:00:35.990
Function, great.

12
00:00:35.990 --> 00:00:37.770
There it is, function.

13
00:00:37.770 --> 00:00:39.300
And what could we call it, Cara?

14
00:00:39.300 --> 00:00:41.330
&gt;&gt; Cara: Ten squared.

15
00:00:41.330 --> 00:00:44.060
&gt;&gt; Will Sentance: Nice,
Cara, ambiguous name.

16
00:00:44.060 --> 00:00:50.810
Ten squared and does it take any
parameters, Craig, any parameters for it?

17
00:00:52.240 --> 00:00:56.320
No, correct, and then in the body
of the function, what do we add?

18
00:00:57.830 --> 00:01:01.634
Whatever return, ten by ten.

19
00:01:02.950 --> 00:01:04.780
Such a useful function.

20
00:01:04.780 --> 00:01:05.780
Do you agree?

21
00:01:06.840 --> 00:01:08.840
No, it's a terribly useless function.

22
00:01:08.840 --> 00:01:12.050
This is a useless function,
come on, it's a useless function.

23
00:01:12.050 --> 00:01:16.270
10 squared evaluates to 100, perfect.

24
00:01:16.270 --> 00:01:19.390
Now, what if, though, here's a more
useful function, nine squared.

25
00:01:19.390 --> 00:01:21.660
Griffin, how I would make nine squared?

26
00:01:21.660 --> 00:01:24.640
&gt;&gt; Griffin: Same thing,
you just change the numbers.

27
00:01:25.840 --> 00:01:30.373
&gt;&gt; Will Sentance: Yeah,
what about 100 squared, Lindsey?

28
00:01:30.373 --> 00:01:31.905
&gt;&gt; Lindsey: Same thing,
you just change the numbers.

29
00:01:31.905 --> 00:01:33.380
&gt;&gt; Will Sentance: Yeah,
I'm gonna really drag this out.

30
00:01:33.380 --> 00:01:35.370
Barb, what about 2,000 squared?

31
00:01:36.620 --> 00:01:37.650
&gt;&gt; Barb: Same thing.

32
00:01:37.650 --> 00:01:39.920
&gt;&gt; Will Sentance: How much
longer can I drag this out?

33
00:01:39.920 --> 00:01:41.200
We could go a while.

34
00:01:41.200 --> 00:01:43.830
Yeah, we're breaking some
sort of principle here.

35
00:01:43.830 --> 00:01:47.070
What principle are we breaking as I
come up with all these functions?

36
00:01:47.070 --> 00:01:48.510
What principle are we breaking, everyone?

37
00:01:48.510 --> 00:01:49.140
&gt;&gt; Group: Don't repeat yourself.

38
00:01:49.140 --> 00:01:50.370
&gt;&gt; Will Sentance: Don't
repeat yourself dry.

39
00:01:50.370 --> 00:01:54.372
As developers, the reason we have
functions in the first place is to wrap up

40
00:01:54.372 --> 00:01:56.787
some functionality that we wanna reuse,
and

41
00:01:56.787 --> 00:01:59.550
then we can refer to it just by its label.

42
00:01:59.550 --> 00:02:03.786
And only write out a functionality once.

43
00:02:03.786 --> 00:02:06.361
So we're constantly trying to
avoid repeating ourselves.

44
00:02:06.361 --> 00:02:09.903
Not just cuz we're lazy, but
mainly cuz we're lazy, but

45
00:02:09.903 --> 00:02:14.820
also because it makes for a far more
readable code, far more reusable code.

46
00:02:14.820 --> 00:02:17.490
We're only rewriting stuff
because it makes it hard.

47
00:02:17.490 --> 00:02:19.230
Well, this functionality
is the same as here, but

48
00:02:19.230 --> 00:02:21.580
I've got to change it in both places.

49
00:02:21.580 --> 00:02:22.970
This is problematic.

50
00:02:22.970 --> 00:02:26.590
So instead I write, what could I do here?

51
00:02:26.590 --> 00:02:29.820
Right now, nine squared,
eight squared, we've got a problem.

52
00:02:29.820 --> 00:02:32.040
We're breaking this dry principal.

53
00:02:32.040 --> 00:02:34.640
What could we do here, Griffin?

54
00:02:34.640 --> 00:02:38.930
&gt;&gt; Griffin: You could do function
n squared with an input of nine.

55
00:02:38.930 --> 00:02:43.266
&gt;&gt; Will Sentance: So tell me more
abstractly, what am I, there we go,

56
00:02:43.266 --> 00:02:44.163
[LAUGH] no?

57
00:02:44.163 --> 00:02:45.174
No one got that pun?

58
00:02:45.174 --> 00:02:48.660
All right, tell me more abstractly, no?

59
00:02:48.660 --> 00:02:53.640
Tell me more,
what are we doing here in the sentence?

60
00:02:53.640 --> 00:02:57.911
&gt;&gt; Griffin: Well, you'd be, I guess,
modulizing it and being able to-

61
00:02:57.911 --> 00:02:58.648
&gt;&gt; Will Sentance: I like that,

62
00:02:58.648 --> 00:03:01.050
you're making your code more reusable.

63
00:03:01.050 --> 00:03:03.700
&gt;&gt; Griffin: Yeah,
you're able to call that function

64
00:03:03.700 --> 00:03:05.690
anytime you want a function squared.

65
00:03:05.690 --> 00:03:07.760
&gt;&gt; Will Sentance: Very nice,
that's exactly right.

66
00:03:07.760 --> 00:03:10.010
We can generalize the function.

67
00:03:10.010 --> 00:03:12.897
We can create a function, it's gonna be,
look at this, yeah, yeah, yeah, obviously.

68
00:03:12.897 --> 00:03:15.110
We're not gonna create 10 squared,
100 squared.

69
00:03:15.110 --> 00:03:17.330
This is the very essence of why
we have high order functions.

70
00:03:18.350 --> 00:03:23.370
We're gonna see in a second here,
we've created a function squared num.

71
00:03:23.370 --> 00:03:27.511
And left a placeholder, you see every now
and then I realize I shouldn't be pointing

72
00:03:27.511 --> 00:03:31.695
up here because everyone online's just
like, yeah, to the edge of my computer.

73
00:03:31.695 --> 00:03:34.328
&gt;&gt; Group: [LAUGH]
&gt;&gt; Will Sentance: There it is here

74
00:03:34.328 --> 00:03:37.612
squareNum function.

75
00:03:37.612 --> 00:03:41.078
I have to really just jolt it
around to make it do that thing.

76
00:03:41.078 --> 00:03:41.823
Nope, there we go.

77
00:03:41.823 --> 00:03:43.854
All right, squareNum function.

78
00:03:43.854 --> 00:03:48.951
I left a placeholder, and
then it's only when I invoke call,

79
00:03:48.951 --> 00:03:54.352
execute, run that squareNum
function with 10, 9, 100.

80
00:03:54.352 --> 00:03:59.618
I get to dynamically, at the same time,
create the function effectively 9 squared,

81
00:03:59.618 --> 00:04:03.100
nine squared, and
then call it at the same time.

82
00:04:03.100 --> 00:04:06.488
So at my definition stage of the function,
so functions have two stages,

83
00:04:06.488 --> 00:04:07.810
definition and execution.

84
00:04:07.810 --> 00:04:11.180
And my definition stage, where I store
it in memory, I leave a placeholder.

85
00:04:11.180 --> 00:04:15.439
Like a kinda, I don't yet know what
data I'm gonna apply this to yet.

86
00:04:15.439 --> 00:04:16.602
So just leave it blank for now.

87
00:04:16.602 --> 00:04:20.759
And I'll figure out when I
run the function what actual,

88
00:04:20.759 --> 00:04:25.560
specific number my data I'm gonna
apply this functionality to.

89
00:04:25.560 --> 00:04:32.702
Okay, this is making our function cleaner
and more efficient, but this is obvious.

90
00:04:32.702 --> 00:04:35.590
Well, it's not obvious but
it's fairly obvious.

91
00:04:35.590 --> 00:04:40.670
It turns out we may not only want to leave

92
00:04:40.670 --> 00:04:45.790
some of our data general
until we call the function.

93
00:04:45.790 --> 00:04:50.480
In other words, leave a placeholder for
some of our data in the definition.

94
00:04:50.480 --> 00:04:52.420
And only when we run the function,

95
00:04:52.420 --> 00:04:57.730
determine what data I want to apply my
multiply by itself functionality to.

96
00:04:59.520 --> 00:05:03.620
It turns out I might also
want to leave a placeholder.

97
00:05:03.620 --> 00:05:08.830
I might want to leave, for now,
unknown some of my specific

98
00:05:08.830 --> 00:05:14.650
functionality until I call my function.

99
00:05:14.650 --> 00:05:17.660
I may not just want to say,
leave a placeholder for my data.

100
00:05:17.660 --> 00:05:21.580
I may also want to leave a placeholder
to be determined later for

101
00:05:21.580 --> 00:05:24.710
some of my actual specific functionality.

102
00:05:24.710 --> 00:05:27.890
And then only determine
what that functionality is

103
00:05:27.890 --> 00:05:33.010
when I actually go ahead and
call, run, the function.

104
00:05:33.010 --> 00:05:37.400
Here, I determine my data, ten,
nine, eight, when I run the function.

105
00:05:37.400 --> 00:05:42.480
What if I were to determine some of
my functionality only when I run

106
00:05:42.480 --> 00:05:43.990
the function?

107
00:05:43.990 --> 00:05:45.616
That's very powerful, and

108
00:05:45.616 --> 00:05:49.690
that is what we're gonna see is
the essence of higher order functions.

