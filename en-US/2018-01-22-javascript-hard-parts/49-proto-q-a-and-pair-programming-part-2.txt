[00:00:00]
>> Will Sentance: All right, let's have fun. This is solution two, and by the way, solution three and four, they are only gonna do this stuff. We're gonna see some fancy keywords you all have heard of and probably tried to use, and used effectively maybe. Those fancy keywords, they're all just gonna take some of these lines that we've handwritten here and automate them for us.

[00:00:22]
That's all they're gonna do. We have seen here the essence of how OOP is implemented in JavaScript, using this special prototype, _proto_ bond to an object above. That JavaScript knows to go and look at, when it hits an object property that ain't there on the object directly. It knows to go check through it's prototypal feature, it's prototypal nature.

[00:00:50]
All right, let's have thumbs on this. I don't know what happened, clarification question, clear to go on. Dave has one, excellent. Andrew has one, Katie has one, Art has one. Art, can we start with you?
>> Art: I was kind of wondering if you can have multiple prototypes?
>> Will Sentance: Great question.

[00:01:07]
So you cannot have, so you're sort of saying, could I pass and use the function store, and then Art's function store? No, you can not. You can only have one direct parent, but of course you could then have another paired to that object. And another paired into that object.

[00:01:26]
And you can have multiple different children of different types coming from the same parent. That is known as sub-classing. We're not gonna cover that today, there is a talk I have on that. Maybe one day we'll do it in front of masters, it does sub-classing in all of OP.

[00:01:44]
It is a brutal talk. There is no way we're gonna do it right now because we are more than doing enough with pure OP here. But yes, you cannot have multiple but you can have multiple hierarchically up and they can have multiple descendants out. You just, one can only have one parent, okay.

[00:02:03]
Andrew?
>> Andrew: So does it only create the prototype like that if you use the object create?
>> Will Sentance: That's not the only way we can make that bond. Actually all objects have some automatic bond. At the top of the chain, so above user function store, user function store also has, I don't want to get into this too much, Andrew, but it's a little preview.

[00:02:26]
Also has a protobond on it which points up to JavaScript's, for this one, default object, which has a whole bunch of shared functions of its own. Things like getPrototypeOf, all the functions you can ever call on an object, JavaScript dog foods its own functionality. It uses its own built in prototype chain to let, when you do an array.push, that push is actually stored on the array, on any array that gets created.

[00:02:58]
It has it's own parent which is all the bonus functionality that we can use on arrays. So when you do, I don't know, array.push, array is an array. Well that guy here has its own because really an array is just actually on object, has its own protobond to the array object that has all of the shared functionality that all arrays have, push, pop, all of these.

[00:03:28]
I won't go into that too much, but Andrew, as a preview there, all of these objects have a protobond by default. What we're really doing here is inserting our own in the way. So there's a default one here which is all objects proto is just the overall object which has on its own a bunch of properties like get prototype of.

[00:03:51]
All of these functions can be used on all objects because they're all available up the prototype chain. But we're just inserting ourselves in the way here to set our own user function store in the sort of in the interim, so we check there first. Does that make sense?

[00:04:08]
And I don't wanna go into that too much, if you don't mind. I don't wanna go into that too much, if you don't mind, but just know that every object has an _proto_. It's just that we're overriding the standard one here with our set to share functions. So all about objects that were created by user creator have access to, okay Andrew.

[00:04:31]
There's more clarifications. Katie?
>> Katie: I'm clarified now.
>> Will Sentance: You are?
>> Katie: Yes.
>> Will Sentance: There we go. Norman, Griffin first, Griffin first.
>> Griffin: You said it's like overrating the object one, you can still get to the object, right?
>> Will Sentance: Because we're overriding it with an object, which, whose object prototype is?

[00:04:47]

>> Griffin: Is object, okay.
>> Will Sentance: Yes, exactly. So there's a chain all the way up. Great clarification, Griffin. Dave?
>> Dave: That second line up there, the let new user equal object dot create user, how do you say that in English?
>> Will Sentance: Well it's the right technical communication. We all declare it.

[00:05:02]
Okay, very nice, I like that question, Dave, very thoughtful question. We are declaring an object, or we're declaring new user, and assigning to it an empty object with,
>> Will Sentance: With the prototype of it being user function store. Now again, I hate this with the prototype of it. I wish we said with the _proto_ of it being, but _proto_ is the label we give to the prototype.

[00:05:32]
What we call whatever's here, the prototype of this object, but it's not stored in a property called the prototype, it's stored in a property called _proto_. It is what it is, but it causes a humongous amount of confusion, and you're going to see why in a moment cuz there is a property called prototype, and it ain't this one, and it ain't behaving the way that this one is behaving.

[00:05:54]
That's why I don't like the fact we call this guy the prototype of this object because it's stored in _proto_, it's the _proto_. So I have to say it's the object that's one step up the prototype chain. Not exactly a catchy phrase. So if you wanted to say that, you could say declare new user, assign to an empty object with user function store set as the object that's one step up the prototype chain.

[00:06:14]
If you wanna be super intuitive, but the typical way is with user function store as new users prototype, okay. Ask the question, Dave.
>> Dave: Yeah.
>> Will Sentance: You want to try again?
>> Dave: Just the distinction between prototype and inherit from-
>> Will Sentance: In JavaScript, by the way, I actually wrote a little note to myself when I first was giving this talk, I hate the word inherit describing what we're doing here.

[00:06:42]
Doesn't inherit make it feel like you've actually copied down the functionality onto the object? It does to me a bit. This here, increment, sorry, user one, inherits from user function store. When we say inherit in JavaScript, that is all we mean. Now are we copying those functions down to user one?

[00:07:02]
No, inherent is a weird ass word to use for this process. What actually happens is when we run user one with a function reference on it that isn't in user one, we check its proto_proto_ where we find this other object and you just want to store. And we look up to it and go, there's an increment function there.

[00:07:23]
Now does that mean, in a sense, that user one inherits increment function? I guess it feels like it does, but that is not being copied down, it's not. JavaScript at the runtime, is going to look up at that stuff and finds it there. But when you hear people saying user one inherited increment, that's exactly what it's saying.

[00:07:43]
Okay, great question man. Really glad you brought up that word. Okay, all right, at this point, do we do pairing now or do we push on? We're still quite early, so I think we do another block of pairing. Then we'll come back to this after another block of 20 minutes of pairing.

[00:08:00]
So we'll going to finish out 4:00 I reckon today, 4:00 to 4:15, so we're gonna do another block of pairing just to cement some of this stuff. And in a moment after that we're gonna come back and say, you know what, all this writing, object.create, new user, return new user, we're gonna automate it all away with the insertion of a magic keyword.

[00:08:23]
What's that magic keyword do we think?
>> class: Prototype.
>> Will Sentance: Prototype. [LAUGH] Gives you three letters. New, exactly. That's gonna automate a ton of all this work for us. That work of creating an object, that when it gets returned out, give it a label, get somehow a special secret bond to the shared store of functions.

[00:08:48]
We're gonna automate so much of this with the keyword new. But for now folks back to the challenges.

