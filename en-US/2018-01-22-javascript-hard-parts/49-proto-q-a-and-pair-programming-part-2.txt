[00:00:00]
>> Will Sentance: All right, let's have fun. This is solution two. And by the way, solution three and four, they are only gonna do this stuff. We're gonna see some fancy keywords you've all heard of and probably tried to use and use effectively maybe. Those fancy keywords, they're all just gonna take some of these lines that we've handwritten here and automate them for us.

[00:00:22]
That's all I'm gonna do. We have seen here the essence of how OOP is implemented in JavaScript using this special prototypal, _proto_, bond to an object above. That JavaScript knows to go and look at when it hits an object, property that ain't there on the object, directly. It knows to go check, through its prototypal feature, its prototypal nature.

[00:00:49]
All right, let's have thumbs on this. I don't know what happened, clarification question, clear to go on. Dave has one, excellent, Andrew has one, Katie has one, Art has one. Art, can we start with you?
>> Art: I was kind of wondering if you could have multiple prototypes?
>> Will Sentance: Great question.

[00:01:06]
So, you cannot have, so you could, but you're like sort of saying could I parse and use the function store and then Arts function store. No, you cannot, you can only have one direct parent. But, of course, you could then have another parent of that object, and another parent of that object.

[00:01:26]
And you can have multiple different children of different types coming from the same parent. That is known as subclassing. We're not gonna cover that today. There is a talk I have on that. Maybe one day we'll do it in Frontend Masters. It does subclassing in all of OP, it is a brutal talk.

[00:01:46]
There is no way we are going to do it right now because we are more than doing enough with pure OP here. But yes, you cannot have multiple but you can multiple hierarchy up and they can have multiple descendants out. One can only have one parent, okay? Andrew?

[00:02:02]

>> Andrew: So does it only create the prototype like that if you use the Object.create?
>> Will Sentance: That's not the only way we can make that bond. Actually, all objects have some automatic bonds. At the top of the chain, so above userFunctionStore, userFunctionStore also has I don't wanna get into this too much Andrew, but it's a little preview.

[00:02:27]
Also has a proto bond on it, which points up to, JavaScript's for this one, default object, which has a whole bunch of shared functions on it of it's own. Things like get prototype of all the functions you could ever call on an object, JavaScript dog foods its own functionality.

[00:02:45]
It uses its own built in prototype chain to let, when you do a ray.push, that push is actually stored on the array. On any array that gets created it has it's own parent, which is all the bonus functionality that we can use on arrays. So when you do an array.push, array is an array, well that guy here has it's own, because really, an array is just actually an object has its own proto bond to the array object that has all of these shared functionality that all arrays have, push, pop, all of these.

[00:03:25]
I won't go into too much but Andrews as preview there, all of these objects have a proto bond by default. What we're really doing here is inserting our own in the way. So there's a default one here, which is all objects, proto, it's just the overall object. Which has its own, on its own, a bunch of properties like, get prototype of.

[00:03:51]
All of these functions can be used on all objects, because they're all available up the prototype chain. But we're just inserting ourselves in the way here to set our own user function store in the interim, so we check there first. Does that make sense? I don't want to go into that too much if you don't mind.

[00:04:09]
I don't want to go into too much if you don't mind. But just know that every object has an underscore _proto_. It's just that we're overriding the standard one, here, with our own set of shared functions that all of our objects that were created by user creator, have access to.

[00:04:28]
Okay, Andrew? There's more clarifications, Katie?
>> Katie: I'm clarified, now.
>> Will Sentance: You are. There we go. [INAUDIBLE] from Griffin first, Griffin first.
>> Griffin: You said it's like overriding the object one? You can still get to the object one, right?
>> Will Sentance: Because we're overriding it with an object, which, who's object prototype is?

[00:04:46]

>> Griffin: The main object.
>> Will Sentance: Okay, exactly, so it's a chain all the way up. Great clarification Griffin. Dave?
>> Dave: Second line up there, the let newUser = Object.create. Sorry, how do you say that in English?
>> Will Sentance: What's the right technical communication?
>> Dave: Yeah.
>> Will Sentance: We are declaring, okay, very nice I like that question Dave.

[00:05:03]
Very thoughtful question. We are declaring an object, we are declaring newUser and assigning to it an empty object with the prototype of it being userFunctionStore. Now again, I hate this with the prototype of it, I wish we said with the _proto_ of it being but _proto_ is the label we give to the prototype.

[00:05:32]
We call whatever's here, the prototype of this object but it's not stored in a property called the prototype, it's stored in a property called _proto_. It is what it is but it causes a humongous amount of confusion. And we're gonna see why in a moment because there is a property called prototype and it ain't this one and it ain't behaving the way this one is behaving.

[00:05:53]
That is why I don't like the fact we call this guy the prototype of this object because it's stored _ proto_, it's the _proto_. I would say it's the object that's one step part of the prototype chain. Not exactly a catchy phrase. If you wanna say that, you can say declare newUser, assign two at an empty object with userFunctionStore set as the one object that's one step up the prototype chain.

[00:06:15]
If you wanna be super intuitive. But the typical ways, we'd userFunctionStore as newUsers prototype. Okay, ask the question, Dave.
>> Dave: Yeah.
>> Will Sentance: Do you want to try again?
>> Dave: Just the distinction between prototype and inherit from a-
>> Will Sentance: In JavaScript, by the way, I actually wrote a little note to myself when I was first started giving the talk, I hate the word inherit describing what we're doing here.

[00:06:42]
Does inherit make it feel like you've actually copied down the functionality onto the object? It does to me, a bit. This here, increment, sorry, user 1, inherits the userFunctionStore. When we say inherit in JavaScript, that is all we mean. Now are we copying those functions down to user 1?

[00:07:02]
No, inherit is a weird ass word to use for this process. What actually is when we run user 1, with a function reference on it that isn't in user 1, we check it's _proto_ where we find this other object userFunctionStore. And we look up to it and go, there's an increment function there.

[00:07:23]
Now does that mean in a sense that user 1 inherits increment function? Eh, I guess it feels like it does but that is not being copied down, it's not. It's JavaScript at the run time is to look up at that stuff and find it there. But when you hear people saying user 1 inherited increment, that's exactly what it's saying.

[00:07:43]
Great question, man. Really glad ou brought up that word. Okay, at this point do we do pairing now, or do we push on? We're still quite early, so I think we do another block of pairing, and then we're gonna come back to this after another block of 20 minutes of pairings.

[00:07:59]
We're gonna finish out for, I reckon today, 4:00 to 4:15. So we're gonna do another blocker pairing, just to cement some of this stuff. And in a moment after that we're gonna come back and say you know what? All this writing, Object.create, newUser, return newUser, we're gonna automate it all the way with the insertion of a magic keyword.

[00:08:23]
What's that magic keyword, do we think?
>> Art: Prototype.
>> Will Sentance: Three letters. New, exactly. That's gonna automate a ton of all this work for us. That work of creating an object that when it gets returned out, give it a label, get somehow a special secret bond to this shared store of functions.

[00:08:48]
We're going to automate so much of this with the keyword New. But for now folks back to challenges.

