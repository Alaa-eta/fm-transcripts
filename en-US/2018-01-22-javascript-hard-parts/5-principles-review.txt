[00:00:00]
>> Will Sentance: Unfortunately my slides are less. Man, that thing there that says functional programming, that's meant to be a grand, bold statement on a new slide but instead it's a little thing on the bottom. So let's imagine we're just looking at this functional programming. Here we go, we now have call platform of JavaScript from which to learn from.

[00:00:23]
We have our call platform, there it is. Our memory, where stuff gets stored, our thread, where stuff gets run line by line. When we start running a function. Remind me again, Shelby, how do I start running a function? How do I start calling a function?
>> Shelby: With parentheses.

[00:00:43]

>> Will Sentance: Parentheses, there it is. What does calling a function create? Everyone together, it creates a brand new [CROSSTALK]. It creates a brand new execution context. Believe me, this is everything. JavaScript is so powerful like this, whenever I start calling a function, I get to create a new execution context.

[00:01:03]
So how do I call a function, Lindsay?
>> Lindsey: With parentheses.
>> Will Sentance: Parentheses, and when I call a function I create a new-
>> audience: Execution context.
>> Will Sentance: Exactly, smart room, a new execution context. Where, we just have exactly what we do when we always run code. We have our memory and thread but now we do it inside the function.

[00:01:22]
Where we start doing the code line by line inside the function and our memory inside the function. But we're doing now multiple execution context, all at the same time, but they're all around. So how do we keep track of them? Because we're only ever reading one at a time.

[00:01:35]
So you got to know which one to go back to, etc. How do we keep track of them? Don't panic, JavaScript has the call stack to track which function call we're in, which execution context we're in. Okay, those are our three fundamental principles. All of JavaScript, there's little bonus features like the prototypical nature that are coming out tomorrow.

[00:01:56]
There are little bonus features of JavaScript, but otherwise all of JavaScript can be captured by these three underlying principles. Now, we're gonna come tomorrow also to asynchronous JavaScript. That introduces a couple of bonus very significant pieces that cannot be explained by this world view. Tomorrow we're gonna see some code and try and evaluate it from this world view, this paradigm, and we're gonna go up.

[00:02:26]
No, no this doesn't capture what I'm trying to do here. There must be something else going on. We'll see that tomorrow morning. But, for synchronous JavaScript, this is it. What's up, Mark?
>> Mark: Online they were asking about, so you were saying JavaScript goes line by line, but there must be some other process to create the context and stuff ahead of time.

[00:02:50]
So they're asking if there's a compilation phase, or does JavaScript just [CROSSTALK]
>> Will Sentance: So maybe we mention before people came on, but we talked about there being an interpretation style. JavaScript nowadays actually uses what's called just-in-time compilation. The V8 engine from Chrome uses just-in-time compilation, which does all sorts of very small optimizations around which bit of this gets assigned to memory first.

[00:03:15]
But for our process, again this comes back to that question. Going deep, going under the hood of the language, is not for theoretical purposes. It's not for our intellectual curiosity. We do it because it makes debugging, writing clean code, and communicating what we're really doing much, much more possible.

[00:03:38]
But that also means we have to hit a level where we go, hold on, do I need to understand how this is turned into bytecode? Well, no I don't, because it doesn't have any implications for how I write my code. It doesn't help me write cleaner or more efficient code.

[00:03:52]
So the question from the online audience about how does the compilation step work here? How does the just-in-time compilation actually work? We don't need to worry about here, these are our three already quite under the hood aspects of the JavaScript run time. These are the three we need to know to effectively write, debug and communicate our code.

