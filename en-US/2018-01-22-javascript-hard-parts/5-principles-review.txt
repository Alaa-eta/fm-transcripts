[00:00:00]
>> Will Sentance: Unfortunately my slides are less, man, that thing there that says functional programming, that's meant to be like a grand, bold statement on a new slide. But instead it's like a little thing on the bottom. So let's imagine we're just looking at this, functional programming. Here we go, we now have core platform of JavaSript from which to learn from.

[00:00:23]
We have our core platform, there it is. Our memory where stuff gets stored, our thread where stuff gets run line-by-line. When we start running a function, remind me again, Shelby, how do I start running a function?
>> Will Sentance: How do I start calling a function?
>> off screen female: With parenthesis?
>> Will Sentance: Parenthesis, there it is.

[00:00:45]
What does calling a function create? Everyone together, it creates a brand new?
>> [INAUDIBLE]
>> Will Sentance: It creates a brand new execution context. This is, believe me, this is everything, JavaScript is so powerful like this. Whenever I start calling a function, I get to create a new execution context.

[00:01:03]
So how do I call a function, Lindsay?
>> off screen female: With parentheses.
>> Will Sentance: Parentheses, and when I call a function, I create a new?
>> Execution context.
>> Will Sentance: Exactly, smart room, a new execution context where we just have exactly what we do when we always run code. We have our memory and thread, but now we do it inside the function.

[00:01:22]
When we start doing the code line-by-line inside the function, and our memory inside the function. But we're doing now, multiple execution contexts, not at the same time, but they're all around. So how do we keep track of them? Cuz we're only ever in one at a time. So we've gotta know which one to go back to, etc.

[00:01:37]
How do we keep track of them? Don't panic, JavaScript has the call stack to track which function call we're in, which execution context we're in. Okay, those are our three fundamental principles. There's little bonus features like the prototypal nature, we'll cover that tomorrow. There are little bonus features of JavaScript.

[00:01:58]
But otherwise, all of JavaScript can be captured by these three underlying principles. Now, we're gonna come tomorrow also to asynchronous JavaScript. That introduces a couple of bonus, very significant pieces that cannot be explained by this worldview. Tomorrow we're gonna see some code and try and evaluate it from this worldview, this paradigm.

[00:02:23]
And we're gonna go, no, no this doesn't capture what I'm trying to do here, there must be something else going on. We'll see that tomorrow morning, but for synchronous JavaScript this is it. What's that, Mark? Online they're asking about, so you're saying JavaScript goes line-by-line but there must be some other process to create the context and stuff ahead of time.

[00:02:50]

>> off screen male: So they're asking if there's a compilation phase, or does JavaScript just go line-by-line?
>> Will Sentance: So we mentioned, we only mentioned it before people came on. But we talked about there being an interpretation style. JavaScript nowadays actually uses what's called just-in-time compilation, the V8 engine from Chrome uses just-in-time compilation.

[00:03:09]
Which does all sorts of very smart optimizations around which bits of this gets assigned to memory first. But for our purposes, again, this comes back to that question. Going deep, going under the hood of the language is not for theoretical purposes, it's not for our intellectual curiosity. We do it because it makes debugging, writing clean code, and communicating what we're really doing much, much more possible.

[00:03:38]
But that also means we have to hit a level where we go hold on, do I need to understand how this is turned into byte code? Well, no I don't, because it doesn't have any implications for how I write my code. It doesn't help me write cleaner or more efficient code.

[00:03:52]
So the question from the online audience about how does the compliation step work here? How does the just-in-time compilation actually work? We don't need to worry about it here. These are our three already quite under-the-hood aspects of the JavaScript runtime. These are the three we need to know to effectively write, debug, and communicate our code.

