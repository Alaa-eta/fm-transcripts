[00:00:00]
>> Will Sentance: In the challenges we started to encounter, this magic keyword new. So we can remind ourselves that we wanted a function that when called, when run, would return out little baby objects, user one. Call the first one, user 1, next one user 2, user 5,000, user whatever. But we wanna have available on each of those objects our functionality.

[00:00:24]
Have I mentioned this yet? I know I've mentioned this many times. This is our fundamental goal. Can I call this function on the object? Is it available right there on the object? That's all I want! But I don't wanna have multiple copies of this function on user 1, and user 2, user 5,000.

[00:00:39]
So along comes this special shared store of the functions that I could ever want on user one, user. It wouldn't just be increment login. It would be increment login, logout, change avatar, display avatar, etc, etc. All those functions on user functions store would be available when I call user one dot that function.

[00:01:01]
Cuz when I don't find that function on user one, my prototypal nature of JavaScript means I check the _proto_, where I find a bond through the prototype chain to the next object up, user function store. Okay, but I'm sure you agree Muhammad, quite a lot of space here of our typing is being taken up by creating that new user object in here, and creating that bond to that shared function store, and returning the other object.

[00:01:34]
Who comes from a true OOP language? Do you do all that stuff by hand there? I know you do not. And JavaScript increasingly wants us to feel liberated from all of this manual work of making our prototype bonds.
>> Will Sentance: Muhammad.
>> Will Sentance: All these prototype bonds? I hate putting you away from the pairing.

[00:01:57]
I'm sorry, I feel very bad. The pairing is where the real value's at, it really is. But right now, we're gonna see our solution three in a moment. Man, let's see our review of this approach. Problems? No problems, this is a beautiful approach. I love this approach, maybe a little long winded.

[00:02:14]
We declared a new variable with an object associated with a bond to function store. We've returned out that object. Six words, that's not bad. But I will say this, this is super sophisticated, but it is non-standard. This is a non-standard way of creating our objects with shared functionality.

[00:02:36]
It's a non-standard way, we have a standardized way. The downside of this approach, yes six words, but also once you start creating objects in which you have your data and functionality, you start doing this for everything. You're creating a quiz game, you generate a quiz board as an object with functionality attached to it.

[00:02:56]
It's a single instance of the quiz board. You're not going to create more of them. You just start thinking OOP for everything. And therefore, if you are manually doing this shit inside each time, yeah, maybe there is a better way. Another language is you're not doing this if you are trying to achieve OOP.

[00:03:09]
But, I'll say it this way, sophisticated. We get to see every precise bit. We get to manually set our bond to the, hey, we now know what's actually going on. But a lot of this stuff gets automated. It's still happening under the hood. But it's getting typed in for us, essentially, by JavaScript when we use this magic keyword new.

[00:03:33]
It's not magic, there's not a lot of magic there, this keyword new. When we run this userCreator function with the new keyword in front of it, it behaves in a totally under the hood similar way to this. Not identical, but similar, but it's gonna automate so much of the hard work we did here declaring the and so forth.

[00:03:56]
Let's see, when we call the constructor function, this guy here is known as our constructor function, with new in front, we automate two things. We automatically create the new user object. We automatically return out that user object when complete and store in user1, for example. We have to rethink how we write this code then.

[00:04:19]
Cuz right now, I declare an object called new user. It's an empty object. And then to fill in the property's name, how do I refer to that object, Katie? What label do I use to refer to the object, to fill in the name property?
>> Katie: New user.
>> Will Sentance: New user, if I'm automatically creating that out of this line, JavaScript is going to automate this line for us.

[00:04:42]
What's the label for my object? That label's gone, and that's automatically done for me. The object is created for me by Java. Everything in red is stuff that the new keyword. When I run the userCreator function instead of but instead with the new keyword in front of it, I get an object automatically created and that object gets automatically, again everything in red is automatically done for us, gets returned out.

[00:05:08]
But how do I fill in properly something that's been auto created? Anyone got an idea of how JavaScript might allow me to point to, refer to that object? Anyone, what might be a useful placeholder keyword, or word, that we could use to point to that object? Katie, what do you think might be a useful word?

[00:05:27]
Griffin?
>> Griffin: This?
>> Will Sentance: It's this. It's a different use of the word, this, totally different use. But it's still refer, JavaScript, when we use new, create an empty object by default, and gives it the label of this. So behind the scenes, we're sort of going, not new user, but behind the scenes, we're sort of going, this is equal to object.create, empty object.

[00:05:51]
But it's automatic, we're gonna see which bits get cut in a second. We're not writing this, JavaScript inserts this for us. Because we use the new keyword in front of user creator. So who can now see another problem? We now know how we can refer to our object.

[00:06:04]
But who can see another problem that this automation, by automating this line, by automatically creating another object, what's another problem here that someone can see? Andrea, can you see? With our existing structure. Yeah, your eyes moved in the way of.
>> Andrea: [LAUGH] I don't know, sorry.
>> Will Sentance: What do you think, Shelby?

[00:06:24]

>> Shelby: Is there still a bond?
>> Will Sentance: How do we get that bond? Cuz before, we manually made that bond, didn't we? We said user object.create(userfunctionstore). Now, we don't get a chance to make that bond. That's going to be automatically done for us. The bond here is also gonna be automated.

[00:06:43]
But if it's automated, what's it gonna refer to?
>> Speaker 6: This.
>> Will Sentance: Yeah, cuz this is this object here. We want something up here that's gonna be a shared function store.
>> Will Sentance: Something like, where do we end up actually storing our shared functions? Well, Java needs a default place.

[00:07:08]
It needs a default place, and it chooses the default place for the user creator function. If the other functions like quiz question creator, or game board creator, anything that's going to return on an object with all the data functionality associated. You need a default place. Before I tell you what a default place is, you need to know something.

[00:07:27]
Many of you already know, we've said it many times, functions in JavaScript are really just what? Anyone remember?
>> Speaker 7: Objects.
>> Will Sentance: Objects, okay, so if that's the case, userCreator is a function. Yeah, no problem, it's a function. There it is, it's a function. So if I treat userCreator as a function, and put parens on the end, it runs its functionality, hurray.

[00:07:57]
But what is userCreator also, Andrew?
>> Andrew: An object.
>> Will Sentance: An object, it's also an object. So if I treat userCreator as an object, it behaves as an object. If I try and store on userCreator, usercreator.andrew = 3, that has no consequences on my function. The next line I can still go userCreator ().

[00:08:30]
If I treat it like an object, it does its object stuff. If I treat it like a function, it does its function stuff. Who feels that it's a bit weird? Raise your hand if you think that's a bit weird. Feels a bit like, that's odd to me. Okay, good, I mean, at least we're being honest.

[00:08:48]
It is a bit weird. So if I did this line here, what would I have in userCreator as in its object version, Andrew?
>> Andrew: Andrew.
>> Will Sentance: Andrew, that's the property and the value would be?
>> Andrew: 3.
>> Will Sentance: 3, yeah, now, there's one way I've heard I think it's quite a smart way of thinking about it.

[00:09:09]
In reality, userCreator, it's a function, but it really is like an object first. It's an object first with a special property on it called call, which is the running of the functionality. This not necessarily respective of how we actually have it. But think of JavaScript functions as really just an object.

[00:09:30]
And when we do userCreator (), what we're really doing is say, go run user creator and its call property, which is the functionality. I know that sounds weird, but that's really what we're doing. Think of it as being the functionality is sort of there under a call property, a run me property.

[00:09:49]
Otherwise, it's just. So if you're thinking wow, how can it be both things at the same time? Well, really it's just an object with some functionality that can be run. Even though we think of it as a function first, it's really an object first. But we, obviously, use its functionality far more.

[00:10:04]
But it really is an object first with functionality attached. But we always, when we do (), we speak to its functionality bit. Okay, let's have thumbs on that, because it really is important for us to understand. This is our final piece of knowledge we need to understand for us to be able to use the new keyword effectively.

[00:10:23]
Let's have thumbs.

