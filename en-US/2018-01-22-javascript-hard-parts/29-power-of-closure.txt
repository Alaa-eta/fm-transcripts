[00:00:00]
>> Will Sentance: We have achieved something really remarkable here. We have given our function definitions, ain't just function definitions anymore. They're function definitions plus live data stores attached to the back of them, little mini caches. Persistent state, little state stores that were created. My quinoa salad. Created by the fact that these functions were themselves defined inside another function being called and they, therefore, got this little bond to their surrounding live memory.

[00:00:31]
And that bond did not go away when that inner function got returned out and stored in its new label. It's very, very profound. So what else is there to do? Well, if we go back to the very beginning we said, what does it say? We said, what if our functions could hold on to live data/state between their executions?

[00:00:53]
Well, what do you know? They can. This will let our function definitions have an associated persistent memory. This would let us do things like well, create these highly professional functions like once memorize. Basically, any function that needs the memory of the past time it was run. So one of them would be called once.

[00:01:15]
So the onceified version of multiplied by two would say, the first time you run me, I'm a multiply two function that's got a memory of the last time I run. The first time you run me with input of 3, multiply by 2, return 6. Okay, fine, good. But don't just return six, also have a little counter in my backpack.

[00:01:38]
The function in such a way that when you run me, also increment my backpack counter to one. Next time you run me with I don't know, anything, 10, 11, whatever. We'll go with ten, check my backpack first. Counter says, one, return out. Sorry, I can only be run once.

[00:01:55]
I've clearly been run before. My function gets a memory. This means you can do stuff like build a tic-tac-toe game, click the cell. You only wanna click it once and you can't ever click it again, because the function is being called already once. Various situations like this. This turns out to be very useful in professional engineering to oncefied to make a function only be allowed to be run once.

[00:02:21]
That's one of your challenges, by the way, very demanding challenge. What about memoize? Memoize says, well, hold on. Suppose, I build as we said nth prime. To find the thousandth prime number, you gotta find all the prime numbers up to that as well. It's a complicated, demanding task.

[00:02:38]
It takes lots of steps. Maybe two, three, four seconds. If you pass 1,000 to nth prime, you don't wanna have to if you end up having to pass 1,000 again to it have to go and recalculate 1,000 when you already ran 1,000 in it a few seconds ago.

[00:02:54]
So you memoize the function such that when you call it the first time with 1,000, you do all the hard work to find the 1,000th prime number. Do all the sieve thing. Anyone come from math? I do the sieve thing, whatever it is. I don't know how you do it, but you find the thousandth prime number.

[00:03:12]
And then yes, you turn it out. Great, the function worked. But also have an object in the backpack. Let's call it store and it's an object. And in there, you make a key a 1,000 and you make a value the associated 1,000th prime number from the time you just ran it then.

[00:03:32]
Next time you run ninth prime with the input of 1,000, you don't do all the hard work first. You go look in the backpack. You look in the store. We already rounded to the thousand. We could just part in one step out the 1,000th prime number. All bundled up in our persistent cache on the back of our function nth prime.

[00:03:52]
It's very profound. Very powerful, our functions get to have their own memories. Now, we can hold onto D3 global memory. We could say like have counter at zero, but the problem with that, couple of things. One, we want often independent live stores associated with each other function. Can you imagine how good that is for modularizing our code?

[00:04:13]
There we go and another thing is when we write code at scale and this is where close is particularly powerful. We do not want to what's called pollute our global memory. You've got a 100 engineers working on the same team. 10,000 lines of code and you've got a variable saying, counter.

[00:04:35]
This is not realistic. Someone else wants to call their variable counter. You've got one saying result. I promise you, someone else on the team wants to call their variable result, but you've got to hold on to data. Suppose, you've got a game. You want player one's score not to be gone.

[00:04:52]
You need to have player 1 equals 20, but it gets super complicated. You don't necessarily want to taint the global namespace. You wanna put that counter to four here. So what do you do? Well, one option is use what's called a module pattern. And the module pattern in JavaScript says, if I saw my data inside my function, but every time that function finished running, the data's gone.

[00:05:19]
But I wanna to hold onto data, sort in global. But that's dangerous, cuz it can get overwritten really easily. It's really hard to maintain. What if I wrote these functions in such a way, the way Katie said that they were really easy to write to by passing something in, but then sent off into the backpack and easy to get the data out of.

[00:05:40]
What if I store the data I want to persist in the backpacks on my functions? Therefore, for the life of my application, I have that data around, but it's persisting in a very protected area. So I just write this function in a really clean way and the module pattern lets do that such that my data sticks around, but I'm not polluting.

[00:06:05]
Tainting the global memory itself and this is called the module pattern, and that's advanced stuff.
>> Will Sentance: Quinoa salads are not. That's advanced stuff. It lies even in Codesmith. I think it's week seven of Codesmith. It's very demanding stuff, the module pattern. But it's also super, seasoned developer, professional type of code writing and that relies fundamentally on using our persistent lexical scope reference.

[00:06:37]
Our closed over variable environment, all the same thing. Our closure, our backpack. Did I say, closed over variable environment? Closed over, I said that one already. What other one? Closer variable environment, persistence reference, closure, backpack. There you go, all those things. They all mean the same thing. There we go, folk.

[00:07:00]
That's it. At this point, we have covered the end of day one thread execution context call stack which gave us the foundations to tackle quite a lot harder stuff. You're sitting there thinking yeah, I got multiply by 2 does. But all those pieces gave us the pieces to handle higher order functions and then the most esoteric of JavaScript concepts, closure.

[00:07:23]
At this point, we wait until tomorrow to continue. Tomorrow, we will handle asynchronous JavaScript and object-oriented JavaScript.

