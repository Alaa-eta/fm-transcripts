[00:00:00]
>> Will Sentance: Now we introduce executing or running or invoking or calling a function. So what happens when we do this? This is not the same as defining a function, but how do we tell JavaScript to define a function? Keyword function. How do I tell JavaScript to call a function?

[00:00:23]
Art, how do I tell JavaScript to call a function?
>> Will Sentance: All I have to do is add parentheses, that's it. I take the name of the function and add parentheses. No input, adding parentheses is enough. It just says go run the code of that function. It may not have an actually there for an argument pass a actual value, but it's still running the function.

[00:00:42]
So let's keep going line 1, num is 3, line 2, multiply by 2 as a function. We may be thinking man, yeah, I know how this working. I can look at this right away and figure it out. Getting this level of precision down now is what makes closure, higher order functions all flow much more naturally.

[00:01:04]
So, what's our next line of code after declaring multiply by 2, Clara?
>> off screen female: After declaring the function then you're declaring your outputs, constants.
>> Will Sentance: Okay, there it is. And what are we going to assign to it, Clara?
>> off screen female: So, eventually it would be the return value in the function.

[00:01:25]

>> Will Sentance: Correct. Eventually will be the return value of calling the multiply by two function with the input of four, but we haven't done that yet, we've gotta go do that work. But JavaScript likes to have everything have a value, even when it's in the waiting game. So what's this default waiting value.

[00:01:41]

>> off screen female: Undefined?
>> Will Sentance: Undefined, I'll draw this as a little dotted line, we just don't know what it's going to be there yet. So just to be really clear, what's definitely not there, is multiply by two. Output has no interest in multiply by two. It only gets interested in multiply by 2 in the sense of its run multiply by 2 in the values come back as a return value.

[00:02:02]
The result, whatever is in the return, or whatever is after the return keyword, inside the function. That is what's gonna be stored in output. So, we gotta go do some work. So let's do that work. We've gotta see what happens when I run, multiplied by 2. And assign the result of calling it with the input of 4, assign the result to output.

[00:02:30]
So, who knows what we do? When we start running our code we create a global execution context. What about when we start running a function? What do we create, Lindsay? Can we start running a function?
>> off screen female: A local execution.
>> Will Sentance: Everyone together, we create a local.
>> [INAUDIBLE]

[00:02:51]

>> Will Sentance: Excellent. Perfect. Good job Lindsay and team. There we are. What's in it? Let's have a look. Here's our look at execution context. And it has just like our global one, had a global memory and a global thread, in which we are doing all this work. Right? We're doing the work line by line.

[00:03:14]
Now we got a local one, in which the local memory and a local thread. And the local thread just means, doing the code inside the function now line-by-line. Before we were doing the code globally, now we're going the code inside the function line-by-line. And we've paused doing the code globally.

[00:03:29]
We're not hitting the line new output, we just paused before this line here. We're waiting to go back to this output, this global execution context. While we're busy inside running this local execution context when multiplied by two with input of four. So Andrea, what's the first thing we do inside of multiply by two with the input of four.

[00:03:53]

>> off screen female: So then we pass-
>> Will Sentance: Andrea, you're gonna say a phenominal answer I can already tell so I turn the volume up very high.
>> off screen female: [LAUGH] So we-
>> Will Sentance: Andrea, that was the same volume.
>> off screen female: [LAUGH] You're getting close there. We take four and we put it in input number and then we times it by two.

[00:04:13]

>> Will Sentance: Andrea, yes, very good. Well yes, we take four and put in an input number. What's the posh way of saying we take four and put in an input number? Andrew, you wanna give it a shot?
>> off screen male: We assign it to the.
>> Will Sentance: What's the partial word for the input, the case order?

[00:04:29]

>> off screen male: Parameter?
>> Will Sentance: Parameter, exactly. So we take the parameter, input number, assign it an argument value which is 4. Hooray, okay, next line, Andrew.
>> off screen male: Would be the constant result.
>> Will Sentance: Good, there it is, also stored in our local memory. And what do we assign to it?
>> off screen male: 4 x 2?

[00:04:50]

>> Will Sentance: Yeah, and the posh word, by the way, for saying that, is the evaluated result. Evaluate means they did the work, did the calculation. The evaluated result of input number, which is you look at our memory, 4 by 2 which gives us 8. Excellent. Good? And now what do we do with that result Andrew?

[00:05:15]

>> off screen male: Return it [INAUDIBLE]
>> Will Sentance: So we already said whatever gets returned out of calling this multiply by 2 function will be stored in this output variable. Look what it turned out but the variable 8. And we're gonna store that 8 in output. There it is. All right, perfect.

[00:05:43]

>> Will Sentance: Beautiful. Very very nice. Andrew, go ahead.
>> off screen male: Were you saying that the output when it's officially or when it's first put out there's defined as undefined until it's read that's changed to eight?
>> Will Sentance: Correct. Until it gets its return value of eight assigned to it. All right.

[00:06:00]
I told you to more product to has the return value of eight assigned to it. Okay so, now, what's happened to this execution context, Griffin? We've finished calling multiply by 2, what do you think happens to this execution context, Griffin?
>> off screen male: It gets erased.
>> Will Sentance: Get erased. Gets removed.

[00:06:21]
Except for the returned value out, which gets stored in output. I'm gonna mark. I've never figured out a way of indicating that it gets erased but I'm gonna do this. I'm gonna write done like that. That execution context is done. It's not a great, I grant you. I'll come up with a better way of doing it but there we go.

[00:06:41]
So now which execution context do we go back to, Griffin?
>> off screen male: To the global.
>> Will Sentance: Global. Now, JavaScript doesn't know that by default. It needs to keep track of that fact somehow. We're gonna see that bonus thing that it uses to keep track of which execution context it's in and which one to go to next in a moment.

[00:07:03]
Raise your hand if you think you know what that's called, the place that keeps track of that. Okay we'll come to it in a second, so now we're back to global and what's the next line in global execution context. Tell us what to do
>> off screen female: New output is the new variable

[00:07:21]

>> Will Sentance: New output and what are we assigning it?
>> off screen female: We're gonna pass the parameter of ten into input?
>> Will Sentance: Yeah, because we don't yet know, do we, what we're gonna assign it. For now, it's undefined because we've gotta go cool multiply by two, figure out what comes out the bottom and that's what's gonna be stored in new output.

[00:07:45]
So Clara, pulled me through as in complete form as you can, Clara, this final line about global execution context. New output is the return value, of multiplied by 2, when called with 10. Pull me through this completely if you can Clara.
>> off screen female: All right, so once you've started your new local execution context.

[00:08:10]

>> Will Sentance: So creating a new execution context, that's the first thing. Got it, doing that now, excellent. What is it comprised? What sort of an execution context is comprised?
>> off screen female: Save your local memory?
>> Will Sentance: Local memory, which has a posh name. We'll say what it is in a second.

[00:08:24]
But local memory and the thread jumps inside to run the code inside the function. Clara go ahead.
>> off screen female: So your parameter, input number, so the value ten. And then, setting up your constant results.
>> Will Sentance: Yep. And decide what?
>> off screen female: Some maths.
>> Will Sentance: Yeah, good, exactly. You get 20.

[00:08:45]
And what's the final line in the body of the function tell us to do?
>> off screen female: Returning results.
>> Will Sentance: Returning result. And I realize already we're reaching the extremities of the board. There we go. So the result value is gonna be returned. And where did we say that result value's gonna be stored?

[00:09:05]

>> off screen female: That's gonna go to your new outputs.
>> Will Sentance: There it is.
>> off screen female: In the global context.
>> Will Sentance: In the global execution context memory, and so out returns 20. And we store 20 in new output. And we return, what happens to this execution context Clara?
>> off screen female: Goes away.
>> Will Sentance: Goes away.

