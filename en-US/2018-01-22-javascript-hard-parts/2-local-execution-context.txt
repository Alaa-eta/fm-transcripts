[00:00:00]
>> Now we introduce executing or running or invoking or calling a function. So what happens when we do this. This is not the same as defining a function. But how do we tell JavaScript to define a function? Keyword function. How do I tell JavaScript to call a function?

[00:00:21]
Art, how do I tell JavaScript to call a function?
>> By?
>> All I had to do is add parentheses, that's it. I take the name of the function and add parentheses. Not input. Adding parentheses is enough. It just says go run the code at that function. It may not have actually therefore an argument parsed with an actual value but it's still running the function.

[00:00:41]
So, let's keep going. Line 1 num is 3. Line 2 [INAUDIBLE]. We may be thinking man, yeah I know how this is working. I can look at this right away and figure it out. Getting this level of precision down now is what makes closure. Higher order functions OOP, all flow much more naturally.

[00:01:03]
So, what's our next line of code after declaring multiply by 2, Clara.
>> After declaring the function then you're declaring your outputs constants.
>> Perfect. There it is. And what are we going to assign to it Clara? So eventually it would be the return value
>> Correct.
>> of the function.

[00:01:25]

>> Eventually it would be the return value of cooling the multiplied by 2 function with the input of 4 but we haven't done that yet. We've gotta go do that work but JavaScript likes to have everything have a value even when it's in the waiting so what's its Default waiting value.

[00:01:41]

>> Undefined.
>> Undefined, I will draw it as a dotted line, we just don't know what is going to be there yet. So let's be really clear. What is definitely not there, is multiply by two. Output has no interest in "multiply by two". It only gets interested in multiply by two in the sense of, its run multiply by two and the values come back in the return value.

[00:02:01]
The result. Whatever's after the return keyword inside the function, that is what's gonna be stored in output. So you've gotta go do some work. So let's do that work! We've gotta see what happens when I run, multiply it by two, and assign the result of calling it with the input of four.

[00:02:25]
Assign the result to output. So who knows what we do? When we start out of code we create a global execution context. What about when we start running a function? What do we create? Lindsay. and we start running our function?
>> A local.
>> Local what?
>> Execution.

[00:02:46]

>> Everyone together. We create a local.
>> Execution context.
>> Excellent, perfect good job Lindsey and team. There we are. What's in it? Lets have a look. Here's our local execution context. And it has, just like our global one had a global memory and a global thread in which we're doing all this work, right.

[00:03:10]
We're doing the work line by line, now we've got a local one in which has got a local memory and a local thread. And a local thread just means Doing the code inside the function now line by line. Before we were doing the code globally, now we're doing the code inside the function line by line.

[00:03:28]
And we've paused doing the code globally. We're not hitting the line. We're not hitting the line newOutput. We just pause before this line here. We're waiting to go back to this global execution context while we're busy inside running this Local execution context multiplied by two with an input of four.

[00:03:46]
So, Andrea. What's the first thing we do inside a multiplier by two with an input of four?
>> So then, so we pass.
>> Andrea, you are going to say a normal answer, I can already tell. So I'm going to turn the volume up very high. We assign it to the.

[00:04:23]

>> What's the posh word for the input, the place order?
>> Parameter.
>> Parameter, exactly. So we take the parameter, input, number, assign it argument value which is four. Hurray! Okay next line, Andrew? The constant result.
>> Good. There it is. Also stored in our local memory. And what do we assign to it?

[00:04:50]

>> 4x2.
>> Yeah. And the proper way of saying that is the evaluated result. Evaluated means they did the work, did the calculation. The evaluated result of input number which is You look at our memory, 4 by 2, which gives us 8. Excellent, good, and now what do we do with that?

[00:05:11]
What do we do with that result, Andrew?
>> Return it. [CROSSTALK]
>> Exactly, so we already said, whatever gets returned out of calling this multiplyBy2 function will be stored In this output variable. Well look what got returned out, but the value eight. And we're gonna store that eight in output.

[00:05:39]
There it is, all right perfect. Beautiful. Very very nice. Andrew go ahead.
>> Were you saying that the output, when it's first put out there it's defined as undefined until it's read it's change date?
>> Correct, until it gets it's return value of eight assigned to it. All right so we've got [INAUDIBLE] multiplied by two return value of eight assigned to it.

[00:06:05]
Okay So now what's happened to this execution context, Griffin? We finished cooling multiply by 2, what do you think happens to the execution context?
>> It gets erased.
>> It gets erased, gets removed except for the returned value out which gets. Stored in output. I'm gonna, I've never figured out a way of indicating that it gets erased.

[00:06:29]
But I'm gonna do this, I'm gonna write done, like that. That execution context is done. It's not great, I grant you, I will come up with a better way of doing it but, there you go. So now, which execution context do we go back to, Griffin?
>> The global context.

[00:06:46]

>> Global. Now, JavaScript doesn't know that by default. It needs to keep track of that fact, somehow. We're gonna see that bonus thing that uses to keep track of which execution context it's in. And which one to go to next in a moment. Raise your hand if you think you know what that's called, the place that keeps track of that Okay, we'll come to it in a second.

[00:07:09]
So now we're back in global. And what's the next line, Shelby, in the global execution context? Tell us
>> New output is a new variable.
>> You have this new variable, the new new output. And what are we assigning it? We're gonna pass the parameter of 10 into input.

[00:07:28]

>> Yeah, because we don't yet know, do we, what we're going to assign it. For now, it's undefigned because we've gotta go call multiply by two, figure out what comes out the bottom, and that's what's gonna be stored in new output. So Clara, talk me through as in a complete form as you can Clara.

[00:07:50]
This final line in our global execution context. New output is the return value if multiplied by two when code with ten. Talk me through tis as completely as you can Clara.
>> Alright so once you started your new local. Execution context?
>> So create a new execution context, that's the first thing, got it doing that now.

[00:08:14]
Excellent, it's got a what is it comprised? What sort of execution context comprised?
>> Local memory.
>> Local memory, which has a posh name. We'll say what it is in a second. But local memory and the thread jumps inside. To run the code inside the function. Cara go ahead.

[00:08:31]

>> So your parameter input number, store the value 10. And then setting up your constant results.
>> Assigning it what.
>> Some maths. Yeah, good, exactly. Get 20. And what's the final at the function telling us to do?
>> Returning result.
>> Returning result, and I realize already we're reaching the extremities of the board.

[00:08:57]
There we go. So the result value is gonna be returned, and where did we say that result value is gonna be stored? That's gonna go to your new outputs.
>> There it is.
>> In the global context.
>> In the global execution context memory and to out returned 20 and we stored 20 in new output and we returned.

[00:09:14]
What happens to this execution context Clara?
>> Goes away.
>> Goes away.

