WEBVTT

1
00:00:00.115 --> 00:00:00.924
&gt;&gt; Will: One more thing.

2
00:00:00.924 --> 00:00:03.632
Let's remind ourselves we keep track

3
00:00:03.632 --> 00:00:08.124
of the functions being called
in JavaScript with a call stack.

4
00:00:08.124 --> 00:00:11.279
It tracks which execution
context we are in.

5
00:00:11.279 --> 00:00:15.163
That is,
what function is currently being run and

6
00:00:15.163 --> 00:00:19.797
when we finish running that
function where do we return to?

7
00:00:19.797 --> 00:00:20.459
The next thing down the stack.

8
00:00:21.820 --> 00:00:24.120
We start with one global
execution context,

9
00:00:24.120 --> 00:00:29.530
and then we can have many function
level execution contexts above.

10
00:00:29.530 --> 00:00:33.390
All right, so at this point,
we are gonna use a tried and

11
00:00:33.390 --> 00:00:38.410
tested teaching pedagogical
method known as thumbs.

12
00:00:38.410 --> 00:00:40.350
I've no idea what has happened here.

13
00:00:40.350 --> 00:00:44.050
I need to go back to,
what's that place called?

14
00:00:45.310 --> 00:00:46.050
What's it called?

15
00:00:46.050 --> 00:00:47.240
Point something academy.

16
00:00:47.240 --> 00:00:48.520
I need to go back.

17
00:00:48.520 --> 00:00:50.860
I have some clarifications.

18
00:00:50.860 --> 00:00:53.300
I can see where we're going,
but I've got some questions.

19
00:00:53.300 --> 00:00:54.940
I can phrase this as a question.

20
00:00:54.940 --> 00:00:59.470
Unclear on these
fundamental pivotal pieces

21
00:00:59.470 --> 00:01:03.200
that are running in
the background as we run our code.

22
00:01:03.200 --> 00:01:06.560
I'm clear on why we have them,
that they're there and

23
00:01:06.560 --> 00:01:10.260
that we will use these as our tools for
the rest of the two days.

24
00:01:10.260 --> 00:01:12.080
So I need to see clarifications.

25
00:01:12.080 --> 00:01:13.130
Sorry, how does this bit work?

26
00:01:13.130 --> 00:01:15.001
Or so how does this bit work?

27
00:01:15.001 --> 00:01:18.290
I need to understand that before I can
fully understand the rest of stuff.

28
00:01:18.290 --> 00:01:21.954
So everybody thumbs out, nor
do what happened, clarifications and

29
00:01:21.954 --> 00:01:22.910
clear to move on.

30
00:01:22.910 --> 00:01:26.770
Everybody thumbs out I want
the honest thumb self-appraisal.

31
00:01:26.770 --> 00:01:28.520
Matt has a clarification.

32
00:01:28.520 --> 00:01:29.460
If you've got your thumb up,

33
00:01:29.460 --> 00:01:32.690
I should be confident to go to RC to
explain what's just happened here.

34
00:01:32.690 --> 00:01:37.080
Everyone's thumbs out, Matt has
a clarification, Mohammad has one,

35
00:01:37.080 --> 00:01:39.080
Mohammad's thumb went from
up to a clarification.

36
00:01:39.080 --> 00:01:39.820
It's up, still up?

37
00:01:40.890 --> 00:01:42.895
Okay, what was your name again?

38
00:01:42.895 --> 00:01:44.356
&gt;&gt; Clara: Kara.
&gt;&gt; Will: Kara, sorry Kara.

39
00:01:44.356 --> 00:01:45.316
Is that a medium thumb?

40
00:01:45.316 --> 00:01:48.817
&gt;&gt; Clara: I wouldn't say I'm
comfortable explaining things, but

41
00:01:48.817 --> 00:01:49.490
[CROSSTALK]
&gt;&gt; Will: Okay.

42
00:01:49.490 --> 00:01:50.220
&gt;&gt; Clara: I think I understand it.

43
00:01:50.220 --> 00:01:52.570
&gt;&gt; Will: Well, I would love to see,
if everyone's thumbs up, okay,

44
00:01:52.570 --> 00:01:53.850
I wanna see Matt's clarification.

45
00:01:53.850 --> 00:01:55.226
Can you talk us through Matt?

46
00:01:55.226 --> 00:02:01.800
&gt;&gt; Matt: Well, I guess I just wonder how
do we get from the function of multiply2,

47
00:02:01.800 --> 00:02:07.539
and then we bounce down to
the constant of output multiply by 2.

48
00:02:07.539 --> 00:02:09.889
I guess-
&gt;&gt; Will: That's a really, see,

49
00:02:09.889 --> 00:02:12.004
this is why clarification is so great.

50
00:02:12.004 --> 00:02:13.085
What a great clarification from Matt.

51
00:02:13.085 --> 00:02:16.613
It shows a, I don't wanna say confusion,

52
00:02:16.613 --> 00:02:21.170
an interpretation that many,
many people have.

53
00:02:21.170 --> 00:02:27.720
And there is based in a misunderstanding,
I guess.

54
00:02:27.720 --> 00:02:29.600
Maybe you're on it, whatever.

55
00:02:29.600 --> 00:02:31.240
Matt, great question.

56
00:02:31.240 --> 00:02:34.850
We do not jump back up to multiply by 2.

57
00:02:34.850 --> 00:02:39.330
When I run my one, it says to,
what that one line say in the code

58
00:02:42.131 --> 00:02:44.824
&gt;&gt; Will: No, what's my one say?

59
00:02:44.824 --> 00:02:47.744
Yep, what's line two say?

60
00:02:47.744 --> 00:02:49.526
&gt;&gt; Matt: The function is multiplied by 2.

61
00:02:49.526 --> 00:02:54.795
&gt;&gt; Will: It says, that says go store,
it says go store all

62
00:02:54.795 --> 00:03:00.709
the exact function text in
that function definition,

63
00:03:00.709 --> 00:03:05.220
go store it in the label multiplied by 2.

64
00:03:05.220 --> 00:03:11.211
After I've declared
the function multiplied

65
00:03:11.211 --> 00:03:16.277
by 2 map, what if I were to write this,

66
00:03:16.277 --> 00:03:22.750
console.log to log to my
console multiply by 2.

67
00:03:22.750 --> 00:03:27.909
What would I see in my console Matt?

68
00:03:27.909 --> 00:03:28.994
&gt;&gt; Matt: I don't know.

69
00:03:28.994 --> 00:03:29.751
&gt;&gt; Will: Have a think about it.

70
00:03:29.751 --> 00:03:30.617
Give it a shot.

71
00:03:30.617 --> 00:03:31.332
What do you think?

72
00:03:31.332 --> 00:03:32.319
What would make sense?

73
00:03:32.319 --> 00:03:35.178
JavaScript sees the word multiply by 2,
where does it go looking for it?

74
00:03:37.148 --> 00:03:38.500
&gt;&gt; Matt: In the function.

75
00:03:38.500 --> 00:03:40.570
&gt;&gt; Will: Where do you go looking for
more Andrea?

76
00:03:40.570 --> 00:03:41.250
&gt;&gt; Andrea: The global memory.

77
00:03:41.250 --> 00:03:42.950
&gt;&gt; Will: In global memory what's defined?

78
00:03:42.950 --> 00:03:47.480
&gt;&gt; Andrea: The function?

79
00:03:47.480 --> 00:03:49.660
&gt;&gt; Will: The whole function definition.

80
00:03:49.660 --> 00:03:52.990
So if I where to console log multiple by
2, Clara, what would I see in my console?

81
00:03:52.990 --> 00:03:54.880
&gt;&gt; Clara: I don't remember exactly, but

82
00:03:54.880 --> 00:03:57.140
it says something like this
is a function objects.

83
00:03:57.140 --> 00:03:59.220
&gt;&gt; Will: It will say this is a function,
but it will actually be,

84
00:03:59.220 --> 00:04:00.490
it's the whole function.

85
00:04:00.490 --> 00:04:03.232
Depending on your call,
that's a really good point by Clara.

86
00:04:03.232 --> 00:04:06.620
Some basic,
I would call it console just say function.

87
00:04:06.620 --> 00:04:12.398
But Chrome DevTools will
literally say console here,

88
00:04:12.398 --> 00:04:18.430
it'll literally say function
multiplyby2(num) and

89
00:04:18.430 --> 00:04:25.400
then it'll have return,
it'll have the whole code inside.

90
00:04:25.400 --> 00:04:30.250
So Matt, when we call multiply by 2
there in line three, when we invoke,

91
00:04:30.250 --> 00:04:34.750
when we run it with threads, do you see
where it says const output equal, yeah.

92
00:04:34.750 --> 00:04:36.430
We're not jumping back into the function.

93
00:04:36.430 --> 00:04:37.060
What are we doing?

94
00:04:37.060 --> 00:04:39.670
We're going into here memory, and
we're grabbing this definition to use it.

95
00:04:39.670 --> 00:04:40.860
Does that make sense?

96
00:04:40.860 --> 00:04:41.860
&gt;&gt; Matt: So it's already stored.

97
00:04:41.860 --> 00:04:43.300
&gt;&gt; Will: It's already stored.

98
00:04:43.300 --> 00:04:45.850
The word function, the word const,
all they're doing is saying,

99
00:04:45.850 --> 00:04:49.540
JavaScript, free up some space to
store this stuff that's following.

100
00:04:49.540 --> 00:04:50.390
Does that make sense now?

101
00:04:50.390 --> 00:04:51.860
&gt;&gt; Matt: So that's the state.

102
00:04:51.860 --> 00:04:52.460
&gt;&gt; Will: That's our state.

103
00:04:52.460 --> 00:04:53.440
That's our live data.

104
00:04:53.440 --> 00:04:58.339
That's how, and that live data can
include actual functionality, like that.

105
00:04:58.339 --> 00:04:59.840
Do you see that now, Matt?

106
00:04:59.840 --> 00:05:04.413
When you're calling multiply by 2,
you're not going back in the code,

107
00:05:04.413 --> 00:05:06.793
back up to the definition earlier on.

108
00:05:06.793 --> 00:05:11.190
No, that definition is being grabbed,
stored under a label in memory.

109
00:05:11.190 --> 00:05:18.436
&gt;&gt; Matt: So, that's the definition of
the synchronous line by line reading of.

110
00:05:18.436 --> 00:05:19.329
&gt;&gt; Will: I don't know,

111
00:05:19.329 --> 00:05:23.044
I would say essentially we have
taken our function definition,

112
00:05:23.044 --> 00:05:27.537
stored the what do I do line by line in
memory under the label multiplied by 2.

113
00:05:27.537 --> 00:05:30.796
When I run multiplied by 2,
I go look in memory,

114
00:05:30.796 --> 00:05:33.910
I find this code and I say grab this code.

115
00:05:33.910 --> 00:05:36.600
Make some space to start going
through it line by line.

116
00:05:36.600 --> 00:05:40.720
I just start doing it line by line and
storing stuff in memory there.

117
00:05:40.720 --> 00:05:44.830
When I finish running that function,
well, where do I go next?

118
00:05:44.830 --> 00:05:47.060
Well we have multiply
by 2 on the Call Stack.

119
00:05:47.060 --> 00:05:48.542
I go back out to global.

120
00:05:48.542 --> 00:05:50.240
Art go ahead.

121
00:05:50.240 --> 00:05:53.840
&gt;&gt; Art: I was just curious, where is
the Call Stack, is it also in the memory?

122
00:05:53.840 --> 00:05:54.876
The Call Stack.

123
00:05:54.876 --> 00:05:58.086
&gt;&gt; Will: It is also in our memory,
but for our purposes,

124
00:05:58.086 --> 00:06:01.952
we don't need to know exactly
where it's being stored.

125
00:06:01.952 --> 00:06:04.703
But it's there in our JavaScript runtime.

126
00:06:04.703 --> 00:06:07.526
It's part of the JavaScript
engine being run.

127
00:06:07.526 --> 00:06:08.448
Make sense?

128
00:06:08.448 --> 00:06:10.544
&gt;&gt; Art: Makes sense.

129
00:06:10.544 --> 00:06:11.447
&gt;&gt; Will: Go ahead, Griffin.

130
00:06:11.447 --> 00:06:13.547
&gt;&gt; Griffin: Is there
a different Call Stack for

131
00:06:13.547 --> 00:06:18.580
each JavaScript file if you're importing
stuff from one file to another?

132
00:06:18.580 --> 00:06:22.760
Because it imported into
that one's Call Stack?

133
00:06:22.760 --> 00:06:27.720
&gt;&gt; Will: If we have one JavaScript,
if we have one

134
00:06:27.720 --> 00:06:32.840
JavaScript application running,
it has one Call Stack.

135
00:06:32.840 --> 00:06:36.110
&gt;&gt; Griffin: We just add the highest,
or what?

136
00:06:36.110 --> 00:06:40.290
&gt;&gt; Will: It's just, when that's
supported you're taking code to be run

137
00:06:40.290 --> 00:06:43.880
while it's being run in this environment,
a singular environment.

138
00:06:43.880 --> 00:06:46.620
But you do raise an interesting question,
which we're going to go into here.

139
00:06:46.620 --> 00:06:52.460
But you can have multiple separate
JavaScript call stacks run all this,

140
00:06:52.460 --> 00:06:57.560
and that happens when you use
things like web workers or

141
00:06:57.560 --> 00:07:00.520
other child processes,
things which allow you to have

142
00:07:00.520 --> 00:07:04.480
multiple background areas in jobs, but we
don't need to worry about that for here.

143
00:07:04.480 --> 00:07:05.475
Yeah, Mark?

144
00:07:05.475 --> 00:07:10.430
&gt;&gt; Mark: I don't know how to pronounce his
name, but he's asking about const num = 3.

145
00:07:10.430 --> 00:07:11.010
Why did you write that?

146
00:07:13.290 --> 00:07:14.240
&gt;&gt; Will: Good question.

147
00:07:14.240 --> 00:07:16.792
Just to show some basic data being stored.

148
00:07:16.792 --> 00:07:18.276
We did not use num is 3,

149
00:07:18.276 --> 00:07:23.487
we just wanted to have some evidence that
we can store data in memory, that's all.

150
00:07:23.487 --> 00:07:26.850
It was just for
a pedagogical technique, tell him that.

151
00:07:26.850 --> 00:07:28.220
All right.

152
00:07:28.220 --> 00:07:31.780
&gt;&gt; Mark: Is the global thread and
local thread different?

153
00:07:31.780 --> 00:07:35.880
&gt;&gt; Will: No they are,
it's the single thread.

154
00:07:35.880 --> 00:07:38.041
It's the thread is just a posh name,

155
00:07:38.041 --> 00:07:42.110
don't think of the thread as some
kind of fancy mystic driven thing.

156
00:07:42.110 --> 00:07:46.297
All it is is just a portion name for
we did line 1, then we did line 2,

157
00:07:46.297 --> 00:07:49.779
multiply by 2, then we did line 3,
declaring output.

158
00:07:49.779 --> 00:07:52.422
That said,
we don't want to put an output yet.

159
00:07:52.422 --> 00:07:55.001
We've got to go run
the function multiply by 2.

160
00:07:55.001 --> 00:07:57.891
And so we stopped doing the code
line by line globally and

161
00:07:57.891 --> 00:08:01.100
started doing the code line by
line inside the function body.

162
00:08:01.100 --> 00:08:03.560
But it's just more code to be read and
done.

163
00:08:03.560 --> 00:08:06.510
So they are absolutely the same thing,
okay?

164
00:08:07.710 --> 00:08:08.690
Yes, go ahead Clara.

165
00:08:08.690 --> 00:08:11.260
&gt;&gt; Clara: Is there any reason
to use const instead of var?

166
00:08:12.450 --> 00:08:14.994
&gt;&gt; Will: Because as a default,
I personally,

167
00:08:14.994 --> 00:08:20.239
there's a default increase in the fruit
in 2015, for anything you should

168
00:08:20.239 --> 00:08:25.750
default to constants unless you're going
to actually reassign it in memory.

169
00:08:25.750 --> 00:08:29.720
Because this num is never touched,
we can use const.

170
00:08:29.720 --> 00:08:33.520
Because output is not being altered
any way here, we can use const.

171
00:08:33.520 --> 00:08:37.910
So it's a sort of default rule that
you should always default to const for

172
00:08:37.910 --> 00:08:42.530
declaring what you previously would have
thought of as declaring your variables.

173
00:08:42.530 --> 00:08:48.570
And then use let as a backup if you're
ever going to do some reassignment and

174
00:08:48.570 --> 00:08:49.760
say no, no, no, no.

175
00:08:49.760 --> 00:08:51.560
Right now it's four,
we're gonna make it five.

176
00:08:51.560 --> 00:08:56.262
Right now it's a string Will, we're gonna
make it string Clara, then you can use

177
00:08:56.262 --> 00:09:00.374
let, but otherwise you should be
declaring all your stuff with const.

178
00:09:00.374 --> 00:09:03.871
Okay, but think of it as just, it's var.

179
00:09:03.871 --> 00:09:07.677
It's var, but
just has some special rules around it.

180
00:09:07.677 --> 00:09:10.784
Which aren't gonna, those special
rules aren't going to effect us here.

181
00:09:10.784 --> 00:09:13.444
Not in any of the stuff we're doing today.

182
00:09:13.444 --> 00:09:14.852
But, think of it as var,

183
00:09:14.852 --> 00:09:18.830
just as you know the behavior of
var think of it the same way here.

184
00:09:18.830 --> 00:09:20.490
It has some special properties, but

185
00:09:20.490 --> 00:09:22.010
we don't need to worry
about those right here.

186
00:09:22.010 --> 00:09:25.160
Those special properties
being you can't change it.

187
00:09:25.160 --> 00:09:28.414
But besides that,
we don't need to worry about those here.

188
00:09:28.414 --> 00:09:32.071
All right, so here we go.

189
00:09:32.071 --> 00:09:32.571
&gt;&gt; Ami: I have a question.

190
00:09:33.800 --> 00:09:34.690
&gt;&gt; Will: Go ahead Ami.

191
00:09:34.690 --> 00:09:38.310
&gt;&gt; Ami: What about if the function
is declared after it's been got?

192
00:09:40.300 --> 00:09:42.570
&gt;&gt; Will: Yeah,
I want to hold on that question,

193
00:09:42.570 --> 00:09:46.020
I mean,
this is a concept known as hoisting.

194
00:09:46.020 --> 00:09:50.023
We don't need to in this case,
we're not going to come to it.

195
00:09:50.023 --> 00:09:53.937
Again, it has no implications for
the things that we're gonna see today.

196
00:09:53.937 --> 00:09:57.213
So part of the challenge we must face
when we're doing the hard parts.

197
00:09:57.213 --> 00:10:00.710
All the language is figuring out which
bits do we wanna dive deep on and

198
00:10:00.710 --> 00:10:04.813
which bits we would say, actually,
that's not gonna have any implications for

199
00:10:04.813 --> 00:10:07.126
how we're going to solve these challenges.

200
00:10:07.126 --> 00:10:08.872
So on that one, we'll hold on it.

