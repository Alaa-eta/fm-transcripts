WEBVTT

1
00:00:00.260 --> 00:00:03.060
&gt;&gt; Will Sentance: Unfortunately
my slides are less.

2
00:00:03.060 --> 00:00:07.533
Man, that thing there that says functional
programming, that's meant to be a grand,

3
00:00:07.533 --> 00:00:12.120
bold statement on a new slide but
instead it's a little thing on the bottom.

4
00:00:12.120 --> 00:00:16.120
So let's imagine we're just looking
at this functional programming.

5
00:00:16.120 --> 00:00:23.810
Here we go, we now have call platform
of JavaScript from which to learn from.

6
00:00:23.810 --> 00:00:26.520
We have our call platform, there it is.

7
00:00:26.520 --> 00:00:32.760
Our memory, where stuff gets stored, our
thread, where stuff gets run line by line.

8
00:00:32.760 --> 00:00:34.630
When we start running a function.

9
00:00:34.630 --> 00:00:37.749
Remind me again, Shelby,
how do I start running a function?

10
00:00:41.010 --> 00:00:42.900
How do I start calling a function?

11
00:00:42.900 --> 00:00:43.680
&gt;&gt; Shelby: With parentheses.

12
00:00:43.680 --> 00:00:45.310
&gt;&gt; Will Sentance: Parentheses,
there it is.

13
00:00:45.310 --> 00:00:46.588
What does calling a function create?

14
00:00:46.588 --> 00:00:51.139
Everyone together,
it creates a brand new [CROSSTALK].

15
00:00:51.139 --> 00:00:53.630
It creates a brand new execution context.

16
00:00:53.630 --> 00:00:58.380
Believe me, this is everything.

17
00:00:58.380 --> 00:01:01.480
JavaScript is so powerful like this,
whenever I start calling a function,

18
00:01:01.480 --> 00:01:03.370
I get to create a new execution context.

19
00:01:03.370 --> 00:01:04.950
So how do I call a function, Lindsay?

20
00:01:04.950 --> 00:01:05.745
&gt;&gt; Lindsey: With parentheses.

21
00:01:05.745 --> 00:01:06.535
&gt;&gt; Will Sentance: Parentheses, and

22
00:01:06.535 --> 00:01:11.370
when I call a function I create a new-
&gt;&gt; audience: Execution context.

23
00:01:11.370 --> 00:01:14.780
&gt;&gt; Will Sentance: Exactly,
smart room, a new execution context.

24
00:01:14.780 --> 00:01:17.930
Where, we just have exactly what
we do when we always run code.

25
00:01:17.930 --> 00:01:22.830
We have our memory and thread but
now we do it inside the function.

26
00:01:22.830 --> 00:01:25.370
Where we start doing the code line
by line inside the function and

27
00:01:25.370 --> 00:01:26.760
our memory inside the function.

28
00:01:26.760 --> 00:01:30.320
But we're doing now multiple execution
context, all at the same time, but

29
00:01:30.320 --> 00:01:31.970
they're all around.

30
00:01:31.970 --> 00:01:32.884
So how do we keep track of them?

31
00:01:32.884 --> 00:01:35.190
Because we're only ever
reading one at a time.

32
00:01:35.190 --> 00:01:38.090
So you got to know which
one to go back to, etc.

33
00:01:38.090 --> 00:01:39.250
How do we keep track of them?

34
00:01:39.250 --> 00:01:44.940
Don't panic, JavaScript has the call stack
to track which function call we're in,

35
00:01:44.940 --> 00:01:47.120
which execution context we're in.

36
00:01:47.120 --> 00:01:50.029
Okay, those are our three
fundamental principles.

37
00:01:51.260 --> 00:01:54.590
All of JavaScript, there's little
bonus features like the prototypical

38
00:01:54.590 --> 00:01:56.510
nature that are coming out tomorrow.

39
00:01:56.510 --> 00:01:59.830
There are little bonus features of
JavaScript, but otherwise all of

40
00:01:59.830 --> 00:02:05.630
JavaScript can be captured by
these three underlying principles.

41
00:02:05.630 --> 00:02:10.730
Now, we're gonna come tomorrow
also to asynchronous JavaScript.

42
00:02:10.730 --> 00:02:13.940
That introduces a couple of bonus

43
00:02:13.940 --> 00:02:18.540
very significant pieces that cannot
be explained by this world view.

44
00:02:18.540 --> 00:02:21.478
Tomorrow we're gonna see some code and
try and

45
00:02:21.478 --> 00:02:26.235
evaluate it from this world view,
this paradigm, and we're gonna go up.

46
00:02:26.235 --> 00:02:31.082
No, no this doesn't capture
what I'm trying to do here.

47
00:02:31.082 --> 00:02:32.990
There must be something else going on.

48
00:02:32.990 --> 00:02:34.460
We'll see that tomorrow morning.

49
00:02:34.460 --> 00:02:36.910
But, for synchronous JavaScript,
this is it.

50
00:02:36.910 --> 00:02:38.230
What's up, Mark?

51
00:02:38.230 --> 00:02:41.030
&gt;&gt; Mark: Online they were asking about, so

52
00:02:41.030 --> 00:02:43.580
you were saying JavaScript
goes line by line, but

53
00:02:43.580 --> 00:02:49.560
there must be some other process to create
the context and stuff ahead of time.

54
00:02:50.660 --> 00:02:54.122
So they're asking if there's
a compilation phase, or

55
00:02:54.122 --> 00:02:57.225
does JavaScript just [CROSSTALK]
&gt;&gt; Will Sentance: So maybe we mention

56
00:02:57.225 --> 00:03:02.360
before people came on, but we talked about
there being an interpretation style.

57
00:03:02.360 --> 00:03:06.320
JavaScript nowadays actually uses
what's called just-in-time compilation.

58
00:03:06.320 --> 00:03:09.550
The V8 engine from Chrome uses
just-in-time compilation,

59
00:03:09.550 --> 00:03:13.440
which does all sorts of very
small optimizations around

60
00:03:13.440 --> 00:03:15.950
which bit of this gets
assigned to memory first.

61
00:03:15.950 --> 00:03:18.720
But for our process,
again this comes back to that question.

62
00:03:19.880 --> 00:03:25.080
Going deep, going under the hood of the
language, is not for theoretical purposes.

63
00:03:25.080 --> 00:03:28.590
It's not for our intellectual curiosity.

64
00:03:28.590 --> 00:03:33.180
We do it because it makes debugging,
writing clean code, and

65
00:03:33.180 --> 00:03:38.110
communicating what we're really
doing much, much more possible.

66
00:03:38.110 --> 00:03:40.600
But that also means we have
to hit a level where we go,

67
00:03:40.600 --> 00:03:44.540
hold on, do I need to understand
how this is turned into bytecode?

68
00:03:44.540 --> 00:03:50.000
Well, no I don't, because it doesn't have
any implications for how I write my code.

69
00:03:50.000 --> 00:03:52.520
It doesn't help me write cleaner or
more efficient code.

70
00:03:52.520 --> 00:03:55.470
So the question from
the online audience about

71
00:03:55.470 --> 00:03:57.800
how does the compilation step work here?

72
00:03:57.800 --> 00:04:01.110
How does the just-in-time
compilation actually work?

73
00:04:01.110 --> 00:04:06.020
We don't need to worry about here, these
are our three already quite under the hood

74
00:04:07.050 --> 00:04:10.890
aspects of the JavaScript run time.

75
00:04:10.890 --> 00:04:15.920
These are the three we need to know
to effectively write, debug and

76
00:04:15.920 --> 00:04:16.880
communicate our code.

