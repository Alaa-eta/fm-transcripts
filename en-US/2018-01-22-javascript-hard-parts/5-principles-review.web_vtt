WEBVTT

1
00:00:00.000 --> 00:00:02.617
&gt;&gt; Will Sentance: Unfortunately
my slides are less, man,

2
00:00:02.617 --> 00:00:05.804
that thing there that says
functional programming,

3
00:00:05.804 --> 00:00:09.644
that's meant to be like a grand,
bold statement on a new slide.

4
00:00:09.644 --> 00:00:12.357
But instead it's like
a little thing on the bottom.

5
00:00:12.357 --> 00:00:17.740
So let's imagine we're just looking
at this, functional programming.

6
00:00:17.740 --> 00:00:23.184
Here we go, we now have core platform
of JavaSript from which to learn from.

7
00:00:23.184 --> 00:00:25.441
We have our core platform, there it is.

8
00:00:25.441 --> 00:00:30.900
Our memory where stuff gets stored, our
thread where stuff gets run line-by-line.

9
00:00:30.900 --> 00:00:35.292
When we start running a function,
remind me again, Shelby,

10
00:00:35.292 --> 00:00:40.756
how do I start running a function?
&gt;&gt; Will Sentance: How

11
00:00:40.756 --> 00:00:43.040
do I start calling a function?
&gt;&gt; off screen female: With

12
00:00:43.040 --> 00:00:43.680
parenthesis?

13
00:00:43.680 --> 00:00:45.310
&gt;&gt; Will Sentance: Parenthesis,
there it is.

14
00:00:45.310 --> 00:00:46.329
What does calling a function create?

15
00:00:46.329 --> 00:00:51.240
Everyone together, it creates a brand new?
&gt;&gt; [INAUDIBLE]

16
00:00:51.240 --> 00:00:52.050
&gt;&gt; Will Sentance: It creates a brand new

17
00:00:52.050 --> 00:00:53.630
execution context.

18
00:00:53.630 --> 00:00:59.910
This is, believe me, this is everything,
JavaScript is so powerful like this.

19
00:00:59.910 --> 00:01:03.370
Whenever I start calling a function,
I get to create a new execution context.

20
00:01:03.370 --> 00:01:05.500
So how do I call a function, Lindsay?
&gt;&gt; off screen female: With parentheses.

21
00:01:05.500 --> 00:01:06.170
&gt;&gt; Will Sentance: Parentheses, and

22
00:01:06.170 --> 00:01:11.370
when I call a function, I create a new?
&gt;&gt; Execution context.

23
00:01:11.370 --> 00:01:12.440
&gt;&gt; Will Sentance: Exactly,

24
00:01:12.440 --> 00:01:15.590
smart room, a new execution context where

25
00:01:15.590 --> 00:01:17.930
we just have exactly what we
do when we always run code.

26
00:01:17.930 --> 00:01:22.880
We have our memory and thread, but
now we do it inside the function.

27
00:01:22.880 --> 00:01:25.370
When we start doing the code
line-by-line inside the function, and

28
00:01:25.370 --> 00:01:26.750
our memory inside the function.

29
00:01:26.750 --> 00:01:30.311
But we're doing now, multiple execution
contexts, not at the same time, but

30
00:01:30.311 --> 00:01:31.970
they're all around.

31
00:01:31.970 --> 00:01:32.972
So how do we keep track of them?

32
00:01:32.972 --> 00:01:34.230
Cuz we're only ever in one at a time.

33
00:01:34.230 --> 00:01:37.360
So we've gotta know which
one to go back to, etc.

34
00:01:37.360 --> 00:01:39.250
How do we keep track of them?

35
00:01:39.250 --> 00:01:44.940
Don't panic, JavaScript has the call stack
to track which function call we're in,

36
00:01:44.940 --> 00:01:47.120
which execution context we're in.

37
00:01:47.120 --> 00:01:51.216
Okay, those are our three
fundamental principles.

38
00:01:51.216 --> 00:01:54.492
There's little bonus features
like the prototypal nature,

39
00:01:54.492 --> 00:01:56.070
we'll cover that tomorrow.

40
00:01:56.070 --> 00:01:58.460
There are little bonus
features of JavaScript.

41
00:01:58.460 --> 00:01:59.570
But otherwise,

42
00:01:59.570 --> 00:02:05.630
all of JavaScript can be captured by
these three underlying principles.

43
00:02:05.630 --> 00:02:10.270
Now, we're gonna come tomorrow
also to asynchronous JavaScript.

44
00:02:10.270 --> 00:02:12.716
That introduces a couple of bonus,

45
00:02:12.716 --> 00:02:17.535
very significant pieces that cannot
be explained by this worldview.

46
00:02:17.535 --> 00:02:20.462
Tomorrow we're gonna see some code and
try and

47
00:02:20.462 --> 00:02:23.701
evaluate it from this worldview,
this paradigm.

48
00:02:23.701 --> 00:02:29.751
And we're gonna go, no, no this doesn't
capture what I'm trying to do here,

49
00:02:29.751 --> 00:02:32.990
there must be something else going on.

50
00:02:32.990 --> 00:02:36.910
We'll see that tomorrow morning, but
for synchronous JavaScript this is it.

51
00:02:36.910 --> 00:02:38.242
What's that, Mark?

52
00:02:38.242 --> 00:02:43.580
Online they're asking about, so you're
saying JavaScript goes line-by-line but

53
00:02:43.580 --> 00:02:48.580
there must be some other process
to create the context and

54
00:02:48.580 --> 00:02:50.784
stuff ahead of time.
&gt;&gt; off screen male: So

55
00:02:50.784 --> 00:02:53.574
they're asking if there's
a compilation phase, or

56
00:02:53.574 --> 00:02:56.340
does JavaScript just go line-by-line?
&gt;&gt; Will Sentance: So we mentioned,

57
00:02:56.340 --> 00:02:58.460
we only mentioned it
before people came on.

58
00:02:58.460 --> 00:03:02.360
But we talked about there
being an interpretation style.

59
00:03:02.360 --> 00:03:06.438
JavaScript nowadays actually uses
what's called just-in-time compilation,

60
00:03:06.438 --> 00:03:09.531
the V8 engine from Chrome uses
just-in-time compilation.

61
00:03:09.531 --> 00:03:13.996
Which does all sorts of very smart
optimizations around which bits of this

62
00:03:13.996 --> 00:03:15.950
gets assigned to memory first.

63
00:03:15.950 --> 00:03:18.720
But for our purposes, again,
this comes back to that question.

64
00:03:19.880 --> 00:03:23.330
Going deep, going under the hood
of the language is not for

65
00:03:23.330 --> 00:03:28.590
theoretical purposes, it's not for
our intellectual curiosity.

66
00:03:28.590 --> 00:03:33.180
We do it because it makes debugging,
writing clean code, and

67
00:03:33.180 --> 00:03:38.110
communicating what we're really
doing much, much more possible.

68
00:03:38.110 --> 00:03:41.660
But that also means we have to
hit a level where we go hold on,

69
00:03:41.660 --> 00:03:44.540
do I need to understand how
this is turned into byte code?

70
00:03:44.540 --> 00:03:50.000
Well, no I don't, because it doesn't have
any implications for how I write my code.

71
00:03:50.000 --> 00:03:52.520
It doesn't help me write cleaner or
more efficient code.

72
00:03:52.520 --> 00:03:55.470
So the question from
the online audience about

73
00:03:55.470 --> 00:03:57.800
how does the compliation step work here?

74
00:03:57.800 --> 00:04:01.110
How does the just-in-time
compilation actually work?

75
00:04:01.110 --> 00:04:02.660
We don't need to worry about it here.

76
00:04:02.660 --> 00:04:07.283
These are our three already
quite under-the-hood

77
00:04:07.283 --> 00:04:10.890
aspects of the JavaScript runtime.

78
00:04:10.890 --> 00:04:15.920
These are the three we need to know
to effectively write, debug, and

79
00:04:15.920 --> 00:04:16.880
communicate our code.

