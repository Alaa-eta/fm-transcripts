[00:00:00]
>> Will Sentance: Folk, we're gonna work through this line by line. This is our final function for our higher order functions. So we're gonna walk through this line by line and to kick us off. Muhammad, line one. This is a mistake. Muhammad line one, what are we doing Muhammad. Talk me through the line one of this set of code.

[00:00:23]

>> Speaker 2: Declaring a function called copyArrayAndManipulate.
>> Will Sentance: Perfect, thank you, man, CopyArrayManipulate. And of course, we're at a global level, right, aren't we? We're not inside a function. So where's that being stored, Byron?
>> Speaker 2: In the global memory?
>> Will Sentance: In the global memory, there it is. I wanna draw it as a function box and f function.

[00:00:42]
The whole description, okay. Next line is what, Shelby?
>> Speaker 3: Declaring the function multiplied by 2.
>> Will Sentance: There it is, multiplied by 2. As a little baby function that only takes in a single what? A little baby function, it only takes in a single Element, and then multiplies it by two.

[00:01:06]
Little baby function, there it is. And let's just highlight it slightly so we know which function it is, and if I were Shelby, in the line after that definition declaration mobile if I were to console .log. That's why I do that. If I were to do this. console.log multiply by two, never ends.

[00:01:24]
What would this display on my console Shelby? Let's make sure we're really clear. What would this display on my console?
>> Speaker 3: Undefined.
>> Will Sentance: Undefined? What have we stored and multiplied by two? So obviously you go and look in memory C multiplied by two, what's the C?
>> Speaker 2: Whole function?

[00:01:45]

>> Will Sentance: The whole function definition. So if I were to console all the work multiplied by two, what would I see in my console? Howard?
>> Speaker 2: Just the whole function.
>> Will Sentance: The whole function definition. It is, multiply by two is a label for my whole function description. Okay, okay it is the whole function definition.

[00:02:02]
Meaning, if I then pass, multiply by two in, two instructions. I'm not passing undefined in. I'm not running copy, manipulate with multiply by two is action to find no its going to literally be the whole function definition. Being pathed in to replace the place holder word, instructions. All right, so now we've declared CopyArrayAndManipulate, declared multiplyBy2, what's the next line tell her to do?

[00:02:32]
Matthew, what's the final line on the left hand side say?
>> Speaker 2: Let results.
>> Will Sentance: Which is saying? Give javascript label results. Right?
>> Speaker 2: Right.
>> Will Sentance: Good. And Matthew, do we know what's going to be stored, Matthew, in result yet?
>> Speaker 2: No.
>> Will Sentance: No, because we've got to go run that function.

[00:02:52]
Matthew, how do I know I've got to go run that function, what symbols?
>> Speaker 2: Parentheses.
>> Will Sentance: Good job, Matthew. Very nice. Yeah. Correct. I'm going to go run that function. It's undefined for now. I'm gonna go run that function. And I'm going to do it. Copy array manipulate call with, order what?

[00:03:14]
What's our first argument, Griffin?
>> Speaker 2: Is the array 1, 2, 3.
>> Will Sentance: Good, there it is. Array, 1, 2, 3. And our second argument, Griffin?
>> Speaker 2: Is the function, multiply it by 2.
>> Will Sentance: Spot on, multiply by 2, and it's the whole function definition, right, Shelby? It's a whole function definition.

[00:03:36]
That wasn't a passive-aggressive statement. Well, it sort of was, but no, no. There it is. It was not intentionally. There, the whole function definition, the whole loaded description. It's the whole function definition. Good job, there it is. And the output, we're saying already we know that whatever gets returned out of this function, whatever comes out of the bottom of this function is going to be stored where, Shelby?

[00:04:00]
The output of running this function is going to be stored where Shelby?
>> Speaker 2: Global.
>> Will Sentance: In what label? What's it saying?
>> Speaker 2: End result.
>> Will Sentance: Exactly. End result. But we've got a whole set of instructions copulate and manipulate that we've got to run through line by line. That's the thread of execution.

[00:04:19]
And we've got a whole bunch of data we've got to store. Output array that's the variable environment, the local memory. What do we call those two things together? Everyone together a?
>> Execution context!
>> Will Sentance: Perfect! There it is. We're going to create it. There it is. An execution context with a local memory.

[00:04:41]
Local memory in which anything we declare, define, create inside of the code or running copyArrayAndManipulate stored in there, not in global. So, at this point
>> Will Sentance: Bob, what's the first thing we do inside copyArrayAndManipulate? Before we even get inside copyArrayAnd Manipulate, what's the first thing we're gonna handle?

[00:05:11]

>> Speaker 3: The placeholder passing the array in.
>> Will Sentance: Yeah, nice, so what do we say? What's the posh way of saying Yeah, here we go.
>> Speaker 3: Sorry. [LAUGH]
>> Will Sentance: What's the first place where we gonna handle?
>> Speaker 3: The 1, 2, 3?
>> Will Sentance: Which is gonna fit in to what sort of place order?

[00:05:29]
That's the actual value, the argument, what's-
>> Speaker 3: The array param.
>> Will Sentance: Array parameter, exactly. And what will array now be, because of what you just said, everywhere inside this function call?
>> Speaker 2: 1, 2, 3.
>> Will Sentance: 1, 2, 3, spot on. And now, Clara, Clara, because whenever someone's on their phone, they get called upon.

[00:05:49]
Clara, we filled an array as 1, 2, 3. We now have another parameter which is what?
>> Speaker 3: Instructions
>> Will Sentance: And what is instructions, Clara, going to be replaced with? It's just a placeholder. What's it gonna point to? What it's value gonna be throughout the life of this function called?

[00:06:13]

>> Speaker 3: It's a function. The multiply by two function
>> Will Sentance: Spot on. The entire multiply by two functionality. We no longer are going to refer to it as multiply by two inside. We're going to refer to it as instructions. But it is that entire function definition that we gave birth to out here in global.

[00:06:32]
We defined out here and then passed in to be available inside copyArrayManipulate under it's new label instructions. So Clara if I wanted to inside copyArrayManipulate run that multiplyBy2 functionality in here under it's new label, what's the exact wording I would use to run it?
>> Speaker 3: You'd say instructions parentheses-

[00:06:52]

>> Will Sentance: Instructions, I'm sorry, say that again.
>> Speaker 3: Instructions parentheses.
>> Will Sentance: Parentheses, I would probably wanna parse something because. Right, and if you look the definition I'm pointing right to it called a 'placeholder', so I'll pass in 3. Because, instruction literally evaluates to, it becomes the multiply by 2 function.

[00:07:10]
Just like array, if we were to go array position 1 inside of here, we are going to look at this array. Instructions, we're gonna look at what it is at. It's the multiply by two functionality. It has literally replaced the placeholder that was previously a placeholder instructions. All right, let's walk through it as precisely as we can.

[00:07:32]
Okay, so we've done our parameters Art, we've done our perameters, what's our next line in our local memory? We've done our our perameters, our arguments whats our next bit in local memory?
>> Speaker 2: We're sending our output to an array.
>> Will Sentance: Spot on, I'm gonna put, again, our sort of working area over here.

[00:07:48]
So it's sort of not ideal, but there we go. Output is exactly an empty array. There we go, output, just so we can work with these slightly easier. Okay, big moment. Andrea, we're going to hit the body of that Four Loop. We've done outfits on MD Ray. We're going to hit the body of that Four loop.

[00:08:10]
First time we do, what's the first I guess variable of whose value we're interested in. JavaScript kinda works inwards, outward. So, what's the first one we're interested in?
>> Speaker 3: Is the I to zero
>> Will Sentance: I is zero, spot on. So, I is zero, so array index zero is what?

[00:08:29]
Andrea.
>> Speaker 3: Sub zero one.
>> Will Sentance: This is very very good. But everyone wants to hear so nice. Spot on Andrea, really nice. So array sub zero is the value one. Exactly. There it is, the value one. And now, that one, that means this little portion here, 0, 1.

[00:08:55]
What's his instructions, placeholder now being filled in with, Andrea?
>> Speaker 3: Multiply by 2
>> Will Sentance: The word multiply, the function multiply by 2. So actually, what does this little portion here become but multiply by 2, open parens, 1, close parens. Well, that's saying, go run the multiply by 2 function.

[00:09:17]
And when we start running a function, Andrea, what do we do? We create a brand new, everyone together? Execution context. We forgot to add this one in the first place. Well. So copyArrayAndManipulate, when we started running it, we add it to the call stack. So it already inside copyArrayAndManipulate, CC.

[00:09:34]
JavaScript needs to know this stuff. There we are, that's all by call stack. And yes, we now exactly, as Andrea said, start calling instructions, which is really just multiply by 2. But let's refer to it as instructions here. Instructions, which is really just what, Andrea?
>> Speaker 3: A paremeter?

[00:09:57]

>> Will Sentance: What is instructions really just?
>> Speaker 3: Multiply by 2.
>> Will Sentance: Multiply by 2, and we pass in the what value?
>> Speaker 3: First value in the area.
>> Will Sentance: Which is?
>> Speaker 3: One.
>> Will Sentance: One exactly. And if we're calling it, we create a new execution context. There it is, with a local memory of its own.

[00:10:16]
And Andrea, what happens to our call stack?
>> Speaker 3: It gets added to the.
>> Will Sentance: The call to instructions multiplied by 2, they're the same thing, gets added to the call stack. There it is. Now we know when we finish running it, where are we gonna to go back to, Andrea?

[00:10:33]

>> Speaker 3: Doing a background and stack.
>> Will Sentance: Exactly, that's why a stack is such a good way of tracking this. If you add something, start running it, when you finish running it, you wanna go out one step. Where you go down, and you take it off, and you go back out to copy array and manipulate.

[00:10:47]
And so when we go, this is a tough bit. Clara, I'm inside the call to instructions, I've passed, which is really multiplied by two. I passed in one. What is my first pairing of label and data inside the local memory given this is just really multiply by two, Clara?

[00:11:02]

>> Speaker 3: So, input.
>> Will Sentance: Input, exactly, and it's assigned what?
>> Speaker 3: The- Equate to one, right?
>> Will Sentance: One. Exactly, because we are really running the functionality of multiply by two, everyone. So this portion here, 0, 1. And that 1 got thrown into instructions, which is really multiply by 2.

[00:11:25]
So that 1 got thrown in as input. And there it is, shit. There it is, input: 1. And so we do 1, which is input, by 2, and return that 2 out. Which means now, multiply by 2, with the input of 1, this whole statement, multiply by 2, has evaluated, has become, that output value 2.

[00:11:51]
And what do we do with that 2, Andrea?
>> Will Sentance: What do we do with that evaluation of result lindsey?
>> Speaker 3: We push it into the output.
>> Will Sentance: We push it into output spot on there it is and what happens Lindsey?
>> Speaker 3: It goes away
>> Will Sentance: It goes away.

[00:12:09]
We poshly say it gets popped off.
>> Speaker 3: Popped off.
>> Will Sentance: Yeah, it goes away, but it's a full loop. So what happens even though we threw away our execution context it's all gone for the running of instructions that first time. Well what do you know it's a follow so we are going to hit the body of the follow again and this time Griffin, this time, Griffin, what is the value of i?

[00:12:38]

>> Speaker 2: 1.
>> Will Sentance: And therefore, we get array sub 1 which is?
>> Speaker 2: 2.
>> Will Sentance: And we take that 2, and we do what with it?
>> Speaker 2: We pass into instructions.
>> Will Sentance: Which is really just?
>> Speaker 2: Multiply by 2.
>> Will Sentance: Very good, exactly, instructions. And we call that instructions, there it is.

[00:12:54]
The two gets passed in. Do the local memory. What happens?
>> Speaker 2: It gets pushed on to there.
>> Will Sentance: It gets pushed on again. A new execution context. Inside, what's the first data pairing?
>> Speaker 2: Input and two.
>> Will Sentance: Yeah, input and 2, and we do 2 by 2, which becomes 4.

[00:13:15]
Out it returns, return out 4. That means this little portion here multiplied by 2 with the input of 2, is evaluated to 4. And that 4 gets pushed where?
>> Speaker 2: To outputs?
>> Will Sentance: Fate, there it is. And then it gets created again. We get 6. Output is now 2, 4, 6.

[00:13:34]
And we hit the key line, Mohammed, which is? What's the final line of the function?
>> Speaker 2: Return output.
>> Will Sentance: Return, see, I have an amazing habit of always calling on the same people for the same thing. So what it actually will return, Mohammed?
>> Speaker 2: 2,4,6.
>> Will Sentance: Yeah, the value associated with output.

[00:13:56]
Javascript never sees a word and leaves it. It valuates everything down to its lowest possible part. So, it sees the word output, it goes, hold on, what is that? It's 2,4,6. Returns that outward out, two, four, six. And where did we say, Muhammed, we're gonna assign it?
>> Speaker 2: To the label result.

[00:14:16]

>> Will Sentance: To the label result. And there it is. So this is hard. This is supposedly one of those profound areas of all higher functions. We'll see in a moment, we've already encountered all the material of higher order functions, at least with callbacks. But, I wanna have thumbs in a moment, on what we saw here.

[00:14:39]
But look, we acheived, with a generalized copyArrayAndManipulate, and then a specific little baby function, that we passed in for the specifics of what we're gonna do to each element. We achieved exactly the same as we did copyArrayMultiplyBy2 we took a one two three and came out with two four six.

[00:14:58]
Look at this, when to one two three but we had no specificity of MultiplyBy2 in there. Instead we left a place holder which we then determined what it would be when we called, CopyArrayAndManipulate. And what do we end up with, but, 2, 4, 6. The very same result.

[00:15:17]
We could have parsed in, not muliply by 2, but add 3. Or divide by 2. We ended up with the same result. We parametized, we generalized, our function.

