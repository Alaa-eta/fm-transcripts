[00:00:00]
>> Will: Folk we’re gonna walk through this, line by line, this is a final function for our higher order functions. So we’re gonna walk through this line by line, and to kick this off, Mohamed, line one, no, this was a mistake, Mohamed line one, what are we doing Mohamed?

[00:00:17]
Talk me through line one of this function, of this set of code.
>> Muhammad: Declaring a function called copy array, and manipulating-
>> Will: Perfect, thank you man. Copy, array, manipulate and of course we're at the global level, aren't we? We're not inside a function, so where's that being stored, Mohammad?

[00:00:36]

>> Muhammad: In the global memory?
>> Will: In the global memory, there it is. I'm gonna draw it as a little function box, a little function. A whole inscription. Okay, next line is what Shelby?
>> Shelby: Declaring the function multiplied by 2.
>> Will: There it is, multiply by 2. That's a baby function that only takes in, a single, what?

[00:00:58]

>> [LAUGH]
>> Will: A baby function. So it takes in a single element, and then multiplies it by 2. Little baby function there it is. And let's just highlight it slightly so we know which function it is. And, if I were Shelby, in the line after that definition declaration of multiply by 2, why would a console.log?

[00:01:19]
Let's write it up. If I were to do this. Console.log(multiplyBy2) no parenths, what would this display on my console, Shelby, just to make sure we're really clear what would this display on my console?
>> Muhammad: Undefined.
>> Will: Undefined, what have we stored and multiply by 2? So obviously it goes and looks in global memory, C is multiplied by 2.

[00:01:43]
What's at C?
>> Muhammad: The whole function.
>> Will: The whole function definition. So if I were the console alone, the word multiplied by 2, what would I see in my console, Mohamed?
>> Muhammad: Just the whole function.
>> Will: The whole function definition, multipliedBy2 is a label for my whole function description.

[00:01:59]
Okay, okay, it is the whole function definition. Meaning, if I then parse multiplyBy2 in to instructions, I'm not parsing undefined in, I am not running, copy array manipulate with multiplyBy2, it's actually undefined, no, it's gonna literally be the whole function definition, being passed in to replace the placeholder word instructions.

[00:02:26]
All right, so, now we've declared, copy array, manipulate, declare, multiply by 2. What's the next line? Tell us to do, Mathew. What's the finalizer left hand side say?
>> Mathew: Lab results.
>> Will: Which is saying? Give JavaScript label results, right?
>> Mathew: Right.
>> Will: Good, and Matthew, do we know what's gonna be stored, Matthew, in result yet?

[00:02:48]

>> Mathew: No.
>> Will: No, cuz we've gotta go run that function. Matthew, how do I know I've gotta go run that function? What symbols?
>> Mathew: Parenthesis.
>> Will: Good job Matthew, very nice, yeah, correct. I'm gonna go run that function, its undefined for now. I'm gonna go run that function, and I'm gonna do it.

[00:03:06]
CopyArrayManipulate called with, called what? What's our first argument, Griffin?
>> Griffin: It is the array one, two, three.
>> Will: Good there it is, array one two three, and our second argument Griffin?
>> Griffin: Is the function multipliedBy 2.
>> Will: Spot on, multipliedBy2 and it's the whole function definition. Right Coby, the whole function definition?

[00:03:35]
That wasn't a passive aggressive statement, well it sort of was. It was not intentional. The whole function definition there. The whole descriptor. Yeah, it's the whole function definition. Good job, there it is. And the output, we're saying already that we know that whatever gets returned out of this function, whatever comes out the bottom of this function, is gonna be stored where?

[00:03:58]
Shelby? The output of running this function is gonna be stored where, Shelby?
>> Shelby: Global.
>> Will: In what label? What's it say?
>> Shelby: In result.
>> Will: In result, exactly. In result, but we've got a whole set of instructions copyArrayAndManipulate, that we've gotta run through line by line, that's the thread of execution.

[00:04:19]
And we got a hold bunch of data we gotta store, output array. That's the variable environment, the local memory. What do we call those two things together? Everyone together, a
>> All: Execution context.
>> Will: Perfect, there it is. We're gonna create it, there it is. Execution context, with a local memory, local memory.

[00:04:45]
In which anything we declare, define, create inside of the code of running, copyArrayandManipulate, stored it there not in global. So, at this point, Bob, what's the first thing we do inside copyArrayandManipulate? Before we even get inside copyArrayandManipulate, what's the first thing we're gotta handle?
>> Shelby: The placeholder parsing the array.

[00:05:13]

>> Will: Yeah nice. So what do we say? What's the posh way of saying we're gonna yeah, here we go.
>> Shelby: Sorry [LAUGH] the-
>> Will: So what's the first placeholder we're gotta have it on?
>> Shelby: The one, two, three.
>> Will: Which is gonna fill in, what's the placeholder that's the actual value, the argument.

[00:05:30]
What's the-
>> Shelby: The array param.
>> Will: Array parameter, exactly. And what will a array now be because of what you just said, everywhere inside this function call?
>> Shelby: One.
>> Will: One, two, three, spot on. And now, Clara, Clara, whenever someone's on their phone, they get called upon. Clara, we filled an array as one, two, three.

[00:05:55]
We now have another parameter which is what?
>> Clara: Instructions.
>> Will: And what is instructions, Clara, going to be replaced with? It's just a placeholder but what's it gonna point to? What's it value gonna be, throughout the life of this function call.
>> Clara: It's a function, the multiplyBy2 function.

[00:06:16]

>> Will: Spot on, the entire multiplyBy2 functionality. We no longer are gonna refer to it as multiplyBy2 inside, we are gonna refer to it as instructions. But it is that entire function definition that we gave birth to out here, in global, we defined out here, and parse in to be available inside copyArrayManipulate under it's new label instructions.

[00:06:40]
So Clara, if I wanted to inside copyArrayManipulate, run that multiplierBy2 functionality in here under its new label, what's the exact wording I would use to run it?
>> Clara: You use instructions-
>> Will: Instructions. Sorry, say that again.
>> Clara: Instructions, parentheses.
>> Will: Parentheses. I probably wanna parse something in here because.

[00:06:58]
Right, and if you look at the definition multiplyBy2, it's got a placeholder and I parse in 3. Because instructions literally evaluates 2, that becomes, the multiplyBy2 function. Just like array, if we were go array position 1 inside of here, we are gonna look at this array. Instructions, we're gonna look at what it is.

[00:07:19]
It's the multiplyBy2 functionality. That has literally replaced the placeholder that was previously, a placeholder instructions. All right let's walk through it, as precisely as we can. Okay, so we've done our parameters, Alt? We've done our parameters. What's our next line in our local memory? Don't add parameters arguments, what's the next bit in our local memory?

[00:07:41]

>> Muhammad: We're starting our output to our memory.
>> Will: I'm gonna put again, our sort of working area over here, so sort of not ideal but there we go. Output exactly is an empty array, there we go, output. Just so we can work with these slightly easier. Okay, big moment, Andrea, we're gonna hit the body of that for loop.

[00:08:05]
We've done outputs in empty array. We're going to hit the body of that for loop. First time we do, what's the first, I guess, variable, of who's value we're interested in? JavaScript kinda works inwards-outwards, so what's the first one we're interested in?
>> Andrea: That's the i to 0.

[00:08:21]

>> Will: i is 0, spot on. So i is 0, so array index zero is what, Andrea?
>> Andrea: Subzero 1.
>> Will: Andrea, this is very very good but everyone want's to hear. So nice. So, it's spot on Andrea, it's really nice. So array subzero is the value 1.
>> Andrea: Yes.

[00:08:43]

>> Will: My goodness, exactly, there it is, the value 1. And now that 1, that means this little portion here 0, 1, what's this instructions work be a placeholder now being filled with, Andrea?
>> Andrea: MultiplyBy2.
>> Will: The function multipliedB2. So actually, what is this little portion here become but, multiplyBy2, open parens, 1, close parens.

[00:09:13]
Well that's saying, go run the multiplyBy2 function. And when we start running a function Andrea, what do we do? We create a brand new, everyone together?
>> All: And in context?
>> Will: We forgot to add this one in the first place well. So copyArrayandManipulate, when we started running it we added it to the cold stacks.

[00:09:30]
So we already inside copyArrayandManipulate, to see, JavaScript needs to know these stuff. There we are, add that to the cold stacks. And yes, we now exactly as Andrea said, stop calling, instructions which is really just multipliedBy2. But let's refer to it as instructions here. Instructions which is really just what Andrea?

[00:09:54]

>> Andrea: Parameter.
>> Will: What is instructions really just?
>> Andrea: MultiplyBy2.
>> Will: By 2. And we pass in the what value?
>> Andrea: First value in the array.
>> Will: Which is?
>> Andrea: 1.
>> Will: 1 exactly, and if we're calling it we create a new, execution context. There it is with a local memory of its own.

[00:10:16]
And Andrea what happens to our call stack?
>> Andrea: It get's added to the call stack.
>> Will: The call to instructions, multipliedBy2, there the same thing, gets added to the call stack. There it is. Now we know when we finish writing it, where are we gonna go back to Andrea?

[00:10:34]

>> Andrea: It's gonna back down and it's gonna come up.
>> Will: Exactly, that's why a stack is a good way of tracking this, you add something, start running it. When you finish running it you want to go out one step, where you go down and you take it off and go back out to copyArrayandManipulate.

[00:10:47]
And when we go, this is a tough bit Clara. I'm inside the core to instructions, I've passed which is really multipliedBy2, I passed in one. What's my first pairing of label and data inside the local memory, given this is really just multiplyBy2, Clara?
>> Clara: So input.
>> Will: Input, exactly, and it's assigned what?

[00:11:08]

>> Clara: The parameter, you're going with 1.
>> Will: The 1, exactly, exactly, cuz we're now really running the functionality multipliedBy2, everyone. So that, this portion here, 0, 1 and that 1 got thrown into instructions which is really multipliedBy2, so that 1 got thrown in as input. And there it is.

[00:11:29]
Shit, there it is, input 1, and so we do. 1, which is input, by 2 and return that 2 out. Which means now, multiplyBy2 with the input of 1, this whole statement, has evaluated, has become, that output value 2. And what do we do with that 2, Andrea?

[00:11:54]
We times it. What do we do with that evaluated result, Lindsay?
>> Lindsay: Push it into the output.
>> Will: We push it into output. Spot on, there it is. And what happens to our execution context, Lindsay?
>> Lindsay: It goes away.
>> Will: It goes away. We poshly say it gets popped off.

[00:12:12]
Yeah, it goes away but it's a for loop, it's a for loop. So, what happens, even though we throw away execution context, it's all gone for the running of instructions that first time. Well what do you know, it's a for loop. So, we're gonna hit the body of the for loop again and this time, Griffin, this time Griffin, what is the value of i?

[00:12:38]

>> Griffin: 1
>> Will: 1 and therefore we've get a raise sub-1 which is.
>> Griffin: 2
>> Will: And we take that 2 and we do what with it?
>> Griffin: We pass it into instructions.
>> Will: Which is really just?
>> Griffin: MultiplyBy2.
>> Will: Very good, exactly, instructions and we call that instructions, there it is, the 2 gets parsed in to the local memory.

[00:12:58]
Call stack, what happens?
>> Griffin: It gets pushed out of there?
>> Will: It gets pushed on again, new execution context. Inside, what's the first data pairing?
>> Griffin: Input and 2?
>> Will: Yeah, input and 2, and we do 2 by 2, which becomes 4 out at returns. Return out four.

[00:13:19]
That means this little portion here, multipliedBy2 the input of 2 is evaluated to 4, and that 4 gets pushed where?
>> Griffin: To outputs?
>> Will: Perfect, there it is, and then, this goes it gets created again, we get 6, our output is now 2, 4, 6. And we hit the key line, Mohamed, which is?

[00:13:41]
What's the final line of the function?
>> Muhammad: Return output.
>> Will: Return, see, I have an amazing habit of always calling on the same people for the same thing. So what do I actually return out Mohamed?
>> Muhammad: 2, 4, 6.
>> Will: Yeah the value associated with output right? JavaScript never see's a word and leaves it, it evaluates everything down to it's lowest possible part so it see's the word output.

[00:14:03]
It goes, hold on, what is that? It's 2, 4, 6, return's that output out, 2, 4, 6, and where do we say Mohamed we’re gonna assign it?
>> Muhammad: To the label result.
>> Will: To the label result, and there it is. So this is hard, this is supposedly one of the profound areas of JavaScript, high order func, we'll see in a moment we've already encountered all of the material high order functions, at least with call backs.

[00:14:35]
But I wanna have thumbs in a moment, on what we saw here. But look, we achieved with a generalized copyArrayAndManipulate, and then a specific little baby function, that we passed in, for the specifics, of what we're gonna do to each element. We achieved exactly the same as we did, copy array and multiplyBy2, when we took a 1, 2, 3 and came out with 2, 4, 6.

[00:14:58]
Look at this, went in 1, 2, 3, but we had no specificity, of multiplyBy2 in there. Instead we left a placeholder, which we then determined what it would be when we called copyArrayAndManipulate, and what do we end up with? 2, 4, 6. The very same result, we could have parsed in no multiplyBy2 but add 3 or divide by 2, we ended up with the same result.

[00:15:16]
We paramitised, we generalized our function.

