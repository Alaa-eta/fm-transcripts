[00:00:00]
>> Will Sentance: We've achieved our goal though or, have we? We've achieved our basic goal that we've bundled up our functions that could be used on the user data, in one user object, user1, user2. Who can see, though, that while this approach fundamentally solves our basic problem of, is my functionality gonna be available on my data when I need it?

[00:00:22]
Wherever I pass that user2 object, the functionality increment is available on it. Wherever I pass a user, and by the way, there could be 1000 user objects.. User400, user1000, there could be 1000 functions. I can be doing, I can know safely in this model that if I do user2002.displayAvatar, whatever of 100 of functions that I can never use in this function.

[00:00:45]
I'll know, don't worry it will be there. So I've achieved that goal, which we said is our fundamental goal. Let's have thumbs on this. I don't know what happened, I'm got a clarification, I'm clear to go on. Everyone's thumb out, anyone see any issue? With this approach? Yeah, Dave.

[00:01:07]

>> Dave: If you're gonna update the functionality, you have to go [CROSSTALK]?
>> Will Sentance: Yeah, that's a good one, that's a really good one. So maintenance of this is a bit of a pain, right? Because I can't go adding to all my user objects because I've already generated them, and they were created inside of this individual function.

[00:01:26]
Andrew, what do you think is the problem?
>> Andrew: If you have 1000 of users you have to have different variable names for every one?
>> Will Sentance: Okay, well but that's sort of inherent cuz you are pointing at different labels. Now you can store them in an array or something like that ultimately.

[00:01:38]
But they all have to have their own space for their own data, what do you think Griffin?
>> Dave: Any functions that would then call those user functions. They would, it says it's user1, it's not generic enough just to be able to call it end user. You have to make a function for each user.

[00:01:54]

>> Will Sentance: You're getting so close there, right? So you're saying something like, this increment function is a new version for every single.
>> Will Sentance: But the problem from that from the generic list, the problem with that is suppose I have 1,000 functions that are being declared inside of when I call userCreator.

[00:02:15]
Get attached to the new user and get stored in user1. This is another brand new user object with all those functions again. All my data's unique in each user, but these functionality, is increment function here, does it need to be a brand new version versus this one? What if I have a 1000 functions, each with a 100 lines of code in them and then a 1000 users.

[00:02:35]
I'm getting a 1000 times by a 100 times by a 1000 of the lines of code just to describe the same functions. If I have a 1000 functions I wanna be able to use on my users and I copy them across every single user, that's filling in memory.

[00:02:53]
That's saying declare this function, store it in the user. This is the actual copy of the function increment that's attached to the user object. If it's a 1000 of those functions, and then on here, an actual brand new copy of that function increment, it's actually user1. Griffin, is that gonna be good on my memory?

[00:03:10]
That is absolutely unusable. This approach may be simple. It's simple, but it has a fundamental problem. Each time we create a new user, we make space in our computer's memory for all our data and functions. Data, no problem, yeah, like name, Will, score, 3. I've gotta create a brand new space in memory for name Will, score, 3.

[00:03:34]
Name Tim, score 5, but my functions, they're the same on every single object. User1, User2, User400, User1000, why am I making copies? Our function just copy, is there a better way?
>> Will Sentance: We're gonna see, thank goodness there is a better way in JavaScript. But this at least is a very intuitive straight forward in some essence way, but what is a better way?

[00:04:01]

>> [INAUDIBLE]
>> Dave: Inheritance?
>> Will Sentance: Inheritance everyone's is shouting out, words from the land of OP.
>> Dave: [LAUGH]
>> Will Sentance: Probably one of those words is gonna be correct, maybe. One of those words is gonna be correct, but how are they working? What we're going to see today is under the hood, how they're working.

[00:04:16]
And I wanna stress to all of you and online, when I sit down with other Senior Engineers and say what questions do you ask? Senior Developers in interview, one of the classic questions, and it has a great core answer, saying how can I spot a Senior Developer? I don't think it's necessarily, a great way to spot a senior java developer.

[00:04:36]
But the top voted answer is ask them to rebuild how the new key word and how classes which one of the words we shouted out, are actually working. We're going to see under the hood how those are actually working. It is a classic Senior Developer for JavaScript interview question.

[00:04:56]
We're gonna go through it, we're gonna build up the different ways of achieving this fundamental goal of calling our functionality a vate immediately on our data. But, not being incredibly inefficient with space, like we have been here. That's our attention, we're gonna resolve it today. All right, so at this point, we're gonna end the pairs.

[00:05:21]
After the pairing, we're gonna see, how this works? What is our better way of achieving this? But, it lies on the other side of the pairing. For now folk, I think staying the same page we're in. We don't need to go through this, go to csbin.io/oop. We'll get started on pairing an OOP, and we'll start to see afterwards how we can do it better.

[00:05:44]
Everybody, to your pairs.

