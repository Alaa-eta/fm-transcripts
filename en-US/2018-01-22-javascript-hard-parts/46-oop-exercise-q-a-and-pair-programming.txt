[00:00:00]
>> Will Sentance: We've achieved that goal, though, or have we? We've achieved our basic goal, that we've bundled up our functions that could be used on the user data in one user object, user one, user two, user. Who can see, though, that while this approach fundamentally solves our basic problem of, is my functionality going to be available, or my data, when I need it?

[00:00:22]
Wherever I pass that user to object, the functionality increment is available on it. Wherever I pass a user, and by the way there could be a thousand user objects. User 400, user 1000, there could be a thousand functions. I could know safely in this model that if I do user 2002.displayavatar, whatever the hundreds of functions I could ever use on this function.

[00:00:45]
I'll know, don't worry it'll be there. So I've achieved that goal, which we've said is our fundamental goal. Let's have thumbs on this. I don't know what happened. I'm going to need clarification. I'm clear to go on. Everyone's thumbs out. Anyone see any issue with this approach? Yeah, Dave?

[00:01:05]

>> Dave: If you're gonna update the functionality, you have to go-
>> Will Sentance: Yeah, that's good one, that's a really good one. So, maintenance of this is a bit of a pain, right? Because, I can't go adding to all my user objects. Because I've already generated them, and they were created inside of this individual function.

[00:01:26]
Andrew, what do you see as a problem?
>> Andrew: If you have thousands of users, you have to have different variable names for everyone.
>> Will Sentance: Okay, but that's sort of inherent, cuz you're pointing to different labels. Then you can sort them in an array or something like that. But ultimately, and they've all gotta have their own space for their own data.

[00:01:41]
Yeah, what do you think, Griffin?
>> Griffin: Any functions that then would call those user functions, since it's user one, it's not generic enough just to be able to call it end user. You'd have to make a function for each user.
>> Will Sentance: You're getting so close there, right? So you're saying something like, this increment function is a new version for every single.

[00:02:04]
But the problem with that is on my genericness. The problem with that is, suppose I have a thousand functions that have been declared inside of what I call user creator. They get attached to the new user which then gets stored in user one. This is another brand new user object with all those functions again.

[00:02:22]
All my data is unique in each user. But these functionality is increment function here, does it need to be a brand new version versus this one? What if I have a thousand functions, each with a hundred lines of code in them, and then a thousand users? I'm getting a thousand, times by a hundred, times by a thousand sort of lines of code just to describe the same functions.

[00:02:45]
If I have a thousand functions, I wanna be able to use all my users. And I copy them across every single user, that's filling in memory. That's saying declare this function. Store it in the user. This is an actual copy of the function increment that's attached to the user object.

[00:03:01]
If it's a thousand of those functions, and then on here, an actual brand new copy of that function increment, it's actually User 1. Griffin, is that going to be good on my memory? That is absolutely unusable. This approach may be simple. It's simple, but it has a fundamental problem.

[00:03:19]
Each time we create a new user, we make space in our computer's memory, but all our data and functions. Data, no problem. Yeah, name, will_3, I've got to create a brand new space in memory for name will_3, name tim_5. But my functions, they're the same on every single object.

[00:03:40]
User one, user two, user 400, user 1,000. Why not make them copies? Our functions are just copies. Is there a better way? We're gonna see, thank goodness, there is a better way in JavaScript. But this at least is a very intuitive, straightforward, in some essence, way. So what is a better way?

[00:04:02]

>> Speaker 5: Inheritance.
>> Will Sentance: Inheritance, everyone is shouting out words from the land of OP. Probably one of those words is gonna be correct. Maybe one of those words is gonna be correct, but how they're working? What we're gonna see today is under the hood how they're working. And I wanna stress to all of you and online, when I sit down with other senior engineers, and say what questions do you ask senior developers in interview?

[00:04:26]
One of the classic questions, and there's a great core answer, saying how can I spot a senior developer? I think this is necessarily a great way to spot a senior JavaScript developer. But the answer, top voted answer, is ask them to rebuild how the new keywords and how classes, which one of the words is shouted out, are actually working.

[00:04:48]
We're gonna see under the hood how those are actually working. It is a classic senior developer for JavaScript interview question. We're gonna go through it. We're gonna build up the different ways of achieving this fundamental goal of calling a functionality immediately on our data. But not being incredibly inefficient with space like we have been here.

[00:05:13]
That's our tension. We're gonna resolve it today. All right, so at this point we're going into pairs. After the pairing, we're gonna see how this works. What is our better way of achieving this? But it lies on the other side of the pairing. For now, folk, I think, stay in the same page you're in.

[00:05:35]
We don't need to go through these. Go to csbin.io/oop. We'll get started on pairing an oop. And we'll start to see afterwards how we can do it better. Everybody, to your pairs.

