[00:00:00]
>> Will Sentance: So before we get into how high order functions work, we are going to see a metaphor. A metaphor for why we have our high order functions in the first place. So function 10 squared, no input, returns 10x10. Sounds like a very useful functions, I'm sure you can already agree.

[00:00:17]
What is the syntax of this function, Cara? What is the wording of this function? It's a function 10 squared, no input, and returns 10x10. How do we declare the function? What's the first word to declare a function Cara? Function. Great. There it is, function. And what should we call it Cara?

[00:00:39]

>> Cara: Squared?
>> Will Sentance: Nice, Clara. And video's name, 10 squared. Does it take any parameters? Cree, any parameters for it?
>> Cree: No.
>> Will Sentance: No, correct. And then in the body of the function what do we add? Whatever return, 10x10. Such a useful function. Do you agree? No. Terribly useless function.

[00:01:08]
It's a useless function. Come on. The useless function. 10 squared evaluates to 100. Perfect. Now, what if though, here's a more useful function. 9 squared, Griffin, how would I make 9 squared.
>> Griffin: Same thing, you just change the numbers.
>> Will Sentance: Yeah. What about 100 square, Lindsey.
>> Lindsey: Same thing, you just change the numbers.

[00:01:32]

>> Will Sentance: Yeah, I know you already drag this out but what about 2,000 square?
>> Lindsey: Same thing.
>> Will Sentance: How much will it gonna drive us out? We could go a little while, we're breaking some sort of principle here, what principle are we breaking as I come up with all these functions?

[00:01:46]
What principle are we breaking here?
>> Speaker 6: Don't repeat yourself.
>> Will Sentance: Don't repeat yourself, right. As developers the reason we have functions is to wrap up some functionality that we use and we can just refer to it by it's label. And only refer to it, only write out the functionality once.

[00:02:01]
So we constantly try to avoid repeating ourselves. Not because we're lazy, but merely because we're, because it makes for a far more readable code. Far more reusable code. We don't wanna be re-writing stuff because it makes it hard. Well, this functionality's the same as here, but I'm not gonna change in both places.

[00:02:21]
This is problematic, so instead I write a, what do I do here? Right now, 9 squared, 8 squared. We've got a problem, we're breaking this dry principle. What could we do instead here? Griffin?
>> Griffin: You could do function N squared input of N.
>> Will Sentance: So tell me more abstractly.

[00:02:40]
What am I, There we go. [LAUGH] No, nobody get that pun? All right, tell me more abstractly, no, tell me more, what are we doing, what are we doing here in a sense?
>> Griffin: Well you'd be, I guess modulizing it and being able to-
>> Will Sentance: I like that.

[00:02:58]
You're making your clone more useable.
>> Griffin: Yeah you're able to call that function, any time you want a number squared.
>> Will Sentance: Very nice. That's exactly right. We are, we can generalize the function. We can create a function, we all look at it like yeah, yeah obviously we're not going to create 10 squared, 100 squared, 9.

[00:03:15]
This is the very essence of why we have higher order functions. We're going to see in a second, here, we've created a function squared num. I left a place holder, you see every now and then I realize I shouldn't be pointing up here. Because everyone online is like yeah, to the edge of my computer.

[00:03:32]

>> Cara: [LAUGH]
>> Will Sentance: Here square num function, I really just have to jolt it around to make it do that thing. Nope, there we go. All right, square num function, I left a place holder. And then it's only when I invoke, call, execute, run, that's when that function with 10, 9, 100, I get to dynamically at the same time create the function effectively 10 squared, 9 squared, and then call it at the same time.

[00:04:03]
So at my definition stage of the function. So functions have two stages, definition and execution. And my definition stage where I store the memory, I leave a place holder like I don't know yet what dates that I'm going to apply this to yet. So just leave it blank for now and I'll figure out when I run the function what actual specific number my data I'm going to apply this functionality 2.

[00:04:25]
Okay, this is making our function cleaner and more efficient. But this is obvious. It turns out, well, that's obvious. But it's fairly obvious. It turns out we may not only want to leave some of our data general until we call the function. In other words, leave a placeholder for some of our data in the definition.

[00:04:50]
And only when we run the function, determine what data I want to apply my multiply by itself functionality to. It turns out I might also want to leave a placeholder. I might want to leave for now unknown. Some of my specific functionality until I call my function. I may not just wanna say leave a placeholder for my data.

[00:05:17]
I may also wanna leave a placeholder to be determined later for some of my actual specific functionality. And then, only determine what that functionality is when I actually go ahead and call, run, the function. Here I determine my data, 10, 9, 8, when I run the function, what if I were to determine so my functionality only when I run the function.

[00:05:43]
That's very powerful. And that is what we're gonna see is the essence of higher order functions.

