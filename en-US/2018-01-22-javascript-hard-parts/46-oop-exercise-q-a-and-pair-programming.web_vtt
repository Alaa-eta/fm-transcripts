WEBVTT

1
00:00:00.750 --> 00:00:03.268
&gt;&gt; Will Sentance: We've achieved
that goal, though, or have we?

2
00:00:03.268 --> 00:00:06.760
We've achieved our basic goal, that we've
bundled up our functions that could

3
00:00:06.760 --> 00:00:12.030
be used on the user data in one user
object, user one, user two, user.

4
00:00:12.030 --> 00:00:17.970
Who can see, though, that while this
approach fundamentally solves our basic

5
00:00:17.970 --> 00:00:22.790
problem of, is my functionality going to
be available, or my data, when I need it?

6
00:00:22.790 --> 00:00:24.890
Wherever I pass that user to object,

7
00:00:24.890 --> 00:00:27.170
the functionality increment
is available on it.

8
00:00:27.170 --> 00:00:30.530
Wherever I pass a user, and by the way
there could be a thousand user objects.

9
00:00:30.530 --> 00:00:33.730
User 400, user 1000,
there could be a thousand functions.

10
00:00:34.820 --> 00:00:42.760
I could know safely in this model
that if I do user 2002.displayavatar,

11
00:00:42.760 --> 00:00:45.590
whatever the hundreds of functions
I could ever use on this function.

12
00:00:45.590 --> 00:00:48.820
I'll know, don't worry it'll be there.

13
00:00:48.820 --> 00:00:52.440
So I've achieved that goal,
which we've said is our fundamental goal.

14
00:00:52.440 --> 00:00:53.670
Let's have thumbs on this.

15
00:00:53.670 --> 00:00:55.000
I don't know what happened.

16
00:00:55.000 --> 00:00:57.000
I'm going to need clarification.

17
00:00:57.000 --> 00:00:57.730
I'm clear to go on.

18
00:00:57.730 --> 00:00:58.580
Everyone's thumbs out.

19
00:01:00.180 --> 00:01:04.650
Anyone see any issue with this approach?

20
00:01:04.650 --> 00:01:06.859
Yeah, Dave?
&gt;&gt; Dave: If you're gonna update

21
00:01:06.859 --> 00:01:11.109
the functionality, you have to go-
&gt;&gt; Will Sentance: Yeah, that's good one,

22
00:01:11.109 --> 00:01:12.421
that's a really good one.

23
00:01:12.421 --> 00:01:15.176
So, maintenance of this is
a bit of a pain, right?

24
00:01:15.176 --> 00:01:20.440
Because, I can't go adding
to all my user objects.

25
00:01:20.440 --> 00:01:21.810
Because I've already generated them,

26
00:01:21.810 --> 00:01:26.660
and they were created inside
of this individual function.

27
00:01:26.660 --> 00:01:29.130
Andrew, what do you see as a problem?
&gt;&gt; Andrew: If you have thousands of users,

28
00:01:29.130 --> 00:01:31.150
you have to have different
variable names for

29
00:01:31.150 --> 00:01:32.415
everyone.
&gt;&gt; Will Sentance: Okay, but

30
00:01:32.415 --> 00:01:35.394
that's sort of inherent,
cuz you're pointing to different labels.

31
00:01:35.394 --> 00:01:36.944
Then you can sort them in an array or
something like that.

32
00:01:36.944 --> 00:01:41.330
But ultimately, and they've all gotta
have their own space for their own data.

33
00:01:41.330 --> 00:01:43.960
Yeah, what do you think, Griffin?
&gt;&gt; Griffin: Any functions that then would

34
00:01:43.960 --> 00:01:48.610
call those user functions,
since it's user one,

35
00:01:48.610 --> 00:01:51.790
it's not generic enough just to
be able to call it end user.

36
00:01:51.790 --> 00:01:53.160
You'd have to make a function for

37
00:01:53.160 --> 00:01:55.570
each user.
&gt;&gt; Will Sentance: You're getting so

38
00:01:55.570 --> 00:01:56.750
close there, right?

39
00:01:56.750 --> 00:01:59.720
So you're saying something like,

40
00:01:59.720 --> 00:02:04.870
this increment function is
a new version for every single.

41
00:02:04.870 --> 00:02:08.010
But the problem with that
is on my genericness.

42
00:02:08.010 --> 00:02:11.920
The problem with that is,
suppose I have a thousand functions

43
00:02:11.920 --> 00:02:15.540
that have been declared inside
of what I call user creator.

44
00:02:15.540 --> 00:02:18.880
They get attached to the new user
which then gets stored in user one.

45
00:02:18.880 --> 00:02:21.620
This is another brand new user object
with all those functions again.

46
00:02:22.710 --> 00:02:24.730
All my data is unique in each user.

47
00:02:24.730 --> 00:02:27.610
But these functionality is
increment function here,

48
00:02:27.610 --> 00:02:30.660
does it need to be a brand
new version versus this one?

49
00:02:30.660 --> 00:02:34.059
What if I have a thousand functions, each
with a hundred lines of code in them, and

50
00:02:34.059 --> 00:02:35.590
then a thousand users?

51
00:02:35.590 --> 00:02:38.719
I'm getting a thousand,
times by a hundred,

52
00:02:38.719 --> 00:02:43.950
times by a thousand sort of lines of code
just to describe the same functions.

53
00:02:45.070 --> 00:02:49.350
If I have a thousand functions,
I wanna be able to use all my users.

54
00:02:49.350 --> 00:02:53.410
And I copy them across every single user,
that's filling in memory.

55
00:02:53.410 --> 00:02:54.880
That's saying declare this function.

56
00:02:54.880 --> 00:02:56.330
Store it in the user.

57
00:02:56.330 --> 00:02:59.150
This is an actual copy of
the function increment

58
00:02:59.150 --> 00:03:01.050
that's attached to the user object.

59
00:03:01.050 --> 00:03:03.930
If it's a thousand of those functions,
and then on here,

60
00:03:03.930 --> 00:03:07.915
an actual brand new copy of that function
increment, it's actually User 1.

61
00:03:07.915 --> 00:03:10.520
Griffin, is that going
to be good on my memory?

62
00:03:10.520 --> 00:03:12.600
That is absolutely unusable.

63
00:03:13.680 --> 00:03:15.440
This approach may be simple.

64
00:03:17.400 --> 00:03:19.970
It's simple, but
it has a fundamental problem.

65
00:03:19.970 --> 00:03:24.650
Each time we create a new user, we make
space in our computer's memory, but

66
00:03:24.650 --> 00:03:28.320
all our data and functions.

67
00:03:28.320 --> 00:03:29.200
Data, no problem.

68
00:03:29.200 --> 00:03:33.764
Yeah, name, will_3, I've got to create
a brand new space in memory for

69
00:03:33.764 --> 00:03:36.220
name will_3, name tim_5.

70
00:03:36.220 --> 00:03:40.090
But my functions,
they're the same on every single object.

71
00:03:40.090 --> 00:03:42.420
User one, user two, user 400, user 1,000.

72
00:03:42.420 --> 00:03:43.580
Why not make them copies?

73
00:03:43.580 --> 00:03:46.010
Our functions are just copies.

74
00:03:46.010 --> 00:03:46.980
Is there a better way?

75
00:03:46.980 --> 00:03:53.520
We're gonna see, thank goodness,
there is a better way in JavaScript.

76
00:03:53.520 --> 00:03:59.770
But this at least is a very intuitive,
straightforward, in some essence, way.

77
00:03:59.770 --> 00:04:03.910
So what is a better way?
&gt;&gt; Speaker 5: Inheritance.

78
00:04:03.910 --> 00:04:04.550
&gt;&gt; Will Sentance: Inheritance,

79
00:04:04.550 --> 00:04:06.600
everyone is shouting out
words from the land of OP.

80
00:04:06.600 --> 00:04:10.010
Probably one of those
words is gonna be correct.

81
00:04:10.010 --> 00:04:13.000
Maybe one of those words is gonna be
correct, but how they're working?

82
00:04:13.000 --> 00:04:16.144
What we're gonna see today is under
the hood how they're working.

83
00:04:16.144 --> 00:04:21.360
And I wanna stress to all of you and
online, when I sit down with other senior

84
00:04:21.360 --> 00:04:26.300
engineers, and say what questions do
you ask senior developers in interview?

85
00:04:26.300 --> 00:04:29.930
One of the classic questions,
and there's a great core answer,

86
00:04:29.930 --> 00:04:32.830
saying how can I spot a senior developer?

87
00:04:32.830 --> 00:04:36.640
I think this is necessarily a great way
to spot a senior JavaScript developer.

88
00:04:36.640 --> 00:04:43.390
But the answer, top voted answer, is ask
them to rebuild how the new keywords and

89
00:04:43.390 --> 00:04:47.080
how classes, which one of the words
is shouted out, are actually working.

90
00:04:48.300 --> 00:04:51.980
We're gonna see under the hood
how those are actually working.

91
00:04:51.980 --> 00:04:56.710
It is a classic senior developer for
JavaScript interview question.

92
00:04:56.710 --> 00:04:58.100
We're gonna go through it.

93
00:04:58.100 --> 00:05:03.210
We're gonna build up the different ways
of achieving this fundamental goal

94
00:05:03.210 --> 00:05:08.520
of calling a functionality
immediately on our data.

95
00:05:08.520 --> 00:05:13.670
But not being incredibly inefficient
with space like we have been here.

96
00:05:13.670 --> 00:05:14.830
That's our tension.

97
00:05:14.830 --> 00:05:17.020
We're gonna resolve it today.

98
00:05:17.020 --> 00:05:21.960
All right, so
at this point we're going into pairs.

99
00:05:21.960 --> 00:05:27.230
After the pairing,
we're gonna see how this works.

100
00:05:27.230 --> 00:05:29.550
What is our better way of achieving this?

101
00:05:29.550 --> 00:05:32.400
But it lies on the other
side of the pairing.

102
00:05:32.400 --> 00:05:35.396
For now, folk, I think,
stay in the same page you're in.

103
00:05:35.396 --> 00:05:36.609
We don't need to go through these.

104
00:05:36.609 --> 00:05:39.988
Go to csbin.io/oop.

105
00:05:39.988 --> 00:05:41.485
We'll get started on pairing an oop.

106
00:05:41.485 --> 00:05:44.881
And we'll start to see afterwards
how we can do it better.

107
00:05:44.881 --> 00:05:46.591
Everybody, to your pairs.

