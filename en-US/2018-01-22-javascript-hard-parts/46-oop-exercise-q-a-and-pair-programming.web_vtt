WEBVTT

1
00:00:00.750 --> 00:00:03.285
&gt;&gt; Will Sentance: We've achieved
our goal though or, have we?

2
00:00:03.285 --> 00:00:08.082
We've achieved our basic goal that we've
bundled up our functions that could

3
00:00:08.082 --> 00:00:12.030
be used on the user data,
in one user object, user1, user2.

4
00:00:12.030 --> 00:00:17.510
Who can see, though, that while this
approach fundamentally solves our basic

5
00:00:17.510 --> 00:00:22.849
problem of, is my functionality gonna
be available on my data when I need it?

6
00:00:22.849 --> 00:00:24.616
Wherever I pass that user2 object,

7
00:00:24.616 --> 00:00:27.170
the functionality increment
is available on it.

8
00:00:27.170 --> 00:00:30.471
Wherever I pass a user, and by the way,
there could be 1000 user objects..

9
00:00:30.471 --> 00:00:33.989
User400, user1000,
there could be 1000 functions.

10
00:00:33.989 --> 00:00:40.387
I can be doing, I can know safely in this
model that if I do user2002.displayAvatar,

11
00:00:40.387 --> 00:00:45.570
whatever of 100 of functions that
I can never use in this function.

12
00:00:45.570 --> 00:00:48.790
I'll know, don't worry it will be there.

13
00:00:48.790 --> 00:00:52.440
So I've achieved that goal,
which we said is our fundamental goal.

14
00:00:52.440 --> 00:00:54.216
Let's have thumbs on this.

15
00:00:54.216 --> 00:00:57.730
I don't know what happened, I'm got
a clarification, I'm clear to go on.

16
00:00:57.730 --> 00:01:02.234
Everyone's thumb out,
anyone see any issue?

17
00:01:02.234 --> 00:01:04.561
With this approach?

18
00:01:04.561 --> 00:01:07.072
Yeah, Dave.

19
00:01:07.072 --> 00:01:09.890
&gt;&gt; Dave: If you're gonna update the
functionality, you have to go [CROSSTALK]?

20
00:01:09.890 --> 00:01:12.414
&gt;&gt; Will Sentance: Yeah, that's a good one,
that's a really good one.

21
00:01:12.414 --> 00:01:15.177
So maintenance of this is a bit of a pain,
right?

22
00:01:15.177 --> 00:01:20.605
Because I can't go adding to all my
user objects because I've already

23
00:01:20.605 --> 00:01:26.601
generated them, and they were created
inside of this individual function.

24
00:01:26.601 --> 00:01:27.859
Andrew, what do you think is the problem?

25
00:01:27.859 --> 00:01:31.458
&gt;&gt; Andrew: If you have 1000 of users you
have to have different variable names for

26
00:01:31.458 --> 00:01:32.047
every one?

27
00:01:32.047 --> 00:01:32.673
&gt;&gt; Will Sentance: Okay, well but

28
00:01:32.673 --> 00:01:35.450
that's sort of inherent cuz you
are pointing at different labels.

29
00:01:35.450 --> 00:01:38.312
Now you can store them in an array or
something like that ultimately.

30
00:01:38.312 --> 00:01:41.124
But they all have to have their
own space for their own data,

31
00:01:41.124 --> 00:01:42.427
what do you think Griffin?

32
00:01:42.427 --> 00:01:46.530
&gt;&gt; Dave: Any functions that would
then call those user functions.

33
00:01:46.530 --> 00:01:48.510
They would, it says it's user1,

34
00:01:48.510 --> 00:01:51.819
it's not generic enough just to
be able to call it end user.

35
00:01:51.819 --> 00:01:54.866
You have to make a function for each user.

36
00:01:54.866 --> 00:01:56.750
&gt;&gt; Will Sentance: You're getting so
close there, right?

37
00:01:56.750 --> 00:01:59.682
So you're saying something like,

38
00:01:59.682 --> 00:02:04.578
this increment function is
a new version for every single.

39
00:02:06.232 --> 00:02:08.961
&gt;&gt; Will Sentance: But the problem
from that from the generic list,

40
00:02:08.961 --> 00:02:12.356
the problem with that is
suppose I have 1,000 functions

41
00:02:12.356 --> 00:02:15.699
that are being declared inside
of when I call userCreator.

42
00:02:15.699 --> 00:02:18.823
Get attached to the new user and
get stored in user1.

43
00:02:18.823 --> 00:02:22.609
This is another brand new user object
with all those functions again.

44
00:02:22.609 --> 00:02:26.055
All my data's unique in each user,
but these functionality,

45
00:02:26.055 --> 00:02:30.621
is increment function here, does it need
to be a brand new version versus this one?

46
00:02:30.621 --> 00:02:34.349
What if I have a 1000 functions,
each with a 100 lines of code in them and

47
00:02:34.349 --> 00:02:35.490
then a 1000 users.

48
00:02:35.490 --> 00:02:40.328
I'm getting a 1000 times
by a 100 times by a 1000

49
00:02:40.328 --> 00:02:44.994
of the lines of code just to
describe the same functions.

50
00:02:44.994 --> 00:02:49.136
If I have a 1000 functions I wanna
be able to use on my users and

51
00:02:49.136 --> 00:02:53.454
I copy them across every single user,
that's filling in memory.

52
00:02:53.454 --> 00:02:56.330
That's saying declare this function,
store it in the user.

53
00:02:56.330 --> 00:02:59.391
This is the actual copy of
the function increment that's

54
00:02:59.391 --> 00:03:00.993
attached to the user object.

55
00:03:00.993 --> 00:03:04.018
If it's a 1000 of those functions,
and then on here,

56
00:03:04.018 --> 00:03:08.119
an actual brand new copy of that
function increment, it's actually user1.

57
00:03:08.119 --> 00:03:10.495
Griffin, is that gonna
be good on my memory?

58
00:03:10.495 --> 00:03:13.637
That is absolutely unusable.

59
00:03:13.637 --> 00:03:17.302
This approach may be simple.

60
00:03:17.302 --> 00:03:19.909
It's simple, but
it has a fundamental problem.

61
00:03:19.909 --> 00:03:22.423
Each time we create a new user,

62
00:03:22.423 --> 00:03:28.238
we make space in our computer's memory for
all our data and functions.

63
00:03:28.238 --> 00:03:30.765
Data, no problem, yeah,
like name, Will, score, 3.

64
00:03:30.765 --> 00:03:34.442
I've gotta create a brand new space
in memory for name Will, score, 3.

65
00:03:34.442 --> 00:03:40.073
Name Tim, score 5, but my functions,
they're the same on every single object.

66
00:03:40.073 --> 00:03:44.837
User1, User2, User400, User1000,
why am I making copies?

67
00:03:44.837 --> 00:03:47.080
Our function just copy,
is there a better way?

68
00:03:48.925 --> 00:03:50.137
&gt;&gt; Will Sentance: We're gonna see,

69
00:03:50.137 --> 00:03:53.483
thank goodness there is
a better way in JavaScript.

70
00:03:53.483 --> 00:03:59.153
But this at least is a very intuitive
straight forward in some essence way,

71
00:03:59.153 --> 00:04:01.049
but what is a better way?

72
00:04:01.049 --> 00:04:03.728
&gt;&gt; [INAUDIBLE]
&gt;&gt; Dave: Inheritance?

73
00:04:03.728 --> 00:04:05.914
&gt;&gt; Will Sentance: Inheritance
everyone's is shouting out,

74
00:04:05.914 --> 00:04:07.219
words from the land of OP.

75
00:04:07.219 --> 00:04:08.459
&gt;&gt; Dave: [LAUGH]
&gt;&gt; Will Sentance: Probably one

76
00:04:08.459 --> 00:04:10.997
of those words is gonna be correct, maybe.

77
00:04:10.997 --> 00:04:13.349
One of those words is gonna be correct,
but how are they working?

78
00:04:13.349 --> 00:04:16.154
What we're going to see today is
under the hood, how they're working.

79
00:04:16.154 --> 00:04:21.096
And I wanna stress to all of you and
online, when I sit down with other

80
00:04:21.096 --> 00:04:24.934
Senior Engineers and
say what questions do you ask?

81
00:04:24.934 --> 00:04:29.072
Senior Developers in interview,
one of the classic questions, and

82
00:04:29.072 --> 00:04:33.222
it has a great core answer,
saying how can I spot a Senior Developer?

83
00:04:33.222 --> 00:04:36.688
I don't think it's necessarily, a great
way to spot a senior java developer.

84
00:04:36.688 --> 00:04:42.220
But the top voted answer is ask them
to rebuild how the new key word and

85
00:04:42.220 --> 00:04:48.257
how classes which one of the words we
shouted out, are actually working.

86
00:04:48.257 --> 00:04:51.939
We're going to see under the hood
how those are actually working.

87
00:04:51.939 --> 00:04:56.659
It is a classic Senior Developer for
JavaScript interview question.

88
00:04:56.659 --> 00:04:58.687
We're gonna go through it,

89
00:04:58.687 --> 00:05:03.757
we're gonna build up the different
ways of achieving this fundamental

90
00:05:03.757 --> 00:05:08.501
goal of calling our functionality
a vate immediately on our data.

91
00:05:08.501 --> 00:05:13.631
But, not being incredibly inefficient
with space, like we have been here.

92
00:05:13.631 --> 00:05:17.013
That's our attention,
we're gonna resolve it today.

93
00:05:17.013 --> 00:05:21.866
All right, so at this point,
we're gonna end the pairs.

94
00:05:21.866 --> 00:05:27.200
After the pairing,
we're gonna see, how this works?

95
00:05:27.200 --> 00:05:29.510
What is our better way of achieving this?

96
00:05:29.510 --> 00:05:32.439
But, it lies on the other
side of the pairing.

97
00:05:32.439 --> 00:05:35.289
For now folk,
I think staying the same page we're in.

98
00:05:35.289 --> 00:05:40.034
We don't need to go through this,
go to csbin.io/oop.

99
00:05:40.034 --> 00:05:42.116
We'll get started on pairing an OOP, and

100
00:05:42.116 --> 00:05:44.860
we'll start to see afterwards
how we can do it better.

101
00:05:44.860 --> 00:05:46.591
Everybody, to your pairs.

