[00:00:00]
>> Will Sentance: Okay, so at this point, we are already feeling, yeah, thank you so much. I could tell straightaway that calling multiplyBy2(4) was going to return 8 into output. Why have I built all this for that? Well, because there's even more still that was going on behind the scenes here that we need to know.

[00:00:20]
Such that the hard bits follow more easily, and it's known as our, well, what? What is the way we've got these execution contacts being created? One here, this one we said, closed, actually now, this one we said, closed. And already I'm already kind of struggling to keep track of it, am I in the global one, am I in this?

[00:00:39]
What if I ran another function inside of multiplyBy2? What if I ran multiplyBy2 recursively? Inside of here, I ran multiplyBy2 and then inside of that I ran multiplyBy2. How I'm I gonna keep track of all these? Where I'm I in my execution? Which function I'm I inside at the moment?

[00:00:57]
How can I keep track of it? Griffin?
>> Griffin: Is it the state?
>> Will Sentance: State, Amin?
>> Amin: Call stack.
>> Will Sentance: Call stack, Amin is spot on. It's called the call stack, call stack. There it is, and it's a special data structure. That just means a way of storing information, of storing data.

[00:01:22]
Special data structure that allows us to track where am I currently? Where is JavaScript currently? Where is the thread of execution currently in my code? Am I running through line one, line two, line three, global land, global execution context? Am I running inside of a code to multiplyBy2?

[00:01:47]
The first one or the second? Okay, so it keeps track of it, what does it add immediately when it starts running my code? Whatâ€™s the first execution context on my call stack, Art?
>> Will Sentance: Dave, what's the first one on my call stack? Or which one do we start in, Art?

[00:02:05]
Where do we start in our code, Griffin?
>> Griffin: Global?
>> Will Sentance: Global, so that's the very first one we add, is our global execution context, okay? Now, Shelby, I hit the line multiplyBy2 being called with the input of 4. What happens to my call stack, do you think, Shelby, at that point?

[00:02:29]

>> Shelby: It goes to local.
>> Will Sentance: It goes to local. So what does that mean, Amin, in terms of my actual call stack? So we said when we entered we added global to the call sack. Let me just tell you what that means. Whatever is top of the call stack, is where JavaScript's thread, where it currently is running my code.

[00:02:50]
Whatever is top, so JavaScript never has to worry where am I? Where am I in the code right now? Whatever is top of the call stack, that's where I am. And a stack is a very good way of storing this, because when I start calling multiplyBy2(4), I add it to the top of the call stack.

[00:03:12]
And the stack is a data structure of the format the last thing you put into it is the first thing you take out of it. So when I add multiplyBy2 onto top of global, that means I've started running multiplyBy2. When I finish running multiplyBy2, I close that execution context, I go back to global.

[00:03:36]
What happens to my multiplyBy2 on top of the call stack, Andrea?
>> Andrea: It goes away.
>> Will Sentance: Goes away. Because it was the last thing that was put in. So it's the first thing that gets taken out. So this is a great format for tracking our execution context and where we are in our code.

[00:03:53]
Because as soon as I start writing a function, I go inside. When I finish it, I close that one out. So I created and then it's inevitably the next one I take off, the next one I remove. So last in, first out. It's a stack of calls to functions.

[00:04:08]
Starts global and then we add multiplyBy2(4). And what's the posh name for adding to a stack? Who knows what the fancy, technical name for adding to a stack is? Andrew? Anyone know?
>> Clara: Pushing.
>> Will Sentance: Pushing. Clara is right. We push onto the stack and now we're inside multiplyBy2.

[00:04:28]
When I finish executing multiplyBy2 and I return out, how do I know I finished executing a function? Return. What if it doesn't say return, just a closing curly brace means implicit return. And the implicit return defaults to returning what, if I don't write the word return, what do I default to?

[00:04:46]
Muhammad?
>> Muhammed: The value?
>> Will Sentance: What's the default, Griffin, return value of a function if I don't return something explicitly? Clara?
>> Clara: Undefined.
>> Will Sentance: Undefined, correct, exactly. So out I come and I go back into, so out I come and this execution context gets removed, erased, deleted. Well, so that gets taken off the call stack and we go back to global.

[00:05:13]
And what's the posh term for being taken off of call stack? Remove from the stack, Clara?
>> Clara: Popping?
>> Will Sentance: Popping. I popped the call to multiplyBy2 off the call stack and where do I go? JavaScript says, where do I go next? We may think, Griffin, I asked you if you finished running multiplyBy2, we go back into global but JavaScript doesn't know that by default.

[00:05:31]
It only knows that because look at that. It got rid of the call to multiplyBy2 and where did it go back to? What's top of the call stack now?
>> Griffin: Global.
>> Will Sentance: Global. So now it knows to go back there. But wait, the next line says, spin up a new execution context because of the parens.

[00:05:46]
Parens say make a execution context so at this point, what's gonna happen to my call stack, Dave?
>> Dave: Sorry, I was writing this down and wasn't listening.
>> Will Sentance: So what's gonna happen when I start calling multiplyBy2? What's gonna happen to my call stack, Dave?
>> Dave: The local's gonna go to the top of the call stack.

[00:06:04]

>> Will Sentance: Very good job, Dave. Very nice. I'm gonna add the execution context, the call to multiplyBy2(10) to my call stack. There it is, top of the call stack. All right, then I finish running the call to multiplyBy2, Mathew, what happens to my call stack? I've finished running multiplyBy2(10), what happens to my call stack?

[00:06:30]

>> Matthew: Local is removed, global is-
>> Will Sentance: Is left. And therefore is top of the call stack.
>> Matthew: Right.
>> Will Sentance: And therefore we know that is where our code is now running. Okay, folk, when you execute a function, you create a new execution context. It comprises the thread. We go through the code inside the function, line by line, by line, by line.

[00:06:55]
And a local memory, where anything defined inside the function is stored there, not in global. Anything defined inside the function, do we store results in global? No, we store it in the local memory. By the way, we store in the local memory because the call to multiplyBy2, that execution context was top of the call stack, perfect.

[00:07:18]
This top of the call stack means that's where my thread is and that's where I'm storing myself in memory. Top of the call stack means everything. And when we finish running multiplyBy2(4), we jump back out to global and we pop off the call to multiplyBy2 from the stack, okay?

[00:07:37]
This call stack let's us keep track of all these execution context. We have the global one to start. Now this little baby one here, for the running and multiplyBy2. And then we go back to global, and we do another little baby one here for running multiplyBy2 again, okay?

[00:07:53]
This local memory by the way has a very fancy name. Anyone know what the fancy name for the local memory is, Shelby?
>> Will Sentance: I mean, it's only a knowledge question, you should know this. It's called a variable environment. I like that name, I guess, because it's like the environment of available variables, sort of, the environment stuff around you.

[00:08:16]
It's the available variables around you, it's the available data. This is live data stored in memory. Sitting there, live in memory, stored inside the running and multiplyBy2.

