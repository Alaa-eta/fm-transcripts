[00:00:00]
>> Will Sentance: Okay, so at this point we are already feeling, yeah, thank you so much. I could tell straight away that calling multiplied by 2 is the input of 4 was going to return 8 into output. Why have I built all this for that? Well because there is even more still that was going on behind the scenes here that we need to know.

[00:00:20]
So actually the hard bits follow more easily. And it's known as our well, what? What is the way? We've got these execution contexts being created, one here. This one we said closed or actually now this one we said closed. And already I'm kinda struggling to keep track of it.

[00:00:37]
Am I in the global one? Am I in this? What if I ran another function inside or multiply by 2. What if I ran multiply by 2 recursively? Inside of here I ran multiplied by 2 and then inside of that, I ran my multiplied by 2. How am I gonna keep track of all these where am I in my execution?

[00:00:54]
Which function am I inside of at the moment? How can I keep track of it? Christian?
>> off screen male: Is that the state?
>> Will Sentance: The state. Amin?
>> off screen male: Call Stack.
>> Will Sentance: Call Stack, Amin is spot on, it's called the Call Stack. Call Stack, there it is. And it's a special data structure, that just means a way of storing information, of storing data.

[00:01:22]
Special data structure that allows us to track where am I currently, where is JavaScript currently, where is the thread of execution currently in my code? Am I running through line 1, line 2, line 3? Global and global execution context. Am I running inside of a call to multiply by 2?

[00:01:46]
The first one or the second one. Okay, so he keeps track of it. What does it add immediately when it starts running my code? What's the first execution context on my Call Stack? Art.
>> Will Sentance: Dave, what's the first one in my Call Stack? Or which one do we start in, Art?

[00:02:05]
Where do we start in our code, Griffin?
>> off screen male: Global?
>> Will Sentance: Global, so that's the very first one we add, is our global execution context. Okay, now, Shelby, I hit the line multiplied by 2 being called with the input of 4. What happens to my Call Stack do you think Shelby me at that point?

[00:02:30]

>> off screen female: It goes to local.
>> Will Sentance: It goes to local. So what does that mean, I mean in terms of my actual Call Stack? So we said when we entered we added global to the Call Stack. Let me just tell you what that means. Whatever is top of the Call Stack is where JavaScripts thread, where it currently is running my code.

[00:02:50]
Whatever is top. So JavaScript never has to worry where am I. Where am I in the code right now? Whatever is top of the Call Stock, that's where I am. And then stock is a very good way of storing this because when I start calling multiply by 2 in the input of 4, I added to the top of the Call Stock.

[00:03:12]
And this stock is a data structure of the format the last thing you put into it is the first thing you take out of it. So when I am multiplied by 2 onto top of global, that means I've started running multiply by 2. When I've finished running multiply by 2, I close that execution context, I go back to global.

[00:03:36]
What happens to my multiply by 2 on top of the Call Stack, Andrea?
>> off screen female: It goes away.
>> Will Sentance: Goes away. Because it was the last thing that was put in. So it's the first thing that gets taken out. So this is a great format for tracking our execution context and where we are in our code, because as soon as I start running a function, I go inside.

[00:03:55]
When I finish it, I close that one out. So I create it and then it's inevitably the next one I take off the next one I remove. So last in, first out. It's a stack of calls to functions. Starts global and then we add multiply by 2 with the input of 4.

[00:04:12]
And what's the posh name for adding to a stack? Who knows what the fancy, technical name for adding to a stack is, Andrew? Anyone know?
>> off screen female: Pushing.
>> Will Sentance: Pushing, Claire is is right. We push on to the stack, and now we're inside, multiply by 2. When I finish executing multiply by 2, and I return out, how do I know I finished executing a function?

[00:04:34]
Return, what if it doesn't say return? Just the closing curly brace means implicit return. And the implicit return defaults to returning what? If I don't write the word return, what do I default to, Mohammad?
>> off screen male: On the value.
>> Will Sentance: What's the default, Griffin, return value of a function if I don't return something explicity.

[00:04:55]
Clara?
>> off screen female: Undefined.
>> Will Sentance: Undefined, correct, exactly. So out I come and I go back into, so out of com and this execution context gets removed, erased, deleted. So that gets taken off the Call Stack and we go back to global. And what's the posh term for being taken off of Call Stack?

[00:05:16]
Remove from a stack. Clara?
>> off screen female: Popping.
>> Will Sentance: Popping, I popped the call to mode 102 off the Call Stack, and where do I go? Charles goes, where do I go next? We may think, Griffin, I offered you, we finished one in mode 102, we go back into the global, but Jarvis doesn't know that by default, it only knows that because, look at that, it got rid of the quarter multiplied by 2 and where does it go back to?

[00:05:37]
What's top of the Call Stack now?
>> off screen male: Global.
>> Will Sentance: Global. So now it knows to go back there, but wait, the next slide says spin up a new exhusion context because the parens. Parens say make execution context, so at this point, what's gonna happen to my Call Stack, Dave?

[00:05:54]

>> off screen male: Sorry, I was writing this down and wasn't listening.
>> Will Sentance: So what's gonna happen when I started calling multiply by 2, what's gonna happen to my Call Stack, Dave?
>> off screen male: The local's gonna go to the top of the Call Stack?
>> Will Sentance: Very good job, Dave Very nice, I'm gonna add the execution context, the call to multiply by 2 at the input of 10 to my Call Stack.

[00:06:15]
There it is, top of the Call Stack. All right, then I finish running The call to most probably two. Matthew what happens to my Call Stack? I finished running multiply by 2 and into 10. What is my Call Stack?
>> off screen male: Local is removed, global list.
>> Will Sentance: It's left and is therefore
>> off screen male: Right.

[00:06:36]

>> Will Sentance: And therefore we know that is where our code is now running. Okay, folks, when you execute a function you create a new execution context. It comprises the thread. We go through the code inside the function line by line by line by line. And a local memory where anything defined inside the function is stored there not in global.

[00:07:04]
Anything defined inside the function, did we store results in global? No, we stored it in the local memory. By the way, we store in local memory because the call to multiply by 2, that execution context was top of the Call Stack. Perfect. This top of the call stack means that's where my thread is and that's why I'm storing myself in memory.

[00:07:24]
Top of the Call Stack means everything. And when we finish running multiple by 2, we put a 4, we jump back out to global, and we pop off the call to multiple by 2 from the stack, okay. This Call Stack lets us keep track of all these execution contexts.

[00:07:41]
We have the global one to start. There's a little baby one here, for the running of multiply by 2. Then, we have another. Then, we go back to global. Then, we do another baby one here for running multiply by 2 again. Okay, this local memory, by the way, has a very fancy name.

[00:07:57]
Anyone know what the fancy name for the local memory is? Shelby?
>> Will Sentance: I mean it's only a knowledge question if you know this. It's called a variable environment. I like that name I guess because it's like the environment of available, sort of the environment is the stuff around you.

[00:08:16]
It's the available variables around you. It's the available data. This is live data stored in memory, sitting there, live in memory, stored inside the running of multiply by 2.

