WEBVTT

1
00:00:00.000 --> 00:00:02.380
&gt;&gt; Will Sentance: Folk, we're gonna
work through this line by line.

2
00:00:02.380 --> 00:00:06.510
This is our final function for
our higher order functions.

3
00:00:06.510 --> 00:00:09.616
So we're gonna walk through this
line by line and to kick us off.

4
00:00:09.616 --> 00:00:13.870
Muhammad, line one.

5
00:00:13.870 --> 00:00:15.710
This is a mistake.

6
00:00:15.710 --> 00:00:18.680
Muhammad line one,
what are we doing Muhammad.

7
00:00:18.680 --> 00:00:22.250
Talk me through the line
one of this set of code.

8
00:00:23.660 --> 00:00:25.960
&gt;&gt; Speaker 2: Declaring a function called

9
00:00:27.400 --> 00:00:30.100
copyArrayAndManipulate.
&gt;&gt; Will Sentance: Perfect, thank you,

10
00:00:30.100 --> 00:00:31.890
man, CopyArrayManipulate.

11
00:00:31.890 --> 00:00:33.840
And of course, we're at a global level,
right, aren't we?

12
00:00:33.840 --> 00:00:34.850
We're not inside a function.

13
00:00:34.850 --> 00:00:37.017
So where's that being stored, Byron?
&gt;&gt; Speaker 2: In the global memory?

14
00:00:37.017 --> 00:00:38.680
&gt;&gt; Will Sentance: In the global memory,

15
00:00:38.680 --> 00:00:39.650
there it is.

16
00:00:39.650 --> 00:00:42.540
I wanna draw it as a function box and
f function.

17
00:00:42.540 --> 00:00:44.080
The whole description, okay.

18
00:00:44.080 --> 00:00:48.010
Next line is what, Shelby?
&gt;&gt; Speaker 3: Declaring the function

19
00:00:48.010 --> 00:00:50.398
multiplied by 2.
&gt;&gt; Will Sentance: There it is,

20
00:00:50.398 --> 00:00:52.131
multiplied by 2.

21
00:00:52.131 --> 00:00:57.802
As a little baby function that
only takes in a single what?

22
00:00:57.802 --> 00:01:01.890
A little baby function,
it only takes in a single

23
00:01:04.140 --> 00:01:06.350
Element, and then multiplies it by two.

24
00:01:06.350 --> 00:01:08.240
Little baby function, there it is.

25
00:01:08.240 --> 00:01:10.810
And let's just highlight it slightly so

26
00:01:10.810 --> 00:01:15.620
we know which function it is,
and if I were Shelby, in the line

27
00:01:15.620 --> 00:01:19.700
after that definition declaration
mobile if I were to console .log.

28
00:01:19.700 --> 00:01:20.620
That's why I do that.

29
00:01:20.620 --> 00:01:21.430
If I were to do this.

30
00:01:21.430 --> 00:01:24.895
console.log multiply by two, never ends.

31
00:01:24.895 --> 00:01:29.708
What would this display
on my console Shelby?

32
00:01:29.708 --> 00:01:32.863
Let's make sure we're really clear.

33
00:01:32.863 --> 00:01:37.486
What would this display on my console?
&gt;&gt; Speaker 3: Undefined.

34
00:01:37.486 --> 00:01:39.050
&gt;&gt; Will Sentance: Undefined?

35
00:01:39.050 --> 00:01:40.781
What have we stored and multiplied by two?

36
00:01:40.781 --> 00:01:44.064
So obviously you go and
look in memory C multiplied by two,

37
00:01:44.064 --> 00:01:45.270
what's the C?
&gt;&gt; Speaker 2: Whole function?

38
00:01:45.270 --> 00:01:46.505
&gt;&gt; Will Sentance: The whole function

39
00:01:46.505 --> 00:01:47.434
definition.

40
00:01:47.434 --> 00:01:49.831
So if I were to console all
the work multiplied by two,

41
00:01:49.831 --> 00:01:51.228
what would I see in my console?

42
00:01:51.228 --> 00:01:52.886
Howard?
&gt;&gt; Speaker 2: Just the whole function.

43
00:01:52.886 --> 00:01:53.503
&gt;&gt; Will Sentance: The whole

44
00:01:53.503 --> 00:01:55.050
function definition.

45
00:01:55.050 --> 00:01:57.950
It is, multiply by two is a label for
my whole function description.

46
00:01:57.950 --> 00:02:02.466
Okay, okay it is the whole
function definition.

47
00:02:02.466 --> 00:02:07.132
Meaning, if I then pass,
multiply by two in, two instructions.

48
00:02:07.132 --> 00:02:10.036
I'm not passing undefined in.

49
00:02:10.036 --> 00:02:15.160
I'm not running copy,
manipulate with multiply by two is action

50
00:02:15.160 --> 00:02:20.480
to find no its going to literally
be the whole function definition.

51
00:02:20.480 --> 00:02:25.038
Being pathed in to replace the place
holder word, instructions.

52
00:02:25.038 --> 00:02:28.648
All right, so
now we've declared CopyArrayAndManipulate,

53
00:02:28.648 --> 00:02:32.267
declared multiplyBy2,
what's the next line tell her to do?

54
00:02:32.267 --> 00:02:35.870
Matthew, what's the final
line on the left hand side

55
00:02:35.870 --> 00:02:36.560
say?
&gt;&gt; Speaker 2: Let results.

56
00:02:36.560 --> 00:02:37.743
&gt;&gt; Will Sentance: Which is saying?

57
00:02:37.743 --> 00:02:40.560
Give javascript label results.

58
00:02:40.560 --> 00:02:41.520
Right?
&gt;&gt; Speaker 2: Right.

59
00:02:41.520 --> 00:02:42.028
&gt;&gt; Will Sentance: Good.

60
00:02:42.028 --> 00:02:46.080
And Matthew, do we know what's going to be

61
00:02:46.080 --> 00:02:49.170
stored, Matthew, in result yet?
&gt;&gt; Speaker 2: No.

62
00:02:49.170 --> 00:02:50.050
&gt;&gt; Will Sentance: No, because we've got to

63
00:02:50.050 --> 00:02:52.030
go run that function.

64
00:02:52.030 --> 00:02:55.330
Matthew, how do I know I've got to
go run that function, what symbols?

65
00:02:55.330 --> 00:02:55.840
&gt;&gt; Speaker 2: Parentheses.

66
00:02:55.840 --> 00:02:56.420
&gt;&gt; Will Sentance: Good job, Matthew.

67
00:02:56.420 --> 00:02:57.140
Very nice.
Yeah.

68
00:02:57.140 --> 00:02:57.830
Correct.

69
00:02:57.830 --> 00:02:59.120
I'm going to go run that function.

70
00:02:59.120 --> 00:03:00.440
It's undefined for now.

71
00:03:00.440 --> 00:03:02.228
I'm gonna go run that function.

72
00:03:02.228 --> 00:03:05.860
And I'm going to do it.

73
00:03:05.860 --> 00:03:14.130
Copy array manipulate call with,
order what?

74
00:03:14.130 --> 00:03:19.610
What's our first argument, Griffin?
&gt;&gt; Speaker 2: Is the array 1,

75
00:03:19.610 --> 00:03:21.550
2, 3.
&gt;&gt; Will Sentance: Good, there it is.

76
00:03:21.550 --> 00:03:23.550
Array, 1, 2, 3.
And our second argument,

77
00:03:23.550 --> 00:03:25.300
Griffin?
&gt;&gt; Speaker 2: Is the function,

78
00:03:25.300 --> 00:03:28.030
multiply it by 2.
&gt;&gt; Will Sentance: Spot on, multiply by 2,

79
00:03:28.030 --> 00:03:33.530
and it's the whole function definition,
right, Shelby?

80
00:03:33.530 --> 00:03:34.990
It's a whole function definition.

81
00:03:36.150 --> 00:03:37.420
That wasn't
a passive-aggressive statement.

82
00:03:37.420 --> 00:03:38.610
Well, it sort of was, but no, no.

83
00:03:38.610 --> 00:03:40.200
There it is.

84
00:03:40.200 --> 00:03:40.990
It was not intentionally.

85
00:03:40.990 --> 00:03:43.260
There, the whole function definition,
the whole loaded description.

86
00:03:43.260 --> 00:03:47.120
It's the whole function definition.

87
00:03:47.120 --> 00:03:49.330
Good job, there it is.

88
00:03:49.330 --> 00:03:53.240
And the output, we're saying already
we know that whatever gets returned

89
00:03:53.240 --> 00:03:55.670
out of this function, whatever comes
out of the bottom of this function is

90
00:03:55.670 --> 00:03:58.960
going to be stored where, Shelby?

91
00:04:00.330 --> 00:04:03.850
The output of running this function
is going to be stored where

92
00:04:03.850 --> 00:04:04.550
Shelby?
&gt;&gt; Speaker 2: Global.

93
00:04:04.550 --> 00:04:06.880
&gt;&gt; Will Sentance: In what label?

94
00:04:06.880 --> 00:04:08.580
What's it saying?
&gt;&gt; Speaker 2: End result.

95
00:04:08.580 --> 00:04:09.230
&gt;&gt; Will Sentance: Exactly.

96
00:04:09.230 --> 00:04:11.430
End result.

97
00:04:11.430 --> 00:04:15.050
But we've got a whole set of
instructions copulate and

98
00:04:15.050 --> 00:04:17.580
manipulate that we've got to
run through line by line.

99
00:04:17.580 --> 00:04:19.230
That's the thread of execution.

100
00:04:19.230 --> 00:04:21.790
And we've got a whole bunch
of data we've got to store.

101
00:04:21.790 --> 00:04:25.770
Output array that's the variable
environment, the local memory.

102
00:04:25.770 --> 00:04:27.680
What do we call those two things together?

103
00:04:27.680 --> 00:04:30.300
Everyone together a?
&gt;&gt; Execution context!

104
00:04:30.300 --> 00:04:31.430
&gt;&gt; Will Sentance: Perfect!

105
00:04:31.430 --> 00:04:33.020
There it is.

106
00:04:33.020 --> 00:04:33.960
We're going to create it.

107
00:04:33.960 --> 00:04:34.960
There it is.

108
00:04:36.270 --> 00:04:41.510
An execution context with a local memory.

109
00:04:41.510 --> 00:04:48.990
Local memory in which anything we declare,
define, create inside of the code or

110
00:04:48.990 --> 00:04:55.275
running copyArrayAndManipulate
stored in there, not in global.

111
00:04:55.275 --> 00:05:01.355
So, at this point
&gt;&gt; Will Sentance: Bob,

112
00:05:01.355 --> 00:05:05.840
what's the first thing we do
inside copyArrayAndManipulate?

113
00:05:05.840 --> 00:05:07.690
Before we even get inside
copyArrayAnd Manipulate,

114
00:05:07.690 --> 00:05:12.720
what's the first thing we're gonna handle?
&gt;&gt; Speaker 3: The placeholder

115
00:05:12.720 --> 00:05:14.490
passing the array in.
&gt;&gt; Will Sentance: Yeah, nice,

116
00:05:14.490 --> 00:05:15.580
so what do we say?

117
00:05:15.580 --> 00:05:18.372
What's the posh way of saying Yeah,
here we go.

118
00:05:18.372 --> 00:05:19.521
&gt;&gt; Speaker 3: Sorry.

119
00:05:19.521 --> 00:05:22.830
[LAUGH]
&gt;&gt; Will Sentance: What's the first place

120
00:05:22.830 --> 00:05:26.560
where we gonna handle?
&gt;&gt; Speaker 3: The 1, 2, 3?

121
00:05:26.560 --> 00:05:28.240
&gt;&gt; Will Sentance: Which is gonna fit in to

122
00:05:28.240 --> 00:05:29.150
what sort of place order?

123
00:05:29.150 --> 00:05:31.010
That's the actual value,
the argument, what's-

124
00:05:31.010 --> 00:05:32.070
&gt;&gt; Speaker 3: The array param.

125
00:05:32.070 --> 00:05:33.230
&gt;&gt; Will Sentance: Array parameter,

126
00:05:33.230 --> 00:05:34.490
exactly.

127
00:05:34.490 --> 00:05:38.470
And what will array now be,
because of what you just said,

128
00:05:38.470 --> 00:05:40.890
everywhere inside this function call?
&gt;&gt; Speaker 2: 1, 2, 3.

129
00:05:40.890 --> 00:05:41.950
&gt;&gt; Will Sentance: 1, 2, 3, spot on.

130
00:05:41.950 --> 00:05:44.007
And now, Clara, Clara,

131
00:05:44.007 --> 00:05:49.710
because whenever someone's on their phone,
they get called upon.

132
00:05:49.710 --> 00:05:54.250
Clara, we filled an array as 1, 2, 3.

133
00:05:55.570 --> 00:06:01.380
We now have another
parameter which is what?

134
00:06:01.380 --> 00:06:02.220
&gt;&gt; Speaker 3: Instructions

135
00:06:02.220 --> 00:06:02.820
&gt;&gt; Will Sentance: And what is

136
00:06:02.820 --> 00:06:07.290
instructions, Clara,
going to be replaced with?

137
00:06:07.290 --> 00:06:08.200
It's just a placeholder.

138
00:06:08.200 --> 00:06:09.470
What's it gonna point to?

139
00:06:09.470 --> 00:06:13.860
What it's value gonna be throughout
the life of this function called?

140
00:06:13.860 --> 00:06:15.470
&gt;&gt; Speaker 3: It's a function.

141
00:06:15.470 --> 00:06:17.730
The multiply by two function
&gt;&gt; Will Sentance: Spot on.

142
00:06:17.730 --> 00:06:20.980
The entire multiply by two functionality.

143
00:06:20.980 --> 00:06:25.180
We no longer are going to refer
to it as multiply by two inside.

144
00:06:25.180 --> 00:06:27.080
We're going to refer
to it as instructions.

145
00:06:27.080 --> 00:06:32.490
But it is that entire function definition
that we gave birth to out here in global.

146
00:06:32.490 --> 00:06:35.280
We defined out here and then passed in

147
00:06:36.500 --> 00:06:40.610
to be available inside copyArrayManipulate
under it's new label instructions.

148
00:06:40.610 --> 00:06:45.170
So Clara if I wanted to
inside copyArrayManipulate

149
00:06:45.170 --> 00:06:49.020
run that multiplyBy2 functionality
in here under it's new label, what's

150
00:06:49.020 --> 00:06:51.960
the exact wording I would use to run it?
&gt;&gt; Speaker 3: You'd say instructions

151
00:06:51.960 --> 00:06:53.680
parentheses-
&gt;&gt; Will Sentance: Instructions, I'm sorry,

152
00:06:53.680 --> 00:06:55.570
say that again.
&gt;&gt; Speaker 3: Instructions parentheses.

153
00:06:55.570 --> 00:06:56.099
&gt;&gt; Will Sentance: Parentheses, I

154
00:06:56.099 --> 00:06:57.659
would probably wanna
parse something because.

155
00:06:57.659 --> 00:07:02.084
Right, and if you look the definition
I'm pointing right to it called

156
00:07:02.084 --> 00:07:04.715
a 'placeholder', so I'll pass in 3.

157
00:07:04.715 --> 00:07:10.105
Because, instruction literally evaluates
to, it becomes the multiply by 2 function.

158
00:07:10.105 --> 00:07:14.822
Just like array, if we were to go
array position 1 inside of here,

159
00:07:14.822 --> 00:07:17.660
we are going to look at this array.

160
00:07:17.660 --> 00:07:19.720
Instructions, we're gonna
look at what it is at.

161
00:07:19.720 --> 00:07:22.510
It's the multiply by two functionality.

162
00:07:22.510 --> 00:07:25.350
It has literally replaced the placeholder

163
00:07:25.350 --> 00:07:28.330
that was previously
a placeholder instructions.

164
00:07:28.330 --> 00:07:30.920
All right, let's walk through
it as precisely as we can.

165
00:07:32.310 --> 00:07:36.980
Okay, so we've done our parameters Art,
we've done our perameters,

166
00:07:36.980 --> 00:07:38.430
what's our next line in our local memory?

167
00:07:38.430 --> 00:07:40.410
We've done our our perameters,
our arguments whats our next bit

168
00:07:40.410 --> 00:07:42.440
in local memory?
&gt;&gt; Speaker 2: We're sending our output

169
00:07:42.440 --> 00:07:43.750
to an array.
&gt;&gt; Will Sentance: Spot on,

170
00:07:43.750 --> 00:07:48.190
I'm gonna put, again,
our sort of working area over here.

171
00:07:48.190 --> 00:07:50.940
So it's sort of not ideal,
but there we go.

172
00:07:50.940 --> 00:07:54.430
Output is exactly an empty array.

173
00:07:54.430 --> 00:07:58.150
There we go, output, just so
we can work with these slightly easier.

174
00:07:59.630 --> 00:08:01.045
Okay, big moment.

175
00:08:01.045 --> 00:08:06.009
Andrea, we're going to hit
the body of that Four Loop.

176
00:08:06.009 --> 00:08:07.653
We've done outfits on MD Ray.

177
00:08:07.653 --> 00:08:09.239
We're going to hit the body
of that Four loop.

178
00:08:10.480 --> 00:08:11.600
First time we do,

179
00:08:11.600 --> 00:08:16.930
what's the first I guess variable
of whose value we're interested in.

180
00:08:16.930 --> 00:08:18.500
JavaScript kinda works inwards, outward.

181
00:08:18.500 --> 00:08:20.290
So, what's the first one
we're interested in?

182
00:08:20.290 --> 00:08:21.760
&gt;&gt; Speaker 3: Is the I to zero

183
00:08:21.760 --> 00:08:22.960
&gt;&gt; Will Sentance: I is zero, spot on.

184
00:08:23.980 --> 00:08:28.380
So, I is zero, so
array index zero is what?

185
00:08:29.730 --> 00:08:32.050
Andrea.
&gt;&gt; Speaker 3: Sub zero one.

186
00:08:33.580 --> 00:08:35.990
&gt;&gt; Will Sentance: This is very very good.

187
00:08:35.990 --> 00:08:39.010
But everyone wants to hear so nice.

188
00:08:39.010 --> 00:08:40.310
Spot on Andrea, really nice.

189
00:08:40.310 --> 00:08:44.620
So array sub zero is the value one.

190
00:08:45.740 --> 00:08:46.520
Exactly.

191
00:08:46.520 --> 00:08:48.730
There it is, the value one.

192
00:08:48.730 --> 00:08:55.830
And now, that one,
that means this little portion here, 0, 1.

193
00:08:55.830 --> 00:09:00.771
What's his instructions,
placeholder now being filled in with,

194
00:09:00.771 --> 00:09:02.355
Andrea?
&gt;&gt; Speaker 3: Multiply by 2

195
00:09:02.355 --> 00:09:03.630
&gt;&gt; Will Sentance: The word multiply,

196
00:09:03.630 --> 00:09:05.510
the function multiply by 2.

197
00:09:05.510 --> 00:09:10.600
So actually, what does this little
portion here become but multiply by 2,

198
00:09:10.600 --> 00:09:12.670
open parens, 1, close parens.

199
00:09:12.670 --> 00:09:17.980
Well, that's saying,
go run the multiply by 2 function.

200
00:09:17.980 --> 00:09:20.770
And when we start running a function,
Andrea, what do we do?

201
00:09:20.770 --> 00:09:24.110
We create a brand new, everyone together?

202
00:09:24.110 --> 00:09:25.820
Execution context.

203
00:09:25.820 --> 00:09:27.340
We forgot to add this
one in the first place.

204
00:09:27.340 --> 00:09:27.880
Well.

205
00:09:27.880 --> 00:09:30.870
So copyArrayAndManipulate, when we started
running it, we add it to the call stack.

206
00:09:30.870 --> 00:09:34.240
So it already inside
copyArrayAndManipulate, CC.

207
00:09:34.240 --> 00:09:36.110
JavaScript needs to know this stuff.

208
00:09:36.110 --> 00:09:37.340
There we are, that's all by call stack.

209
00:09:37.340 --> 00:09:41.540
And yes, we now exactly, as Andrea said,

210
00:09:41.540 --> 00:09:47.670
start calling instructions,
which is really just multiply by 2.

211
00:09:47.670 --> 00:09:50.970
But let's refer to it
as instructions here.

212
00:09:50.970 --> 00:09:54.390
Instructions, which is really just what,
Andrea?

213
00:09:54.390 --> 00:09:57.150
&gt;&gt; Speaker 3: A paremeter?

214
00:09:57.150 --> 00:09:57.820
&gt;&gt; Will Sentance: What is instructions

215
00:09:57.820 --> 00:09:59.890
really just?
&gt;&gt; Speaker 3: Multiply by 2.

216
00:09:59.890 --> 00:10:00.690
&gt;&gt; Will Sentance: Multiply by 2, and we

217
00:10:00.690 --> 00:10:04.121
pass in the what value?
&gt;&gt; Speaker 3: First value in the area.

218
00:10:04.121 --> 00:10:04.763
&gt;&gt; Will Sentance: Which

219
00:10:04.763 --> 00:10:05.327
is?
&gt;&gt; Speaker 3: One.

220
00:10:05.327 --> 00:10:07.033
&gt;&gt; Will Sentance: One exactly.

221
00:10:07.033 --> 00:10:12.347
And if we're calling it,
we create a new execution context.

222
00:10:12.347 --> 00:10:16.801
There it is,
with a local memory of its own.

223
00:10:16.801 --> 00:10:17.842
And Andrea,

224
00:10:17.842 --> 00:10:21.251
what happens to our call stack?
&gt;&gt; Speaker 3: It gets added

225
00:10:21.251 --> 00:10:23.844
to the.
&gt;&gt; Will Sentance: The call to instructions

226
00:10:23.844 --> 00:10:28.369
multiplied by 2, they're the same thing,
gets added to the call stack.

227
00:10:28.369 --> 00:10:30.799
There it is.
Now we know when we finish running it,

228
00:10:30.799 --> 00:10:34.193
where are we gonna to go back to, Andrea?
&gt;&gt; Speaker 3: Doing a background and

229
00:10:34.193 --> 00:10:35.188
stack.
&gt;&gt; Will Sentance: Exactly,

230
00:10:35.188 --> 00:10:38.631
that's why a stack is such
a good way of tracking this.

231
00:10:38.631 --> 00:10:41.477
If you add something, start running it,
when you finish running it,

232
00:10:41.477 --> 00:10:42.548
you wanna go out one step.

233
00:10:42.548 --> 00:10:46.594
Where you go down, and you take it off,
and you go back out to copy array and

234
00:10:46.594 --> 00:10:47.880
manipulate.

235
00:10:47.880 --> 00:10:50.180
And so when we go, this is a tough bit.

236
00:10:50.180 --> 00:10:52.880
Clara, I'm inside
the call to instructions,

237
00:10:52.880 --> 00:10:54.810
I've passed,
which is really multiplied by two.

238
00:10:54.810 --> 00:10:56.160
I passed in one.

239
00:10:56.160 --> 00:11:01.220
What is my first pairing of label and
data inside the local memory given this

240
00:11:01.220 --> 00:11:03.910
is just really multiply by two, Clara?
&gt;&gt; Speaker 3: So, input.

241
00:11:03.910 --> 00:11:06.090
&gt;&gt; Will Sentance: Input, exactly, and

242
00:11:06.090 --> 00:11:11.040
it's assigned what?
&gt;&gt; Speaker 3: The- Equate to one,

243
00:11:11.040 --> 00:11:11.620
right?
&gt;&gt; Will Sentance: One.

244
00:11:11.620 --> 00:11:14.550
Exactly, because we are really

245
00:11:14.550 --> 00:11:16.950
running the functionality of
multiply by two, everyone.

246
00:11:16.950 --> 00:11:19.480
So this portion here, 0, 1.

247
00:11:19.480 --> 00:11:25.440
And that 1 got thrown into instructions,
which is really multiply by 2.

248
00:11:25.440 --> 00:11:28.390
So that 1 got thrown in as input.

249
00:11:28.390 --> 00:11:30.250
And there it is, shit.

250
00:11:30.250 --> 00:11:32.640
There it is, input: 1.

251
00:11:32.640 --> 00:11:37.390
And so we do 1, which is input, by 2,

252
00:11:37.390 --> 00:11:41.400
and return that 2 out.

253
00:11:41.400 --> 00:11:47.160
Which means now, multiply by 2,
with the input of 1, this whole statement,

254
00:11:47.160 --> 00:11:51.840
multiply by 2, has evaluated,
has become, that output value 2.

255
00:11:51.840 --> 00:11:55.860
And what do we do with that 2, Andrea?
&gt;&gt; Will Sentance: What do we

256
00:11:55.860 --> 00:12:00.192
do with that evaluation of result lindsey?
&gt;&gt; Speaker 3: We push it

257
00:12:00.192 --> 00:12:02.851
into the output.
&gt;&gt; Will Sentance: We push it into output

258
00:12:02.851 --> 00:12:04.678
spot on there it is and

259
00:12:04.678 --> 00:12:07.725
what happens Lindsey?
&gt;&gt; Speaker 3: It

260
00:12:07.725 --> 00:12:09.398
goes away
&gt;&gt; Will Sentance: It goes away.

261
00:12:09.398 --> 00:12:12.547
We poshly say it gets popped off.
&gt;&gt; Speaker 3: Popped off.

262
00:12:12.547 --> 00:12:14.227
&gt;&gt; Will Sentance: Yeah, it goes away, but

263
00:12:14.227 --> 00:12:15.509
it's a full loop.

264
00:12:15.509 --> 00:12:20.630
So what happens even though we
threw away our execution context

265
00:12:20.630 --> 00:12:25.860
it's all gone for the running
of instructions that first time.

266
00:12:25.860 --> 00:12:31.066
Well what do you know it's a follow so
we are going to hit the body

267
00:12:31.066 --> 00:12:35.585
of the follow again and
this time Griffin, this time,

268
00:12:35.585 --> 00:12:38.930
Griffin, what is the value of i?
&gt;&gt; Speaker 2: 1.

269
00:12:38.930 --> 00:12:40.126
&gt;&gt; Will Sentance: And therefore,

270
00:12:40.126 --> 00:12:43.210
we get array sub 1 which is?
&gt;&gt; Speaker 2: 2.

271
00:12:43.210 --> 00:12:43.740
&gt;&gt; Will Sentance: And

272
00:12:43.740 --> 00:12:47.160
we take that 2, and we do what with it?
&gt;&gt; Speaker 2: We pass into

273
00:12:47.160 --> 00:12:48.090
instructions.
&gt;&gt; Will Sentance: Which is really

274
00:12:48.090 --> 00:12:48.990
just?
&gt;&gt; Speaker 2: Multiply by 2.

275
00:12:48.990 --> 00:12:49.800
&gt;&gt; Will Sentance: Very good,

276
00:12:49.800 --> 00:12:51.667
exactly, instructions.

277
00:12:51.667 --> 00:12:54.774
And we call that instructions,
there it is.

278
00:12:54.774 --> 00:12:56.021
The two gets passed in.

279
00:12:56.021 --> 00:12:58.615
Do the local memory.

280
00:12:58.615 --> 00:13:01.751
What happens?
&gt;&gt; Speaker 2: It gets pushed on to there.

281
00:13:01.751 --> 00:13:04.096
&gt;&gt; Will Sentance: It gets pushed on again.

282
00:13:04.096 --> 00:13:05.733
A new execution context.

283
00:13:05.733 --> 00:13:10.125
Inside, what's the first data pairing?
&gt;&gt; Speaker 2: Input and two.

284
00:13:10.125 --> 00:13:12.400
&gt;&gt; Will Sentance: Yeah, input and 2,

285
00:13:12.400 --> 00:13:15.290
and we do 2 by 2, which becomes 4.

286
00:13:15.290 --> 00:13:19.650
Out it returns, return out 4.

287
00:13:19.650 --> 00:13:23.580
That means this little portion here
multiplied by 2 with the input of 2,

288
00:13:23.580 --> 00:13:24.790
is evaluated to 4.

289
00:13:24.790 --> 00:13:28.554
And that 4 gets pushed where?
&gt;&gt; Speaker 2: To outputs?

290
00:13:28.554 --> 00:13:29.851
&gt;&gt; Will Sentance: Fate, there it is.

291
00:13:29.851 --> 00:13:32.348
And then it gets created again.

292
00:13:32.348 --> 00:13:34.892
We get 6.
Output is now 2, 4, 6.

293
00:13:34.892 --> 00:13:37.890
And we hit the key line,
Mohammed, which is?

294
00:13:37.890 --> 00:13:42.554
What's the final line of the function?
&gt;&gt; Speaker 2: Return output.

295
00:13:42.554 --> 00:13:44.330
&gt;&gt; Will Sentance: Return, see,

296
00:13:44.330 --> 00:13:51.650
I have an amazing habit of always calling
on the same people for the same thing.

297
00:13:51.650 --> 00:13:54.160
So what it actually will return, Mohammed?
&gt;&gt; Speaker 2: 2,4,6.

298
00:13:54.160 --> 00:13:55.040
&gt;&gt; Will Sentance: Yeah, the value

299
00:13:55.040 --> 00:13:56.460
associated with output.

300
00:13:56.460 --> 00:13:58.300
Javascript never sees a word and
leaves it.

301
00:13:58.300 --> 00:14:01.800
It valuates everything down
to its lowest possible part.

302
00:14:01.800 --> 00:14:05.926
So, it sees the word output,
it goes, hold on, what is that?

303
00:14:05.926 --> 00:14:07.202
It's 2,4,6.

304
00:14:07.202 --> 00:14:10.570
Returns that outward out, two, four, six.

305
00:14:10.570 --> 00:14:15.463
And where did we say, Muhammed,
we're gonna assign it?

306
00:14:15.463 --> 00:14:16.767
&gt;&gt; Speaker 2: To the label result.

307
00:14:16.767 --> 00:14:19.071
&gt;&gt; Will Sentance: To the label result.

308
00:14:19.071 --> 00:14:19.923
And there it is.

309
00:14:19.923 --> 00:14:21.775
So this is hard.

310
00:14:21.775 --> 00:14:26.118
This is supposedly one of those
profound areas of all higher functions.

311
00:14:26.118 --> 00:14:29.703
We'll see in a moment,
we've already encountered

312
00:14:29.703 --> 00:14:35.010
all the material of higher order
functions, at least with callbacks.

313
00:14:35.010 --> 00:14:39.160
But, I wanna have thumbs in a moment,
on what we saw here.

314
00:14:39.160 --> 00:14:43.742
But look, we acheived,
with a generalized copyArrayAndManipulate,

315
00:14:43.742 --> 00:14:47.721
and then a specific little baby function,
that we passed in for

316
00:14:47.721 --> 00:14:51.400
the specifics of what we're
gonna do to each element.

317
00:14:51.400 --> 00:14:55.160
We achieved exactly the same as we did
copyArrayMultiplyBy2 we took a one two

318
00:14:55.160 --> 00:14:58.660
three and came out with two four six.

319
00:14:58.660 --> 00:15:01.040
Look at this, when to one two three but

320
00:15:01.040 --> 00:15:04.370
we had no specificity of
MultiplyBy2 in there.

321
00:15:04.370 --> 00:15:08.830
Instead we left a place holder which we
then determined what it would be when we

322
00:15:08.830 --> 00:15:11.500
called, CopyArrayAndManipulate.

323
00:15:11.500 --> 00:15:14.800
And what do we end up with, but, 2, 4, 6.

324
00:15:14.800 --> 00:15:17.200
The very same result.

325
00:15:17.200 --> 00:15:19.590
We could have parsed in,
not muliply by 2, but add 3.

326
00:15:19.590 --> 00:15:21.820
Or divide by 2.

327
00:15:21.820 --> 00:15:24.870
We ended up with the same result.

328
00:15:24.870 --> 00:15:28.960
We parametized,
we generalized, our function.

