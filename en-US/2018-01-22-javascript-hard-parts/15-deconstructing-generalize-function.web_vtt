WEBVTT

1
00:00:00.006 --> 00:00:03.042
&gt;&gt; Will: Folk we’re gonna walk
through this, line by line,

2
00:00:03.042 --> 00:00:06.360
this is a final function for
our higher order functions.

3
00:00:06.360 --> 00:00:11.903
So we’re gonna walk through this line
by line, and to kick this off, Mohamed,

4
00:00:11.903 --> 00:00:17.630
line one, no, this was a mistake, Mohamed
line one, what are we doing Mohamed?

5
00:00:17.630 --> 00:00:21.626
Talk me through line one of this function,

6
00:00:21.626 --> 00:00:25.222
of this set of code.
&gt;&gt; Muhammad: Declaring a function called

7
00:00:25.222 --> 00:00:28.699
copy array, and manipulating-
&gt;&gt; Will: Perfect, thank you man.

8
00:00:28.699 --> 00:00:33.670
Copy, array, manipulate and of course
we're at the global level, aren't we?

9
00:00:33.670 --> 00:00:36.475
We're not inside a function, so
where's that being stored, Mohammad?

10
00:00:36.475 --> 00:00:37.022
&gt;&gt; Muhammad: In the global memory?

11
00:00:37.022 --> 00:00:38.848
&gt;&gt; Will: In the global memory,

12
00:00:38.848 --> 00:00:39.907
there it is.

13
00:00:39.907 --> 00:00:42.580
I'm gonna draw it as a little
function box, a little function.

14
00:00:42.580 --> 00:00:43.194
A whole inscription.

15
00:00:43.194 --> 00:00:47.932
Okay, next line is what Shelby?
&gt;&gt; Shelby: Declaring the function

16
00:00:47.932 --> 00:00:53.370
multiplied by 2.
&gt;&gt; Will: There it is, multiply by 2.

17
00:00:53.370 --> 00:00:58.477
That's a baby function that only takes in,
a single, what?

18
00:00:58.477 --> 00:00:59.120
&gt;&gt; [LAUGH]

19
00:00:59.120 --> 00:01:00.540
&gt;&gt; Will: A baby function.

20
00:01:00.540 --> 00:01:06.350
So it takes in a single element,
and then multiplies it by 2.

21
00:01:06.350 --> 00:01:08.240
Little baby function there it is.

22
00:01:08.240 --> 00:01:12.049
And let's just highlight it slightly so
we know which function it is.

23
00:01:12.049 --> 00:01:16.842
And, if I were Shelby, in the line
after that definition declaration of

24
00:01:16.842 --> 00:01:19.760
multiply by 2, why would a console.log?

25
00:01:19.760 --> 00:01:20.670
Let's write it up.

26
00:01:20.670 --> 00:01:21.434
If I were to do this.

27
00:01:21.434 --> 00:01:26.342
Console.log(multiplyBy2) no parenths,
what would this

28
00:01:26.342 --> 00:01:31.801
display on my console, Shelby,
just to make sure we're really clear

29
00:01:31.801 --> 00:01:36.609
what would this display on my console?
&gt;&gt; Muhammad: Undefined.

30
00:01:36.609 --> 00:01:37.699
&gt;&gt; Will: Undefined,

31
00:01:37.699 --> 00:01:40.970
what have we stored and multiply by 2?

32
00:01:40.970 --> 00:01:43.460
So obviously it goes and looks in
global memory, C is multiplied by 2.

33
00:01:43.460 --> 00:01:46.334
What's at C?
&gt;&gt; Muhammad: The whole function.

34
00:01:46.334 --> 00:01:47.739
&gt;&gt; Will: The whole function definition.

35
00:01:47.739 --> 00:01:50.067
So if I were the console alone,
the word multiplied by 2,

36
00:01:50.067 --> 00:01:52.640
what would I see in my console, Mohamed?
&gt;&gt; Muhammad: Just the whole function.

37
00:01:52.640 --> 00:01:54.890
&gt;&gt; Will: The whole function definition,

38
00:01:54.890 --> 00:01:59.159
multipliedBy2 is a label for
my whole function description.

39
00:01:59.159 --> 00:02:05.928
Okay, okay,
it is the whole function definition.

40
00:02:05.928 --> 00:02:10.816
Meaning, if I then parse multiplyBy2
in to instructions, I'm not parsing

41
00:02:10.816 --> 00:02:15.703
undefined in, I am not running,
copy array manipulate with multiplyBy2,

42
00:02:15.703 --> 00:02:20.590
it's actually undefined, no,
it's gonna literally be the whole function

43
00:02:20.590 --> 00:02:26.010
definition, being passed in to replace
the placeholder word instructions.

44
00:02:26.010 --> 00:02:30.221
All right, so, now we've declared, copy
array, manipulate, declare, multiply by 2.

45
00:02:30.221 --> 00:02:31.443
What's the next line?

46
00:02:31.443 --> 00:02:33.550
Tell us to do, Mathew.

47
00:02:33.550 --> 00:02:37.420
What's the finalizer left hand side say?
&gt;&gt; Mathew: Lab results.

48
00:02:37.420 --> 00:02:38.590
&gt;&gt; Will: Which is saying?

49
00:02:38.590 --> 00:02:41.220
Give JavaScript label results, right?
&gt;&gt; Mathew: Right.

50
00:02:41.220 --> 00:02:42.885
&gt;&gt; Will: Good, and Matthew,

51
00:02:42.885 --> 00:02:45.660
do we know what's gonna be stored,

52
00:02:45.660 --> 00:02:49.170
Matthew, in result yet?
&gt;&gt; Mathew: No.

53
00:02:49.170 --> 00:02:51.049
&gt;&gt; Will: No, cuz we've gotta go run that

54
00:02:51.049 --> 00:02:51.749
function.

55
00:02:51.749 --> 00:02:54.510
Matthew, how do I know I've
gotta go run that function?

56
00:02:54.510 --> 00:02:55.606
What symbols?
&gt;&gt; Mathew: Parenthesis.

57
00:02:55.606 --> 00:02:56.765
&gt;&gt; Will: Good job Matthew, very nice,

58
00:02:56.765 --> 00:02:57.830
yeah, correct.

59
00:02:57.830 --> 00:03:00.841
I'm gonna go run that function,
its undefined for now.

60
00:03:00.841 --> 00:03:06.518
I'm gonna go run that function,
and I'm gonna do it.

61
00:03:06.518 --> 00:03:13.370
CopyArrayManipulate called with,
called what?

62
00:03:13.370 --> 00:03:18.718
What's our first argument, Griffin?
&gt;&gt; Griffin: It

63
00:03:18.718 --> 00:03:21.820
is the array one, two, three.
&gt;&gt; Will: Good there it is, array one two

64
00:03:21.820 --> 00:03:24.374
three, and our second argument Griffin?
&gt;&gt; Griffin: Is

65
00:03:24.374 --> 00:03:28.796
the function multipliedBy 2.
&gt;&gt; Will: Spot on, multipliedBy2 and

66
00:03:28.796 --> 00:03:32.054
it's the whole function definition.

67
00:03:32.054 --> 00:03:35.232
Right Coby, the whole function definition?

68
00:03:35.232 --> 00:03:40.200
That wasn't a passive aggressive
statement, well it sort of was.

69
00:03:40.200 --> 00:03:41.120
It was not intentional.

70
00:03:41.120 --> 00:03:42.430
The whole function definition there.

71
00:03:42.430 --> 00:03:43.280
The whole descriptor.

72
00:03:43.280 --> 00:03:47.120
Yeah, it's the whole function definition.

73
00:03:47.120 --> 00:03:49.056
Good job, there it is.

74
00:03:49.056 --> 00:03:53.626
And the output, we're saying already that
we know that whatever gets returned out of

75
00:03:53.626 --> 00:03:57.117
this function, whatever comes
out the bottom of this function,

76
00:03:57.117 --> 00:03:58.530
is gonna be stored where?

77
00:03:58.530 --> 00:04:00.087
Shelby?

78
00:04:00.087 --> 00:04:02.820
The output of running this function
is gonna be stored where, Shelby?

79
00:04:02.820 --> 00:04:03.630
&gt;&gt; Shelby: Global.

80
00:04:03.630 --> 00:04:04.537
&gt;&gt; Will: In what label?

81
00:04:04.537 --> 00:04:07.640
What's it say?
&gt;&gt; Shelby: In result.

82
00:04:07.640 --> 00:04:09.230
&gt;&gt; Will: In result, exactly.

83
00:04:09.230 --> 00:04:14.442
In result, but we've got a whole set
of instructions copyArrayAndManipulate,

84
00:04:14.442 --> 00:04:19.442
that we've gotta run through line by line,
that's the thread of execution.

85
00:04:19.442 --> 00:04:22.630
And we got a hold bunch of data
we gotta store, output array.

86
00:04:22.630 --> 00:04:25.770
That's the variable environment,
the local memory.

87
00:04:25.770 --> 00:04:27.525
What do we call those two things together?

88
00:04:27.525 --> 00:04:30.300
Everyone together, a
&gt;&gt; All: Execution context.

89
00:04:30.300 --> 00:04:33.020
&gt;&gt; Will: Perfect, there it is.

90
00:04:33.020 --> 00:04:36.179
We're gonna create it, there it is.

91
00:04:36.179 --> 00:04:39.440
Execution context,

92
00:04:39.440 --> 00:04:45.060
with a local memory, local memory.

93
00:04:45.060 --> 00:04:50.126
In which anything we declare, define,
create inside of the code of running,

94
00:04:50.126 --> 00:04:53.984
copyArrayandManipulate, stored
it there not in global.

95
00:04:53.984 --> 00:05:00.253
So, at this point, Bob,
what's the first thing

96
00:05:00.253 --> 00:05:05.340
we do inside copyArrayandManipulate?

97
00:05:05.340 --> 00:05:07.252
Before we even get inside
copyArrayandManipulate,

98
00:05:07.252 --> 00:05:12.306
what's the first thing we're gotta handle?
&gt;&gt; Shelby: The placeholder

99
00:05:12.306 --> 00:05:14.395
parsing the array.
&gt;&gt; Will: Yeah nice.

100
00:05:14.395 --> 00:05:15.410
So what do we say?

101
00:05:15.410 --> 00:05:20.566
What's the posh way of
saying we're gonna yeah,

102
00:05:20.566 --> 00:05:22.140
here we go.
&gt;&gt; Shelby: Sorry [LAUGH] the-

103
00:05:22.140 --> 00:05:23.245
&gt;&gt; Will: So what's the first

104
00:05:23.245 --> 00:05:26.463
placeholder we're gotta have it on?
&gt;&gt; Shelby: The one, two, three.

105
00:05:26.463 --> 00:05:27.568
&gt;&gt; Will: Which is gonna fill in,

106
00:05:27.568 --> 00:05:30.730
what's the placeholder that's
the actual value, the argument.

107
00:05:30.730 --> 00:05:32.070
What's the-
&gt;&gt; Shelby: The array param.

108
00:05:32.070 --> 00:05:34.270
&gt;&gt; Will: Array parameter, exactly.

109
00:05:34.270 --> 00:05:37.760
And what will a array now be
because of what you just said,

110
00:05:37.760 --> 00:05:41.420
everywhere inside this function call?
&gt;&gt; Shelby: One.

111
00:05:41.420 --> 00:05:43.302
&gt;&gt; Will: One, two, three, spot on.

112
00:05:43.302 --> 00:05:49.710
And now, Clara, Clara, whenever someone's
on their phone, they get called upon.

113
00:05:49.710 --> 00:05:55.368
Clara, we filled an array as one,
two, three.

114
00:05:55.368 --> 00:06:01.380
We now have another
parameter which is what?

115
00:06:01.380 --> 00:06:02.005
&gt;&gt; Clara: Instructions.

116
00:06:02.005 --> 00:06:04.993
&gt;&gt; Will: And what is instructions, Clara,

117
00:06:04.993 --> 00:06:07.290
going to be replaced with?

118
00:06:07.290 --> 00:06:10.110
It's just a placeholder but
what's it gonna point to?

119
00:06:10.110 --> 00:06:13.615
What's it value gonna be,
throughout the life of this function call.

120
00:06:13.615 --> 00:06:14.856
&gt;&gt; Clara: It's a function,

121
00:06:14.856 --> 00:06:17.509
the multiplyBy2 function.
&gt;&gt; Will: Spot on,

122
00:06:17.509 --> 00:06:20.715
the entire multiplyBy2 functionality.

123
00:06:20.715 --> 00:06:24.274
We no longer are gonna refer
to it as multiplyBy2 inside,

124
00:06:24.274 --> 00:06:27.080
we are gonna refer to it as instructions.

125
00:06:27.080 --> 00:06:31.855
But it is that entire function definition
that we gave birth to out here,

126
00:06:31.855 --> 00:06:36.317
in global, we defined out here, and
parse in to be available inside

127
00:06:36.317 --> 00:06:40.342
copyArrayManipulate under
it's new label instructions.

128
00:06:40.342 --> 00:06:43.916
So Clara,
if I wanted to inside copyArrayManipulate,

129
00:06:43.916 --> 00:06:48.858
run that multiplierBy2 functionality
in here under its new label, what's

130
00:06:48.858 --> 00:06:52.225
the exact wording I would use to run it?
&gt;&gt; Clara: You use instructions-

131
00:06:52.225 --> 00:06:52.734
&gt;&gt; Will: Instructions.

132
00:06:52.734 --> 00:06:55.384
Sorry, say that again.
&gt;&gt; Clara: Instructions, parentheses.

133
00:06:55.384 --> 00:06:55.934
&gt;&gt; Will: Parentheses.

134
00:06:55.934 --> 00:06:58.000
I probably wanna parse
something in here because.

135
00:06:58.000 --> 00:07:01.020
Right, and if you look at the definition
multiplyBy2, it's got a placeholder and

136
00:07:01.020 --> 00:07:02.260
I parse in 3.

137
00:07:02.260 --> 00:07:09.740
Because instructions literally evaluates
2, that becomes, the multiplyBy2 function.

138
00:07:09.740 --> 00:07:14.845
Just like array, if we were go
array position 1 inside of here,

139
00:07:14.845 --> 00:07:17.407
we are gonna look at this array.

140
00:07:17.407 --> 00:07:19.340
Instructions, we're gonna
look at what it is.

141
00:07:19.340 --> 00:07:22.315
It's the multiplyBy2 functionality.

142
00:07:22.315 --> 00:07:25.088
That has literally replaced
the placeholder that was previously,

143
00:07:25.088 --> 00:07:26.770
a placeholder instructions.

144
00:07:26.770 --> 00:07:32.084
All right let's walk through it,
as precisely as we can.

145
00:07:32.084 --> 00:07:36.131
Okay, so we've done our parameters, Alt?

146
00:07:36.131 --> 00:07:36.980
We've done our parameters.

147
00:07:36.980 --> 00:07:38.317
What's our next line in our local memory?

148
00:07:38.317 --> 00:07:39.571
Don't add parameters arguments,

149
00:07:39.571 --> 00:07:42.440
what's the next bit in our local memory?
&gt;&gt; Muhammad: We're starting our output

150
00:07:42.440 --> 00:07:45.190
to our memory.
&gt;&gt; Will: I'm gonna put again,

151
00:07:45.190 --> 00:07:50.940
our sort of working area over here,
so sort of not ideal but there we go.

152
00:07:50.940 --> 00:07:55.400
Output exactly is an empty array,
there we go, output.

153
00:07:55.400 --> 00:07:59.358
Just so
we can work with these slightly easier.

154
00:07:59.358 --> 00:08:05.948
Okay, big moment, Andrea,
we're gonna hit the body of that for loop.

155
00:08:05.948 --> 00:08:07.732
We've done outputs in empty array.

156
00:08:07.732 --> 00:08:10.396
We're going to hit the body of that for
loop.

157
00:08:10.396 --> 00:08:14.325
First time we do, what's the first,
I guess, variable,

158
00:08:14.325 --> 00:08:16.930
of who's value we're interested in?

159
00:08:16.930 --> 00:08:18.508
JavaScript kinda works inwards-outwards,
so

160
00:08:18.508 --> 00:08:21.760
what's the first one we're interested in?
&gt;&gt; Andrea: That's the i to 0.

161
00:08:21.760 --> 00:08:23.677
&gt;&gt; Will: i is 0, spot on.

162
00:08:23.677 --> 00:08:29.159
So i is 0, so array index zero is what,

163
00:08:29.159 --> 00:08:33.670
Andrea?
&gt;&gt; Andrea: Subzero 1.

164
00:08:33.670 --> 00:08:34.680
&gt;&gt; Will: Andrea,

165
00:08:34.680 --> 00:08:37.430
this is very very good but
everyone want's to hear.

166
00:08:37.430 --> 00:08:40.310
So nice.
So, it's spot on Andrea, it's really nice.

167
00:08:40.310 --> 00:08:43.355
So array subzero is the value 1.
&gt;&gt; Andrea: Yes.

168
00:08:43.355 --> 00:08:44.585
&gt;&gt; Will: My goodness,

169
00:08:44.585 --> 00:08:48.730
exactly, there it is, the value 1.

170
00:08:48.730 --> 00:08:53.894
And now that 1,
that means this little portion here 0,

171
00:08:53.894 --> 00:08:58.737
1, what's this instructions
work be a placeholder

172
00:08:58.737 --> 00:09:02.953
now being filled with, Andrea?
&gt;&gt; Andrea: MultiplyBy2.

173
00:09:02.953 --> 00:09:04.983
&gt;&gt; Will: The function multipliedB2.

174
00:09:04.983 --> 00:09:09.508
So actually, what is this
little portion here become but,

175
00:09:09.508 --> 00:09:13.407
multiplyBy2, open parens, 1, close parens.

176
00:09:13.407 --> 00:09:17.980
Well that's saying,
go run the multiplyBy2 function.

177
00:09:17.980 --> 00:09:20.770
And when we start running
a function Andrea, what do we do?

178
00:09:20.770 --> 00:09:24.333
We create a brand new, everyone together?
&gt;&gt; All: And

179
00:09:24.333 --> 00:09:26.710
in context?
&gt;&gt; Will: We forgot to add this one in

180
00:09:26.710 --> 00:09:27.892
the first place well.

181
00:09:27.892 --> 00:09:30.890
So copyArrayandManipulate, when we started
running it we added it to the cold stacks.

182
00:09:30.890 --> 00:09:33.825
So we already inside
copyArrayandManipulate, to see,

183
00:09:33.825 --> 00:09:35.851
JavaScript needs to know these stuff.

184
00:09:35.851 --> 00:09:37.340
There we are, add that to the cold stacks.

185
00:09:37.340 --> 00:09:42.439
And yes, we now exactly as Andrea said,
stop calling,

186
00:09:42.439 --> 00:09:47.336
instructions which is
really just multipliedBy2.

187
00:09:47.336 --> 00:09:50.761
But let's refer to it
as instructions here.

188
00:09:50.761 --> 00:09:53.725
Instructions which is really just what

189
00:09:53.725 --> 00:09:54.475
Andrea?

190
00:09:54.475 --> 00:09:57.390
&gt;&gt; Andrea: Parameter.
&gt;&gt; Will: What is

191
00:09:57.390 --> 00:09:58.860
instructions really just?

192
00:09:58.860 --> 00:10:00.020
&gt;&gt; Andrea: MultiplyBy2.
&gt;&gt; Will: By 2.

193
00:10:00.020 --> 00:10:03.823
And we pass in the what value?
&gt;&gt; Andrea: First value in

194
00:10:03.823 --> 00:10:04.790
the array.
&gt;&gt; Will: Which

195
00:10:04.790 --> 00:10:05.780
is?
&gt;&gt; Andrea: 1.

196
00:10:05.780 --> 00:10:07.220
&gt;&gt; Will: 1 exactly, and

197
00:10:07.220 --> 00:10:11.510
if we're calling it we create a new,
execution context.

198
00:10:11.510 --> 00:10:16.891
There it is with a local
memory of its own.

199
00:10:16.891 --> 00:10:22.232
And Andrea what happens to our call stack?
&gt;&gt; Andrea: It

200
00:10:22.232 --> 00:10:25.400
get's added to the call stack.
&gt;&gt; Will: The call to instructions,

201
00:10:25.400 --> 00:10:30.540
multipliedBy2, there the same thing,
gets added to the call stack.

202
00:10:30.540 --> 00:10:31.475
There it is.

203
00:10:31.475 --> 00:10:32.883
Now we know when we finish writing it,

204
00:10:32.883 --> 00:10:35.713
where are we gonna go back to Andrea?
&gt;&gt; Andrea: It's gonna back down and

205
00:10:35.713 --> 00:10:37.110
it's gonna come up.
&gt;&gt; Will: Exactly,

206
00:10:37.110 --> 00:10:39.030
that's why a stack is a good
way of tracking this,

207
00:10:39.030 --> 00:10:40.930
you add something, start running it.

208
00:10:40.930 --> 00:10:44.653
When you finish running it you want to
go out one step, where you go down and

209
00:10:44.653 --> 00:10:47.677
you take it off and
go back out to copyArrayandManipulate.

210
00:10:47.677 --> 00:10:51.030
And when we go, this is a tough bit Clara.

211
00:10:51.030 --> 00:10:55.175
I'm inside the core to instructions,
I've passed which is really multipliedBy2,

212
00:10:55.175 --> 00:10:55.980
I passed in one.

213
00:10:55.980 --> 00:11:00.944
What's my first pairing of label and data
inside the local memory, given this is

214
00:11:00.944 --> 00:11:04.528
really just multiplyBy2, Clara?
&gt;&gt; Clara: So input.

215
00:11:04.528 --> 00:11:05.727
&gt;&gt; Will: Input, exactly, and

216
00:11:05.727 --> 00:11:08.697
it's assigned what?
&gt;&gt; Clara: The parameter,

217
00:11:08.697 --> 00:11:11.202
you're going with 1.
&gt;&gt; Will: The 1, exactly, exactly,

218
00:11:11.202 --> 00:11:16.761
cuz we're now really running
the functionality multipliedBy2, everyone.

219
00:11:16.761 --> 00:11:22.854
So that, this portion here, 0, 1 and
that 1 got thrown into instructions

220
00:11:22.854 --> 00:11:28.390
which is really multipliedBy2, so
that 1 got thrown in as input.

221
00:11:28.390 --> 00:11:29.600
And there it is.

222
00:11:29.600 --> 00:11:33.870
Shit, there it is, input 1, and so we do.

223
00:11:35.570 --> 00:11:41.400
1, which is input, by 2 and
return that 2 out.

224
00:11:41.400 --> 00:11:47.240
Which means now, multiplyBy2 with
the input of 1, this whole statement,

225
00:11:47.240 --> 00:11:51.750
has evaluated, has become,
that output value 2.

226
00:11:51.750 --> 00:11:54.325
And what do we do with that 2, Andrea?

227
00:11:54.325 --> 00:11:56.759
We times it.

228
00:11:56.759 --> 00:12:00.173
What do we do with that evaluated result,
Lindsay?

229
00:12:00.173 --> 00:12:01.090
&gt;&gt; Lindsay: Push it into the output.

230
00:12:01.090 --> 00:12:02.550
&gt;&gt; Will: We push it into output.

231
00:12:02.550 --> 00:12:03.830
Spot on, there it is.

232
00:12:03.830 --> 00:12:06.278
And what happens to our execution context,
Lindsay?

233
00:12:06.278 --> 00:12:09.730
&gt;&gt; Lindsay: It goes away.

234
00:12:09.730 --> 00:12:10.401
&gt;&gt; Will: It goes away.

235
00:12:10.401 --> 00:12:12.770
We poshly say it gets popped off.

236
00:12:12.770 --> 00:12:18.100
Yeah, it goes away but it's a for
loop, it's a for loop.

237
00:12:18.100 --> 00:12:23.084
So, what happens, even though
we throw away execution context,

238
00:12:23.084 --> 00:12:27.891
it's all gone for the running
of instructions that first time.

239
00:12:27.891 --> 00:12:30.186
Well what do you know, it's a for loop.

240
00:12:30.186 --> 00:12:36.340
So, we're gonna hit the body of the for
loop again and this time, Griffin,

241
00:12:36.340 --> 00:12:38.910
this time Griffin, what is the value of i?
&gt;&gt; Griffin: 1

242
00:12:38.910 --> 00:12:41.060
&gt;&gt; Will: 1 and therefore we've get

243
00:12:41.060 --> 00:12:43.210
a raise sub-1 which is.
&gt;&gt; Griffin: 2

244
00:12:43.210 --> 00:12:44.726
&gt;&gt; Will: And we take that 2 and

245
00:12:44.726 --> 00:12:46.441
we do what with it?
&gt;&gt; Griffin: We pass

246
00:12:46.441 --> 00:12:48.090
it into instructions.
&gt;&gt; Will: Which is really

247
00:12:48.090 --> 00:12:48.872
just?
&gt;&gt; Griffin: MultiplyBy2.

248
00:12:48.872 --> 00:12:50.530
&gt;&gt; Will: Very good, exactly,

249
00:12:50.530 --> 00:12:54.895
instructions and
we call that instructions, there it is,

250
00:12:54.895 --> 00:12:58.370
the 2 gets parsed in to the local memory.

251
00:12:58.370 --> 00:13:01.740
Call stack, what happens?
&gt;&gt; Griffin: It gets pushed out of there?

252
00:13:01.740 --> 00:13:03.927
&gt;&gt; Will: It gets pushed on again,

253
00:13:03.927 --> 00:13:06.410
new execution context.

254
00:13:06.410 --> 00:13:10.350
Inside, what's the first data pairing?
&gt;&gt; Griffin: Input and 2?

255
00:13:10.350 --> 00:13:12.611
&gt;&gt; Will: Yeah, input and 2, and

256
00:13:12.611 --> 00:13:17.530
we do 2 by 2,
which becomes 4 out at returns.

257
00:13:17.530 --> 00:13:19.693
Return out four.

258
00:13:19.693 --> 00:13:24.062
That means this little portion here,
multipliedBy2 the input of 2 is evaluated

259
00:13:24.062 --> 00:13:27.221
to 4, and that 4 gets pushed where?
&gt;&gt; Griffin: To outputs?

260
00:13:27.221 --> 00:13:30.358
&gt;&gt; Will: Perfect, there it is, and then,

261
00:13:30.358 --> 00:13:36.780
this goes it gets created again,
we get 6, our output is now 2, 4, 6.

262
00:13:36.780 --> 00:13:41.690
And we hit the key line,
Mohamed, which is?

263
00:13:41.690 --> 00:13:45.585
What's the final line of the function?
&gt;&gt; Muhammad: Return output.

264
00:13:45.585 --> 00:13:46.514
&gt;&gt; Will: Return, see,

265
00:13:46.514 --> 00:13:51.650
I have an amazing habit of always calling
on the same people for the same thing.

266
00:13:51.650 --> 00:13:54.130
So what do I actually return out Mohamed?
&gt;&gt; Muhammad: 2, 4, 6.

267
00:13:54.130 --> 00:13:55.543
&gt;&gt; Will: Yeah the value associated with

268
00:13:55.543 --> 00:13:56.253
output right?

269
00:13:56.253 --> 00:14:00.374
JavaScript never see's a word and leaves
it, it evaluates everything down to it's

270
00:14:00.374 --> 00:14:03.180
lowest possible part so
it see's the word output.

271
00:14:03.180 --> 00:14:05.425
It goes, hold on, what is that?

272
00:14:05.425 --> 00:14:10.407
It's 2, 4, 6,
return's that output out, 2, 4,

273
00:14:10.407 --> 00:14:15.210
6, and where do we say Mohamed
we’re gonna assign it?

274
00:14:15.210 --> 00:14:17.048
&gt;&gt; Muhammad: To the label result.

275
00:14:17.048 --> 00:14:21.018
&gt;&gt; Will: To the label result, and

276
00:14:21.018 --> 00:14:23.102
there it is.

277
00:14:23.102 --> 00:14:27.244
So this is hard, this is supposedly one
of the profound areas of JavaScript,

278
00:14:27.244 --> 00:14:31.197
high order func, we'll see in a moment
we've already encountered all of

279
00:14:31.197 --> 00:14:35.010
the material high order functions,
at least with call backs.

280
00:14:35.010 --> 00:14:39.160
But I wanna have thumbs in a moment,
on what we saw here.

281
00:14:39.160 --> 00:14:44.750
But look, we achieved with
a generalized copyArrayAndManipulate,

282
00:14:44.750 --> 00:14:49.010
and then a specific little baby function,
that we passed in, for

283
00:14:49.010 --> 00:14:51.400
the specifics,
of what we're gonna do to each element.

284
00:14:51.400 --> 00:14:55.089
We achieved exactly the same as we did,
copy array and multiplyBy2,

285
00:14:55.089 --> 00:14:58.660
when we took a 1, 2, 3 and
came out with 2, 4, 6.

286
00:14:58.660 --> 00:15:04.370
Look at this, went in 1, 2, 3, but we had
no specificity, of multiplyBy2 in there.

287
00:15:04.370 --> 00:15:09.516
Instead we left a placeholder,
which we then determined what it would

288
00:15:09.516 --> 00:15:14.760
be when we called copyArrayAndManipulate,
and what do we end up with?

289
00:15:14.760 --> 00:15:15.502
2, 4, 6.

290
00:15:15.502 --> 00:15:16.407
The very same result, we could have
parsed in no multiplyBy2 but add 3 or

291
00:15:16.407 --> 00:15:16.999
divide by 2,
we ended up with the same result.

292
00:15:16.999 --> 00:15:21.374
We paramitised,

293
00:15:21.374 --> 00:15:28.960
we generalized our function.

