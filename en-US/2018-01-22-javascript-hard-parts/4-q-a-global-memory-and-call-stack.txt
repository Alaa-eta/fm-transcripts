[00:00:00]
>> Will Sentance: One more thing, let's just remind ourselves, we keep track of the functions being called in JavaScript with a call stack. It tracks which execution context we are in. That is, what function is currently being run and when we finish running that function, where do we return to?

[00:00:19]
The next thing down the stack, we start with one global execution context and then we could have many function level execution contexts above. All right, so at this point, we are gonna use a tried and tested teaching pedagogical method known as thumbs. I have no idea what has happened here I need to go back to, what is that place called?

[00:00:45]
What is it called? Point something academy? I need to go back, I have some clarifications. I can see where we're going but I've got some questions. I can phrase it as a question. I'm clear on these fundamental, pivotal pieces. That are running in the background as we run our code.

[00:01:03]
I'm clear on why we have them. That they're there and we will use these as our tools for the rest of the two days. So I need to see clarifications. Sorry, how does this bit work or how does this bit work? I need to understand that before I can fully understand the rest of stuff.

[00:01:18]
Everybody's thumbs out. No idea what happened, clarifications? And clear to move on. Everybody's thumbs out. I want a honest thumb self appraisal. Matt has a clarification, if you have your thumb up, I should be confident to be able ask you to explain whats just happened here. Everyone's thumbs out.

[00:01:34]
Matt has a clarification. Mohammed has one. Mohammed's thumb went from up to clarification. It's up, it's still up. Okay, what was your name again?
>> Cara: Cara,
>> Will Sentance: Cara, sorry Cara. Is that a medium thumb?
>> Cara: I wouldn't say I'm comfortable explaining things, but I think I understand.
>> Will Sentance: Okay, well I would love to see, if everyone's thumbs up, okay, I wanna see Matt's clarification.

[00:01:53]
Can you talk us through, Matt?
>> Matt: Well, I guess I just wonder how do we get from the function of multiply two and then we bounce down to the constant of output multiplied by two.
>> Will Sentance: See this is why clarifications are so great, what a great clarification by Matt it shows a, I don't want to say confusion, an interpretation.

[00:02:18]
That many, many people have and that is based in a yes misunderstanding I guess maybe I don't know whatever. Matt, great question. We do not jump back up to multiply by two. When I run my one. It says store. Well, what does my one say in the code?

[00:02:40]

>> Matt: Store the function.
>> Will Sentance: No, what's line one say?
>> Matt: [INAUDIBLE]
>> Will Sentance: Yep, what's line two say?
>> Matt: Function is multiplied by 2.
>> Will Sentance: It says, exactly, it says go store, it says go store all the exact function text In that function definition go store it in the label multiplied by two.

[00:03:05]
After I've declared the function multiplied by two Matt. What if I were to write this, console dot log, to log into my console multiplyBy2. What would I see in my console, Matt?
>> Matt: I don't know.
>> Will Sentance: Have a think about it, give it a shot. What would make sense?

[00:03:32]
Javascript sees the the word multiplBy2, where's it go looking for it in the function. Where is it go looking for more [INAUDIBLE], Andrea?
>> Andrea: In global memory.
>> Will Sentance: In global memory, what's it find?
>> Andrea: It finds the function.
>> Will Sentance: The whole function definition. So if I were to console.Log(Multiplyby2), Clara, what would I see in my console?

[00:03:53]

>> Cara: Don't remember exactly, but it say something like this is a function object.
>> Will Sentance: It will say this is a functional object, but it will actually be, it's the whole function. Depending on your console, that's a really good point by Clara. Some basic older consoles will just say function, but chrome dev tools will literally say, if there's that console here, it'll literally say, function.

[00:04:15]
Multiply by two num and then have return, it would have the whole code inside. So Matt, when we call multiply by two there in line two and we invoke, when we run it with parenthesis, do you see where it says cons output? Equal yet, we are not jumping back into the function.

[00:04:36]
What are we doing? We're going to memory and we're grabbing this definition to use it. Does that make sense?
>> Matt: So it's already stored?
>> Will Sentance: It's already stored. The word function, the word count, all they're doing is saying javascript, free up some space to store this stuff that's following.

[00:04:49]
Does that make sense?
>> Matt: So that's our state?
>> Will Sentance: That's our state. That's our live data Docile. And that life dated can include actual functionality like that. Do you see that now Matt that when you are calling multiply by two you are not going back in the code back up to the definition earlier on.

[00:05:07]
No, that definition is being grabbed. Stored under a label in memory.
>> Matt: So that's the definition of the synchronus line by line. Reading of, I don't know.
>> Will Sentance: I would say essentially we have taken our function definition, stored the what do I do line by line, in memory, under the label multiply by two, when I run multiplyBy2, I go look in memory.

[00:05:30]
I find this code and I say grab this code make some space to start going through it line by line and just start doing it line by line, and storing stuff in memory there. When I finish running that function, well, where do I go next? Well, we have multiplied by 2 on the call stack, I go back out to global.

[00:05:49]
Alex, go ahead.
>> Alex: I'm just curious where, where the call stack is located, is it also in the memory? The call stack.
>> Will Sentance: It is also in our memory but for our purposes, we don't need to know exactly where it's being stored. But it's there in our JavaScript run time.

[00:06:04]
It's part of the JavaScript engine being run. Makes sense?
>> Alex: Makes sense.
>> Will Sentance: All right, go ahead, Griffin.
>> Griffin: Is there a different call stack for each JavaScript file? If you're importing stuff from one file to another. Does it import it into that one's call stack?
>> Will Sentance: If we have one JavaScript application running it has one call stack.

[00:06:32]

>> Griffin: Which is at the highest one?
>> Will Sentance: When that's imported you're taking code to be run, when it's being run in this environment, in a single environment. But you do raise an interesting question, which I'm going to go into here. But you can have multiple separate JavaScript call stats run to all of this.

[00:06:52]
And that happens when you use things like web workers or other child. Things which allow you to have multiple background areas in JavaScript. But we don't need to worry about that for here, okay? Yeah Mark?
>> Mark: I don't know how to pronounce his name, but he's asking about const num equals 3, why did you write that?

[00:07:13]

>> Will Sentance: Good question. Just to show some basic data being stored. We did not use as 3, we just wanted to have some evidence that we can store data in memory. That's all, it was just for a pedagogical technique. Tell him that, all right.
>> Mark: Is the global threat and local threat different?

[00:07:31]

>> Will Sentance: No, they are, it's the single threat. The threat is just a posh name, don't think of the threat as some fancy mystique driven thing. All it is is just a posh name for, we did line one, then we did line two multiplied by two. Then we did line three declaring output.

[00:07:49]
That said, we don't want to put an output yet, we've gotta go run the function multiplied by two. And so we stopped doing the code line by line globally and started doing the code line by line inside the function body but it's just more code to read and done.

[00:08:03]
So they are absolutely same thing, okay? Yes go ahead, Clara.
>> Cara: Is there any reason to use constants that are like var?
>> Will Sentance: Because as a default, I personally, there's a default increasingly through EF2015 for anything you should default to const, unless you are actually going to reassign it in memory.

[00:08:25]
Because this num is never touched, we can use const. Because output is not being outed any way here, we can use const. So there's this sort of default rule that you should always default to const for declaring what you previously would have thought of as declaring your variables.

[00:08:42]
And then use let as a backup, if you're ever going to do some reassignment. And say no, no, no, no, right now, it's four, we're gonna make it five. Right not it's string will, we're gonna make it to string Clara, then you can use let. But otherwise, you should be declaring all your stuff with const, okay?

[00:09:01]
But think of it as just, it's var. It's var, but just has some special rules around it which aren't gonna. Those special rules aren't gonna affect us here. Not in any of the stuff we're doing today. But think of it as var, just as you know the behavior of var.

[00:09:17]
Think of it the same way here. It has some special properties but we don't need to worry about those right here. Those special properties being you can't change it but besides that we don't need to worry about those here. All right, so here we go.
>> Ahmin: I have a question.

[00:09:33]

>> Will Sentance: Go ahead Ahmin.
>> Ahmin: What about if the function is declared after it's being caught?
>> Will Sentance: Yeah, I wanna hold on that question, Ahmin, this is a concept known as hoisting. We don't need to in this, we're not going to come to it. Again, it has no implications for the things we're gonna see today.

[00:09:53]
So part of the challenge we are to face, when we're doing the hard parts over language is figuring out which bits do we wanna dive deep on. And which ones are we gonna say you know what, actually, that's not gonna have any implications for how we're gonna solve these challenges.

[00:10:07]
So on that one, we'll hold on that.

