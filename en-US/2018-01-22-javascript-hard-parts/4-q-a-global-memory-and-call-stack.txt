[00:00:00]
>> Will: One more thing. Let's remind ourselves we keep track of the functions being called in JavaScript with a call stack. It tracks which execution context we are in. That is, what function is currently being run and when we finish running that function where do we return to? The next thing down the stack.

[00:00:21]
We start with one global execution context, and then we can have many function level execution contexts above. All right, so at this point, we are gonna use a tried and tested teaching pedagogical method known as thumbs. I've no idea what has happened here. I need to go back to, what's that place called?

[00:00:45]
What's it called? Point something academy. I need to go back. I have some clarifications. I can see where we're going, but I've got some questions. I can phrase this as a question. Unclear on these fundamental pivotal pieces that are running in the background as we run our code.

[00:01:03]
I'm clear on why we have them, that they're there and that we will use these as our tools for the rest of the two days. So I need to see clarifications. Sorry, how does this bit work? Or so how does this bit work? I need to understand that before I can fully understand the rest of stuff.

[00:01:18]
So everybody thumbs out, nor do what happened, clarifications and clear to move on. Everybody thumbs out I want the honest thumb self-appraisal. Matt has a clarification. If you've got your thumb up, I should be confident to go to RC to explain what's just happened here. Everyone's thumbs out, Matt has a clarification, Mohammad has one, Mohammad's thumb went from up to a clarification.

[00:01:39]
It's up, still up? Okay, what was your name again?
>> Clara: Kara.
>> Will: Kara, sorry Kara. Is that a medium thumb?
>> Clara: I wouldn't say I'm comfortable explaining things, but [CROSSTALK]
>> Will: Okay.
>> Clara: I think I understand it.
>> Will: Well, I would love to see, if everyone's thumbs up, okay, I wanna see Matt's clarification.

[00:01:53]
Can you talk us through Matt?
>> Matt: Well, I guess I just wonder how do we get from the function of multiply2, and then we bounce down to the constant of output multiply by 2. I guess-
>> Will: That's a really, see, this is why clarification is so great. What a great clarification from Matt.

[00:02:13]
It shows a, I don't wanna say confusion, an interpretation that many, many people have. And there is based in a misunderstanding, I guess. Maybe you're on it, whatever. Matt, great question. We do not jump back up to multiply by 2. When I run my one, it says to, what that one line say in the code

[00:02:42]

>> Will: No, what's my one say? Yep, what's line two say?
>> Matt: The function is multiplied by 2.
>> Will: It says, that says go store, it says go store all the exact function text in that function definition, go store it in the label multiplied by 2. After I've declared the function multiplied by 2 map, what if I were to write this, console.log to log to my console multiply by 2.

[00:03:22]
What would I see in my console Matt?
>> Matt: I don't know.
>> Will: Have a think about it. Give it a shot. What do you think? What would make sense? JavaScript sees the word multiply by 2, where does it go looking for it?
>> Matt: In the function.
>> Will: Where do you go looking for more Andrea?

[00:03:40]

>> Andrea: The global memory.
>> Will: In global memory what's defined?
>> Andrea: The function?
>> Will: The whole function definition. So if I where to console log multiple by 2, Clara, what would I see in my console?
>> Clara: I don't remember exactly, but it says something like this is a function objects.

[00:03:57]

>> Will: It will say this is a function, but it will actually be, it's the whole function. Depending on your call, that's a really good point by Clara. Some basic, I would call it console just say function. But Chrome DevTools will literally say console here, it'll literally say function multiplyby2(num) and then it'll have return, it'll have the whole code inside.

[00:04:25]
So Matt, when we call multiply by 2 there in line three, when we invoke, when we run it with threads, do you see where it says const output equal, yeah. We're not jumping back into the function. What are we doing? We're going into here memory, and we're grabbing this definition to use it.

[00:04:39]
Does that make sense?
>> Matt: So it's already stored.
>> Will: It's already stored. The word function, the word const, all they're doing is saying, JavaScript, free up some space to store this stuff that's following. Does that make sense now?
>> Matt: So that's the state.
>> Will: That's our state. That's our live data.

[00:04:53]
That's how, and that live data can include actual functionality, like that. Do you see that now, Matt? When you're calling multiply by 2, you're not going back in the code, back up to the definition earlier on. No, that definition is being grabbed, stored under a label in memory.

[00:05:11]

>> Matt: So, that's the definition of the synchronous line by line reading of.
>> Will: I don't know, I would say essentially we have taken our function definition, stored the what do I do line by line in memory under the label multiplied by 2. When I run multiplied by 2, I go look in memory, I find this code and I say grab this code.

[00:05:33]
Make some space to start going through it line by line. I just start doing it line by line and storing stuff in memory there. When I finish running that function, well, where do I go next? Well we have multiply by 2 on the Call Stack. I go back out to global.

[00:05:48]
Art go ahead.
>> Art: I was just curious, where is the Call Stack, is it also in the memory? The Call Stack.
>> Will: It is also in our memory, but for our purposes, we don't need to know exactly where it's being stored. But it's there in our JavaScript runtime.

[00:06:04]
It's part of the JavaScript engine being run. Make sense?
>> Art: Makes sense.
>> Will: Go ahead, Griffin.
>> Griffin: Is there a different Call Stack for each JavaScript file if you're importing stuff from one file to another? Because it imported into that one's Call Stack?
>> Will: If we have one JavaScript, if we have one JavaScript application running, it has one Call Stack.

[00:06:32]

>> Griffin: We just add the highest, or what?
>> Will: It's just, when that's supported you're taking code to be run while it's being run in this environment, a singular environment. But you do raise an interesting question, which we're going to go into here. But you can have multiple separate JavaScript call stacks run all this, and that happens when you use things like web workers or other child processes, things which allow you to have multiple background areas in jobs, but we don't need to worry about that for here.

[00:07:04]
Yeah, Mark?
>> Mark: I don't know how to pronounce his name, but he's asking about const num = 3. Why did you write that?
>> Will: Good question. Just to show some basic data being stored. We did not use num is 3, we just wanted to have some evidence that we can store data in memory, that's all.

[00:07:23]
It was just for a pedagogical technique, tell him that. All right.
>> Mark: Is the global thread and local thread different?
>> Will: No they are, it's the single thread. It's the thread is just a posh name, don't think of the thread as some kind of fancy mystic driven thing.

[00:07:42]
All it is is just a portion name for we did line 1, then we did line 2, multiply by 2, then we did line 3, declaring output. That said, we don't want to put an output yet. We've got to go run the function multiply by 2. And so we stopped doing the code line by line globally and started doing the code line by line inside the function body.

[00:08:01]
But it's just more code to be read and done. So they are absolutely the same thing, okay? Yes, go ahead Clara.
>> Clara: Is there any reason to use const instead of var?
>> Will: Because as a default, I personally, there's a default increase in the fruit in 2015, for anything you should default to constants unless you're going to actually reassign it in memory.

[00:08:25]
Because this num is never touched, we can use const. Because output is not being altered any way here, we can use const. So it's a sort of default rule that you should always default to const for declaring what you previously would have thought of as declaring your variables.

[00:08:42]
And then use let as a backup if you're ever going to do some reassignment and say no, no, no, no. Right now it's four, we're gonna make it five. Right now it's a string Will, we're gonna make it string Clara, then you can use let, but otherwise you should be declaring all your stuff with const.

[00:09:00]
Okay, but think of it as just, it's var. It's var, but just has some special rules around it. Which aren't gonna, those special rules aren't going to effect us here. Not in any of the stuff we're doing today. But, think of it as var, just as you know the behavior of var think of it the same way here.

[00:09:18]
It has some special properties, but we don't need to worry about those right here. Those special properties being you can't change it. But besides that, we don't need to worry about those here. All right, so here we go.
>> Ami: I have a question.
>> Will: Go ahead Ami.
>> Ami: What about if the function is declared after it's been got?

[00:09:40]

>> Will: Yeah, I want to hold on that question, I mean, this is a concept known as hoisting. We don't need to in this case, we're not going to come to it. Again, it has no implications for the things that we're gonna see today. So part of the challenge we must face when we're doing the hard parts.

[00:09:57]
All the language is figuring out which bits do we wanna dive deep on and which bits we would say, actually, that's not gonna have any implications for how we're going to solve these challenges. So on that one, we'll hold on it.

