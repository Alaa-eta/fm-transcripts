[00:00:00]
>> Will: We're gonna go through it line by line and see it play out in action. This is our final function for asynchronous JavaScript. Line one, what are we creating?
>> Arthur: We're declaring the display function.
>> Will: Exactly, we're declaring, we're defining the display function. There it is.
>> Will: Good.

[00:00:24]
Line two, so this line here is using jQuery's library, but we are really, inside this function, we are going to do something else. That this function does actually create an execution context in the conventional sense. Unlike setTimeout, which is built into JavaScript, $.get is not building to JavaScript, but it wraps up some built-in functionality.

[00:00:51]
So we're not going to look into how $.get works, it's just a jQuery function. But what it does do inside of it, which we can do ourselves manually in JavaScript, is spin up and speak to a web browser feature, API. Web browser feature, the one that does web requests, data requests.

[00:01:13]
That's what happens inside this $.get. So we're gonna treat it like it's a built-in function, so it's not going to create an execution constant on the call stack in the conventional sense. It is, because it's not a built-in function, it's gonna inside itself, use a built-in function. But unlike the setTimeout, which is very simple single line, the setting up the built-in function that makes a web request is four or five lines.

[00:01:36]
So we've wrapped it in this $.get. Just think of it, just like setTimeout, it's not gonna do anything interesting in JavaScript land, it's going to speak to web browser feature land, just like setTimeout does. Actually, it does a few things but they're not relevant to what we, they're not important.

[00:01:56]
All it does is spin up something in web browser feature land, not JavaScript land. So on that note, let's see that happen. $.get, just like setTimeout, we're gonna invoke it. We're gonna parse to it, this string, which is a URL, to somewhere on the Internet, this is a pretend API address.

[00:02:21]
Somewhere on the Internet where we have supposedly, a single tweet, which we can access from our API. How wonderfully convenient and unlikely that is. And we're gonna parse to it, this whole function definition, not calling this function, just its definition, okay? Now, how do I know what this is gonna look like?

[00:02:48]
Well, I go and look at the documentation for JavaScript, or in this case, jQuery, and look and see, what do I expect to parse to this function? If it says parse a URL, an API address that I can go and get data from, and a function that will be run when this API request, is request the data is complete.

[00:03:10]
So even though this does actually create an execution context because inside of $.get is not a built-in function to JavaScript, inside of it, it's using built-in functions that speak to APIs. So it's going to treat it the same way, and rather than say, creates execution context, we're gonna say, it speaks to web browser feature, which feature?

[00:03:33]
Well, it speaks to another one, we can go and see a list of all these features on MDN. We've seen timer, this one is called XHR HttpRequest.
>> Will: And what's it's taking in? Well, and remember this is not a JavaScript function in the conventional sense, this is a browser feature, a browser API.

[00:03:56]
That term is a bit confusing because it itself is going to make a request to an API, but it's a browser feature. And it takes in our functionality and our, or reference to our functionality and our URL that we're gonna speak to. And down here in web browser API land, we, yes, create, look at this.

[00:04:21]

>> Will: XHR HttpRequest before we create a timer, now we're gonna create an XHR HttpRequest. And associated with it, is our functionality which we call display. And we really clear, it doesn't care who display, that's all in JavaScript. That's just down here, and is it complete? Now before our timer completed instantly, this one ain't gonna complete instantly, this one's gonna go and do some work.

[00:04:55]
So firstly, it's got to figure out what is it going to be sending? Where is it even going? Where is it even sending out information? Well, it's sending out to twitter.com. And I'm not gonna get into exactly how that API request works, but just know that this is a feature of the browser, Chrome or Firefox, or whatever.

[00:05:16]
It's a feature of the browser that allows our web browser to speak to the Internet and therefore, to Twitter's server where this data is gonna be found. So it's gonna bundle up a message to send off, known as an HTTP request, to get this data. It has a URL, it has a method, a method which is, I'm getting data.

[00:05:43]
Server, expect me to be wanting to receive some data. We know that because we used this get, so in a way this get also makes its way in to access our HTTP request. And we want to know exactly what data we need. Well, it's /willsend/tweet/1. There we go.

[00:06:04]
Those are the things, and this becomes a big, old message that gets sent off to,
>> Will: Twitters, Twitter LLC, so to speak, service, and at this point, $.get has done its work. It's done its work, and we are now back. It's done its work in web browser. It's done its job of setting up this web browser feature, web browser API features in the background.

[00:06:44]
And it's done its work, and it's gonna go back to the global execution context. Where what do we encounter? Mohammad, what's the next line in our global execution context?
>> Mohammad: Log me first.
>> Will: Good, from Manny's eyes, were slowly falling shut, that was truly amazing, stepping up there, well done.

[00:07:02]
Me first, there it is. And so, me first happens in maybe one millisecond, perfect. In one millisecond, this occurs over here. Now, what's on our call stack at this point, where we're in global? We're in global,
>> Will: We are always in global, we have done our console log me first.

[00:07:29]
Me first, we've done that console log me first, there it is, me first. But in the background, is our XHR HttpRequest complete. Arthur, is it complete yet?
>> Arthur: Should be.
>> Will: Would it be complete immediately?
>> Arthur: No.
>> Will: Yeah, how long is it gonna take typically? Maybe a 100 milliseconds, 200 milliseconds to go and get our data from Twitter's server and bring it back.

[00:08:01]
So let's just say, at 200 milliseconds, we get our data back from Twitter's servers. And it comes back, and it's parsed into the form of an object with, this is a little bit approximate, an object with a property post, that says, hi. Perfect, we've got our data back at about 200 milliseconds.

[00:08:26]
Now at this point, Katie, what do you think is going to happen, now that we've complete, we have now completed this background API request. This background XHR HttpRequest is completed, we've got back our data, we said, go off to Twitter, try and get this data, this tweet. We did, back in the data.

[00:08:49]
What do we think's going to happen now, Katie, at this point? We have completed the function.
>> Shelby: Shelby.
>> Will: Shelb, sorry, my.
>> Shelby: [LAUGH]
>> Will: Where's Katie? See, I never really had a problem with confusing redheads before.
>> Shelby: The hair color?
>> Will: But this has been an ongoing issue.

[00:09:04]
Sorry, Shelby. Go ahead, Shelby.
>> Shelby: Push it to the call stack?
>> Will: Push it, meaning?
>> Shelby: The-
>> Will: What functionality?
>> Shelby: Display.
>> Will: Display function, exactly the code, and do we have anything left to run in global? No we don't, so no problem, exactly. I already said you're my favorite person in the class, Shelby, right on top we call our display function, we call our display function.

[00:09:29]
Now, we were waiting to run display. We wanted to defer, why did we want to defer the display in the first place?
>> Shelby: We were waiting for the data
>> Will: For the data to come back, yeah, so. Yes, Shelby. So, [LAUGH] Exactly, exactly as you say. We were waiting for the display, we'ere waiting for the data to come back.

[00:09:51]
So this display functionality, the way this XHR HttpRquest feature of JavaScript works is that, this display functionality when the post, when the data comes back, it's going to bond itself to this display functionality. So when we push display to the call stack, its first parameter is gonna be filled in with what, do you think, Katie?

[00:10:23]

>> Katie: The data that is retained.
>> Will: The data, exactly.
>> Katie: The post.
>> Will: This object here is going to fill in, I'm gonna be calling the display. Right now, it's just definition, I'm gonna call it, this definition has a, now, this is not exactly how the function works, but it has a first argument called data, something like that, that data will be filled in with the data that came back.

[00:10:50]
Now, how do we know whether it's the first argument, the second argument? The first argument is actually typically an error argument. How do we even know? Documentation. Documentation of XHR HttpRequest or documentation of a $.get will say, the first argument of the call back function that gets executed when the data returns, will be populated on execution with the data from the Twitter server.

[00:11:11]
Or it will say the first argument actually is an error parameter, which will be filled in with any error if an error comes back when the display function ends up being executed, the first argument will be filled with error, the second argument will be our data from the API.

[00:11:30]
Different functionality, different features will work in different ways. And that's not magic, it's just, it's out there ready for us to go find. We have to go look at the documentation. So, Bob, at this point. Bob. We have completed our web browser API browser feature, XHR HttpRequest has been completed.

[00:11:52]
We've got our data back from Twitter's server. We've therefore now gonna pass our call to display to our call stack. When we start executing a function Bob, executing a function, we get a brand new Bob.
>> Bob: Execution contact.
>> Will: Excellent Bob, correct. And what is that execution contact for, but a call to display.

[00:12:11]
There it is, and what's being passed, what exact thing is being passed, Katie, to display?
>> Katie: The objects.
>> Will: Exactly, there it is, with post if high. And we are creating context with the functionality of display. Note, where are we calling display? Are we calling it inside $.get?

[00:12:34]
No, we are definitely not. Easy confusion to think that somehow displays being run inside. No, we did $.get, we moved just like setTimeout, we moved straight on all that $.get was spin up and [INAUDIBLE] to be a request and pass a reference of the function that we pass to $.get.

[00:12:51]
Now again, $.get is actually a JavaScript function. But inside of it, it's behaving just like a setTimeout would, and that it's spinning as to any job is to spin up to reference and create using the web browser feature XHR HttpRequest. A request off to the Twitter API and that's all happening here separately and in JavaScript land, we moved straight on, we did not wait for that day to come back.

[00:13:18]
When we run console log, we're at about one millisecond. We are not 200 milliseconds later, but now, our data's come back, we're at about 201 milliseconds when we start calling the display. We're at about 201 milliseconds, when we start calling the display function. And we're executing it. So Griffin, what's the first thing inside our local memory of our display function, Griffin?

[00:13:45]

>> Griffin: That would be the data.
>> Will: That would be the data parameter which now has what associate, what value associated with it?
>> Griffin: B, the post and I.
>> Will: So the whole object, right? Yeah, with post Is high. So when I hit the line, console of data.post, I do console look for data, post.

[00:14:07]
What do I console log?
>> Griffin: High?
>> Will: High, there it is, at about 201 milliseconds. Me first was done at about one millisecond. So again, we've now used a different background browser API. Now I'm gonna give you all of them, your job is to go and figure out that all listed in MDN, will they all work this same way as when you use a built-in function $.get, inside of it, uses a built-in function that creates this.

[00:14:41]
Makes a reference or makes a spins up a background web browser feature. In this case, it's the data request feature, the HttpRequest feature. It could be a timer, it could be with a old bunch of them, in node, there is a whole bunch of them as well. They are all speaking to a non-JavaScript land, this is not JavaScript, this is not JavaScript.

[00:15:07]
Let's make sure we add in our two other pieces of this puzzle. Actually, what happens between,
>> Will: Actually, what happens between our completion and getting back on the course at, well, it's the display functionality is queued up. Display is queued up with its associated data that came back.

[00:15:37]
There's our associated data.
>> Will: With this associated data. And then we checked, was the call stack clear? Let's just go back a second. We checked, was the call stack clear. We said, hold on, is there something in the call back queue? Is the call stack that clear? That's known as the event loop.

[00:16:00]
That is not literally. I try to like desperately call an event loop, because it's not literally looping and checking. But we can think of it in under deep down the hood, it's not looping, but it's basically checking, is the call stack clear. Is it clear, every millisecond is it checking, is it clear, is it clear, is it clear, is it.

[00:16:18]
It's clear? Well of course, it's clear because it's 200 milliseconds later and there's nothing else in our code. Console log, finish at one millisecond. So were done, so it's definitely clear and instantly we can de-queue display and push it to the call stack. There it is. Display push to the call stack at about 201 milliseconds.

[00:16:42]
At about 201 milliseconds. 201 milliseconds with our data that came back from the API. Those are all our parts. And look, we took this display functionality, passed to the call back queue and then it once the event loop said good, we're good to go, de-queued display and added it, pushed it to the call stack where it then got executed just as we thought through.

[00:17:18]
You can see how, in these simple examples, this portion here doesn't really have any consequence, but for more complex examples, where we have things blocking in the main thread or where we have multiple requests, then this becomes very relevant. And as each request completes, it's gonna queue up the relevant call back function that's been associated with the particular web browser API.

[00:17:42]
So we can spin up as many as we want. We can have 30 XHR HttpRequests. All going here. As each one of them completes their function in order of the completion, it's going to be par for the call back queue, queued up. Now, in order of when these requests were made, but just in order of that completion.

