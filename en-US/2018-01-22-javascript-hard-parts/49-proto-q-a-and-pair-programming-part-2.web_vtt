WEBVTT

1
00:00:00.390 --> 00:00:01.710
&gt;&gt; Will Sentance: All right,
let's have fun.

2
00:00:01.710 --> 00:00:02.230
This is solution two.

3
00:00:02.230 --> 00:00:07.050
And by the way, solution three and four,
they are only gonna do this stuff.

4
00:00:07.050 --> 00:00:10.150
We're gonna see some fancy
keywords you've all heard of and

5
00:00:10.150 --> 00:00:13.320
probably tried to use and
use effectively maybe.

6
00:00:13.320 --> 00:00:18.570
Those fancy keywords, they're all just
gonna take some of these lines that we've

7
00:00:18.570 --> 00:00:21.380
handwritten here and automate them for us.

8
00:00:22.910 --> 00:00:23.960
That's all I'm gonna do.

9
00:00:23.960 --> 00:00:29.520
We have seen here the essence of how
OOP is implemented in JavaScript

10
00:00:29.520 --> 00:00:36.065
using this special prototypal,
_proto_, bond to an object above.

11
00:00:36.065 --> 00:00:41.320
That JavaScript knows to go and
look at when it hits an object,

12
00:00:41.320 --> 00:00:45.610
property that ain't there on the object,
directly.

13
00:00:45.610 --> 00:00:49.550
It knows to go check, through its
prototypal feature, its prototypal nature.

14
00:00:49.550 --> 00:00:51.260
All right, let's have thumbs on this.

15
00:00:51.260 --> 00:00:54.670
I don't know what happened,
clarification question, clear to go on.

16
00:00:54.670 --> 00:01:00.400
Dave has one, excellent, Andrew has one,
Katie has one, Art has one.

17
00:01:00.400 --> 00:01:03.584
Art, can we start with you?
&gt;&gt; Art: I was kind of wondering if you

18
00:01:03.584 --> 00:01:06.491
could have multiple prototypes?
&gt;&gt; Will Sentance: Great question.

19
00:01:06.491 --> 00:01:11.678
So, you cannot have, so you could,
but you're like sort of saying

20
00:01:11.678 --> 00:01:17.052
could I parse and use the function
store and then Arts function store.

21
00:01:17.052 --> 00:01:19.854
No, you cannot,
you can only have one direct parent.

22
00:01:19.854 --> 00:01:24.189
But, of course, you could then have
another parent of that object,

23
00:01:24.189 --> 00:01:26.840
and another parent of that object.

24
00:01:26.840 --> 00:01:31.900
And you can have multiple different
children of different types

25
00:01:31.900 --> 00:01:33.470
coming from the same parent.

26
00:01:33.470 --> 00:01:35.710
That is known as subclassing.

27
00:01:35.710 --> 00:01:38.680
We're not gonna cover that today.

28
00:01:38.680 --> 00:01:40.490
There is a talk I have on that.

29
00:01:40.490 --> 00:01:42.630
Maybe one day we'll do
it in Frontend Masters.

30
00:01:42.630 --> 00:01:46.330
It does subclassing in all of OP,
it is a brutal talk.

31
00:01:46.330 --> 00:01:49.580
There is no way we are going
to do it right now because

32
00:01:49.580 --> 00:01:52.510
we are more than doing
enough with pure OP here.

33
00:01:52.510 --> 00:01:56.980
But yes, you cannot have multiple but
you can multiple hierarchy up and

34
00:01:56.980 --> 00:01:59.290
they can have multiple descendants out.

35
00:01:59.290 --> 00:02:02.250
One can only have one parent, okay?

36
00:02:02.250 --> 00:02:04.223
Andrew?
&gt;&gt; Andrew: So does it only create

37
00:02:04.223 --> 00:02:09.101
the prototype like that if
you use the Object.create?

38
00:02:09.101 --> 00:02:10.401
&gt;&gt; Will Sentance: That's not the only

39
00:02:10.401 --> 00:02:12.088
way we can make that bond.

40
00:02:12.088 --> 00:02:16.447
Actually, all objects have
some automatic bonds.

41
00:02:16.447 --> 00:02:21.965
At the top of the chain, so above
userFunctionStore, userFunctionStore also

42
00:02:21.965 --> 00:02:27.335
has I don't wanna get into this too
much Andrew, but it's a little preview.

43
00:02:27.335 --> 00:02:32.573
Also has a proto bond on it, which
points up to, JavaScript's for this one,

44
00:02:32.573 --> 00:02:38.670
default object, which has a whole bunch
of shared functions on it of it's own.

45
00:02:38.670 --> 00:02:42.940
Things like get prototype of all
the functions you could ever call on

46
00:02:42.940 --> 00:02:45.770
an object, JavaScript dog
foods its own functionality.

47
00:02:45.770 --> 00:02:49.427
It uses its own built in
prototype chain to let,

48
00:02:49.427 --> 00:02:54.646
when you do a ray.push,
that push is actually stored on the array.

49
00:02:54.646 --> 00:02:59.027
On any array that gets created
it has it's own parent,

50
00:02:59.027 --> 00:03:04.220
which is all the bonus functionality
that we can use on arrays.

51
00:03:04.220 --> 00:03:10.705
So when you do an array.push, array is
an array, well that guy here has it's own,

52
00:03:10.705 --> 00:03:15.616
because really, an array is just
actually an object has its own

53
00:03:15.616 --> 00:03:20.063
proto bond to the array object
that has all of these shared

54
00:03:20.063 --> 00:03:25.189
functionality that all arrays have,
push, pop, all of these.

55
00:03:25.189 --> 00:03:29.421
I won't go into too much but
Andrews as preview there,

56
00:03:29.421 --> 00:03:33.290
all of these objects have
a proto bond by default.

57
00:03:33.290 --> 00:03:39.070
What we're really doing here is
inserting our own in the way.

58
00:03:39.070 --> 00:03:40.300
So there's a default one here,

59
00:03:40.300 --> 00:03:44.760
which is all objects, proto,
it's just the overall object.

60
00:03:44.760 --> 00:03:51.230
Which has its own, on its own, a bunch
of properties like, get prototype of.

61
00:03:51.230 --> 00:03:53.628
All of these functions can
be used on all objects,

62
00:03:53.628 --> 00:03:56.860
because they're all available
up the prototype chain.

63
00:03:56.860 --> 00:04:01.790
But we're just inserting ourselves
in the way here to set our own

64
00:04:01.790 --> 00:04:06.552
user function store in the interim,
so we check there first.

65
00:04:06.552 --> 00:04:08.710
Does that make sense?

66
00:04:08.710 --> 00:04:09.990
I don't want to go into that
too much if you don't mind.

67
00:04:09.990 --> 00:04:13.960
I don't want to go into too
much if you don't mind.

68
00:04:13.960 --> 00:04:18.240
But just know that every object
has an underscore _proto_.

69
00:04:18.240 --> 00:04:21.548
It's just that we're
overriding the standard one,

70
00:04:21.548 --> 00:04:25.074
here, with our own set of shared
functions that all of our

71
00:04:25.074 --> 00:04:28.840
objects that were created by user creator,
have access to.

72
00:04:28.840 --> 00:04:31.843
Okay, Andrew?
There's more clarifications, Katie?

73
00:04:31.843 --> 00:04:32.349
&gt;&gt; Katie: I'm clarified,

74
00:04:32.349 --> 00:04:33.598
now.
&gt;&gt; Will Sentance: You are.

75
00:04:33.598 --> 00:04:36.060
There we go.
[INAUDIBLE] from Griffin first,

76
00:04:36.060 --> 00:04:38.742
Griffin first.
&gt;&gt; Griffin: You said it's like overriding

77
00:04:38.742 --> 00:04:39.545
the object one?

78
00:04:39.545 --> 00:04:42.451
You can still get to the object one,
right?

79
00:04:42.451 --> 00:04:43.670
&gt;&gt; Will Sentance: Because we're overriding

80
00:04:43.670 --> 00:04:46.221
it with an object, which,
who's object prototype is?

81
00:04:46.221 --> 00:04:47.601
&gt;&gt; Griffin: The main object.

82
00:04:47.601 --> 00:04:48.488
&gt;&gt; Will Sentance: Okay, exactly, so

83
00:04:48.488 --> 00:04:49.748
it's a chain all the way up.

84
00:04:49.748 --> 00:04:51.652
Great clarification Griffin.

85
00:04:51.652 --> 00:04:53.176
Dave?
&gt;&gt; Dave: Second line up there,

86
00:04:53.176 --> 00:04:55.586
the let newUser = Object.create.

87
00:04:55.586 --> 00:04:58.124
Sorry, how do you say that in English?
&gt;&gt; Will Sentance: What's the right

88
00:04:58.124 --> 00:05:00.323
technical communication?
&gt;&gt; Dave: Yeah.

89
00:05:00.323 --> 00:05:01.434
&gt;&gt; Will Sentance: We are declaring, okay,

90
00:05:01.434 --> 00:05:03.005
very nice I like that question Dave.

91
00:05:03.005 --> 00:05:05.978
Very thoughtful question.

92
00:05:05.978 --> 00:05:12.362
We are declaring an object,
we are declaring newUser and

93
00:05:12.362 --> 00:05:16.352
assigning to it an empty object with

94
00:05:16.352 --> 00:05:21.679
the prototype of it
being userFunctionStore.

95
00:05:21.679 --> 00:05:26.453
Now again, I hate this with
the prototype of it, I wish we said with

96
00:05:26.453 --> 00:05:32.023
the _proto_ of it being but _proto_ is
the label we give to the prototype.

97
00:05:32.023 --> 00:05:37.079
We call whatever's here, the prototype
of this object but it's not stored in

98
00:05:37.079 --> 00:05:43.260
a property called the prototype,
it's stored in a property called _proto_.

99
00:05:43.260 --> 00:05:46.126
It is what it is but
it causes a humongous amount of confusion.

100
00:05:46.126 --> 00:05:50.010
And we're gonna see why in a moment
because there is a property called

101
00:05:50.010 --> 00:05:51.040
prototype and

102
00:05:51.040 --> 00:05:53.940
it ain't this one and it ain't
behaving the way this one is behaving.

103
00:05:53.940 --> 00:05:58.137
That is why I don't like the fact we call
this guy the prototype of this object

104
00:05:58.137 --> 00:06:01.301
because it's stored _ proto_,
it's the _proto_.

105
00:06:01.301 --> 00:06:05.328
I would say it's the object that's
one step part of the prototype chain.

106
00:06:05.328 --> 00:06:06.300
Not exactly a catchy phrase.

107
00:06:06.300 --> 00:06:09.248
If you wanna say that,
you can say declare newUser,

108
00:06:09.248 --> 00:06:13.403
assign two at an empty object with
userFunctionStore set as the one object

109
00:06:13.403 --> 00:06:15.760
that's one step up the prototype chain.

110
00:06:15.760 --> 00:06:17.331
If you wanna be super intuitive.

111
00:06:17.331 --> 00:06:22.000
But the typical ways, we'd
userFunctionStore as newUsers prototype.

112
00:06:22.000 --> 00:06:25.050
Okay, ask the question, Dave.
&gt;&gt; Dave: Yeah.

113
00:06:25.050 --> 00:06:26.410
&gt;&gt; Will Sentance: Do you want to

114
00:06:26.410 --> 00:06:28.570
try again?
&gt;&gt; Dave: Just the distinction between

115
00:06:28.570 --> 00:06:32.990
prototype and inherit from a-
&gt;&gt; Will Sentance: In JavaScript,

116
00:06:34.210 --> 00:06:37.760
by the way, I actually wrote a little note
to myself when I was first started giving

117
00:06:37.760 --> 00:06:41.010
the talk, I hate the word inherit
describing what we're doing here.

118
00:06:42.250 --> 00:06:46.020
Does inherit make it feel like you've
actually copied down the functionality

119
00:06:46.020 --> 00:06:46.710
onto the object?

120
00:06:46.710 --> 00:06:47.770
It does to me, a bit.

121
00:06:49.710 --> 00:06:56.620
This here, increment, sorry, user 1,
inherits the userFunctionStore.

122
00:06:56.620 --> 00:07:00.140
When we say inherit in JavaScript,
that is all we mean.

123
00:07:00.140 --> 00:07:02.880
Now are we copying those
functions down to user 1?

124
00:07:02.880 --> 00:07:07.860
No, inherit is a weird ass word to use for
this process.

125
00:07:07.860 --> 00:07:13.421
What actually is when we run user 1,
with a function reference on it that isn't

126
00:07:13.421 --> 00:07:19.737
in user 1, we check it's _proto_ where we
find this other object userFunctionStore.

127
00:07:19.737 --> 00:07:23.820
And we look up to it and go,
there's an increment function there.

128
00:07:23.820 --> 00:07:29.570
Now does that mean in a sense that
user 1 inherits increment function?

129
00:07:29.570 --> 00:07:34.550
Eh, I guess it feels like it does but
that is not being copied down, it's not.

130
00:07:34.550 --> 00:07:38.980
It's JavaScript at the run time is to
look up at that stuff and find it there.

131
00:07:38.980 --> 00:07:42.117
But when you hear people saying
user 1 inherited increment,

132
00:07:42.117 --> 00:07:43.998
that's exactly what it's saying.

133
00:07:43.998 --> 00:07:45.641
Great question, man.

134
00:07:45.641 --> 00:07:47.214
Really glad ou brought up that word.

135
00:07:47.214 --> 00:07:50.787
Okay, at this point do we do pairing now,
or do we push on?

136
00:07:50.787 --> 00:07:54.708
We're still quite early, so I think
we do another block of pairing, and

137
00:07:54.708 --> 00:07:59.289
then we're gonna come back to this after
another block of 20 minutes of pairings.

138
00:07:59.289 --> 00:08:03.361
We're gonna finish out for,
I reckon today, 4:00 to 4:15.

139
00:08:03.361 --> 00:08:07.575
So we're gonna do another blocker pairing,
just to cement some of this stuff.

140
00:08:07.575 --> 00:08:12.650
And in a moment after that we're gonna
come back and say you know what?

141
00:08:12.650 --> 00:08:17.455
All this writing, Object.create,
newUser, return newUser,

142
00:08:17.455 --> 00:08:23.550
we're gonna automate it all the way
with the insertion of a magic keyword.

143
00:08:23.550 --> 00:08:28.023
What's that magic keyword, do we think?
&gt;&gt; Art: Prototype.

144
00:08:28.023 --> 00:08:29.850
&gt;&gt; Will Sentance: Three letters.

145
00:08:29.850 --> 00:08:33.186
New, exactly.
That's gonna automate a ton of all this

146
00:08:33.186 --> 00:08:34.990
work for us.

147
00:08:34.990 --> 00:08:40.020
That work of creating an object that when
it gets returned out, give it a label,

148
00:08:40.020 --> 00:08:48.310
get somehow a special secret bond
to this shared store of functions.

149
00:08:48.310 --> 00:08:52.260
We're going to automate so
much of this with the keyword New.

150
00:08:52.260 --> 00:08:55.130
But for now folks back to challenges.

