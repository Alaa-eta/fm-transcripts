[00:00:00]
>> Will Sentance: And reveal, that actually, some magic happened. Some amazing, precise magic happened. When I've.
>> Will Sentance: Remember what we said? Where I define my function,
>> Will Sentance: determines. What did it say? Where you define your functions determines what variables your function has access to when you call the function. That's our overarching message.

[00:00:26]
Where you define determines. But hold on, increment counter was defined inside of outer, but we said outer's gone. So but we're saying also where your final determines what variables your function access to and you call the function, how can these two things be reconciled? Okay, let's see. When I define increment counter, when I was running outer, so we're right now inside the quarter outer.

[00:00:53]
We're inside the code outer, and the first thing we didn't say was to clear counter is 0. That increment counter is a function. When I declare the increment counter as a function, I didn't just declare it was a function. Behind the scenes, JavaScript did something very special. We're gonna learn how it works in a second.

[00:01:12]
But for now, what I'm gonna say, is where I define increment counter, I said define increment counter, determines what things are gonna be available. Where I define my function determines what data will be available when I end up calling that function. Wherever I call it, wherever I invoke it, wherever I execute it.

[00:01:29]
Where I defined it determines what data when I call it, it will have access to. So I define increment counter here, I did something else. I didn't just define it. I didn't just store its description, increment counter plus plus in memory, I did something else. I made a special bond to the immediate total surrounding live local memory.

[00:01:53]
I said this function get's a special bond to all this surrounding data. It's a special bond to all my surrounding data. IncrementCounter is not just a function. It's a function plus a special bond. To a little reference to all my surrounding data counter is zero, increment counter is a function.

[00:02:19]
Gives it a reference to the whole surrounding data when it gets defined. Meaning when I return that function out, do I just get the function? I get the function plus that special bond to the surrounding data from when that function was born. And what is in that surrounding data, that surrounding live store of data but not counter could be zero, but literally Counter,

[00:02:54]

>> Will Sentance: Is,
>> Will Sentance: 0. There it is, attached to my function definition. I return out the function value. Increment counter is a function with a reference to the surrounding data hidden on the back of the function. And when I return my function out, well, on the back of the function comes with it, it's surrounding data from where it was defined, and there it is.

[00:03:18]
And so that function that gets now, is given a new label. New label's my new function. All we need is the function. It's a function with a bond to its surrounding data.
>> Will Sentance: And now. So, we called my new function. Its code said counter ++. There was no counter in local.

[00:03:45]
Everything would suggest the next place we look at down our call stack, sort of we're calling my new function in global so we go out and look in global, for the counter. Where do you think we actually go and look, Andrea, before we look in global.
>> Andrea: We look in the-

[00:04:03]

>> Will Sentance: In the orange box.
>> Andrea: Yeah. [LAUGH]
>> Will Sentance: So I like to call this orange box a backpack. Now, this is definitely not the technical term for this orange box. There are, we're gonna give you a whole bunch of sophisticated technical terms for them, but note that in many ways it's like a backpack.

[00:04:20]
That function got a little bond to it's surrounding live store of data on it's back, and out came the functions stored in my new function and with it came it's backpack of live data from when it was defined. Not a bad name for it. Unfortunately, it's not standard letter name unfortunately.

[00:04:37]
We're gonna see what the real name for it is in a moment. First, let's just see what actually happens. Andrea, didn't find counter in local. Where did I actually go look before I looked in global? Andrea, where did I actually go look?
>> Andrea: You have my data in the backpack.

[00:04:53]

>> Will Sentance: In the backpack, thank you Andrea for indulging me. Thank you Madison for the green one. In the backpack. Say it proud, aloud, and say it in your interviews and look distressed. When they look at you and say, mm-mm. All right, though, what do we find? Counter is 0.

[00:05:10]
What do we do with, Andrea? What do we say we're gonna do with it?
>> Andrea: We're gonna increment it.
>> Will Sentance: Increment it. This is just the same thing. Increment it to 1.
>> Will Sentance: Increment it to 1.
>> Will Sentance: Not in our local memory, but in this live data store.

[00:05:28]
This backpack attached to the function definition. Okay, before we talk about how this is possible, all the ins and outs of this, we finish running my new function. We hit a counter. It was zero. We increment it to one. What happens to this execution context, Andrea?
>> Andrea: It's garbage-collected.

[00:05:45]

>> Will Sentance: Not that the data does. The execution context gets popped off the call stack. It's gone and we go back to global. Where what's the next line we encounter? Andrea?
>> Andrea: Hm.
>> Will Sentance: We're gonna call mynewfunction() again, basically. Let's call it again, mynewfunction(). Let's call it again. Everybody, actually, just Art.

[00:06:12]
I'm calling my new function, okay? Then, just Griffin. Griffin, I'm calling my new function. What do I create? A new?
>> Speaker 3: Execution.
>> Will Sentance: Are people really good together at doing it, really under the pressure of the individual person? I hope you got it.
>> Speaker 3: Re-execution code.
>> Will Sentance: Good job, man.

[00:06:31]
Yeah, exactly. Push it to the call stack, right?
>> Speaker 3: Yep.
>> Will Sentance: Push the call to mynewfunction(). The call stack. For this level of precision of communication may seem pedantic, but I was telling Lindsay, I was telling Bob, I think I was telling Cara as well. This is the stuff of seasoned developers.

[00:06:55]
There is little explanation why Codesmith folk grads get senior jobs. If there's one explanation, it's technical communication. So I've already seen a resounding levelling up even today. So even though it feels and I go, God, I know what execution context is. That level of precision, it makes a world of difference.

[00:07:14]
So in we go, and what's the first line inside say?
>> Speaker 3: It's counter ++.
>> Will Sentance: Counter ++. Now, where do I look for counter first?
>> Speaker 3: At first, local.
>> Will Sentance: Do I find it?
>> Speaker 3: No.
>> Will Sentance: Nope, just like that. This byte gets it gone, by the way, but yeah.

[00:07:30]
I've got a new empty local memory. Where do I look next? Where would my call stack sort of simplicity say? Given I'm calling my new function in global, one might think I'd look next in.
>> Speaker 3: Global.
>> Will Sentance: But where do I actually look?
>> Speaker 3: You go into your backpack.

[00:07:43]

>> Will Sentance: Into, beautiful music to my ears.
>> Speaker 3: Dora Explore it. [LAUGH] Yeah.
>> Will Sentance: [LAUGH] Dora the Explorer. I like that, she's nice. Okay, and what do we find? 1, and what do we do to it?
>> Speaker 3: You add one to it.
>> Andrea: And we get two.
>> Will Sentance: Okay folk, my backpack is persistent.

[00:08:01]
It holds onto that data life. Man, we've answered that thing, what if our functions had persistent memory in between calls? Anything that I declared inside my new function fills in a local memory, but finish writing that function, start again, it's gonna have to fill it all in again.

[00:08:19]
There's no memory between these function calls. But hold on, this backpack of data is attached to the function definition persists, it sticks on the back of the function definition in between function calls. Our function, my new function is a function with a store of data on it's back.

[00:08:39]
We'll go on in a second dude. We're gonna go round. We're gonna do thumbs in a moment. This is for me the most beautiful concept in all JavaScript. It is the most profound. We're gonna see OOP tomorrow, we're gonna see asynchronicity. Asynchronicity, list of rules. OOP, list of techniques.

[00:08:58]
Closure conceptually beautiful and empowering approach in JavaScript.

