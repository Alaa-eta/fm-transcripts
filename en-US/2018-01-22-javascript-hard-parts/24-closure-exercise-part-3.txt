[00:00:00]
>> Will Sentance: And a reveal that actually, some magic happened. Some amazing, precise magic happened when I.
>> Will Sentance: Remember we said, where I define my function, determines
>> Will Sentance: What does it say? Where you define your functions determines what variables your function have access to, when you call the function. That's a overarching message.

[00:00:26]
Where you define determines, but hold on. The increment count was defined inside of outer. But we said outer's gone. So, but we're saying also where you define one determines what variables your function will have access to, when you call the function. How can these two things be reconciled?

[00:00:44]
Okay, let's see. When I define an increment counter, when I was running outer. So we are right now inside the quarter outer. We're inside the quarter outer, and the first thing we did inside was declare our counter is zero. Then increment counter is a function, when I declared increment counter as a function, I didn't just declare it was a function.

[00:01:06]
Behind the scenes, JavaScript did something very special. We're gonna learn how it word in a second, but for now, what I'm gonna say is when I define increment counter, I said, define IncrementCounter determines what things are gonna be available. Where I define my function determines what data will be available, when I end up calling that function.

[00:01:25]
Wherever I call it. Wherever I invoke it. Wherever I execute it. Where I defined it determines what data, when I call it, it will have access to. So, I define increment counter here, I did something else. I didn't just define it. I didn't just store its description, IncrementCounter plus plus in memory, I did something else.

[00:01:44]
I made a special bond to the immediate total surrounding live local memory. I said, this function gets a special bond to all this surrounding data. Gets a special bond to all my surrounding data. IncrementCounter is not just a function. It's a function, plus a special bond, to a little reference to all my surrounding data, counter is zero, increment counter is a function.

[00:02:19]
It get's a reference to the whole surrounding data, when it gets defined. Meaning, when I return that function out, do I just get the function? Un un. I get the function, plus that special bond to the surrounding data from when that function was born. And what is in that surrounding data?

[00:02:44]
That surrounding live store of data, but not counter could be zero, but literally Counter is zero. There it is, attached to my function definition. I return out the function value, IncrementCounter is a function, with a reference to the surrounding data hidden on the back of the function. And when I return my function out, well, on the back of the function comes with it, its surrounding data from where it was defined.

[00:03:17]
And there it is. And so that function that gets now given a new label, new label's my new function. It ain't just a function. It's a function with a bond to its surrounding data.
>> Will Sentance: And now, so record my new function. Its code said, counter plus plus. There was no counter in local.

[00:03:45]
Everything would suggest the next place we look at down our call stack, sort of recalling my new function. In global, so we go out and look in global for the counter.
>> Will Sentance: Where do you think we actually go and look, Andrea, before we look in global?
>> Andrea: We look in the-

[00:04:02]

>> Will Sentance: In the orange box.
>> Andrea: Yeah.
>> Will Sentance: [LAUGH] So I like to call this orange box a backpack. Now, this is definitely not the technical term for this orange box. We gonna give you a whole bunch of sophisticated technical terms for them, but note, that in many ways it's like a backpack.

[00:04:20]
That function got a little bond to a surrounding life store of data on its back, and out came the function stored in my new function, and with it, came its backpack of live data from when it was defined. What about a name for it? Unfortunately, it's not the standard name, unfortunately.

[00:04:37]
We're gonna see what the real name for it is in a moment. First, let's just see what actually happens. So Andrea, didn't find counter in local. Where did I actually go look, before I looked in global? Andrea, where did I actually go look?
>> Andrea: You have data in the back pack.

[00:04:53]

>> Will Sentance: In the backpack, thank you, Andrea for indulging me, [INAUDIBLE] In the back pack, say it proud, and loud, and say it in your interviews, and look distressed when they look at you and say, mm-mm-mm. Alright, then what do we find counter at zero. What do we do with it, Andrea?

[00:05:10]
What did we say we were going to do with it?
>> Andrea: We are going to, increment it.
>> Will Sentance: Increment it! We are. This is the same, just the same thing. Increment it to one. Increment it to one! Not in our local memory, but in this live data store, this backpack attached to the function definition.

[00:05:32]
Okay, before we talk about how this is possible, and all the ins and outs of this, we finish running my new function, we hit a counter, it was zero, we increment it to one, what is the execution context, Andrea?
>> Andrea: It is garbage collected.
>> Will Sentance: No, the data does

[00:05:47]

>> Will Sentance: The execution context gets popped off the call stack. It's gone, and we go back to global, where what's the next line we encounter, Andrea? Gonna call myNewFunction again, basically, yep. Let's call it again, myNewFunction. Let's call it again. Everybody, actually just Art. I'm calling my new function?

[00:06:15]
Okay, then just Griffin. Griffin, I'm calling my new function, what do I create a new?
>> Will Sentance: People are really good together at doing it, and really under the pressure of the individual person. I'll help you guys out.
>> Griffin: Execution context.
>> Will Sentance: Good job, man, exactly. Push it to the call stack, right?

[00:06:34]
Push the call to my new function and the call stack.
>> Will Sentance: So this level of precision of communication may seem pedantic, but I was telling Lindsey. I was telling Barb. I think I was telling Carr, as well, this is the stuff of seasoned developers. There is little explanation why Codesmith grads get senior jobs.

[00:07:00]
If there's one explanation it's communication. So I've already seen a resounding leveling up, even today. So even though it feels God, I don't know what that context is. That level of precision, it makes a world of difference. So in we go. What's the first line inside say?
>> Griffin: It's counter plus plus.

[00:07:19]

>> Will Sentance: Counter plus plus. Now, where do I look for counter first?
>> Griffin: First in local.
>> Will Sentance: Do I find it?
>> Griffin: No.
>> Andrea: Nope. It's not there. This is gone by the way. I've got new empty local memory. Where do I look next? Where would my call stack sort of.

[00:07:35]
Given I'm calling my new function in global, one might think I'd look next in?
>> Griffin: In global.
>> Andrea: But where do I actually look?
>> Griffin: You go into your backpack.
>> Andrea: Into my. Beautiful music to my ears.
>> Griffin: Dora Explorer.
>> class: [LAUGH]
>> Will Sentance: Yeah.
>> class: [LAUGH]
>> Will Sentance: Dora the Explorer.

[00:07:49]
I like that. She's nice. Okay, what do we find? One? And what do we do to it?
>> Griffin: You add 1 to it.
>> Will Sentance: And we get 2. My backpack is persistent. It holds on to that data live. Man, we've altered that thing. What if our functions have persistent memory in-between calls?

[00:08:11]
Anything that I declared inside my new function fills in the local memory, but finish running that function? Start again, it's gonna have to fill it in all over again, there's no memory between these function calls. But, hold on, this backpack of data is attached to the function of the definition persists, it sticks on the back of the function definition in between function calls.

[00:08:32]
Our function, my new function is not just a function, it's a function with a store of data on it's back. We're going to it in a second, dude. We're gonna go around, and we're gonna do thumbs in a moment. This is, for me, the most beautiful concept in all of JavaScript.

[00:08:49]
It is the most profound, we're gonna see OOP tomorrow. We're gonna see asynchronicity. Asynchronicity lists of rules. OOP, lists of techniques. Closure, conceptually beautiful and empowering approach in JavaScript.

