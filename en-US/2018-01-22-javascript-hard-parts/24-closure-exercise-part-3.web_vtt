WEBVTT

1
00:00:00.001 --> 00:00:03.807
&gt;&gt; Will Sentance: And reveal,
that actually, some magic happened.

2
00:00:03.807 --> 00:00:07.824
Some amazing, precise magic happened.

3
00:00:07.824 --> 00:00:08.998
When I've.

4
00:00:11.596 --> 00:00:12.884
&gt;&gt; Will Sentance: Remember what we said?

5
00:00:12.884 --> 00:00:18.333
Where I define my function,
&gt;&gt; Will Sentance: determines.

6
00:00:18.333 --> 00:00:19.070
What did it say?

7
00:00:19.070 --> 00:00:22.270
Where you define your functions determines
what variables your function has access to

8
00:00:22.270 --> 00:00:23.470
when you call the function.

9
00:00:23.470 --> 00:00:26.200
That's our overarching message.

10
00:00:26.200 --> 00:00:30.420
Where you define determines.

11
00:00:30.420 --> 00:00:35.840
But hold on, increment counter was defined
inside of outer, but we said outer's gone.

12
00:00:35.840 --> 00:00:40.844
So but we're saying also where your final
determines what variables your function

13
00:00:40.844 --> 00:00:45.501
access to and you call the function,
how can these two things be reconciled?

14
00:00:45.501 --> 00:00:46.610
Okay, let's see.

15
00:00:46.610 --> 00:00:50.436
When I define increment counter,
when I was running outer, so

16
00:00:50.436 --> 00:00:53.119
we're right now inside the quarter outer.

17
00:00:53.119 --> 00:00:55.059
We're inside the code outer,

18
00:00:55.059 --> 00:00:58.870
and the first thing we didn't
say was to clear counter is 0.

19
00:00:58.870 --> 00:01:01.470
That increment counter is a function.

20
00:01:01.470 --> 00:01:04.080
When I declare the increment
counter as a function,

21
00:01:04.080 --> 00:01:06.620
I didn't just declare it was a function.

22
00:01:06.620 --> 00:01:10.410
Behind the scenes,
JavaScript did something very special.

23
00:01:10.410 --> 00:01:12.430
We're gonna learn how
it works in a second.

24
00:01:12.430 --> 00:01:16.580
But for now, what I'm gonna say, is where
I define increment counter, I said define

25
00:01:16.580 --> 00:01:19.610
increment counter, determines what
things are gonna be available.

26
00:01:19.610 --> 00:01:24.630
Where I define my function determines
what data will be available when I end up

27
00:01:24.630 --> 00:01:25.950
calling that function.

28
00:01:25.950 --> 00:01:29.550
Wherever I call it, wherever I invoke it,
wherever I execute it.

29
00:01:29.550 --> 00:01:34.020
Where I defined it determines what data
when I call it, it will have access to.

30
00:01:34.020 --> 00:01:37.331
So I define increment counter here,
I did something else.

31
00:01:37.331 --> 00:01:38.304
I didn't just define it.

32
00:01:38.304 --> 00:01:42.639
I didn't just store its description,
increment counter plus plus in memory,

33
00:01:42.639 --> 00:01:43.877
I did something else.

34
00:01:43.877 --> 00:01:48.674
I made a special bond to the immediate

35
00:01:48.674 --> 00:01:53.792
total surrounding live local memory.

36
00:01:53.792 --> 00:02:02.240
I said this function get's a special
bond to all this surrounding data.

37
00:02:02.240 --> 00:02:07.710
It's a special bond to
all my surrounding data.

38
00:02:07.710 --> 00:02:09.545
IncrementCounter is not just a function.

39
00:02:09.545 --> 00:02:13.607
It's a function plus a special bond.

40
00:02:13.607 --> 00:02:17.321
To a little reference to all my
surrounding data counter is zero,

41
00:02:17.321 --> 00:02:19.390
increment counter is a function.

42
00:02:19.390 --> 00:02:24.350
Gives it a reference to the whole
surrounding data when it gets defined.

43
00:02:24.350 --> 00:02:31.920
Meaning when I return that function out,
do I just get the function?

44
00:02:31.920 --> 00:02:36.365
I get the function plus
that special bond to

45
00:02:36.365 --> 00:02:43.010
the surrounding data from
when that function was born.

46
00:02:43.010 --> 00:02:45.987
And what is in that surrounding data,

47
00:02:45.987 --> 00:02:51.197
that surrounding live store of data but
not counter could be zero,

48
00:02:51.197 --> 00:02:55.626
but literally Counter,
&gt;&gt; Will Sentance: Is,

49
00:02:57.132 --> 00:02:57.819
&gt;&gt; Will Sentance: 0.

50
00:02:57.819 --> 00:03:01.440
There it is,
attached to my function definition.

51
00:03:01.440 --> 00:03:03.324
I return out the function value.

52
00:03:03.324 --> 00:03:07.070
Increment counter is a function with
a reference to the surrounding data

53
00:03:07.070 --> 00:03:09.130
hidden on the back of the function.

54
00:03:09.130 --> 00:03:13.147
And when I return my function out, well,
on the back of the function comes with it,

55
00:03:13.147 --> 00:03:18.330
it's surrounding data from where
it was defined, and there it is.

56
00:03:18.330 --> 00:03:22.240
And so that function that gets now,
is given a new label.

57
00:03:22.240 --> 00:03:23.960
New label's my new function.

58
00:03:23.960 --> 00:03:25.410
All we need is the function.

59
00:03:25.410 --> 00:03:31.770
It's a function with a bond
to its surrounding data.

60
00:03:34.747 --> 00:03:36.611
&gt;&gt; Will Sentance: And now.

61
00:03:36.611 --> 00:03:40.460
So, we called my new function.

62
00:03:40.460 --> 00:03:42.850
Its code said counter ++.

63
00:03:42.850 --> 00:03:44.790
There was no counter in local.

64
00:03:45.840 --> 00:03:50.120
Everything would suggest the next place we
look at down our call stack, sort of we're

65
00:03:50.120 --> 00:03:55.530
calling my new function in global so we go
out and look in global, for the counter.

66
00:03:57.730 --> 00:04:02.180
Where do you think we actually go and
look, Andrea, before we look in global.

67
00:04:02.180 --> 00:04:03.800
&gt;&gt; Andrea: We look in the-
&gt;&gt; Will Sentance: In the orange box.

68
00:04:03.800 --> 00:04:05.690
&gt;&gt; Andrea: Yeah.
[LAUGH]

69
00:04:05.690 --> 00:04:06.770
&gt;&gt; Will Sentance: So I like to call this

70
00:04:06.770 --> 00:04:09.710
orange box a backpack.

71
00:04:09.710 --> 00:04:14.760
Now, this is definitely not
the technical term for this orange box.

72
00:04:14.760 --> 00:04:18.270
There are, we're gonna give you a whole
bunch of sophisticated technical terms for

73
00:04:18.270 --> 00:04:20.380
them, but note that in many
ways it's like a backpack.

74
00:04:20.380 --> 00:04:24.422
That function got a little bond to it's
surrounding live store of data on it's

75
00:04:24.422 --> 00:04:27.608
back, and out came the functions
stored in my new function and

76
00:04:27.608 --> 00:04:31.660
with it came it's backpack of live
data from when it was defined.

77
00:04:31.660 --> 00:04:34.054
Not a bad name for it.

78
00:04:34.054 --> 00:04:37.580
Unfortunately, it's not standard
letter name unfortunately.

79
00:04:37.580 --> 00:04:39.768
We're gonna see what the real name for
it is in a moment.

80
00:04:39.768 --> 00:04:42.129
First, let's just see
what actually happens.

81
00:04:42.129 --> 00:04:44.805
Andrea, didn't find counter in local.

82
00:04:44.805 --> 00:04:48.341
Where did I actually go look
before I looked in global?

83
00:04:48.341 --> 00:04:50.590
Andrea, where did I actually go look?

84
00:04:50.590 --> 00:04:53.580
&gt;&gt; Andrea: You have my
data in the backpack.

85
00:04:53.580 --> 00:04:55.870
&gt;&gt; Will Sentance: In the backpack,
thank you Andrea for indulging me.

86
00:04:55.870 --> 00:04:57.210
Thank you Madison for the green one.

87
00:04:59.040 --> 00:05:00.450
In the backpack.

88
00:05:00.450 --> 00:05:06.490
Say it proud, aloud, and say it in
your interviews and look distressed.

89
00:05:06.490 --> 00:05:07.936
When they look at you and say, mm-mm.

90
00:05:07.936 --> 00:05:09.470
All right, though, what do we find?

91
00:05:09.470 --> 00:05:10.010
Counter is 0.

92
00:05:10.010 --> 00:05:11.840
What do we do with, Andrea?

93
00:05:11.840 --> 00:05:13.160
What do we say we're gonna do with it?

94
00:05:13.160 --> 00:05:14.844
&gt;&gt; Andrea: We're gonna increment it.

95
00:05:14.844 --> 00:05:16.101
&gt;&gt; Will Sentance: Increment it.

96
00:05:16.101 --> 00:05:18.020
This is just the same thing.

97
00:05:18.020 --> 00:05:20.480
Increment it to 1.

98
00:05:22.380 --> 00:05:23.080
&gt;&gt; Will Sentance: Increment it to 1.

99
00:05:24.370 --> 00:05:28.890
&gt;&gt; Will Sentance: Not in our local memory,
but in this live data store.

100
00:05:28.890 --> 00:05:32.093
This backpack attached to
the function definition.

101
00:05:32.093 --> 00:05:35.141
Okay, before we talk about how
this is possible, all the ins and

102
00:05:35.141 --> 00:05:37.518
outs of this,
we finish running my new function.

103
00:05:37.518 --> 00:05:38.249
We hit a counter.

104
00:05:38.249 --> 00:05:38.776
It was zero.

105
00:05:38.776 --> 00:05:40.153
We increment it to one.

106
00:05:40.153 --> 00:05:44.875
What happens to this execution context,
Andrea?

107
00:05:44.875 --> 00:05:45.485
&gt;&gt; Andrea: It's garbage-collected.

108
00:05:45.485 --> 00:05:46.175
&gt;&gt; Will Sentance: Not that the data does.

109
00:05:46.175 --> 00:05:52.020
The execution context gets
popped off the call stack.

110
00:05:52.020 --> 00:05:55.240
It's gone and we go back to global.

111
00:05:55.240 --> 00:05:57.480
Where what's the next line we encounter?

112
00:05:57.480 --> 00:05:59.563
Andrea?

113
00:05:59.563 --> 00:06:00.097
&gt;&gt; Andrea: Hm.
&gt;&gt; Will Sentance: We're gonna call

114
00:06:00.097 --> 00:06:00.781
mynewfunction() again, basically.

115
00:06:00.781 --> 00:06:08.220
Let's call it again, mynewfunction().

116
00:06:08.220 --> 00:06:09.760
Let's call it again.

117
00:06:09.760 --> 00:06:12.590
Everybody, actually, just Art.

118
00:06:12.590 --> 00:06:15.490
I'm calling my new function, okay?

119
00:06:15.490 --> 00:06:18.380
Then, just Griffin.

120
00:06:18.380 --> 00:06:20.610
Griffin, I'm calling my new function.

121
00:06:20.610 --> 00:06:21.420
What do I create?

122
00:06:21.420 --> 00:06:23.099
A new?

123
00:06:23.099 --> 00:06:24.477
&gt;&gt; Speaker 3: Execution.

124
00:06:24.477 --> 00:06:26.704
&gt;&gt; Will Sentance: Are people
really good together at doing it,

125
00:06:26.704 --> 00:06:29.348
really under the pressure
of the individual person?

126
00:06:29.348 --> 00:06:29.915
I hope you got it.

127
00:06:29.915 --> 00:06:30.837
&gt;&gt; Speaker 3: Re-execution code.

128
00:06:30.837 --> 00:06:31.510
&gt;&gt; Will Sentance: Good job, man.

129
00:06:31.510 --> 00:06:32.360
Yeah, exactly.

130
00:06:32.360 --> 00:06:33.430
Push it to the call stack, right?

131
00:06:33.430 --> 00:06:34.900
&gt;&gt; Speaker 3: Yep.

132
00:06:34.900 --> 00:06:37.000
&gt;&gt; Will Sentance: Push
the call to mynewfunction().

133
00:06:37.000 --> 00:06:37.830
The call stack.

134
00:06:39.430 --> 00:06:43.570
For this level of precision of
communication may seem pedantic, but

135
00:06:43.570 --> 00:06:49.590
I was telling Lindsay, I was telling Bob,
I think I was telling Cara as well.

136
00:06:50.860 --> 00:06:55.110
This is the stuff of seasoned developers.

137
00:06:55.110 --> 00:07:00.120
There is little explanation why
Codesmith folk grads get senior jobs.

138
00:07:00.120 --> 00:07:03.430
If there's one explanation,
it's technical communication.

139
00:07:03.430 --> 00:07:08.970
So I've already seen a resounding
levelling up even today.

140
00:07:08.970 --> 00:07:12.540
So even though it feels and I go, God,
I know what execution context is.

141
00:07:12.540 --> 00:07:14.981
That level of precision,
it makes a world of difference.

142
00:07:14.981 --> 00:07:17.880
So in we go, and
what's the first line inside say?

143
00:07:17.880 --> 00:07:19.136
&gt;&gt; Speaker 3: It's counter ++.

144
00:07:19.136 --> 00:07:20.240
&gt;&gt; Will Sentance: Counter ++.

145
00:07:20.240 --> 00:07:23.750
Now, where do I look for counter first?

146
00:07:23.750 --> 00:07:25.530
&gt;&gt; Speaker 3: At first, local.

147
00:07:25.530 --> 00:07:26.310
&gt;&gt; Will Sentance: Do I find it?

148
00:07:26.310 --> 00:07:26.950
&gt;&gt; Speaker 3: No.

149
00:07:26.950 --> 00:07:28.180
&gt;&gt; Will Sentance: Nope, just like that.

150
00:07:28.180 --> 00:07:30.550
This byte gets it gone,
by the way, but yeah.

151
00:07:30.550 --> 00:07:32.220
I've got a new empty local memory.

152
00:07:32.220 --> 00:07:33.310
Where do I look next?

153
00:07:33.310 --> 00:07:36.150
Where would my call stack
sort of simplicity say?

154
00:07:36.150 --> 00:07:40.340
Given I'm calling my new function in
global, one might think I'd look next in.

155
00:07:40.340 --> 00:07:40.880
&gt;&gt; Speaker 3: Global.
&gt;&gt; Will Sentance: But

156
00:07:40.880 --> 00:07:42.120
where do I actually look?

157
00:07:42.120 --> 00:07:43.300
&gt;&gt; Speaker 3: You go into your backpack.

158
00:07:43.300 --> 00:07:45.910
&gt;&gt; Will Sentance: Into,
beautiful music to my ears.

159
00:07:45.910 --> 00:07:47.236
&gt;&gt; Speaker 3: Dora Explore it.

160
00:07:47.236 --> 00:07:48.756
[LAUGH] Yeah.

161
00:07:48.756 --> 00:07:50.546
&gt;&gt; Will Sentance: [LAUGH]
Dora the Explorer.

162
00:07:50.546 --> 00:07:51.481
I like that, she's nice.

163
00:07:51.481 --> 00:07:52.980
Okay, and what do we find?

164
00:07:52.980 --> 00:07:55.067
1, and what do we do to it?

165
00:07:55.067 --> 00:07:56.077
&gt;&gt; Speaker 3: You add one to it.

166
00:07:56.077 --> 00:07:56.808
&gt;&gt; Andrea: And we get two.

167
00:07:56.808 --> 00:08:01.290
&gt;&gt; Will Sentance: Okay folk,
my backpack is persistent.

168
00:08:01.290 --> 00:08:03.457
It holds onto that data life.

169
00:08:03.457 --> 00:08:06.660
Man, we've answered that thing,

170
00:08:06.660 --> 00:08:09.890
what if our functions had
persistent memory in between calls?

171
00:08:11.150 --> 00:08:15.980
Anything that I declared inside my new
function fills in a local memory, but

172
00:08:15.980 --> 00:08:19.670
finish writing that function, start again,
it's gonna have to fill it all in again.

173
00:08:19.670 --> 00:08:22.120
There's no memory between
these function calls.

174
00:08:22.120 --> 00:08:23.000
But hold on,

175
00:08:23.000 --> 00:08:27.770
this backpack of data is attached to
the function definition persists,

176
00:08:27.770 --> 00:08:31.570
it sticks on the back of the function
definition in between function calls.

177
00:08:31.570 --> 00:08:33.060
Our function,

178
00:08:33.060 --> 00:08:39.510
my new function is a function with
a store of data on it's back.

179
00:08:39.510 --> 00:08:40.920
We'll go on in a second dude.

180
00:08:40.920 --> 00:08:41.980
We're gonna go round.

181
00:08:41.980 --> 00:08:43.530
We're gonna do thumbs in a moment.

182
00:08:44.820 --> 00:08:49.100
This is for me the most beautiful
concept in all JavaScript.

183
00:08:49.100 --> 00:08:51.061
It is the most profound.

184
00:08:51.061 --> 00:08:54.480
We're gonna see OOP tomorrow,
we're gonna see asynchronicity.

185
00:08:54.480 --> 00:08:56.380
Asynchronicity, list of rules.

186
00:08:56.380 --> 00:08:58.769
OOP, list of techniques.

187
00:08:58.769 --> 00:09:05.918
Closure conceptually beautiful and
empowering approach in JavaScript.

