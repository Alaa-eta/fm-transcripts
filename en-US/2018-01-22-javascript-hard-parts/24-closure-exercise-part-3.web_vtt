WEBVTT

1
00:00:00.310 --> 00:00:03.820
&gt;&gt; Will Sentance: And a reveal that
actually, some magic happened.

2
00:00:03.820 --> 00:00:08.986
Some amazing,
precise magic happened when I.

3
00:00:11.790 --> 00:00:16.057
&gt;&gt; Will Sentance: Remember we said,
where I define my function,

4
00:00:16.057 --> 00:00:19.070
determines
&gt;&gt; Will Sentance: What does it say?

5
00:00:19.070 --> 00:00:22.210
Where you define your functions determines
what variables your function have access

6
00:00:22.210 --> 00:00:23.470
to, when you call the function.

7
00:00:23.470 --> 00:00:26.200
That's a overarching message.

8
00:00:26.200 --> 00:00:31.550
Where you define determines, but hold on.

9
00:00:31.550 --> 00:00:34.430
The increment count was
defined inside of outer.

10
00:00:34.430 --> 00:00:36.598
But we said outer's gone.

11
00:00:36.598 --> 00:00:39.278
So, but we're saying also where you
define one determines what variables your

12
00:00:39.278 --> 00:00:41.880
function will have access to,
when you call the function.

13
00:00:41.880 --> 00:00:43.610
How can these two things be reconciled?

14
00:00:44.740 --> 00:00:46.460
Okay, let's see.

15
00:00:46.460 --> 00:00:49.630
When I define an increment counter,
when I was running outer.

16
00:00:49.630 --> 00:00:52.890
So we are right now
inside the quarter outer.

17
00:00:54.100 --> 00:00:55.280
We're inside the quarter outer,

18
00:00:55.280 --> 00:00:59.090
and the first thing we did inside
was declare our counter is zero.

19
00:00:59.090 --> 00:01:03.010
Then increment counter is a function,
when I declared increment counter as

20
00:01:03.010 --> 00:01:06.620
a function,
I didn't just declare it was a function.

21
00:01:06.620 --> 00:01:10.410
Behind the scenes,
JavaScript did something very special.

22
00:01:10.410 --> 00:01:13.030
We're gonna learn how it word in a second,
but for now,

23
00:01:13.030 --> 00:01:16.020
what I'm gonna say is when I
define increment counter, I said,

24
00:01:16.020 --> 00:01:19.610
define IncrementCounter determines
what things are gonna be available.

25
00:01:19.610 --> 00:01:23.510
Where I define my function determines
what data will be available,

26
00:01:23.510 --> 00:01:25.950
when I end up calling that function.

27
00:01:25.950 --> 00:01:27.210
Wherever I call it.

28
00:01:27.210 --> 00:01:28.060
Wherever I invoke it.

29
00:01:28.060 --> 00:01:29.550
Wherever I execute it.

30
00:01:29.550 --> 00:01:34.490
Where I defined it determines what data,
when I call it, it will have access to.

31
00:01:34.490 --> 00:01:37.530
So, I define increment counter here,
I did something else.

32
00:01:37.530 --> 00:01:38.440
I didn't just define it.

33
00:01:38.440 --> 00:01:39.825
I didn't just store its description,

34
00:01:39.825 --> 00:01:44.080
IncrementCounter plus plus in memory,
I did something else.

35
00:01:44.080 --> 00:01:49.310
I made a special bond to the immediate

36
00:01:49.310 --> 00:01:53.880
total surrounding live local memory.

37
00:01:53.880 --> 00:02:02.280
I said, this function gets a special
bond to all this surrounding data.

38
00:02:02.280 --> 00:02:05.950
Gets a special bond to
all my surrounding data.

39
00:02:07.970 --> 00:02:10.720
IncrementCounter is not just a function.

40
00:02:10.720 --> 00:02:15.380
It's a function, plus a special bond,
to a little reference to

41
00:02:15.380 --> 00:02:19.350
all my surrounding data, counter is zero,
increment counter is a function.

42
00:02:19.350 --> 00:02:24.350
It get's a reference to the whole
surrounding data, when it gets defined.

43
00:02:24.350 --> 00:02:30.170
Meaning, when I return that function out,
do I just get the function?

44
00:02:31.280 --> 00:02:32.140
Un un.

45
00:02:32.140 --> 00:02:35.720
I get the function, plus that special bond

46
00:02:37.720 --> 00:02:43.010
to the surrounding data from
when that function was born.

47
00:02:43.010 --> 00:02:44.810
And what is in that surrounding data?

48
00:02:44.810 --> 00:02:50.980
That surrounding live store of data,
but not counter could be zero,

49
00:02:50.980 --> 00:02:58.050
but literally Counter is zero.

50
00:02:58.050 --> 00:03:01.440
There it is,
attached to my function definition.

51
00:03:01.440 --> 00:03:04.750
I return out the function value,
IncrementCounter is a function,

52
00:03:04.750 --> 00:03:09.130
with a reference to the surrounding
data hidden on the back of the function.

53
00:03:09.130 --> 00:03:13.164
And when I return my function out, well,
on the back of the function comes with it,

54
00:03:13.164 --> 00:03:17.340
its surrounding data from
where it was defined.

55
00:03:17.340 --> 00:03:18.330
And there it is.

56
00:03:18.330 --> 00:03:24.100
And so that function that gets now given
a new label, new label's my new function.

57
00:03:24.100 --> 00:03:25.410
It ain't just a function.

58
00:03:25.410 --> 00:03:31.941
It's a function with a bond
to its surrounding data.

59
00:03:34.832 --> 00:03:40.460
&gt;&gt; Will Sentance: And now,
so record my new function.

60
00:03:40.460 --> 00:03:42.850
Its code said, counter plus plus.

61
00:03:42.850 --> 00:03:44.790
There was no counter in local.

62
00:03:45.840 --> 00:03:49.500
Everything would suggest the next
place we look at down our call stack,

63
00:03:49.500 --> 00:03:52.150
sort of recalling my new function.

64
00:03:52.150 --> 00:03:55.859
In global, so we go out and
look in global for the counter.

65
00:03:57.701 --> 00:04:00.188
&gt;&gt; Will Sentance: Where do you think
we actually go and look, Andrea,

66
00:04:00.188 --> 00:04:01.440
before we look in global?

67
00:04:01.440 --> 00:04:04.550
&gt;&gt; Andrea: We look in the-
&gt;&gt; Will Sentance: In the orange box.

68
00:04:04.550 --> 00:04:05.960
&gt;&gt; Andrea: Yeah.
&gt;&gt; Will Sentance: [LAUGH] So

69
00:04:05.960 --> 00:04:09.710
I like to call this orange box a backpack.

70
00:04:09.710 --> 00:04:14.560
Now, this is definitely not
the technical term for this orange box.

71
00:04:14.560 --> 00:04:18.390
We gonna give you a whole bunch of
sophisticated technical terms for them,

72
00:04:18.390 --> 00:04:20.476
but note,
that in many ways it's like a backpack.

73
00:04:20.476 --> 00:04:24.076
That function got a little bond to
a surrounding life store of data on its

74
00:04:24.076 --> 00:04:27.256
back, and out came the function
stored in my new function, and

75
00:04:27.256 --> 00:04:31.290
with it, came its backpack of live
data from when it was defined.

76
00:04:31.290 --> 00:04:32.680
What about a name for it?

77
00:04:34.290 --> 00:04:37.440
Unfortunately, it's not the standard name,
unfortunately.

78
00:04:37.440 --> 00:04:39.850
We're gonna see what the real name for
it is in a moment.

79
00:04:39.850 --> 00:04:42.140
First, let's just see
what actually happens.

80
00:04:42.140 --> 00:04:44.980
So Andrea, didn't find counter in local.

81
00:04:44.980 --> 00:04:48.510
Where did I actually go look,
before I looked in global?

82
00:04:48.510 --> 00:04:50.590
Andrea, where did I actually go look?

83
00:04:50.590 --> 00:04:53.588
&gt;&gt; Andrea: You have data in the back pack.

84
00:04:53.588 --> 00:04:58.412
&gt;&gt; Will Sentance: In the backpack, thank
you, Andrea for indulging me, [INAUDIBLE]

85
00:04:58.412 --> 00:05:03.751
In the back pack, say it proud, and
loud, and say it in your interviews,

86
00:05:03.751 --> 00:05:08.427
and look distressed when they
look at you and say, mm-mm-mm.

87
00:05:08.427 --> 00:05:10.080
Alright, then what do we
find counter at zero.

88
00:05:10.080 --> 00:05:10.890
What do we do with it, Andrea?

89
00:05:10.890 --> 00:05:12.760
What did we say we were
going to do with it?

90
00:05:12.760 --> 00:05:14.970
&gt;&gt; Andrea: We are going to, increment it.

91
00:05:14.970 --> 00:05:15.900
&gt;&gt; Will Sentance: Increment it!

92
00:05:15.900 --> 00:05:18.020
We are.
This is the same, just the same thing.

93
00:05:18.020 --> 00:05:20.156
Increment it to one.

94
00:05:22.380 --> 00:05:25.560
Increment it to one!

95
00:05:25.560 --> 00:05:27.150
Not in our local memory, but

96
00:05:27.150 --> 00:05:32.280
in this live data store, this backpack
attached to the function definition.

97
00:05:32.280 --> 00:05:34.620
Okay, before we talk about how this
is possible, and all the ins and

98
00:05:34.620 --> 00:05:39.000
outs of this, we finish running my new
function, we hit a counter, it was zero,

99
00:05:39.000 --> 00:05:41.880
we increment it to one,
what is the execution context, Andrea?

100
00:05:41.880 --> 00:05:44.230
&gt;&gt; Andrea: It is garbage collected.

101
00:05:44.230 --> 00:05:49.070
&gt;&gt; Will Sentance: No, the data does
&gt;&gt; Will Sentance: The execution context

102
00:05:49.070 --> 00:05:52.020
gets popped off the call stack.

103
00:05:52.020 --> 00:05:57.920
It's gone, and we go back to global, where
what's the next line we encounter, Andrea?

104
00:05:59.620 --> 00:06:05.140
Gonna call myNewFunction again,

105
00:06:05.140 --> 00:06:08.190
basically, yep.

106
00:06:08.190 --> 00:06:08.834
Let's call it again, myNewFunction.

107
00:06:08.834 --> 00:06:09.760
Let's call it again.

108
00:06:09.760 --> 00:06:12.590
Everybody, actually just Art.

109
00:06:12.590 --> 00:06:13.760
I'm calling my new function?

110
00:06:15.120 --> 00:06:18.380
Okay, then just Griffin.

111
00:06:18.380 --> 00:06:21.940
Griffin, I'm calling my new function,
what do I create a new?

112
00:06:24.600 --> 00:06:26.260
&gt;&gt; Will Sentance: People are really
good together at doing it, and

113
00:06:26.260 --> 00:06:28.940
really under the pressure
of the individual person.

114
00:06:28.940 --> 00:06:29.860
I'll help you guys out.

115
00:06:29.860 --> 00:06:30.750
&gt;&gt; Griffin: Execution context.

116
00:06:30.750 --> 00:06:32.360
&gt;&gt; Will Sentance: Good job, man, exactly.

117
00:06:32.360 --> 00:06:33.430
Push it to the call stack, right?

118
00:06:34.965 --> 00:06:38.160
Push the call to my new function and
the call stack.

119
00:06:39.346 --> 00:06:42.731
&gt;&gt; Will Sentance: So this level
of precision of communication may

120
00:06:42.731 --> 00:06:45.870
seem pedantic, but I was telling Lindsey.

121
00:06:45.870 --> 00:06:47.010
I was telling Barb.

122
00:06:47.010 --> 00:06:50.860
I think I was telling Carr, as well,

123
00:06:50.860 --> 00:06:55.110
this is the stuff of seasoned developers.

124
00:06:55.110 --> 00:07:00.120
There is little explanation why
Codesmith grads get senior jobs.

125
00:07:00.120 --> 00:07:03.430
If there's one explanation
it's communication.

126
00:07:03.430 --> 00:07:08.970
So I've already seen a resounding
leveling up, even today.

127
00:07:08.970 --> 00:07:12.540
So even though it feels God,
I don't know what that context is.

128
00:07:12.540 --> 00:07:15.240
That level of precision,
it makes a world of difference.

129
00:07:15.240 --> 00:07:17.880
So in we go.
What's the first line inside say?

130
00:07:17.880 --> 00:07:19.100
&gt;&gt; Griffin: It's counter plus plus.

131
00:07:19.100 --> 00:07:20.240
&gt;&gt; Will Sentance: Counter plus plus.

132
00:07:20.240 --> 00:07:23.830
Now, where do I look for counter first?

133
00:07:23.830 --> 00:07:25.530
&gt;&gt; Griffin: First in local.

134
00:07:25.530 --> 00:07:26.310
&gt;&gt; Will Sentance: Do I find it?

135
00:07:26.310 --> 00:07:26.950
&gt;&gt; Griffin: No.

136
00:07:26.950 --> 00:07:28.250
&gt;&gt; Andrea: Nope.
It's not there.

137
00:07:28.250 --> 00:07:30.550
This is gone by the way.

138
00:07:30.550 --> 00:07:32.220
I've got new empty local memory.

139
00:07:32.220 --> 00:07:33.310
Where do I look next?

140
00:07:33.310 --> 00:07:35.390
Where would my call stack sort of.

141
00:07:35.390 --> 00:07:40.270
Given I'm calling my new function in
global, one might think I'd look next in?

142
00:07:40.270 --> 00:07:42.120
&gt;&gt; Griffin: In global.
&gt;&gt; Andrea: But where do I actually look?

143
00:07:42.120 --> 00:07:43.300
&gt;&gt; Griffin: You go into your backpack.

144
00:07:43.300 --> 00:07:44.630
&gt;&gt; Andrea: Into my.

145
00:07:44.630 --> 00:07:45.910
Beautiful music to my ears.

146
00:07:45.910 --> 00:07:46.916
&gt;&gt; Griffin: Dora Explorer.

147
00:07:46.916 --> 00:07:47.789
&gt;&gt; class: [LAUGH]
&gt;&gt; Will Sentance: Yeah.

148
00:07:47.789 --> 00:07:49.630
&gt;&gt; class: [LAUGH]
&gt;&gt; Will Sentance: Dora the Explorer.

149
00:07:49.630 --> 00:07:51.240
I like that.

150
00:07:51.240 --> 00:07:53.180
She's nice.
Okay, what do we find?

151
00:07:53.180 --> 00:07:54.499
One?
And what do we do to it?

152
00:07:56.380 --> 00:07:57.160
&gt;&gt; Griffin: You add 1 to it.

153
00:07:57.160 --> 00:07:58.140
&gt;&gt; Will Sentance: And we get 2.

154
00:07:58.140 --> 00:08:01.290
My backpack is persistent.

155
00:08:01.290 --> 00:08:03.178
It holds on to that data live.

156
00:08:03.178 --> 00:08:06.660
Man, we've altered that thing.

157
00:08:06.660 --> 00:08:09.890
What if our functions have
persistent memory in-between calls?

158
00:08:11.150 --> 00:08:15.650
Anything that I declared inside my new
function fills in the local memory,

159
00:08:15.650 --> 00:08:17.680
but finish running that function?

160
00:08:17.680 --> 00:08:19.670
Start again, it's gonna have
to fill it in all over again,

161
00:08:19.670 --> 00:08:22.120
there's no memory between
these function calls.

162
00:08:22.120 --> 00:08:23.000
But, hold on,

163
00:08:23.000 --> 00:08:27.770
this backpack of data is attached to
the function of the definition persists,

164
00:08:27.770 --> 00:08:32.260
it sticks on the back of the function
definition in between function calls.

165
00:08:32.260 --> 00:08:34.750
Our function,
my new function is not just a function,

166
00:08:34.750 --> 00:08:39.510
it's a function with a store
of data on it's back.

167
00:08:39.510 --> 00:08:40.920
We're going to it in a second, dude.

168
00:08:40.920 --> 00:08:43.530
We're gonna go around, and
we're gonna do thumbs in a moment.

169
00:08:44.820 --> 00:08:49.100
This is, for me, the most beautiful
concept in all of JavaScript.

170
00:08:49.100 --> 00:08:53.126
It is the most profound,
we're gonna see OOP tomorrow.

171
00:08:53.126 --> 00:08:54.480
We're gonna see asynchronicity.

172
00:08:54.480 --> 00:08:56.380
Asynchronicity lists of rules.

173
00:08:56.380 --> 00:08:58.889
OOP, lists of techniques.

174
00:08:58.889 --> 00:09:05.914
Closure, conceptually beautiful and
empowering approach in JavaScript.

