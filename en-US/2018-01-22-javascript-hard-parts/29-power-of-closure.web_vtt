WEBVTT

1
00:00:00.250 --> 00:00:02.376
&gt;&gt; Will Sentance: We have achieved
something really remarkable here.

2
00:00:02.376 --> 00:00:07.470
We have given our function definitions,
ain't just function definitions anymore.

3
00:00:07.470 --> 00:00:13.315
They're function definitions plus live
data stores attached to the back of them,

4
00:00:13.315 --> 00:00:14.824
little mini caches.

5
00:00:14.824 --> 00:00:19.717
Persistent state,
little state stores that were created.

6
00:00:19.717 --> 00:00:20.222
My quinoa salad.

7
00:00:20.222 --> 00:00:25.205
Created by the fact that these functions
were themselves defined inside another

8
00:00:25.205 --> 00:00:26.818
function being called and

9
00:00:26.818 --> 00:00:31.526
they, therefore, got this little bond
to their surrounding live memory.

10
00:00:31.526 --> 00:00:35.806
And that bond did not go away when that
inner function got returned out and

11
00:00:35.806 --> 00:00:37.293
stored in its new label.

12
00:00:37.293 --> 00:00:40.222
It's very, very profound.

13
00:00:40.222 --> 00:00:42.384
So what else is there to do?

14
00:00:42.384 --> 00:00:46.382
Well, if we go back to the very
beginning we said, what does it say?

15
00:00:46.382 --> 00:00:49.696
We said,
what if our functions could hold on

16
00:00:49.696 --> 00:00:53.382
to live data/state
between their executions?

17
00:00:53.382 --> 00:00:54.911
Well, what do you know?

18
00:00:54.911 --> 00:00:56.515
They can.

19
00:00:56.515 --> 00:01:01.821
This will let our function definitions
have an associated persistent memory.

20
00:01:01.821 --> 00:01:06.528
This would let us do things like well,
create these

21
00:01:06.528 --> 00:01:11.462
highly professional functions
like once memorize.

22
00:01:11.462 --> 00:01:14.159
Basically, any function that needs
the memory of the past time it was run.

23
00:01:14.159 --> 00:01:15.830
So one of them would be called once.

24
00:01:15.830 --> 00:01:20.802
So the onceified version of multiplied by
two would say, the first time you run me,

25
00:01:20.802 --> 00:01:25.075
I'm a multiply two function that's
got a memory of the last time I run.

26
00:01:25.075 --> 00:01:30.575
The first time you run me with input of 3,
multiply by 2, return 6.

27
00:01:30.575 --> 00:01:32.247
Okay, fine, good.

28
00:01:32.247 --> 00:01:38.697
But don't just return six,
also have a little counter in my backpack.

29
00:01:38.697 --> 00:01:41.593
The function in such a way
that when you run me,

30
00:01:41.593 --> 00:01:44.354
also increment my backpack counter to one.

31
00:01:44.354 --> 00:01:48.392
Next time you run me with I don't know,
anything, 10, 11, whatever.

32
00:01:48.392 --> 00:01:51.779
We'll go with ten,
check my backpack first.

33
00:01:51.779 --> 00:01:53.955
Counter says, one, return out.

34
00:01:53.955 --> 00:01:55.483
Sorry, I can only be run once.

35
00:01:55.483 --> 00:01:57.335
I've clearly been run before.

36
00:01:57.335 --> 00:01:59.131
My function gets a memory.

37
00:01:59.131 --> 00:02:04.824
This means you can do stuff like build
a tic-tac-toe game, click the cell.

38
00:02:04.824 --> 00:02:08.096
You only wanna click it once and
you can't ever click it again,

39
00:02:08.096 --> 00:02:10.834
because the function is
being called already once.

40
00:02:10.834 --> 00:02:12.739
Various situations like this.

41
00:02:12.739 --> 00:02:17.246
This turns out to be very useful
in professional engineering to

42
00:02:17.246 --> 00:02:21.421
oncefied to make a function
only be allowed to be run once.

43
00:02:21.421 --> 00:02:24.616
That's one of your challenges,
by the way, very demanding challenge.

44
00:02:24.616 --> 00:02:25.980
What about memoize?

45
00:02:25.980 --> 00:02:30.404
Memoize says, well, hold on.

46
00:02:30.404 --> 00:02:32.829
Suppose, I build as we said nth prime.

47
00:02:32.829 --> 00:02:34.673
To find the thousandth prime number,

48
00:02:34.673 --> 00:02:37.330
you gotta find all the prime
numbers up to that as well.

49
00:02:37.330 --> 00:02:38.895
It's a complicated, demanding task.

50
00:02:38.895 --> 00:02:40.089
It takes lots of steps.

51
00:02:40.089 --> 00:02:42.592
Maybe two, three, four seconds.

52
00:02:42.592 --> 00:02:47.541
If you pass 1,000 to nth prime, you don't
wanna have to if you end up having to

53
00:02:47.541 --> 00:02:49.980
pass 1,000 again to it have to go and

54
00:02:49.980 --> 00:02:54.901
recalculate 1,000 when you already
ran 1,000 in it a few seconds ago.

55
00:02:54.901 --> 00:03:00.683
So you memoize the function such that when
you call it the first time with 1,000,

56
00:03:00.683 --> 00:03:04.956
you do all the hard work to
find the 1,000th prime number.

57
00:03:04.956 --> 00:03:06.386
Do all the sieve thing.

58
00:03:06.386 --> 00:03:07.299
Anyone come from math?

59
00:03:07.299 --> 00:03:08.972
I do the sieve thing, whatever it is.

60
00:03:08.972 --> 00:03:12.591
I don't know how you do it, but
you find the thousandth prime number.

61
00:03:12.591 --> 00:03:15.005
And then yes, you turn it out.

62
00:03:15.005 --> 00:03:16.215
Great, the function worked.

63
00:03:16.215 --> 00:03:20.390
But also have an object in the backpack.

64
00:03:20.390 --> 00:03:23.608
Let's call it store and it's an object.

65
00:03:23.608 --> 00:03:28.548
And in there, you make a key a 1,000 and
you make a value the associated

66
00:03:28.548 --> 00:03:32.637
1,000th prime number from
the time you just ran it then.

67
00:03:32.637 --> 00:03:36.299
Next time you run ninth prime
with the input of 1,000,

68
00:03:36.299 --> 00:03:38.651
you don't do all the hard work first.

69
00:03:38.651 --> 00:03:39.703
You go look in the backpack.

70
00:03:39.703 --> 00:03:40.622
You look in the store.

71
00:03:40.622 --> 00:03:42.335
We already rounded to the thousand.

72
00:03:42.335 --> 00:03:45.639
We could just part in one step
out the 1,000th prime number.

73
00:03:45.639 --> 00:03:52.198
All bundled up in our persistent cache
on the back of our function nth prime.

74
00:03:52.198 --> 00:03:53.609
It's very profound.

75
00:03:53.609 --> 00:03:57.067
Very powerful, our functions
get to have their own memories.

76
00:03:57.067 --> 00:04:00.995
Now, we can hold onto D3 global memory.

77
00:04:00.995 --> 00:04:04.001
We could say like have counter at zero,
but the problem with that,

78
00:04:04.001 --> 00:04:04.868
couple of things.

79
00:04:04.868 --> 00:04:10.128
One, we want often independent live stores
associated with each other function.

80
00:04:10.128 --> 00:04:13.074
Can you imagine how good that is for
modularizing our code?

81
00:04:13.074 --> 00:04:17.181
There we go and another thing is
when we write code at scale and

82
00:04:17.181 --> 00:04:20.413
this is where close is
particularly powerful.

83
00:04:20.413 --> 00:04:25.845
We do not want to what's called
pollute our global memory.

84
00:04:25.845 --> 00:04:28.307
You've got a 100 engineers
working on the same team.

85
00:04:28.307 --> 00:04:35.365
10,000 lines of code and
you've got a variable saying, counter.

86
00:04:35.365 --> 00:04:37.009
This is not realistic.

87
00:04:37.009 --> 00:04:39.322
Someone else wants to call
their variable counter.

88
00:04:39.322 --> 00:04:41.074
You've got one saying result.

89
00:04:41.074 --> 00:04:45.689
I promise you, someone else on the team
wants to call their variable result,

90
00:04:45.689 --> 00:04:47.754
but you've got to hold on to data.

91
00:04:47.754 --> 00:04:48.916
Suppose, you've got a game.

92
00:04:48.916 --> 00:04:52.355
You want player one's
score not to be gone.

93
00:04:52.355 --> 00:04:56.568
You need to have player 1 equals 20,
but it gets super complicated.

94
00:04:56.568 --> 00:05:00.948
You don't necessarily want to
taint the global namespace.

95
00:05:00.948 --> 00:05:05.315
You wanna put that counter to four here.

96
00:05:05.315 --> 00:05:06.233
So what do you do?

97
00:05:06.233 --> 00:05:09.944
Well, one option is use what's
called a module pattern.

98
00:05:09.944 --> 00:05:15.019
And the module pattern in JavaScript says,
if I saw my data inside my function,

99
00:05:15.019 --> 00:05:19.367
but every time that function
finished running, the data's gone.

100
00:05:19.367 --> 00:05:22.552
But I wanna to hold onto data,
sort in global.

101
00:05:22.552 --> 00:05:25.126
But that's dangerous,
cuz it can get overwritten really easily.

102
00:05:25.126 --> 00:05:27.887
It's really hard to maintain.

103
00:05:27.887 --> 00:05:30.859
What if I wrote these
functions in such a way,

104
00:05:30.859 --> 00:05:36.179
the way Katie said that they were really
easy to write to by passing something in,

105
00:05:36.179 --> 00:05:40.503
but then sent off into the backpack and
easy to get the data out of.

106
00:05:40.503 --> 00:05:45.980
What if I store the data I want to
persist in the backpacks on my functions?

107
00:05:47.970 --> 00:05:52.555
Therefore, for the life of my application,
I have that data around,

108
00:05:52.555 --> 00:05:55.677
but it's persisting in
a very protected area.

109
00:05:55.677 --> 00:06:00.806
So I just write this function in a really
clean way and the module pattern

110
00:06:00.806 --> 00:06:05.864
lets do that such that my data sticks
around, but I'm not polluting.

111
00:06:05.864 --> 00:06:10.486
Tainting the global memory itself and
this is called the module pattern, and

112
00:06:10.486 --> 00:06:17.244
that's advanced stuff.
&gt;&gt; Will Sentance: Quinoa salads are not.

113
00:06:17.244 --> 00:06:19.601
That's advanced stuff.

114
00:06:19.601 --> 00:06:20.918
It lies even in Codesmith.

115
00:06:20.918 --> 00:06:22.323
I think it's week seven of Codesmith.

116
00:06:22.323 --> 00:06:25.640
It's very demanding stuff,
the module pattern.

117
00:06:25.640 --> 00:06:31.894
But it's also super, seasoned developer,
professional type of code writing and

118
00:06:31.894 --> 00:06:37.810
that relies fundamentally on using our
persistent lexical scope reference.

119
00:06:37.810 --> 00:06:41.958
Our closed over variable environment,
all the same thing.

120
00:06:41.958 --> 00:06:47.869
Our closure, our backpack.

121
00:06:47.869 --> 00:06:49.165
Did I say,
closed over variable environment?

122
00:06:49.165 --> 00:06:51.445
Closed over, I said that one already.

123
00:06:51.445 --> 00:06:52.309
What other one?

124
00:06:52.309 --> 00:06:56.719
Closer variable environment,
persistence reference, closure, backpack.

125
00:06:56.719 --> 00:06:58.095
There you go, all those things.

126
00:06:58.095 --> 00:06:59.600
They all mean the same thing.

127
00:06:59.600 --> 00:07:00.438
There we go, folk.

128
00:07:00.438 --> 00:07:01.186
That's it.

129
00:07:01.186 --> 00:07:05.749
At this point, we have covered the end
of day one thread execution context call

130
00:07:05.749 --> 00:07:09.912
stack which gave us the foundations
to tackle quite a lot harder stuff.

131
00:07:09.912 --> 00:07:13.200
You're sitting there thinking yeah,
I got multiply by 2 does.

132
00:07:13.200 --> 00:07:18.662
But all those pieces gave us the pieces
to handle higher order functions and

133
00:07:18.662 --> 00:07:23.012
then the most esoteric of
JavaScript concepts, closure.

134
00:07:23.012 --> 00:07:26.968
At this point,
we wait until tomorrow to continue.

135
00:07:26.968 --> 00:07:31.550
Tomorrow, we will handle asynchronous
JavaScript and object-oriented JavaScript.

