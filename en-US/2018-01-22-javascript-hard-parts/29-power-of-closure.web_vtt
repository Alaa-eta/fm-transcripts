WEBVTT

1
00:00:00.000 --> 00:00:04.299
We have achieved something really
remarkable here, we have given,

2
00:00:04.299 --> 00:00:08.747
our function definitions ain't
just function definitions anymore.

3
00:00:08.747 --> 00:00:13.933
They're function definitions plus live
data stores attached to the back of them,

4
00:00:13.933 --> 00:00:15.786
they're all mini-caches.

5
00:00:15.786 --> 00:00:20.283
Persistent state, little state stores
that were created My k1 salad.

6
00:00:20.283 --> 00:00:24.729
Were created by the fact that these
functions were themselves to find inside

7
00:00:24.729 --> 00:00:26.674
another function being called.

8
00:00:26.674 --> 00:00:31.050
And they therefore got this little
bond to their surrounding life memory.

9
00:00:31.050 --> 00:00:34.939
And that bond did not go away when
that function got returned out and

10
00:00:34.939 --> 00:00:36.397
stored in its new label.

11
00:00:36.397 --> 00:00:38.780
It's very, you know, very profound.

12
00:00:38.780 --> 00:00:40.990
So, what does that have to do?

13
00:00:40.990 --> 00:00:46.858
Well if we go back to the very beginning,
we said, what's it's say, we said what

14
00:00:46.858 --> 00:00:52.731
if our functions could hold onto live data
slash state between their executions?

15
00:00:52.731 --> 00:00:55.281
Well, what do you know, they can.

16
00:00:55.281 --> 00:00:59.740
This would let our function
definitions have an associated,

17
00:01:19.750 --> 00:01:25.902
First let me run me, I'm gonna multiply by
two function it's got a memory of the last

18
00:01:25.902 --> 00:01:31.965
time I ran, the first time I run me we put
a 3 multiplied by 2 return 6, okay fine,

19
00:01:31.965 --> 00:01:38.016
good, but don't just return 6, also have
a another counter in my back pack Right?

20
00:01:38.016 --> 00:01:40.736
They function in such a way
that when you run me,

21
00:01:40.736 --> 00:01:43.253
also increment my backpack counter to one.

22
00:01:43.253 --> 00:01:47.809
Next time you run me with, I don't know,
anything, 10, 11, whatever,

23
00:01:47.809 --> 00:01:51.209
we'll probably do it with 10,
check my backpack first.

24
00:01:51.209 --> 00:01:54.813
Counter says one, return out,
sorry, I can only be run once.

25
00:01:54.813 --> 00:01:56.680
I've clearly been run before.

26
00:01:56.680 --> 00:01:58.374
My function gets a memory.

27
00:01:58.374 --> 00:02:02.424
This means that you can do stuff
like build a tic, tac, toe game,

28
00:02:02.424 --> 00:02:03.455
click the cell.

29
00:02:03.455 --> 00:02:05.370
You only wanna click it once and

30
00:02:05.370 --> 00:02:10.379
you can't ever click it again because
the function is being called already one.

31
00:02:10.379 --> 00:02:12.369
Various situations like this.

32
00:02:12.369 --> 00:02:16.394
This turns out to be very useful
In professional engineering,

33
00:02:16.394 --> 00:02:20.560
to once-ify, to make a function
only be allowed to be run once.

34
00:02:20.560 --> 00:02:25.343
That's one of your challenges,
by the way, very demanding challenge.

35
00:02:25.343 --> 00:02:26.810
What about memorize?

36
00:02:26.810 --> 00:02:28.971
Memorize says, well, hold on.

37
00:02:28.971 --> 00:02:31.670
Suppose I build, as we said, nth prime.

38
00:02:31.670 --> 00:02:34.320
To find the 1000th prime number--

39
00:02:34.320 --> 00:02:37.724
You've gotta find all the prime
numbers up to that as well.

40
00:02:37.724 --> 00:02:40.041
It's a complicated, demanding task.

41
00:02:40.041 --> 00:02:41.403
It takes lots of steps.

42
00:02:41.403 --> 00:02:43.446
Maybe two, three, four seconds.

43
00:02:43.446 --> 00:02:46.782
If you parth 100 to nth prime
you don't want to have to,

44
00:02:46.782 --> 00:02:50.049
if you end up parthing 1000 again to it,
have to go and

45
00:02:50.049 --> 00:02:54.450
recalculate 1000 when you already
ran 1000 in it a few seconds ago.

46
00:02:54.450 --> 00:02:58.794
So you memo-ize the function such that,
when you call it the first time,

47
00:02:58.794 --> 00:03:03.630
with 1,000, you do all the hard work
to find the 1,000th prime number.

48
00:03:03.630 --> 00:03:04.822
Do the sieve thing.

49
00:03:04.822 --> 00:03:06.223
Anyone come from math?

50
00:03:06.223 --> 00:03:07.485
I do the sieve thing.

51
00:03:07.485 --> 00:03:10.077
Whatever it is,
I don't know how you do it.

52
00:03:10.077 --> 00:03:12.741
But you find the 1,000th prime number.

53
00:03:12.741 --> 00:03:14.842
And then, yes, you return it out.

54
00:03:14.842 --> 00:03:16.665
Great.
The function worked.

55
00:03:16.665 --> 00:03:21.117
But also You have an object in
the backpack, let's call it store.

56
00:03:21.117 --> 00:03:22.552
And it's an object.

57
00:03:22.552 --> 00:03:26.776
And in there you make a key,
1,000, and you make a value,

58
00:03:26.776 --> 00:03:31.962
the associated 1,000th prime number
from the time you just ran it then.

59
00:03:31.962 --> 00:03:35.840
Next time you run nth prime
with the input of 1,000.

60
00:03:35.840 --> 00:03:38.070
You don't do all the hard work first.

61
00:03:38.070 --> 00:03:43.087
You go look in the backpack, look in
the store, we already ran with 1,000,

62
00:03:43.087 --> 00:03:46.781
we can just pass in one step out,
the thousandth prime number.

63
00:03:46.781 --> 00:03:51.520
All bundled up in our persistent cache,
on the back of our function, nth prime.

64
00:03:51.520 --> 00:03:53.821
It's very profound, very powerful.

65
00:03:53.821 --> 00:03:58.076
Our functions get to have little
memories Now we can hold on to data and

66
00:03:58.076 --> 00:03:59.158
global memory.

67
00:03:59.158 --> 00:04:04.411
We could say have counter of zero but the
problem with that and a couple of things.

68
00:04:04.411 --> 00:04:09.664
One we want often independent live stores
associated with each other function.

69
00:04:09.664 --> 00:04:13.218
You can imagine how good that is for
modulizing a code.

70
00:04:13.218 --> 00:04:14.144
There you go.

71
00:04:14.144 --> 00:04:17.340
And another thing is when
we write code to scale.

72
00:04:17.340 --> 00:04:21.124
And this is where close
is particularly powerful.

73
00:04:21.124 --> 00:04:25.524
We do not want to what's called
pollute our global memory.

74
00:04:25.524 --> 00:04:29.484
You got 100 engineers
working with the same team,

75
00:04:29.484 --> 00:04:34.940
10 thousand lines of code, and
you've got a variable saying counter.

76
00:04:34.940 --> 00:04:39.423
This is not realistic Someone else
wants to call [INAUDIBLE] counter.

77
00:04:39.423 --> 00:04:41.449
You've got one saying results.

78
00:04:41.449 --> 00:04:45.932
I promise you, someone else in the team
wants to call [INAUDIBLE] results.

79
00:04:45.932 --> 00:04:49.328
But you gotta hold on to data
like suppose you go to game.

80
00:04:49.328 --> 00:04:52.074
You want Player 1's score, not to be gone.

81
00:04:52.074 --> 00:04:56.465
You need to have Player 1 equals 20 but
it gets super complicated.

82
00:04:56.465 --> 00:05:00.460
You don't necessarily want to
taint the global name space.

83
00:05:00.460 --> 00:05:04.297
You don't want to put like
counter two counter four here.

84
00:05:04.297 --> 00:05:05.469
So what do you do?

85
00:05:05.469 --> 00:05:09.307
Well one option is use what's
called the module pattern.

86
00:05:09.307 --> 00:05:14.345
And the module pattern in java script says
If I store my data inside my function,

87
00:05:14.345 --> 00:05:18.432
well every time that function
finishes running, the data's gone.

88
00:05:18.432 --> 00:05:20.052
But I wanna hold on to data.

89
00:05:20.052 --> 00:05:21.603
Okay, stored in global.

90
00:05:21.603 --> 00:05:25.618
But that's dangerous,
cuz it can get overwritten really easily,

91
00:05:25.618 --> 00:05:27.873
it's really hard to maintain.

92
00:05:27.873 --> 00:05:32.592
What if I wrote these functions in such a
way that the way Katie said that they were

93
00:05:32.592 --> 00:05:35.900
really easy to write to
By parsing something in,

94
00:05:35.900 --> 00:05:38.384
then sent off into the backpack.

95
00:05:38.384 --> 00:05:40.689
And easy to get the data out of.

96
00:05:40.689 --> 00:05:46.184
What if I store the data I want to
persist in the backpacks on my functions?

97
00:05:46.184 --> 00:05:51.415
Therefore, for the life of my application,
I have that data around,

98
00:05:51.415 --> 00:05:54.990
but it's persisting in
a very protected area.

99
00:05:54.990 --> 00:05:58.579
So I just write the function
a really clean way, and

100
00:05:58.579 --> 00:06:01.167
the module pattern lets you do that.

101
00:06:01.167 --> 00:06:06.510
So my data sticks around but I'm not
polluting, tainting the global memory

102
00:06:06.510 --> 00:06:11.710
itself and this is called the module
pattern and that's advanced stuff.

103
00:06:11.710 --> 00:06:13.135
quinoa salad is.

104
00:06:13.135 --> 00:06:15.225
That's advanced stuff.

105
00:06:15.225 --> 00:06:17.410
It lies even in code smith.

106
00:06:17.410 --> 00:06:20.545
I think it's week seven of code smith.

107
00:06:20.545 --> 00:06:22.920
It's very demanding stuff.

108
00:06:22.920 --> 00:06:24.630
The module pattern.

109
00:06:24.630 --> 00:06:30.922
But it's also super seasoned developer
professional type of code writing And

110
00:06:30.922 --> 00:06:37.370
that rely fundamentally on using our
persistent lexical scope reference.

111
00:06:37.370 --> 00:06:40.796
Our closed over variable environment.

112
00:06:40.796 --> 00:06:43.313
Or same thing, our closure.

113
00:06:43.313 --> 00:06:48.953
Our backpack or our, did I say
closed over variable environment?

114
00:06:48.953 --> 00:06:51.090
I said that one already?

115
00:06:51.090 --> 00:06:52.371
What's the other one?

116
00:06:52.371 --> 00:06:55.767
Closes of the enviroment,
[INAUDIBLE], closure, backpack.

117
00:06:55.767 --> 00:06:56.535
There you go.

118
00:06:56.535 --> 00:06:59.159
All those things,
they all mean the same thing.

119
00:06:59.159 --> 00:07:00.183
There we go folks.

120
00:07:00.183 --> 00:07:04.538
At this point, we have covered at the end
of day one Thread, execution context,

121
00:07:04.538 --> 00:07:08.763
call stack, which gave us the foundations
to tackle quite a lot harder stuff.

122
00:07:08.763 --> 00:07:12.070
Your sitting there thinking,
yeah I got to multiply by two.

123
00:07:12.070 --> 00:07:12.589
Does.

124
00:07:12.589 --> 00:07:18.047
But all those pieces gave us the pieces
to handle higher order functions and

125
00:07:18.047 --> 00:07:22.376
then the most esoteric of
JavaScript concepts, closure.

126
00:07:22.376 --> 00:07:27.051
All right, at this point,
we wait until tomorrow to continue.

127
00:07:27.051 --> 00:07:33.392
Tomorrow we will handle asynchronous
JavaScript and Object-oriented JavaScript.

