[00:00:03]
>> Will Sentance: We are going to move on to now the wonderful world of asynchronicity. Asynchronicity is going to change up this whole model. It's going to change it up, it's gonna augment this whole model. This whole model is going to continue to exist In fact, the reason we're gonna need to augment our model, is this model is going to fundamentally untenable in how you think about doing tasks that take a long time.

[00:00:32]
So let 's just confirm, JavaScript is single threaded, one line of code of executing at the time. When I start running multiple by two, I'm not allowed to continue on in my global code.
>> Will Sentance: To executing the context comprising at the same time. Not allowed to, single threaded.

[00:00:53]
But simultaneously, I'm also not allowed to move on to the next line regardless, because until I finish multiply by 2's call, because JavaScript is synchronous. All that means is I go from top to bottom, I never move on to the next line until I finish on the previous line.

[00:01:08]
I never, ever move on to the next line. If you see a function call, I must return out of it, I must finish executing it before I hit the next line. Well this implies a big problem, what if our multiply by two call were a call to a server that was going to take 300 milliseconds?

[00:01:27]
I'm not allowed to move on from that line to run any more Javascript until that comes back. What if I click view more tweets and it runs Javascript code that says go get more tweets Is gonna take 300 millisecond or 200 milliseconds before the tweets come back. But in the mean time, I'm clicking like on a tweet which is gonna run more JavaScript code to turn it to pink, and to increase the number of likes on that tweet in my state, in my memory.

[00:01:55]
That can't happen, I'll be sitting there clicking, because I'm still busy waiting on the line saying, go get more tweets. Because I've gotta wait till it returns back the tweets, right? Before I can move on to my next line that says color the heart pink cuz I click the button.

[00:02:08]
This is gonna be a profound issue. What is we wanna wait some time before we can execute some bits of code? We want to wait until our data comes back from Twitter before we can then display and run the functionality display that data. That mean to get more data in API or even a timer to complete and then wanna run some code, we have a conundrum a tension between wanting to delay some code running because we're waiting for data to come back so we wanna have the next line of code be Display those tweets.

[00:02:43]
We want to have the data actually come back. But we do know how to block our single thread from continuing to run code, this is going to be a profound conundrum. It is going to be the essence of why we have to introduce in JavaScript a whole a complimentary model to our beautiful synchronous world.

[00:03:01]
These three parts of JavaScript alone are not enough. What's particularly interesting is asynchronicity in Java, asynchronous what Java is the interesting stuff. I love our pure simple JavaScript engine, but everything we love about web application development is not happening in pure JavaScript. Pure JavaScript does not know how to speak to the Internet, that is not a feature of JavaScript to speak to the Internet.

[00:03:28]
Instead all those features are sitting outside of JavaScript. They're sitting outside of JavaScript in where? What's your name, dude? Alec.
>> Alec: Alec.
>> Will Sentance: Alec, where are they sitting?
>> Will Sentance: Where are those features of JavaScript that are not, that are doing things like speaking to the Internet. Where are they?

[00:03:45]

>> Alec: APIs?
>> Will Sentance: Well not features of JavaScript, I'm sorry. Where are the features that speak to the internet that JavaScript uses? Yeah, what does that mean?
>> Alec: I don't know. Restful web services and.
>> Will Sentance: Michelle, where are all those features that can for example speak to the Internet?

[00:03:59]

>> Michelle: Are they in the browser area?
>> Will Sentance: They're in the browser. The browser is a wealth of features that we in JavaScript get access to. We write JavaScript code that is essentially a facade. We're gonna see these our facades for a bunch of features that are not in JavaScript but instead in the web browser.

[00:04:23]
That's what we're gonna end up spending most of our time this morning doing, is writing JavaScript code that interfaces APIs, Alex is right. Interfaces, the I in API stands for interface that interacts with stuff outside of JavaScript. Okay, we need a whole new bunch of features. In JavaScript, and outside of JavaScript, in order to understand how this is working.

[00:04:49]
So, here we go, here's our first solution. And I'll pre-tell you that it's fundamentally untenable, but here's our first solution for how to go and do a task that's going to take a long time, like speaking to Twitter and getting our tweets back. And nevertheless, be able to continue running code, but know where that data is whn it comes back.

[00:05:11]
This first solution here is going to be untenable, but it is nevertheless going to be fairly intuitive, but completely untenable, all right. Line one, and by the way, so far we are still seeing things that are very analagous to first hard parts. But we need to get these foundations down to understand the harder pieces to come.

[00:05:37]
All right, line one. Abdi?
>> Abdi: Yeah, we're declaring display in our variable environment.
>> Will Sentance: Yeah very nicely put Abdi. Display is declared. Excellent. Next line of code. Alec, do the left hand side first.
>> Alec: We are declaring data from API.
>> Will Sentance: Yeah, and what's it gonna be assigned?

[00:06:03]

>> Alec: The faction weight function?
>> Will Sentance: No we never assign function, if we just had, we had no parends there. It could be assigned, it would say whats fetch and weight, it would assign it to that whatever it is. But Java scripts not doing that on the right hand.

[00:06:17]
What are parends always tell me to do, blessing?
>> Blessing: To call a function.
>> Will Sentance: To call. The right-hand side here is a command, it is unfinished work, so be really clear with yourself in no way are we assigning. Data API has zero interest in fetchAndWait. It's only interest is in whatever gets returned from fetchAndWait, which we hope, we'll be at tweet.

[00:06:42]
Okay, so fetch and wait here is a made up function, but let's just see what it does. So dated from API is going to be return of fetch and wait, to our Twitter URL. So we're hoping it's gonna return a nice tweet for us, that's what we're hoping.

[00:07:08]
So let's start tracking our time parsing. We're at about 1 millisecond here, let's say this thing here takes 200 milliseconds to complete.
>> Will Sentance: 200 millisecond, 200 milliseconds later, finally our data comes back. It could be 200 milliseconds, it could be half a second, we don't even know. In that time, are we allowed to move on and run any further jobs for code?

[00:07:43]
Absolutely not, we are not allowed to move on. We are blocked because our JavaScript thread is synchronous, there is work we are still doing on the right hand side here. We are not aloud and we wouldn't want to. Because the next line says, display the data API, so we better have that data back to display it.

[00:08:01]
Is that solution one? To be clear, this is not the right solution, but this is a solution. So 200 milliseconds passes and our request to Twitter returns out. Let's just say very nicely, it returns out our data and it is the, it is a single tweet, and it's not even coming back as an object.

[00:08:24]
Of course, they come back as objects, but just a tweet, hi. And we go to store hi where, Michelle?
>> Michelle: [LAUGH] Sorry, I was distracted by laughing at your topic.
>> Will Sentance: We're going to return that from fetchAndWait, hi. Where is it going to be stored?
>> [INAUDIBLE]
>> Will Sentance: Yeah, Michelle where is it gonna be stored?

[00:08:43]

>> Michelle: In data from API.
>> Will Sentance: In data from API exactly. I apologise for saying like I'm correcting all of your pronunciations of data to data. But I, I'm not, I embrace your mispronounciations, okay. Well done all of you for corrupt no, no corrupting. Good. [INAUDIBLE] amazing. A beautiful language, all right.

[00:09:08]
Okay, good. So [INAUDIBLE] where we are API has high, the string high stored in it, 200 milliseconds later. In that time no further JavaScript code could run, this is absolutely disastrous. Whatever, now we hit our next line which is, who haven't I called on yet? Sonny, what's our next line of code say to do?

[00:09:33]

>> Sonny: We'll pass that data API to display.
>> Will Sentance: Right, so we parse out to recalling the display function with our argument being. The value of data for APR, remember everything in jobs gets evaluated immediately. Data from API here is a string high, we throw it straight in and we create an execution context to run it where, in the memory, the parameter data is set to that argument Hi, and so we're going to log in our console at about 201 milliseconds, we're going to log hi, okay.

[00:10:14]
And now finally, what line do we hit next? Gentleman what's your name?
>> Ben: Ben.
>> Will Sentance: Ben, sorry Ben.
>> Ben: We're gonna log.
>> Will Sentance: Me later is gonna be logged at the much later time of 202 milliseconds. Me later is logged.
>> Will Sentance: Raise your hand if you're a huge fan of this solution.

[00:10:44]
I'm a huge fan of this. No, I don't mind this solution. Here's why I don't mind this solution, it is profoundly intuitive. Three goals we have. Be able to do tasks that take a long time, slow tasks like getting data from Twitter. We have to be able to do that, otherwise our web app is very, very boring.

[00:11:03]
Our best we can make a hangman game, very nice hangman game in the command line, well, that's the best we can do. But we wanna be able to continue running our JavaScript code in the meantime, we could not do that here. Look at this, in the meantime, no JavaScript code was allowed to run for 200 milliseconds.

[00:11:21]
When our slow task completes though we should be able to run functionality knowing the task is done and data is ready. That's the hard bit, it's gonna turn out every other solution we have that's the hard bit. In this solution, not a hard bit, this solution is effortless.

[00:11:35]
I can see where my data is synchronously in order, in memory. I've got no issues when my display function's gonna run, it ain't gonna run literally in my single thread until I've got my data back. I'm dealing only in the synchronous world here, in order. In order of top to bottom.

[00:11:49]
That's why we love Java's single frame model, that's the, the vision behind it is it's highly predictable and easy to work with as a developer. But all this leaves fundamentally untenable blocks our single javascript thread from running any further code while this task completes. Benefits it's definitely easy to reason about, but it's untenable.

