WEBVTT

1
00:00:00.400 --> 00:00:05.710
&gt;&gt; Will Sentance: We now have a situation
here where we create a little function

2
00:00:05.710 --> 00:00:10.350
inside another function,
returned it out into a new global label,

3
00:00:10.350 --> 00:00:15.530
and then use a new global label for that
functionality for what possible reason?

4
00:00:15.530 --> 00:00:17.660
Why did I not define at two globally?

5
00:00:20.110 --> 00:00:23.998
Who already knows the answer, right, so I
love it when there's lots of people feel,

6
00:00:23.998 --> 00:00:26.550
cuz I love the big reveals,
I love the big reveals.

7
00:00:28.940 --> 00:00:34.192
It's gonna turn out when we return
a function from another function we get so

8
00:00:34.192 --> 00:00:36.583
much more than just the function.

9
00:00:36.583 --> 00:00:42.797
We're gonna get a ton of well,
a single profound bonus.

10
00:00:42.797 --> 00:00:45.703
And that's gonna be critical for

11
00:00:45.703 --> 00:00:50.578
us to build out our own functions
that when we call them,

12
00:00:50.578 --> 00:00:54.641
give us our next element
from our flow of data.

13
00:00:54.641 --> 00:00:56.580
And I like calling them iterators,
what a strange name.

14
00:00:56.580 --> 00:00:59.760
But instead give us our next
element from our flow of data.

15
00:00:59.760 --> 00:01:04.165
Let's see it here, so we want to
create a function that holds, hold,

16
00:01:04.165 --> 00:01:09.094
we want to create a function that has the
ability to return our next element from

17
00:01:09.094 --> 00:01:10.086
a list of data.

18
00:01:10.086 --> 00:01:15.285
4, 5, 6, for example, but
then also, bundled on that function,

19
00:01:15.285 --> 00:01:19.288
it must have the underlying
data to grab from, right?

20
00:01:19.288 --> 00:01:21.070
Otherwise, where is it going to draw from?

21
00:01:21.070 --> 00:01:26.530
And it must have the ability to track
which element it was on before,

22
00:01:26.530 --> 00:01:30.860
so that when we run that function again,
it doesn't give us the old element.

23
00:01:30.860 --> 00:01:32.390
The previous element.

24
00:01:32.390 --> 00:01:33.700
How the hell is it gonna do that?

25
00:01:33.700 --> 00:01:37.910
Cuz functions when they're called do
not remember their prior invocation.

26
00:01:37.910 --> 00:01:40.290
They do not remember data that was
created in their prior running.

27
00:01:41.320 --> 00:01:44.475
The low constitution context,
[SOUND] we run this function again,

28
00:01:44.475 --> 00:01:46.230
brand new function add two created.

29
00:01:46.230 --> 00:01:48.290
There's no memory of previous running.

30
00:01:48.290 --> 00:01:51.450
So how can we have a function that when
run somehow remembers its previous running

31
00:01:51.450 --> 00:01:54.710
that its been run before and
had a previous element given out?

32
00:01:56.610 --> 00:01:59.538
We shall see, but
that's what we've got to try and do.

33
00:01:59.538 --> 00:02:04.483
So gonna start calling this create
function that's gonna return out

34
00:02:04.483 --> 00:02:07.732
an inner function into
return next element.

35
00:02:07.732 --> 00:02:12.430
And then we're going to hopefully
about to get our first element.

36
00:02:12.430 --> 00:02:13.240
Who knows how?

37
00:02:13.240 --> 00:02:14.072
We shall see.

38
00:02:14.072 --> 00:02:17.836
All right, we're gonna walk
through this very, very precisely,

39
00:02:17.836 --> 00:02:22.340
because this is pretty much our main,
really our own code on this whole section.

40
00:02:23.640 --> 00:02:24.574
But it's very important code.

41
00:02:24.574 --> 00:02:29.495
And honestly can be
considered quite hard for

42
00:02:29.495 --> 00:02:35.600
folk especially,
who've not seen hard parts before.

43
00:02:35.600 --> 00:02:38.960
For folks who have,
there might be a section that you remember

44
00:02:38.960 --> 00:02:43.980
that this is trying to remind you of
involving something called a backpack.

45
00:02:43.980 --> 00:02:47.070
All right, good, line one.

46
00:02:48.408 --> 00:02:51.138
I would like to call
this instead create flow,

47
00:02:51.138 --> 00:02:55.898
because it's kind of creating the flow but
we'll call it create function here,

48
00:02:55.898 --> 00:03:00.125
so what are we doing in line one Victor?
&gt;&gt; Victor: We're creating a function

49
00:03:00.125 --> 00:03:04.730
called create function in memory.
&gt;&gt; Will Sentance: There it is excellent,

50
00:03:04.730 --> 00:03:05.500
thank you, Victor.

51
00:03:06.580 --> 00:03:10.210
Next line, James.
&gt;&gt; James: You're creating a new constant

52
00:03:10.210 --> 00:03:12.980
called return next element.
&gt;&gt; Will Sentance: Excellent.

53
00:03:12.980 --> 00:03:15.404
Do we know what it's gonna be yet?

54
00:03:15.404 --> 00:03:17.180
It's gonna be stored there yet?
&gt;&gt; James: Not yet.

55
00:03:17.180 --> 00:03:18.008
&gt;&gt; Will Sentance: So it's gonna default

56
00:03:18.008 --> 00:03:19.370
in JavaScript too.
&gt;&gt; James: Undefined.

57
00:03:19.370 --> 00:03:22.555
&gt;&gt; Will Sentance: Undefined, excellent, so

58
00:03:22.555 --> 00:03:23.887
here we go.

59
00:03:23.887 --> 00:03:28.601
I'm trying to get my board
positioning right here, so

60
00:03:28.601 --> 00:03:33.530
return next element is going
to be the output of calling.

61
00:03:35.380 --> 00:03:40.610
Create function, where we're
parsing the array 4, 5, 6 to it,

62
00:03:40.610 --> 00:03:47.027
we're going to create what's, Paul, a new.
&gt;&gt; Paul: Local execution context.

63
00:03:47.027 --> 00:03:48.151
&gt;&gt; Will Sentance: New execution context,

64
00:03:48.151 --> 00:03:51.650
excellent, one on man,
I have the same enthusiasm for it as you.

65
00:03:51.650 --> 00:03:58.240
There it is, into it we go and
Sonny what has of course our thread?

66
00:03:58.240 --> 00:04:03.160
Our threads winded its way in and
it has a memory just for

67
00:04:03.160 --> 00:04:07.250
stuff that's declared
inside this function.

68
00:04:07.250 --> 00:04:11.675
And Sonny what's the first
thing that is declared

69
00:04:11.675 --> 00:04:14.670
inside this function?
&gt;&gt; Sonny: Array, the array.

70
00:04:14.670 --> 00:04:15.741
&gt;&gt; Will Sentance: Yeah, sorry, array,

71
00:04:15.741 --> 00:04:19.504
good job, array, yeah, which is set that's
a parameter to what argument value?

72
00:04:19.504 --> 00:04:20.311
&gt;&gt; Sonny: 4, 5, 6.

73
00:04:20.311 --> 00:04:22.479
&gt;&gt; Will Sentance: 4, 5, 6, thank you,

74
00:04:22.479 --> 00:04:29.930
that's very good, Suni, and what's our
next thing inside of our local memory?

75
00:04:29.930 --> 00:04:32.300
Yeah, go ahead.

76
00:04:32.300 --> 00:04:36.420
Set 2, 0 good, and Ben?

77
00:04:37.620 --> 00:04:42.250
Next thing we set up in our local memory.
&gt;&gt; Ben: Declare the function inner.

78
00:04:42.250 --> 00:04:43.140
&gt;&gt; Will Sentance: Excellent there it is,

79
00:04:45.010 --> 00:04:45.980
just so we can keep track of it,

80
00:04:45.980 --> 00:04:48.860
I'm gonna do it in a different color,
because it is really weird.

81
00:04:48.860 --> 00:04:51.953
I recognized that it's weird to define
functions inside other functions,

82
00:04:51.953 --> 00:04:52.684
return them out.

83
00:04:52.684 --> 00:04:53.603
I recognize it, so

84
00:04:53.603 --> 00:04:57.400
I really wanna make sure we're really
keeping track of how that's evolving.

85
00:04:57.400 --> 00:05:01.233
That's the function are we
going to call it, Ben,

86
00:05:01.233 --> 00:05:03.758
are we gonna evoke it?
&gt;&gt; Ben: No.

87
00:05:03.758 --> 00:05:04.518
&gt;&gt; Will Sentance: No, what are we going to

88
00:05:04.518 --> 00:05:06.420
do instead?
&gt;&gt; Ben: We're going to return it.

89
00:05:06.420 --> 00:05:07.210
&gt;&gt; Will Sentance: Return it's entire

90
00:05:07.210 --> 00:05:11.849
definition out, there it is,
out at returns.

91
00:05:13.360 --> 00:05:17.097
And store it where, Ben?
&gt;&gt; Ben: We're gonna store it in return

92
00:05:17.097 --> 00:05:18.860
next element.
&gt;&gt; Will Sentance: Exactly,

93
00:05:18.860 --> 00:05:22.950
return next element is now our function
that was formally known as what,

94
00:05:22.950 --> 00:05:25.516
Ben?
&gt;&gt; Ben: Great function?

95
00:05:25.516 --> 00:05:28.630
Or no, inner, yeah.
&gt;&gt; Will Sentance: See how hard it is to

96
00:05:28.630 --> 00:05:29.420
keep track of this?

97
00:05:29.420 --> 00:05:32.100
It was formerly known
as that inner function.

98
00:05:32.100 --> 00:05:35.010
Inside of create function
it was known as inner,

99
00:05:35.010 --> 00:05:38.080
now, we've hit the return
statement to create function.

100
00:05:38.080 --> 00:05:42.728
So all the labels in here,
all the data in here, what happens to it?

101
00:05:42.728 --> 00:05:44.066
&gt;&gt; Ben: [INAUDIBLE]

102
00:05:44.066 --> 00:05:44.990
&gt;&gt; Will Sentance: Gone, adjust

103
00:05:44.990 --> 00:05:50.820
the function, they've got returned out,
passed out to return next element.

104
00:05:50.820 --> 00:05:52.220
Perfect!

105
00:05:52.220 --> 00:05:56.730
We've popped out of the call stack and
we're back out to return next element.

106
00:05:56.730 --> 00:05:59.250
Let's just make sure we keep
track of our call stack.

107
00:05:59.250 --> 00:06:00.068
Our call stack,

108
00:06:00.068 --> 00:06:02.451
we're back in what execution context?
&gt;&gt; Ben: Global.

109
00:06:02.451 --> 00:06:03.442
&gt;&gt; Will Sentance: Global, excellent,

110
00:06:03.442 --> 00:06:04.070
into global.

111
00:06:05.870 --> 00:06:07.660
So we've done return next element.

112
00:06:08.930 --> 00:06:14.530
Okay, so how can we, now, in theory what
do we hope that calling the return next

113
00:06:14.530 --> 00:06:20.538
element function is gonna do in theory RD?
&gt;&gt; Will Sentance: What

114
00:06:20.538 --> 00:06:24.305
do we hope in theory Brian is gonna do?
&gt;&gt; Brian: Return 4.

115
00:06:24.305 --> 00:06:25.467
&gt;&gt; Will Sentance: 4, that's what we hope,

116
00:06:25.467 --> 00:06:26.577
if we run it again we hope it

117
00:06:26.577 --> 00:06:27.239
would return.

118
00:06:27.239 --> 00:06:27.930
&gt;&gt; Brian: 5.
&gt;&gt; Will Sentance: And

119
00:06:27.930 --> 00:06:28.830
again?
&gt;&gt; Brian: 6.

120
00:06:28.830 --> 00:06:29.347
&gt;&gt; Will Sentance: And again,

121
00:06:29.347 --> 00:06:31.320
undefined at some point, yeah, okay.

122
00:06:31.320 --> 00:06:35.444
That's what we're hoping for, desperately,
cuz that allows us to rethink our

123
00:06:35.444 --> 00:06:38.671
collection of data as a flow.
&gt;&gt; Will Sentance: I run a function and

124
00:06:38.671 --> 00:06:40.993
get my next element, I run a function,
get my next element.

125
00:06:40.993 --> 00:06:42.334
I run a function, get my next element,

126
00:06:42.334 --> 00:06:44.050
that's a beautiful way of
thinking of your data.

127
00:06:44.050 --> 00:06:47.790
No more I have a collection
statically of data and memory,

128
00:06:47.790 --> 00:06:50.600
I've got to go and look at it,
get an element, use it.

129
00:06:50.600 --> 00:06:54.430
Look at it, get an element, use it,
now, I've just run my function, and

130
00:06:54.430 --> 00:06:56.630
I'm given, I'm given my next element.

131
00:06:57.650 --> 00:07:00.940
It's a really beautiful way of
thinking about my collections of data.

132
00:07:00.940 --> 00:07:03.350
As flows of element after
element after element.

133
00:07:03.350 --> 00:07:04.850
Everyone got that mentality shift?

134
00:07:04.850 --> 00:07:07.000
It's a beautiful way of thinking.

135
00:07:07.000 --> 00:07:08.144
So, you're right.

136
00:07:08.144 --> 00:07:12.030
What it is to run call
return next element.

137
00:07:12.030 --> 00:07:15.104
So let's do just that, so
left-hand side there, Abde,

138
00:07:15.104 --> 00:07:18.493
tends to be what?
&gt;&gt; Abde: Const to element 1.

139
00:07:18.493 --> 00:07:19.524
&gt;&gt; Will Sentance: Okay, element 1 is

140
00:07:19.524 --> 00:07:21.275
declared, yep.
&gt;&gt; Abde: I agree,

141
00:07:21.275 --> 00:07:22.331
&gt;&gt; Will Sentance: Good do we know what to

142
00:07:22.331 --> 00:07:24.490
assign to it yet?
&gt;&gt; Abde: No.

143
00:07:24.490 --> 00:07:25.720
&gt;&gt; Will Sentance: What are we going to

144
00:07:25.720 --> 00:07:27.510
have to do to figure out
what to assign to it?

145
00:07:27.510 --> 00:07:29.670
&gt;&gt; Abde: We are going

146
00:07:29.670 --> 00:07:33.045
to we are gonna have to call it.
&gt;&gt; Will Sentance: Call what?

147
00:07:33.045 --> 00:07:34.277
&gt;&gt; Abde: returnNextElement.

148
00:07:34.277 --> 00:07:34.883
&gt;&gt; Will Sentance: Good, yeah,

149
00:07:34.883 --> 00:07:37.770
what symbol is telling me I've
got a call returnNextElement?

150
00:07:37.770 --> 00:07:38.500
&gt;&gt; Abde: Parenthesis.

151
00:07:38.500 --> 00:07:40.542
&gt;&gt; Will Sentance: Excellent,

152
00:07:40.542 --> 00:07:46.310
returnNextElement(), call it.

153
00:07:46.310 --> 00:07:52.074
I get to create my favorite thing on
Earth, so element 1 for now is undefined.

154
00:07:52.074 --> 00:07:54.232
My favorite thing on earth all together.

155
00:07:54.232 --> 00:07:57.064
[CROSSTALK] Execution collection.

156
00:07:57.064 --> 00:08:02.393
Don't ruin the phraseology A new?
&gt;&gt; Execution

157
00:08:02.393 --> 00:08:03.888
context.
&gt;&gt; Will Sentance: Yeah,

158
00:08:03.888 --> 00:08:07.399
I like it to have a slightly tired tone,
like a kind of slightly exhausted,

159
00:08:07.399 --> 00:08:08.811
please stop doing this tone.

160
00:08:08.811 --> 00:08:09.882
So you did great.

161
00:08:09.882 --> 00:08:15.911
All right, so,
&gt;&gt; Will Sentance: There it is.

162
00:08:15.911 --> 00:08:20.958
It has a local memory,
&gt;&gt; Will Sentance: In which we're gonna

163
00:08:20.958 --> 00:08:25.461
store anything that gets declared in here.

164
00:08:25.461 --> 00:08:27.981
Now we have to visually
look back up to inner, but

165
00:08:27.981 --> 00:08:31.192
know that that's actually code
here in returnNextElement.

166
00:08:31.192 --> 00:08:35.959
So maybe even write element
equals=array[i]; i++,

167
00:08:35.959 --> 00:08:40.733
return element,
that's the code of returnNextElement.

168
00:08:40.733 --> 00:08:42.642
But we're gonna visually
just save ourselves and

169
00:08:42.642 --> 00:08:44.150
just look up to inner to know what it is.

170
00:08:44.150 --> 00:08:47.292
So with that in mind Sean,
what is the first line of code or

171
00:08:47.292 --> 00:08:50.902
what's the first thing we're
gonna do inside return x element?

172
00:08:50.902 --> 00:08:54.076
Left hand side first.
&gt;&gt; Sean: Create a const called element.

173
00:08:54.076 --> 00:08:55.492
&gt;&gt; Will Sentance: Excellent there it is.

174
00:08:55.492 --> 00:08:58.371
Const called element.

175
00:08:58.371 --> 00:09:02.215
Element is going to be

176
00:09:02.215 --> 00:09:07.775
the eighth position of array.

177
00:09:07.775 --> 00:09:10.424
What the hell are these?

178
00:09:10.424 --> 00:09:14.874
Well, let's start to figure it out.

179
00:09:14.874 --> 00:09:18.906
Where do we look first for
something that we don't have a,

180
00:09:18.906 --> 00:09:23.791
we are calling return next element so
it goes on, and I call stack of course.

181
00:09:23.791 --> 00:09:28.906
There it is return next element
we are calling it inside global.

182
00:09:28.906 --> 00:09:33.852
So we're inside of here right now.

183
00:09:33.852 --> 00:09:38.053
Where do we look first for
our array and our i?

184
00:09:38.053 --> 00:09:40.963
That local memory, yeah.

185
00:09:40.963 --> 00:09:43.717
Andy.
&gt;&gt; Abde: Right.

186
00:09:43.717 --> 00:09:44.653
&gt;&gt; Will Sentance: Look her over.

187
00:09:44.653 --> 00:09:45.852
Very good.

188
00:09:45.852 --> 00:09:49.825
All right, do we find them, James?
&gt;&gt; James: No.

189
00:09:49.825 --> 00:09:51.367
&gt;&gt; Will Sentance: No.

190
00:09:51.367 --> 00:09:54.469
I'm calling into our
next element in global so

191
00:09:54.469 --> 00:09:58.222
where are my,
all my intuitions implying in a lit next.

192
00:09:58.222 --> 00:10:01.195
Ben?
&gt;&gt; Ben: Add the definition of-

193
00:10:01.195 --> 00:10:03.016
&gt;&gt; Will Sentance: Okay stop.

194
00:10:03.016 --> 00:10:04.152
Stop.

195
00:10:04.152 --> 00:10:08.423
The definition of what?
&gt;&gt; Ben: The turn next to.

196
00:10:08.423 --> 00:10:10.107
&gt;&gt; Will Sentance: Definition yeah okay.

197
00:10:10.107 --> 00:10:11.375
Yeah because you watch.

198
00:10:11.375 --> 00:10:12.632
That's okay.
All right.

199
00:10:12.632 --> 00:10:14.426
Raise your hand if you never
watched Hard Parts before.

200
00:10:14.426 --> 00:10:15.523
Those are the people I'm going to call on.

201
00:10:15.523 --> 00:10:17.343
You've never watched Hard Parts before?

202
00:10:17.343 --> 00:10:19.743
Okay, Rick.

203
00:10:19.743 --> 00:10:23.264
Where would everything suggest,
I'm calling return its elements out.

204
00:10:23.264 --> 00:10:28.034
Where would everything suggest
the next memory is, I look at?

205
00:10:28.034 --> 00:10:29.385
I don't find it in this local one.

206
00:10:29.385 --> 00:10:30.397
Where do I look next?
&gt;&gt; Rick: In global.

207
00:10:30.397 --> 00:10:32.345
&gt;&gt; Will Sentance: In global, exactly.

208
00:10:32.345 --> 00:10:35.632
Into global I go.

209
00:10:35.632 --> 00:10:39.882
Looking desperately for my array and my i.

210
00:10:39.882 --> 00:10:42.791
Do I find them, Rick?

211
00:10:42.791 --> 00:10:47.421
No, so I get an error right, Rick?
&gt;&gt; [LAUGH]

212
00:10:47.421 --> 00:10:48.726
&gt;&gt; Will Sentance: Is that my answer's

213
00:10:48.726 --> 00:10:49.422
no voice?

214
00:10:49.422 --> 00:10:53.119
Okay, I need to get better at that voice,
all right.

215
00:10:53.119 --> 00:10:58.173
No, that's not much better either.

216
00:10:58.173 --> 00:10:59.451
I get an error.
Okay I get an error.

217
00:10:59.451 --> 00:11:01.206
Now see that was more convincing, right?
&gt;&gt; [LAUGH]

218
00:11:01.206 --> 00:11:05.640
&gt;&gt; Will Sentance: I get an error.

219
00:11:05.640 --> 00:11:11.393
Yeah, cuz I look for
these, [SOUND] not there.

220
00:11:11.393 --> 00:11:18.033
Hm, hm, hm, hm.

221
00:11:18.033 --> 00:11:21.351
There's another hard part where we
focus mainly on this concept, and

222
00:11:21.351 --> 00:11:23.960
I like to drag it out for a long time.

223
00:11:23.960 --> 00:11:28.004
Here we may not have time, but
maybe a little bit of time.

224
00:11:28.004 --> 00:11:29.792
No, I can drag it out for

225
00:11:29.792 --> 00:11:34.332
a little bit longer.
&gt;&gt; Will Sentance: Do you mind Brian

226
00:11:34.332 --> 00:11:35.631
passing me my coffee?

227
00:11:35.631 --> 00:11:37.392
My mocha, thank you.
&gt;&gt; [LAUGH]

228
00:11:37.392 --> 00:11:38.128
&gt;&gt; Will Sentance: I just can't walk

229
00:11:38.128 --> 00:11:39.952
out of this area otherwise
my head gets cut.

230
00:11:39.952 --> 00:11:43.474
My head's being cut off right now.
&gt;&gt; [LAUGH]

231
00:11:43.474 --> 00:11:45.516
&gt;&gt; Will Sentance: So I just want to sip

232
00:11:45.516 --> 00:11:49.983
this for a bit while I,
so we got an error on

233
00:11:49.983 --> 00:11:53.977
the horizon here, right?
&gt;&gt; James: How long do you want us to

234
00:11:53.977 --> 00:11:58.689
wait before we give you the answer?
&gt;&gt; Will Sentance: James has the sound of

235
00:11:58.689 --> 00:12:02.401
a confident person about him.

236
00:12:02.401 --> 00:12:05.083
Where is that array in i?

237
00:12:05.083 --> 00:12:06.141
Cuz I am certain,

238
00:12:06.141 --> 00:12:10.952
do not at any point think I can go back
into my createFunction execution context.

239
00:12:10.952 --> 00:12:13.770
This has long gone.

240
00:12:13.770 --> 00:12:16.291
I cannot suddenly,
I'll just go up and create function.

241
00:12:16.291 --> 00:12:19.467
That is long gone.

242
00:12:19.467 --> 00:12:20.250
So where's my?

243
00:12:20.250 --> 00:12:23.013
All right,
I'm not gonna drag it out any more.

244
00:12:23.013 --> 00:12:23.837
It turns out,

245
00:12:23.837 --> 00:12:28.325
in case James shouts out the answer before
I get to give the punchline myself.

246
00:12:28.325 --> 00:12:32.780
It turns out that,
&gt;&gt; Will Sentance: As soon as I

247
00:12:32.780 --> 00:12:36.049
define my inner function,
inside a createFunction,

248
00:12:36.049 --> 00:12:39.684
while I was still back in createFunction,
before I exited.

249
00:12:39.684 --> 00:12:45.362
As soon as I defined it, I got a bond
to all the surrounding live memory,

250
00:12:45.362 --> 00:12:49.055
the surrounding data,
you can call it state,

251
00:12:49.055 --> 00:12:52.482
you can call it the variable environment.

252
00:12:52.482 --> 00:12:56.817
The live memory,
the data around the function definition,

253
00:12:56.817 --> 00:13:02.172
I got a bond to it, a little link,
a reference to all the surrounding data.

254
00:13:02.172 --> 00:13:04.685
We'll talk about what
property in a moment.

255
00:13:04.685 --> 00:13:06.060
I got a bond data immediately.

256
00:13:06.060 --> 00:13:09.791
Meaning when I return that function out,

257
00:13:09.791 --> 00:13:13.852
I brought with it on
the back of the function.

258
00:13:13.852 --> 00:13:15.688
As the function got returned out,

259
00:13:15.688 --> 00:13:18.734
out on the back of it came all
that surrounding live data.

260
00:13:18.734 --> 00:13:20.693
When I returned that function out,

261
00:13:20.693 --> 00:13:25.281
returned out the function that used to
the label inner, into return next element.

262
00:13:25.281 --> 00:13:26.665
On the back of the function,

263
00:13:26.665 --> 00:13:29.800
I brought all the surrounding
data from when it was borne.

264
00:13:29.800 --> 00:13:34.400
And it got stored in this new label
we are given a new label globally

265
00:13:34.400 --> 00:13:36.083
written next element.

266
00:13:36.083 --> 00:13:40.644
But my surrounding data
is attached to that very

267
00:13:40.644 --> 00:13:45.774
definition with array
literally in the memory as 4,

268
00:13:45.774 --> 00:13:51.143
5, 6, not it will be but
literally stored in memory.

269
00:13:51.143 --> 00:13:54.482
i as literally stored in
memory as the number zero.

270
00:13:54.482 --> 00:13:57.812
And it's attached to
the back of my function.

271
00:13:57.812 --> 00:14:00.552
There is, on the definition itself.

272
00:14:00.552 --> 00:14:03.493
And so Ben was hinting this.

273
00:14:03.493 --> 00:14:08.923
When I don't find array in i in my local
memory, I do not go to global immediately.

274
00:14:08.923 --> 00:14:11.963
Instead, I go look at my definition and
my function.

275
00:14:11.963 --> 00:14:17.894
I see, is there a backpack of data that
was brought out with the function?

276
00:14:17.894 --> 00:14:19.823
And look, there it is.

277
00:14:19.823 --> 00:14:24.601
And then, what do I grab?
&gt;&gt; Ben: You grab

278
00:14:24.601 --> 00:14:27.950
a four.
&gt;&gt; Will Sentance: Correct, but

279
00:14:27.950 --> 00:14:30.885
specifically my array becomes,

280
00:14:30.885 --> 00:14:35.061
my array becomes,
&gt;&gt; Will Sentance: And my i becomes?

281
00:14:35.061 --> 00:14:35.804
&gt;&gt; Ben: 0.

282
00:14:35.804 --> 00:14:37.477
&gt;&gt; Will Sentance: 0.

283
00:14:37.477 --> 00:14:39.700
I'm not getting it from my local memory.

284
00:14:39.700 --> 00:14:43.088
I'm looking on the function definition
that's being called itself and

285
00:14:43.088 --> 00:14:44.318
they're attached to it.

286
00:14:44.318 --> 00:14:48.245
Is my persistent we'll give it
an apostrophe in a moment, but

287
00:14:48.245 --> 00:14:53.466
my backpack of data from when the function
was returned out from where it was born.

288
00:14:53.466 --> 00:14:57.986
As soon as it was born it got a link
to all the surrounding data from

289
00:14:57.986 --> 00:15:00.516
the memory in which it was defined.

290
00:15:00.516 --> 00:15:03.325
When I returned the function
out that bond didn't break.

291
00:15:03.325 --> 00:15:06.732
That bond pulled out on the back of
the function all that surrounding data.

292
00:15:06.732 --> 00:15:13.394
And when I call that function by its new
global label here, and doesn't find some,

293
00:15:13.394 --> 00:15:19.792
the first label doesn't find data of
in your local memory, it doesn't panic.

294
00:15:19.792 --> 00:15:22.837
It looks first to
the function's definition and

295
00:15:22.837 --> 00:15:27.645
finds attached to the function,
&gt;&gt; Will Sentance: Our persistent live

296
00:15:27.645 --> 00:15:30.430
data from where the function was born.

297
00:15:30.430 --> 00:15:35.482
All right, which means exactly as Ben
said what am I storing in element?

298
00:15:35.482 --> 00:15:39.352
I'm gonna take the zero position
of array,4, 5, 6, which is, Ben?

299
00:15:39.352 --> 00:15:39.913
&gt;&gt; Ben: Four.

300
00:15:39.913 --> 00:15:40.773
&gt;&gt; Will Sentance: Four and what am

301
00:15:40.773 --> 00:15:44.221
I gonna do as my next line Ben,
inside my body of the function?

302
00:15:44.221 --> 00:15:46.172
&gt;&gt; Ben: You're going to increment.

303
00:15:46.172 --> 00:15:46.685
&gt;&gt; Will Sentance: Right,

304
00:15:46.685 --> 00:15:48.761
do I find i in local memory?
&gt;&gt; Ben: No.

305
00:15:48.761 --> 00:15:49.771
&gt;&gt; Will Sentance: Where do I go?

306
00:15:49.771 --> 00:15:51.123
&gt;&gt; Ben: Go to the [INAUDIBLE]

307
00:15:51.123 --> 00:15:51.799
&gt;&gt; Will Sentance: Use my name,

308
00:15:51.799 --> 00:15:55.350
yes good, not my name, sorry.
&gt;&gt; [LAUGH]

309
00:15:55.350 --> 00:15:56.202
&gt;&gt; Will Sentance: To this one.

310
00:15:56.202 --> 00:16:01.005
And i goes to One, and
we then hit return element,

311
00:16:01.005 --> 00:16:03.553
which is really return what?
&gt;&gt; Ben: 4.

312
00:16:03.553 --> 00:16:06.959
&gt;&gt; Will Sentance: 4, we return out 4 into

313
00:16:06.959 --> 00:16:11.193
what global constant?
&gt;&gt; Ben: Element1.

314
00:16:11.193 --> 00:16:13.283
&gt;&gt; Will Sentance: Element1, and

315
00:16:13.283 --> 00:16:15.078
look at that.

316
00:16:15.078 --> 00:16:20.073
Look at that, Element 1 is not 4, is 4.

317
00:16:20.073 --> 00:16:24.710
Exactly what we wanted from
calling return next element.

318
00:16:24.710 --> 00:16:26.940
Let's call one more time
to see what happens and

319
00:16:26.940 --> 00:16:30.720
we'll talk about what
concept this backpack is.

320
00:16:30.720 --> 00:16:32.350
You may already know its posture name.

321
00:16:34.460 --> 00:16:36.830
Or it's more unintuitive name.

322
00:16:36.830 --> 00:16:40.421
Or its name that I'm hoping is going to
be replaced backpack in the spec very

323
00:16:40.421 --> 00:16:44.070
soon.
&gt;&gt; Will Sentance: I believe it will be.

324
00:16:44.070 --> 00:16:47.630
All right, return this element
popped off the cool stack.

325
00:16:47.630 --> 00:16:51.254
All of its [INAUDIBLE] context cleared.

326
00:16:51.254 --> 00:16:54.810
So we better not be having
this information in here,

327
00:16:54.810 --> 00:16:59.620
because it's all deleted, and
we hit our next global line of code,

328
00:16:59.620 --> 00:17:03.758
which is what, Abdi?
&gt;&gt; Abde: Const element2,

329
00:17:03.758 --> 00:17:07.223
declaring that in memory.
&gt;&gt; Will Sentance: Yeah, exactly, so

330
00:17:07.223 --> 00:17:07.860
declare.

331
00:17:07.860 --> 00:17:10.673
Let's just try being super precise
in identical communication, so

332
00:17:10.673 --> 00:17:12.524
Abdi do you want to have
another shot on that?

333
00:17:12.524 --> 00:17:15.342
Declare the?
&gt;&gt; Abde: Function.

334
00:17:15.342 --> 00:17:16.642
&gt;&gt; Will Sentance: Declare the constant-

335
00:17:16.642 --> 00:17:18.527
&gt;&gt; Abde: Well, declare the constant

336
00:17:18.527 --> 00:17:21.202
element2.
&gt;&gt; Will Sentance: Excellent, in global

337
00:17:21.202 --> 00:17:27.870
memory, and then we know it's going to be
the return value calling what function?

338
00:17:27.870 --> 00:17:29.294
Abdi?
&gt;&gt; Abde: Return x-element.

339
00:17:29.294 --> 00:17:31.494
&gt;&gt; Will Sentance: Good, so for now quant2,

340
00:17:31.494 --> 00:17:35.690
sorry element2 or default2, everyone?
&gt;&gt; Undefined.

341
00:17:35.690 --> 00:17:36.519
&gt;&gt; Will Sentance: Excellent, so

342
00:17:36.519 --> 00:17:39.930
let's create that execution
context people, almost there.

343
00:17:39.930 --> 00:17:41.670
I wanna have a sit down.

344
00:17:41.670 --> 00:17:43.350
It's great execution context.

345
00:17:43.350 --> 00:17:44.110
In we go.

346
00:17:45.810 --> 00:17:50.537
In our local memory what's
the first thing we declare, Victor?

347
00:17:50.537 --> 00:17:51.595
&gt;&gt; Victor: Element.

348
00:17:51.595 --> 00:17:54.808
&gt;&gt; Will Sentance: Element, which is gonna

349
00:17:54.808 --> 00:18:00.320
be set to a array These
mysterious array i.

350
00:18:00.320 --> 00:18:03.670
What are these mysterious things,
you might be asking?

351
00:18:03.670 --> 00:18:08.121
Well, where do I look for,
where do I look for

352
00:18:08.121 --> 00:18:10.769
array an i first Victor?
&gt;&gt; Victor: In

353
00:18:10.769 --> 00:18:13.679
the local execution context.
&gt;&gt; Will Sentance: Always in the local

354
00:18:13.679 --> 00:18:14.513
execution context first.

355
00:18:14.513 --> 00:18:16.400
Nothing there though right?

356
00:18:16.400 --> 00:18:17.730
So, do I panic?

357
00:18:17.730 --> 00:18:19.010
No, I mean I wouldn't panic anyway.

358
00:18:19.010 --> 00:18:22.604
Where might I intuitively look next?
&gt;&gt; Victor: You would intuitively go to

359
00:18:22.604 --> 00:18:23.828
global blank.
&gt;&gt; Will Sentance: Right.

360
00:18:23.828 --> 00:18:24.444
&gt;&gt; Victor: But

361
00:18:24.444 --> 00:18:29.000
there is an enclosed.
&gt;&gt; Will Sentance: I

362
00:18:29.000 --> 00:18:31.040
like that sort of term.

363
00:18:31.040 --> 00:18:33.440
There's an enclosed backpack.

364
00:18:33.440 --> 00:18:34.210
Good, got it.

365
00:18:35.230 --> 00:18:40.705
Where I find arrays 4, 5, 6 and i is?

366
00:18:40.705 --> 00:18:41.760
&gt;&gt; Victor: 1.
&gt;&gt; Will Sentance: 1!

367
00:18:41.760 --> 00:18:45.150
Our live data here persists attached
to the function definition.

368
00:18:45.150 --> 00:18:48.560
It's persisting attached to our
function definition in memory.

369
00:18:48.560 --> 00:18:53.587
So i is 1, and so array is 4 5 6 and

370
00:18:53.587 --> 00:18:58.451
i is 1 because returnNextElement

371
00:18:58.451 --> 00:19:02.560
is stored in global memory.

372
00:19:02.560 --> 00:19:05.540
So it's not like suddenly deleting all
the data attached to it each shot.

373
00:19:05.540 --> 00:19:08.330
It doesn't care about the running of this
function except what you have stored here.

374
00:19:08.330 --> 00:19:12.110
This is like persistent data just like
returnNextElement function is persistent

375
00:19:12.110 --> 00:19:14.120
function as long as
the application is running.

376
00:19:14.120 --> 00:19:15.560
Not suddenly be deleted.

377
00:19:15.560 --> 00:19:18.360
So two is its attached backpack of data,
persistent.

378
00:19:18.360 --> 00:19:20.690
That just means sticks around,
doesn't change.

379
00:19:20.690 --> 00:19:21.890
Or it changes but it doesn't get removed.

380
00:19:22.920 --> 00:19:26.148
Okay, so position one,
Victor of 4, 5, 6 is what?

381
00:19:26.148 --> 00:19:27.367
&gt;&gt; Victor: 5.

382
00:19:27.367 --> 00:19:29.129
&gt;&gt; Will Sentance: 5, good job.

383
00:19:29.129 --> 00:19:33.802
5, and then we hit the next
line inside the body of vector,

384
00:19:33.802 --> 00:19:35.913
which is?
&gt;&gt; Victor: i++.

385
00:19:35.913 --> 00:19:37.271
&gt;&gt; Will Sentance: We don't find i here,

386
00:19:37.271 --> 00:19:39.419
we find it in the backpack and do.
&gt;&gt; Victor: 2.

387
00:19:39.419 --> 00:19:40.057
&gt;&gt; Will Sentance: 2, and

388
00:19:40.057 --> 00:19:41.611
then we hit return.

389
00:19:41.611 --> 00:19:45.790
Return what, Victor?
&gt;&gt; Victor: Return 5.

390
00:19:45.790 --> 00:19:46.962
&gt;&gt; Will Sentance: Return 5,

391
00:19:46.962 --> 00:19:50.720
the value of element into element2.

392
00:19:52.240 --> 00:19:53.610
Excellent, there it is.

393
00:19:53.610 --> 00:19:54.180
And look at that.

394
00:19:54.180 --> 00:19:56.590
I think that's pretty beautiful.

395
00:19:56.590 --> 00:20:03.058
We have a function now that when born,
got attached to its very definition.

396
00:20:03.058 --> 00:20:08.470
The underlying state; the underlying data
from which it's going to extract and

397
00:20:08.470 --> 00:20:11.630
return to us on its call,

398
00:20:11.630 --> 00:20:16.050
one by one, the individual elements
from that underlying collection of data.

399
00:20:16.050 --> 00:20:20.720
And its keeping track of which ones up
next using this little tracking value

400
00:20:20.720 --> 00:20:25.310
also all bundled up on this
return next element function.

401
00:20:25.310 --> 00:20:26.580
I think it's very, very beautiful.

402
00:20:26.580 --> 00:20:27.483
We'll talk about this in a second.

403
00:20:27.483 --> 00:20:30.800
But I think it's very beautiful that you
can have a function return next element

404
00:20:30.800 --> 00:20:32.750
that has everything you need.

405
00:20:32.750 --> 00:20:36.670
It has the ability when called
to return our next element.

406
00:20:36.670 --> 00:20:41.550
It has bundled on it, the underlying
data that it knows to extract from.

407
00:20:41.550 --> 00:20:47.780
And it has bundled on it, the information
about what next element to return out.

408
00:20:47.780 --> 00:20:50.270
All bundled up in a single function.

409
00:20:50.270 --> 00:20:52.350
That's a very, very beautiful design.

410
00:20:52.350 --> 00:20:57.930
Alright, let's have thumbs, and
one of the thumbs on media might be,

411
00:20:57.930 --> 00:21:00.822
what do we call the backpack of data?

412
00:21:00.822 --> 00:21:01.392
Everybody's thumbs out.

413
00:21:01.392 --> 00:21:04.420
You lost me, I'm clear,
I have clarifications.

414
00:21:04.420 --> 00:21:06.310
Everyone's thumbs out and proud.

415
00:21:06.310 --> 00:21:09.399
Everyone knows what a backpack's called.

416
00:21:09.399 --> 00:21:10.344
No one has medium thumbs?

417
00:21:10.344 --> 00:21:14.050
All right.
&gt;&gt; Alec: It's backpack [INAUDIBLE]

418
00:21:14.050 --> 00:21:14.930
&gt;&gt; Will Sentance: Good, good job, Alec.

