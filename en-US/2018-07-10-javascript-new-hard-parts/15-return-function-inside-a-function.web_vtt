WEBVTT

1
00:00:03.549 --> 00:00:07.542
&gt;&gt; Will Sentance: Now we
move on to iterators, okay.

2
00:00:07.542 --> 00:00:08.983
Iterators.

3
00:00:08.983 --> 00:00:10.868
Iterators.

4
00:00:13.178 --> 00:00:17.779
&gt;&gt; Will Sentance: I say the very start
that when we run or we write and run code,

5
00:00:17.779 --> 00:00:22.297
what we're typically doing is taking data,
storing it.

6
00:00:22.297 --> 00:00:27.490
And then functionality that we then apply
to that data, even as simple as I have

7
00:00:27.490 --> 00:00:32.543
a score for a player, and I increase
that score, functionality onto data.

8
00:00:32.543 --> 00:00:36.264
We call our live data that's stored
in our application our state.

9
00:00:36.264 --> 00:00:37.970
That just means the labels and

10
00:00:37.970 --> 00:00:41.870
the data, the values currently in
our application at that moment.

11
00:00:41.870 --> 00:00:46.708
But that kind of masks a small part
that is actually pretty significant

12
00:00:46.708 --> 00:00:49.417
a lot of the time, which I have my data.

13
00:00:49.417 --> 00:00:54.113
I have my functionality, but often my
data is a collection of data maybe

14
00:00:54.113 --> 00:00:56.615
an array a list of data or
a set of data or

15
00:00:56.615 --> 00:01:02.090
a map of it or of an object containing
a bunch of properties with data.

16
00:01:02.090 --> 00:01:03.243
It's rarely a single element.

17
00:01:03.243 --> 00:01:07.598
So actually,
the process of accessing each of our

18
00:01:07.598 --> 00:01:12.970
elements from a collection
of data is in itself a task.

19
00:01:12.970 --> 00:01:15.770
The data's just not there which
we can apply functionality to.

20
00:01:15.770 --> 00:01:18.350
We have to go and access that data.

21
00:01:18.350 --> 00:01:21.224
And in erase, we do it using indexes
to grab the individual element.

22
00:01:21.224 --> 00:01:24.687
We have a static collection of data and
go and grab an element.

23
00:01:24.687 --> 00:01:32.643
And actually, that's not a small
process in its own right.

24
00:01:32.643 --> 00:01:37.397
But we'll play that out here with a for
loop, and we'll discover that

25
00:01:37.397 --> 00:01:42.152
actually it's not the most,
I think beautifully designed process,

26
00:01:42.152 --> 00:01:45.690
is not clear that that's the best and
necessary.

27
00:01:45.690 --> 00:01:49.450
Most of the time when I'm accessing my
data, I know I just want my element and

28
00:01:49.450 --> 00:01:52.140
I want the next element and
I want the next element.

29
00:01:52.140 --> 00:01:56.970
I don't really care about how I
go about getting those elements.

30
00:01:56.970 --> 00:02:02.680
So wouldn't it be amazing if we could
rethink collections of data as instead

31
00:02:02.680 --> 00:02:07.880
a sort of stream of elements coming
towards me that I could call a function,

32
00:02:07.880 --> 00:02:12.270
I could run a function that's just gonna
instantly return me the next element

33
00:02:12.270 --> 00:02:15.840
from my stream, my flow of data.

34
00:02:15.840 --> 00:02:21.270
So I would run a function, it would
return out the next element for my flow.

35
00:02:21.270 --> 00:02:25.560
Rethink my data, not as a static
collection I've got to go and

36
00:02:25.560 --> 00:02:29.476
manually get each element in
order to run functionality on it.

37
00:02:29.476 --> 00:02:33.620
But instead flip it, my data's there, and
I'm actually gonna have access to it by

38
00:02:33.620 --> 00:02:37.830
running a function which turns on
the flow of the next element of my data.

39
00:02:39.050 --> 00:02:42.730
And that is a paradigm
shift in how we think about

40
00:02:42.730 --> 00:02:44.730
applying functionality to our data.

41
00:02:44.730 --> 00:02:48.340
No longer is there the intermediate
step of getting the elements,

42
00:02:48.340 --> 00:02:51.720
manually going into the data collection
and grabbing the next element.

43
00:02:51.720 --> 00:02:55.980
That's not a small thing, and it's not
a necessary step when most of the time,

44
00:02:55.980 --> 00:02:58.690
all I want is my next element, in order.

45
00:02:59.950 --> 00:03:05.880
So why not instead rethink my process
as being applying functionality to data

46
00:03:05.880 --> 00:03:11.480
as a data being given to me, element by
element, from a sort of flow of that data.

47
00:03:12.550 --> 00:03:16.421
Before we see that beautiful new way of
thinking about our collections of data,

48
00:03:16.421 --> 00:03:19.135
and getting them so
we can apply functionality to them,

49
00:03:19.135 --> 00:03:21.528
or getting them element by element,
one by one.

50
00:03:21.528 --> 00:03:26.127
Before we do that, we're going to see the
old version, but we have a list of data,

51
00:03:26.127 --> 00:03:29.611
and we're gonna manually go and
grab each element.

52
00:03:29.611 --> 00:03:34.301
Beautiful new way of thinking about this,
using each element one by one, but

53
00:03:34.301 --> 00:03:36.391
let's first see, and by the way,

54
00:03:36.391 --> 00:03:40.650
it's gonna show us just how kind of
imperative procedural bit by bit,

55
00:03:40.650 --> 00:03:45.231
kind of exactly how we're gonna do this,
this old-fashioned method is.

56
00:03:45.231 --> 00:03:48.741
It gives us really manual,
fine-grained control, but

57
00:03:48.741 --> 00:03:53.418
at the expense of a clean, readable code,
and also at expense of, I think,

58
00:03:53.418 --> 00:03:57.950
a cleaner way for ourselves of thinking
about data as these flows of data,

59
00:03:57.950 --> 00:04:02.550
rather than static collections that
we go and grab element by element.

60
00:04:02.550 --> 00:04:05.710
So let's first just at least
see this traditional way,

61
00:04:05.710 --> 00:04:09.320
and I think it's gonna show us,
we want a better way.

62
00:04:09.320 --> 00:04:11.720
But here's our traditional way.

63
00:04:11.720 --> 00:04:15.190
And I'm gonna try and diagram this, but

64
00:04:15.190 --> 00:04:18.320
part of the point to say
is that diagramming for

65
00:04:18.320 --> 00:04:25.100
loops is an old,
old thing to do, honestly.

66
00:04:25.100 --> 00:04:26.480
When we think about most of our code,

67
00:04:26.480 --> 00:04:29.340
we run execution context
around functionality.

68
00:04:29.340 --> 00:04:33.580
But our for loops, and
these funny little things that

69
00:04:33.580 --> 00:04:38.250
happen kind of an isolation about
regular way of thinking about code.

70
00:04:38.250 --> 00:04:39.247
There we go, all right.

71
00:04:39.247 --> 00:04:40.392
Line one.

72
00:04:40.392 --> 00:04:44.206
James, what are we doing?

73
00:04:44.206 --> 00:04:48.202
&gt;&gt; James: We're declaring
a constant called numbers.

74
00:04:48.202 --> 00:04:49.247
&gt;&gt; Will Sentance: Numbers.

75
00:04:49.247 --> 00:04:54.508
&gt;&gt; James: And assigning it a new
array containing the values 4, 5, 6.

76
00:04:54.508 --> 00:04:55.714
&gt;&gt; Will Sentance: Excellent,
James, spot on.

77
00:04:55.714 --> 00:05:01.130
Now here comes my favorite
bit diagramming for loops.

78
00:05:01.130 --> 00:05:03.276
All right, here we go.

79
00:05:03.276 --> 00:05:07.871
Check this.

80
00:05:11.029 --> 00:05:14.120
&gt;&gt; Will Sentance: Do this.

81
00:05:14.120 --> 00:05:16.870
Hey, you can already see
why these are problematic.

82
00:05:16.870 --> 00:05:17.730
But check this,

83
00:05:17.730 --> 00:05:22.070
who wants to check we're gonna do is
i less than numbers.length, okay.

84
00:05:22.070 --> 00:05:25.988
Is i, which is initiated to zero,

85
00:05:25.988 --> 00:05:31.026
less than numbers.length which is three.

86
00:05:31.026 --> 00:05:35.420
Okay, which is three, this is less, it is.

87
00:05:35.420 --> 00:05:38.495
And therefore, do this which is

88
00:05:38.495 --> 00:05:49.340
console.log(numbers[i]).

89
00:05:49.340 --> 00:05:52.339
And then.

90
00:05:52.339 --> 00:05:56.600
That's our for loop, try to be written up

91
00:05:56.600 --> 00:06:01.170
in a slightly more logical sense than
the kind of weird check this, do the code,

92
00:06:01.170 --> 00:06:05.960
come back, do this, check this, a weird
circular flow of an actual for loop.

93
00:06:05.960 --> 00:06:09.550
Okay, so i is less than 3,
so we are gonna do this.

94
00:06:09.550 --> 00:06:12.200
What is numbers at this point, Michelle?

95
00:06:13.380 --> 00:06:16.040
&gt;&gt; Michelle: So
numbers is the array 4, 5, 6.

96
00:06:16.040 --> 00:06:18.080
&gt;&gt; Will Sentance: Yeah, and
what is i at this point?

97
00:06:18.080 --> 00:06:19.510
&gt;&gt; Michelle: i is 0.

98
00:06:19.510 --> 00:06:22.750
&gt;&gt; Will Sentance: 0,
already I'm liking to hear the hesitation.

99
00:06:22.750 --> 00:06:25.210
That's enough to tell us
there might be a nicer way.

100
00:06:25.210 --> 00:06:30.320
So position zero of numbers is, Michelle?

101
00:06:30.320 --> 00:06:30.842
&gt;&gt; Michelle: 4, sorry.

102
00:06:30.842 --> 00:06:31.476
&gt;&gt; Will Sentance: 4, excellent.

103
00:06:31.476 --> 00:06:33.170
&gt;&gt; Michelle: I couldn't
tell if it was 4 or not.

104
00:06:33.170 --> 00:06:34.218
&gt;&gt; Will Sentance: Next thing to do is i++.

105
00:06:34.218 --> 00:06:38.370
We're gonna increment i to 1,
is 1 less than 3?

106
00:06:38.370 --> 00:06:39.880
Yes, it is.

107
00:06:39.880 --> 00:06:41.600
So we come back down here.

108
00:06:41.600 --> 00:06:45.646
Now we're getting position
one of numbers which is?

109
00:06:45.646 --> 00:06:47.257
&gt;&gt; Michelle: 5.

110
00:06:47.257 --> 00:06:47.901
&gt;&gt; Will Sentance: 5.

111
00:06:47.901 --> 00:06:52.870
Good 5 plus 5, increment it to 2.

112
00:06:52.870 --> 00:06:55.120
2 less than 3, yes we come back down here.

113
00:06:55.120 --> 00:06:57.538
Now, i is what, Victor?

114
00:06:57.538 --> 00:06:58.845
&gt;&gt; James: It will be 6.

115
00:06:58.845 --> 00:07:01.957
&gt;&gt; Will Sentance: Perfect, thank you-
&gt;&gt; James: [LAUGH]

116
00:07:01.957 --> 00:07:04.523
&gt;&gt; Will Sentance: Thank you, Victor, i is?

117
00:07:04.523 --> 00:07:05.395
&gt;&gt; James: 2.

118
00:07:05.395 --> 00:07:07.995
&gt;&gt; Will Sentance: 2, so
numbers position 2 is?

119
00:07:07.995 --> 00:07:10.970
&gt;&gt; James: 6
&gt;&gt; Will Sentance: 6.

120
00:07:10.970 --> 00:07:14.130
So we come to a log 6, i++.

121
00:07:14.130 --> 00:07:17.090
3, is 3 less than 3?

122
00:07:17.090 --> 00:07:18.290
No it's not.

123
00:07:18.290 --> 00:07:20.690
So we come out of our for loop.

124
00:07:20.690 --> 00:07:22.820
Okay, this is the best you can
dial on a for loop I think.

125
00:07:22.820 --> 00:07:27.160
Honestly, just saying the conditions and
still, we had a,

126
00:07:27.160 --> 00:07:28.510
thank goodness we didn't
make that mistake.

127
00:07:28.510 --> 00:07:29.252
Thank you, ma'am.

128
00:07:29.252 --> 00:07:30.921
Because that, we're so

129
00:07:30.921 --> 00:07:35.696
busy figuring out how to access that
we can't focus on what we wanna do.

130
00:07:35.696 --> 00:07:40.473
And by the way, we're gonna discover,
if we rethink our collections of

131
00:07:40.473 --> 00:07:44.074
data as flows of data where
we grab element by element,

132
00:07:44.074 --> 00:07:48.080
we can dynamically control
those flows of data.

133
00:07:48.080 --> 00:07:51.880
We can even set those flows of, we can set
what our next element in our flow of data

134
00:07:51.880 --> 00:07:55.730
is going to look like based on things that
have happened in previous elements or

135
00:07:55.730 --> 00:07:57.660
if they've been returned out.

136
00:07:57.660 --> 00:08:00.970
Rethinking our collections
of data as instead flows

137
00:08:00.970 --> 00:08:03.370
of elements we want to grab one by one.

138
00:08:03.370 --> 00:08:06.013
Is gonna give us control over
what those next elements will be.

139
00:08:06.013 --> 00:08:08.618
We'll see that a little bit later on,
really, really cool.

140
00:08:08.618 --> 00:08:13.089
But for now, program store data and
apply functionality to it.

141
00:08:13.089 --> 00:08:16.648
The two parts to apply
functionality to collect the data.

142
00:08:16.648 --> 00:08:19.742
One, the process of
accessing each element, and

143
00:08:19.742 --> 00:08:22.181
then two, we wanna do to each element.

144
00:08:22.181 --> 00:08:25.972
Iterators, this new way of
thinking about accessing data,

145
00:08:25.972 --> 00:08:29.760
from collections of data,
that means like lists or arrays or

146
00:08:29.760 --> 00:08:32.902
whatever, automate
the accessing the element.

147
00:08:32.902 --> 00:08:35.488
So we can focus on what we
do to each element, and

148
00:08:35.488 --> 00:08:37.698
make it available in a super smooth way.

149
00:08:37.698 --> 00:08:39.608
They make it available, so they say,

150
00:08:39.608 --> 00:08:43.625
we've got a function that when called
with parens returns out my next element.

151
00:08:43.625 --> 00:08:46.454
Run it again, gives me the next element.

152
00:08:46.454 --> 00:08:48.333
Run it again, gives me the next.

153
00:08:48.333 --> 00:08:50.267
In other words, the function attached and

154
00:08:50.267 --> 00:08:54.037
bundled on it somehow in the background
must be our underlying collection of data.

155
00:08:54.037 --> 00:08:59.066
Plus also you must somehow hold onto
the information of which element

156
00:08:59.066 --> 00:09:04.439
am I'm currently at, so we don't give
me out the same element each time,

157
00:09:04.439 --> 00:09:07.486
but give me out instead the next element.

158
00:09:07.486 --> 00:09:12.132
But we know that when a function runs,
it never remembers its previous running.

159
00:09:12.132 --> 00:09:15.255
Its local memory gets reset every time,
right?

160
00:09:15.255 --> 00:09:16.817
So it empties, you fill it.

161
00:09:16.817 --> 00:09:21.618
So how in the hell am I going to have my
function both be able to be run, give me

162
00:09:21.618 --> 00:09:27.140
the next element, but also therefore have
underlying in it, somehow bundled on it?

163
00:09:27.140 --> 00:09:31.018
My underlying array of data that it's
grabbing the next element from one by one.

164
00:09:31.018 --> 00:09:35.861
And bundled on it the sort of tracking
variable that's tracking which

165
00:09:35.861 --> 00:09:40.549
element have I already given out so
I know which one to give out next.

166
00:09:40.549 --> 00:09:42.138
How did I bundle all of that up?

167
00:09:42.138 --> 00:09:46.338
Imagine if we could create a function
that stored the numbers, and

168
00:09:46.338 --> 00:09:51.372
each time we ran the function it would
return out our next element from numbers.

169
00:09:51.372 --> 00:09:54.552
Note you'd have to remember which
element was next up somehow.

170
00:09:54.552 --> 00:09:58.156
That means between the function's
invocations, runnings,

171
00:09:58.156 --> 00:10:02.032
we still have to remember what was
the last time that was passed out?

172
00:10:02.032 --> 00:10:03.061
Hm.

173
00:10:03.061 --> 00:10:07.540
But if you can do it this would let us
think about array a list four, five,

174
00:10:07.540 --> 00:10:09.523
six as a stream, a flow of data,

175
00:10:09.523 --> 00:10:14.239
with our function returning out the next
element and then the next element.

176
00:10:14.239 --> 00:10:17.501
Did everyone get this bit yet
and the next element?

177
00:10:17.501 --> 00:10:18.321
Did I say this enough times?

178
00:10:18.321 --> 00:10:22.791
This makes our code more readable and
we'll see in a minute more functional.

179
00:10:22.791 --> 00:10:28.854
But it all starts with us returning
a function from another function.

180
00:10:28.854 --> 00:10:33.075
Because all the most beautiful
elegant things in JavaScript begin

181
00:10:33.075 --> 00:10:36.478
with us returning a function
from another function.

182
00:10:36.478 --> 00:10:41.385
Cuz that's gonna give our function
that's returned out super powers.

183
00:10:41.385 --> 00:10:46.597
My favorite feature in JavaScript
is going to be revealed right now.

184
00:10:46.597 --> 00:10:48.438
But also I'm gonna stress to you,

185
00:10:48.438 --> 00:10:51.243
do not get complacent about
what this code is doing.

186
00:10:51.243 --> 00:10:55.962
This code throws the most seasoned
engineers unless we're super precise

187
00:10:55.962 --> 00:10:56.883
line by line.

188
00:10:56.883 --> 00:11:03.136
And remember that we never return
to previous lines of code.

189
00:11:03.136 --> 00:11:06.045
We always finish a line of code,
we're done with it,

190
00:11:06.045 --> 00:11:10.067
we store whatever was the result on
the right side in memory and we move on.

191
00:11:10.067 --> 00:11:11.937
So I just wanted to start off by saying.

192
00:11:11.937 --> 00:11:13.789
Okay, so, line one.

193
00:11:13.789 --> 00:11:21.118
Blessing, what are we doing in line one?

194
00:11:21.118 --> 00:11:23.558
&gt;&gt; Blessing: By defining a function,
create new function.

195
00:11:23.558 --> 00:11:27.220
So [INAUDIBLE] memory.

196
00:11:27.220 --> 00:11:28.531
&gt;&gt; Will Sentance: Excellent, excellent.

197
00:11:28.531 --> 00:11:33.829
Very clear, create new function.

198
00:11:33.829 --> 00:11:37.142
Mm-hm, quite the right casing.

199
00:11:37.142 --> 00:11:39.190
There you go, create new function,
store it in global memory.

200
00:11:39.190 --> 00:11:40.015
Next line up.

201
00:11:40.015 --> 00:11:41.316
Josh?

202
00:11:41.316 --> 00:11:46.388
&gt;&gt; [INAUDIBLE]
&gt;&gt; Will Sentance: So

203
00:11:46.388 --> 00:11:48.200
we grab the whole create new function,
stored it in memory.

204
00:11:48.200 --> 00:11:48.735
What's our next line?

205
00:11:48.735 --> 00:11:52.476
&gt;&gt; Josh: Is it declare
the constant of a new function?

206
00:11:52.476 --> 00:11:53.575
&gt;&gt; Will Sentance: Yes, spot on.

207
00:11:53.575 --> 00:11:55.872
&gt;&gt; Josh: Is the function
create new function?

208
00:11:55.872 --> 00:11:57.671
&gt;&gt; Will Sentance: Yeah, exactly.

209
00:11:57.671 --> 00:12:01.262
We are not immediately gonna go and
create a new function.

210
00:12:01.262 --> 00:12:02.252
Even though its got another
function side we do not go inside.

211
00:12:02.252 --> 00:12:07.427
That's only gonna be reached
if we call createNewFunction.

212
00:12:07.427 --> 00:12:08.975
How do I call create new function, Shawn?

213
00:12:08.975 --> 00:12:09.821
&gt;&gt; Shawn: Parenthesis.

214
00:12:09.821 --> 00:12:10.601
&gt;&gt; Will Sentance: Parenthesis, excellent.

215
00:12:10.601 --> 00:12:13.102
I will never go inside, otherwise.

216
00:12:13.102 --> 00:12:15.499
In fact, if I never call createNewFuction,

217
00:12:15.499 --> 00:12:19.927
that code inside of there would never be
defined, that stuff would never be saved.

218
00:12:19.927 --> 00:12:23.970
The overall description of
the function body is saved,

219
00:12:23.970 --> 00:12:29.053
think almost of a kind of a string of
things that would be done later on.

220
00:12:29.053 --> 00:12:30.400
A string of instructions
to be done later on.

221
00:12:30.400 --> 00:12:33.391
All right, good,
we declare a new function.

222
00:12:33.391 --> 00:12:37.696
You gotta get this piece down,
it's almost an interlude.

223
00:12:37.696 --> 00:12:41.886
This is us understanding what happens when
I return a function from another function

224
00:12:41.886 --> 00:12:44.669
in order the hard piece to follow,
follows naturally.

225
00:12:44.669 --> 00:12:46.887
All right, new function's declared,

226
00:12:46.887 --> 00:12:50.419
it's gonna be the return value
of calling CreateNewFunction.

227
00:12:50.419 --> 00:12:54.452
Sony if I took the parens
off The createNewFunction.

228
00:12:54.452 --> 00:12:57.901
I had just const newFunction
= createNewFunction().

229
00:12:57.901 --> 00:12:59.816
What would I be storing in newFunction?

230
00:12:59.816 --> 00:13:02.938
&gt;&gt; Shawn: The createNewFunction.

231
00:13:02.938 --> 00:13:06.096
&gt;&gt; Will Sentance: Spot on,
the entire createNewFunction definition.

232
00:13:06.096 --> 00:13:10.021
I would have just newFunction is
another label for createNewFunction.

233
00:13:10.021 --> 00:13:10.961
Wouldn't be a copy.

234
00:13:10.961 --> 00:13:13.414
It would just be another label for
that underlying function stored in memory.

235
00:13:13.414 --> 00:13:14.741
Very good, Sonny.

236
00:13:14.741 --> 00:13:16.070
But we're not doing that.

237
00:13:16.070 --> 00:13:18.804
Instead we're saying, go run,
createNewFunction, see what comes back.

238
00:13:18.804 --> 00:13:21.086
And that's what's gonna
be sorting new function.

239
00:13:21.086 --> 00:13:25.248
Let's do it, new,

240
00:13:36.890 --> 00:13:37.444
&gt;&gt; Will Sentance: Ha,

241
00:13:37.444 --> 00:13:41.459
new function is the return value,

242
00:13:41.459 --> 00:13:46.448
the output, of calling create function.

243
00:13:46.448 --> 00:13:49.792
And remember it could be anything,
whatever comes out,

244
00:13:49.792 --> 00:13:53.982
it could be a number, an object,
it could be a function in JavaScript.

245
00:13:53.982 --> 00:13:55.930
So let's create, everybody together.

246
00:13:55.930 --> 00:13:58.107
When we start executing a function,
we create a new?

247
00:13:58.107 --> 00:13:59.459
&gt;&gt; James: Execution context.

248
00:13:59.459 --> 00:14:04.293
[LAUGH]
&gt;&gt; Will Sentance: Rick, you're watching.

249
00:14:04.293 --> 00:14:05.079
We create a new?

250
00:14:05.079 --> 00:14:06.732
&gt;&gt; Rick: Execution context.

251
00:14:06.732 --> 00:14:10.223
&gt;&gt; Will Sentance: That's too fast,
you need to be more measured.

252
00:14:10.223 --> 00:14:12.335
A new?
&gt;&gt; Rick: Execution context.

253
00:14:12.335 --> 00:14:16.113
&gt;&gt; Will Sentance: Yes, don't sound
like a cult unless you do it in

254
00:14:16.113 --> 00:14:17.912
a sing-songy voice.

255
00:14:17.912 --> 00:14:25.335
That is a sign, actually I
shouldn't make that sort of jokes.

256
00:14:25.335 --> 00:14:29.085
Good, I hope you all feel
&gt;&gt; Will Sentance: But

257
00:14:29.085 --> 00:14:30.097
you can leave it any time.

258
00:14:30.097 --> 00:14:31.558
No, okay this is, okay this is not funny.

259
00:14:31.558 --> 00:14:32.346
This is not funny.

260
00:14:32.346 --> 00:14:34.054
All right.
Good okay.

261
00:14:34.054 --> 00:14:39.368
So CreateNewFunction is called what's
the first thing we do inside its memory,

262
00:14:39.368 --> 00:14:40.160
Michelle?

263
00:14:40.160 --> 00:14:43.704
&gt;&gt; Speaker 8: We create a new
function called aditude.

264
00:14:43.704 --> 00:14:44.790
&gt;&gt; Will Sentance: Excellent, there it is.

265
00:14:44.790 --> 00:14:48.594
I'm gonna do this function aside
from a different color @2.

266
00:14:51.063 --> 00:14:52.079
&gt;&gt; Will Sentance: Here it is.

267
00:14:54.931 --> 00:14:57.756
&gt;&gt; Will Sentance: Here it is.
[INAUDIBLE] Where's my nice new green pen?

268
00:14:59.120 --> 00:15:01.346
&gt;&gt; Will Sentance: Okay,
@2 is this function.

269
00:15:01.346 --> 00:15:06.159
Okay, JavaScript is literally storing
the whole functionality associated with

270
00:15:06.159 --> 00:15:07.142
the label @2.

271
00:15:09.339 --> 00:15:10.495
&gt;&gt; Will Sentance: Do
we call that function?

272
00:15:10.495 --> 00:15:12.241
We have to invoke that function, Abdi?

273
00:15:12.241 --> 00:15:15.105
&gt;&gt; Abdi: What question was that?

274
00:15:15.105 --> 00:15:16.313
&gt;&gt; Will Sentance: Are we going to envoke,
execute add to at this point?

275
00:15:16.313 --> 00:15:17.062
&gt;&gt; Abdi: No.

276
00:15:17.062 --> 00:15:18.171
&gt;&gt; Will Sentance: What
are we doing instead, Abdi?

277
00:15:18.171 --> 00:15:23.692
&gt;&gt; Abdi: We are going down to return @2.

278
00:15:23.692 --> 00:15:24.597
&gt;&gt; Will Sentance: Excellent,

279
00:15:24.597 --> 00:15:29.616
return the entire function definition
whose current label is @2, but

280
00:15:29.616 --> 00:15:35.637
we're not returning @2, we're returning
the function that has the label add two.

281
00:15:35.637 --> 00:15:39.171
When JavaScript sees the label
return add two, it goes @2,

282
00:15:39.171 --> 00:15:42.103
let me go look in memory
what I stored in that label.

283
00:15:42.103 --> 00:15:43.925
It's this function, perfect.

284
00:15:43.925 --> 00:15:47.771
So return out that entire
function definition,

285
00:15:47.771 --> 00:15:52.272
the whole thing,
that is literally the words function,

286
00:15:52.272 --> 00:15:56.424
parens, num, curly braces,
return num plus two.

287
00:15:56.424 --> 00:15:59.511
And it's returning all of
that function out, and

288
00:15:59.511 --> 00:16:01.875
it's gonna store it, where Victor?

289
00:16:01.875 --> 00:16:05.229
In what global label is it store it?

290
00:16:06.851 --> 00:16:07.880
&gt;&gt; Abdi: New Function.

291
00:16:07.880 --> 00:16:13.496
&gt;&gt; Will Sentance: Exactly,
there it is under New Function.

292
00:16:13.496 --> 00:16:17.012
It used to be called name add2,
not anymore, but

293
00:16:17.012 --> 00:16:20.292
it is still that
functionality in the memory.

294
00:16:20.292 --> 00:16:23.698
We've just post it out, not copied it out,
it's the underlying function.

295
00:16:23.698 --> 00:16:29.289
We just post it our and give it a new
global label New Function, perfect.

296
00:16:29.289 --> 00:16:33.920
By hitting the return statement,
what happens is execution context vector?

297
00:16:33.920 --> 00:16:37.166
When we hit the return statement of
an execution context with a function?

298
00:16:37.166 --> 00:16:37.894
&gt;&gt; Abdi: It goes away.

299
00:16:37.894 --> 00:16:39.003
&gt;&gt; Will Sentance: It goes away.

300
00:16:39.003 --> 00:16:42.276
In terms of our call stack, it gets popped
off the call stack, but it's deleted.

301
00:16:42.276 --> 00:16:45.376
And all the stuff in it that's
not returned out is deleted, but

302
00:16:45.376 --> 00:16:47.966
the function got returned out so
it ain't deleted.

303
00:16:47.966 --> 00:16:50.301
Gonna give it a new label out here,
so it's not deleted.

304
00:16:50.301 --> 00:16:53.425
Remember a posh word for
deleting stuff from memory is, or

305
00:16:53.425 --> 00:16:57.788
is it deleting stuff when we close an
execution context is, automatic garbage.

306
00:16:57.788 --> 00:17:02.190
Anything that wasn't gonna be used
out here is garbage, wasted memory,

307
00:17:02.190 --> 00:17:03.754
collection, all right.

308
00:17:03.754 --> 00:17:08.205
Good, so we're back out now in
the global execution context.

309
00:17:08.205 --> 00:17:12.545
The last line with New Function is
gonna be the output of create function,

310
00:17:12.545 --> 00:17:13.319
which it is?

311
00:17:13.319 --> 00:17:16.090
There it is,
the output was a New Function called add2.

312
00:17:16.090 --> 00:17:17.774
Well, it was called add2 in here,

313
00:17:17.774 --> 00:17:20.422
now it's just the definition
of add2 in the new label.

314
00:17:20.422 --> 00:17:25.386
So if I wanna now run, call, invoke,
Ben, that inner add2 function out here,

315
00:17:25.386 --> 00:17:27.511
what label do I use for it out here?

316
00:17:27.511 --> 00:17:28.290
&gt;&gt; Ben: New Function.

317
00:17:28.290 --> 00:17:29.846
&gt;&gt; Will Sentance: New Function, excellent.

318
00:17:29.846 --> 00:17:33.485
And how do I run, call,
invoke New Function?

319
00:17:33.485 --> 00:17:34.380
&gt;&gt; Ben: Parenthesis.

320
00:17:34.380 --> 00:17:37.421
&gt;&gt; Will Sentance: Parenthesis, and
because if I look at the definition,

321
00:17:37.421 --> 00:17:41.890
now we visibly
&gt;&gt; Will Sentance: We as developers,

322
00:17:41.890 --> 00:17:44.807
we're gonna look back to
the definition of add2.

323
00:17:44.807 --> 00:17:46.984
JavaScript is not doing that.

324
00:17:46.984 --> 00:17:51.106
It literally passed the definition out,
and sought it a New Function.

325
00:17:51.106 --> 00:17:55.018
So it's gonna look a New Function for
the definition of add2.

326
00:17:55.018 --> 00:17:57.352
And what does it see it needs to receive,
Ben?

327
00:17:57.352 --> 00:17:58.454
&gt;&gt; Ben: An argument.

328
00:17:58.454 --> 00:17:59.572
&gt;&gt; Will Sentance: Exactly, an argument.

329
00:17:59.572 --> 00:18:05.606
So let's put ( 3 ) and we're gonna store
the result of calling New Function in?

330
00:18:05.606 --> 00:18:06.202
&gt;&gt; Ben: Result.

331
00:18:06.202 --> 00:18:07.797
&gt;&gt; Will Sentance: In result, excellent.

332
00:18:07.797 --> 00:18:12.390
So Paul, we're gonna create
at this point a new box.

333
00:18:12.390 --> 00:18:13.744
What are we gonna create when
[CROSSTALK] we execute a new function?

334
00:18:13.744 --> 00:18:15.910
&gt;&gt; Ben: [INAUDIBLE] Your
local execution context?

335
00:18:15.910 --> 00:18:18.940
&gt;&gt; Will Sentance: Excellent, there it is.

336
00:18:18.940 --> 00:18:24.574
Into it we go and Paul,
what's the first thing in our memory?

337
00:18:24.574 --> 00:18:26.226
Or the first pairing?

338
00:18:26.226 --> 00:18:27.313
&gt;&gt; Paul: The parameter?

339
00:18:27.313 --> 00:18:28.421
&gt;&gt; Will Sentance: Which is?

340
00:18:28.421 --> 00:18:29.919
&gt;&gt; Paul: It's called num.

341
00:18:29.919 --> 00:18:30.602
&gt;&gt; Will Sentance: Excellent.

342
00:18:30.602 --> 00:18:32.302
&gt;&gt; Paul: And
it's assigned to the integer 3.

343
00:18:32.302 --> 00:18:34.151
&gt;&gt; Will Sentance: Yeah,
and folk, be really clear,

344
00:18:34.151 --> 00:18:35.822
I know I've said this already.

345
00:18:35.822 --> 00:18:37.861
But do not think that JavaScript,

346
00:18:37.861 --> 00:18:41.882
when it sees New Function,
is going, what's New Function?

347
00:18:41.882 --> 00:18:44.482
I'd better go and check the line before,
it's create New Functions.

348
00:18:44.482 --> 00:18:48.346
But uh-huh,
the line before will never be returned to.

349
00:18:48.346 --> 00:18:52.452
The line before creates an execution
context inside of which

350
00:18:52.452 --> 00:18:56.405
it created add2 was return out,
stored in New Function.

351
00:18:56.405 --> 00:18:59.611
And at no point do we ever,
ever, ever, ever,

352
00:18:59.611 --> 00:19:03.557
does the function ever care
about create function again.

353
00:19:03.557 --> 00:19:06.236
It only cared about create function
in the sense of I don't yet

354
00:19:06.236 --> 00:19:08.359
know what it's storing me,
so I'm undefined.

355
00:19:08.359 --> 00:19:12.496
While I go and run createFunction,
get an actual value, this function, and

356
00:19:12.496 --> 00:19:13.972
store that function here.

357
00:19:13.972 --> 00:19:20.136
Never think that it's like, NewFunction is
a command to go and run createFunction.

358
00:19:20.136 --> 00:19:24.020
It isn't, it's whatever at that moment
you got out of createFunction, and

359
00:19:24.020 --> 00:19:24.809
that's over.

360
00:19:24.809 --> 00:19:26.488
So it's the add2 functionality.

361
00:19:26.488 --> 00:19:28.429
So when we call a New Function line below,

362
00:19:28.429 --> 00:19:30.823
it is just interested in
the add2 functionality.

363
00:19:30.823 --> 00:19:33.079
It never goes back into createFfunction.

364
00:19:33.079 --> 00:19:37.016
Seasoned engineers get muddled about that.

365
00:19:37.016 --> 00:19:38.295
Do not let yourself get muddled.

366
00:19:38.295 --> 00:19:42.248
If we don't get that clear,
all the iterated stuff doesn't follow.

367
00:19:42.248 --> 00:19:44.973
Okay so yeah, we can now run New Function.

368
00:19:44.973 --> 00:19:47.110
We visually, visually,
that's what I meant to say,

369
00:19:47.110 --> 00:19:49.764
visually we have to look back in
to see what add2's definition is.

370
00:19:49.764 --> 00:19:52.604
I wish we didn't, I wish we could
almost literally pull it out and

371
00:19:52.604 --> 00:19:55.406
inspect what New Function is and
we'd see that functionality.

372
00:19:55.406 --> 00:19:56.381
That's what we're looking at.

373
00:19:56.381 --> 00:20:00.060
And you're right,
it says num is the parameter and set to 3.

374
00:20:00.060 --> 00:20:03.788
Where we are then going
to return out 3 + 2,

375
00:20:03.788 --> 00:20:08.122
return out the 5 into what
global variable, Paul?

376
00:20:08.122 --> 00:20:09.001
&gt;&gt; Paul: The result.

377
00:20:09.001 --> 00:20:11.960
&gt;&gt; Will Sentance: Into result,
excellent, there it is.

378
00:20:14.397 --> 00:20:15.708
&gt;&gt; Will Sentance: So in a second on,

379
00:20:15.708 --> 00:20:18.159
I create a function
called createNewFunction.

380
00:20:18.159 --> 00:20:20.293
I then create a placeholder, New Function,

381
00:20:20.293 --> 00:20:24.009
that was gonna be whatever came out
the bottom of running createNewFunction.

382
00:20:24.009 --> 00:20:28.444
Well what came out of the bottom was
an entire function definition, add2 or

383
00:20:28.444 --> 00:20:29.217
turned out.

384
00:20:29.217 --> 00:20:34.257
I now used the new global label
New Function for that functionality add2,

385
00:20:34.257 --> 00:20:38.497
formally known as add2 to run
8 passing (3), add2 to it,

386
00:20:38.497 --> 00:20:42.346
get out 5 and store it in the global,
constant results.

387
00:20:42.346 --> 00:20:46.644
Everyone's thumbs if you lost me I'm
totally clear, I have a clarification.

388
00:20:46.644 --> 00:20:50.623
Your clarification might just be,
why the hell do we do this?

389
00:20:50.623 --> 00:20:54.065
&gt;&gt; James: [LAUGH]
&gt;&gt; Will Sentance: Everybody's thumbs out,

390
00:20:54.065 --> 00:20:54.779
okay.

391
00:20:54.779 --> 00:20:55.626
&gt;&gt; James: I have a dumb question.

392
00:20:55.626 --> 00:20:58.686
&gt;&gt; Will Sentance: Go ahead, Victor,
I do not approve of this language.

393
00:20:58.686 --> 00:20:59.460
&gt;&gt; James: Okay.

394
00:20:59.460 --> 00:21:01.774
&gt;&gt; Will Sentance: You have a smart
question that's gonna illuminate things

395
00:21:01.774 --> 00:21:02.962
for other people, go ahead.

396
00:21:02.962 --> 00:21:06.925
&gt;&gt; James: Can you actually
clone a function?

397
00:21:06.925 --> 00:21:10.605
&gt;&gt; Will Sentance: It's not a dumb
question, it is an interesting question.

398
00:21:10.605 --> 00:21:16.738
It is a question that we're going to
hold on because it's not going to,

399
00:21:16.738 --> 00:21:22.482
we can come back to it if and
when we get through this piece.

400
00:21:22.482 --> 00:21:25.652
It is an interesting question, all right.

401
00:21:25.652 --> 00:21:27.292
It is an interesting question but

402
00:21:27.292 --> 00:21:30.167
it's not going to enable anymore
on deciding any of this.

403
00:21:30.167 --> 00:21:31.090
If you don't mind me holding it mam.

