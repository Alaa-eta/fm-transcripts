WEBVTT

1
00:00:03.595 --> 00:00:06.780
&gt;&gt; Will Sentance: Now we
move on to iterators.

2
00:00:06.780 --> 00:00:09.196
Okay, iterators.

3
00:00:09.196 --> 00:00:15.992
Iterators, I said at the very start
that we run or we write and run code,

4
00:00:15.992 --> 00:00:21.544
what we're typically doing is taking data,
storing it,

5
00:00:21.544 --> 00:00:26.894
and then functionality that
we then apply to that data.

6
00:00:26.894 --> 00:00:31.561
Even as simple as I have a score for
a player, and I increase that score.

7
00:00:31.561 --> 00:00:33.270
Functionality onto data.

8
00:00:33.270 --> 00:00:37.422
We call our live data that's stored
in our application our state.

9
00:00:37.422 --> 00:00:39.213
That just means the labels and the data,

10
00:00:39.213 --> 00:00:41.750
the values currently in our
application at that moment.

11
00:00:43.500 --> 00:00:47.762
But that kind of masks a small part
that's actually pretty significant a lot

12
00:00:47.762 --> 00:00:49.838
of the time, which is I have my data.

13
00:00:49.838 --> 00:00:53.837
I have my functionality, but
often my data is a collection of data,

14
00:00:53.837 --> 00:00:57.693
maybe an array, a list of data, or
a set of data, or a map of data,

15
00:00:57.693 --> 00:01:01.520
or an object containing a bunch
of properties with data.

16
00:01:01.520 --> 00:01:03.627
It's rarely a single element.

17
00:01:03.627 --> 00:01:08.509
So actually the process of
accessing each of our elements

18
00:01:08.509 --> 00:01:12.970
from a collection of
data is in itself a task.

19
00:01:12.970 --> 00:01:16.337
The data's just not there which
we can apply functionality to,

20
00:01:16.337 --> 00:01:18.155
we have to go and access that data.

21
00:01:18.155 --> 00:01:21.499
And in arrays, we do it using indexes
to grab the individual element.

22
00:01:21.499 --> 00:01:25.686
We sort of have a static collection of
data, and go and grab an element, and

23
00:01:25.686 --> 00:01:28.882
actually, that's not a small
process in its own right.

24
00:01:28.882 --> 00:01:33.572
But it's kind of, and
we'll play that out here with a for

25
00:01:33.572 --> 00:01:38.654
loop, and we'll discover that
actually it's not the most,

26
00:01:38.654 --> 00:01:42.189
I think, beautifully designed process.

27
00:01:42.189 --> 00:01:45.999
It's not clear that that's the best and
necessary, most of the time,

28
00:01:45.999 --> 00:01:49.237
when I'm accessing my data,
I know I just want my element and

29
00:01:49.237 --> 00:01:52.118
I want the next element, and
I want the next element.

30
00:01:52.118 --> 00:01:56.970
I don't really care about how I
go about getting those elements.

31
00:01:56.970 --> 00:02:02.680
So wouldn't it be amazing if we could
rethink collections of data as instead

32
00:02:02.680 --> 00:02:07.880
a sort of stream of elements coming
towards me that I could call a function.

33
00:02:07.880 --> 00:02:12.270
I could run a function that's just gonna
instantly return me the next element

34
00:02:12.270 --> 00:02:15.840
from my stream, my flow, of data.

35
00:02:15.840 --> 00:02:16.840
So I would run a function.

36
00:02:16.840 --> 00:02:19.067
It would return out the next
element from my flow.

37
00:02:19.067 --> 00:02:21.324
I'd run it,
return the next element from my flow.

38
00:02:21.324 --> 00:02:25.146
Rethink my data not as a static
collection I've got to go and

39
00:02:25.146 --> 00:02:29.460
manually get each element in
order to run functionality on it.

40
00:02:29.460 --> 00:02:34.300
But it said flip and say my data's there
and I'm actually gonna have access to it

41
00:02:34.300 --> 00:02:39.227
by running a function which kinda turns on
the flow of the next element of my data.

42
00:02:39.227 --> 00:02:43.720
And that is a paradigm shift in how we
think about applying functionality to

43
00:02:43.720 --> 00:02:44.730
our data.

44
00:02:44.730 --> 00:02:48.340
No longer is there the intermediate
step of getting the elements,

45
00:02:48.340 --> 00:02:51.720
manually going into the data collection
and grabbing the next element.

46
00:02:51.720 --> 00:02:55.290
That's not a small thing, and
it's not a necessary step,

47
00:02:55.290 --> 00:02:58.690
when most of the time all I want
is my next element in order.

48
00:02:59.950 --> 00:03:05.880
So why not instead rethink my process
as being applying functionality to data

49
00:03:05.880 --> 00:03:12.540
as the data being given to me, element by
element from a sort of flow of that data.

50
00:03:12.540 --> 00:03:17.000
Before we see that beautiful new way of
thinking about our collections of data and

51
00:03:17.000 --> 00:03:19.260
getting them so
we can apply functionality to them.

52
00:03:19.260 --> 00:03:21.510
We're getting them element by element,
one by one.

53
00:03:21.510 --> 00:03:26.064
Before we do that we're gonna see the old
version where we have a list of data and

54
00:03:26.064 --> 00:03:28.905
we're gonna manually go and
grab each element.

55
00:03:28.905 --> 00:03:32.619
[INAUDIBLE] a beautiful new way
of thinking about this using

56
00:03:32.619 --> 00:03:35.573
each element one by one but
let's first see and

57
00:03:35.573 --> 00:03:40.799
by the way it's gonna show us just how
kind of imperative procedural, bit by bit,

58
00:03:40.799 --> 00:03:45.932
kind of exactly how we're gonna do this,
this old fashioned method is.

59
00:03:45.932 --> 00:03:50.928
Gives us really manual, fine grain
control but at the expense of a clean,

60
00:03:50.928 --> 00:03:52.066
readable code.

61
00:03:52.066 --> 00:03:55.652
And also at the expense of,
I think, a cleaner way for

62
00:03:55.652 --> 00:03:59.503
ourselves of thinking of our
data as these flows of data.

63
00:03:59.503 --> 00:04:02.550
Rather than static collections that
we go and grab, element by element.

64
00:04:02.550 --> 00:04:06.315
So let's first just at least
see this traditional way, and

65
00:04:06.315 --> 00:04:09.336
I think it's gonna show
us we want a better way.

66
00:04:09.336 --> 00:04:14.780
But here's our traditional way,
and I'm going to try and

67
00:04:14.780 --> 00:04:20.670
diagram this but part of the point
to say is that diagramming for

68
00:04:20.670 --> 00:04:24.914
loops is an odd,
odd thing to do, honestly.

69
00:04:24.914 --> 00:04:26.850
When we think about most of our code,

70
00:04:26.850 --> 00:04:29.414
we run execution context
to run functionality.

71
00:04:29.414 --> 00:04:34.096
But our for loops are these funny
little things that happen kind of in

72
00:04:34.096 --> 00:04:38.190
isolation of our regular
way of thinking about code.

73
00:04:38.190 --> 00:04:39.142
But there we go.

74
00:04:39.142 --> 00:04:45.216
All right, line one,
James, what are we doing?

75
00:04:45.216 --> 00:04:48.837
&gt;&gt; James: [COUGH] Declaring
a constant called numbers.

76
00:04:48.837 --> 00:04:50.510
&gt;&gt; Will Sentance: Numbers.

77
00:04:50.510 --> 00:04:55.077
&gt;&gt; James: And assigning it a new
array containing the values 4, 5, 6.

78
00:04:55.077 --> 00:04:56.180
&gt;&gt; Will Sentance: Excellent,
James, spot on.

79
00:04:57.970 --> 00:05:01.130
Now, here comes my favorite bit,
diagramming for loops.

80
00:05:01.130 --> 00:05:03.098
All right, here we go.

81
00:05:03.098 --> 00:05:08.497
Check,
&gt;&gt; Will Sentance: This,

82
00:05:11.924 --> 00:05:13.581
&gt;&gt; Will Sentance: Do This.

83
00:05:13.581 --> 00:05:17.740
Okay, you can already see why these
are problematic, but check this.

84
00:05:17.740 --> 00:05:21.964
So what's the check we're gonna do
is i less than numbers.length, okay.

85
00:05:21.964 --> 00:05:28.151
Is i, which initiated to 0,
less than numbers.length which is 3.

86
00:05:31.085 --> 00:05:37.157
&gt;&gt; Will Sentance: Okay, which is 3,
and since less it is and

87
00:05:37.157 --> 00:05:42.896
therefore do this which is console.log

88
00:05:42.896 --> 00:05:47.142
numbers,
&gt;&gt; Will Sentance: At

89
00:05:47.142 --> 00:05:52.241
position i and then i++.

90
00:05:52.241 --> 00:05:57.201
That's our for loop tried to be written
up in a slightly more logical sense

91
00:05:57.201 --> 00:06:01.841
than the kind of weird check this,
do the code, come back, do this,

92
00:06:01.841 --> 00:06:05.960
check this, the weird circular
flow of an actual for loop.

93
00:06:05.960 --> 00:06:09.550
Okay, so, i less than 3 so
we are gonna do this.

94
00:06:09.550 --> 00:06:13.277
What is numbers at this point, Michelle?

95
00:06:13.277 --> 00:06:15.884
&gt;&gt; Michelle: So
numbers is the array 4, 5, 6.

96
00:06:15.884 --> 00:06:17.179
&gt;&gt; Will Sentance: Yep, and
what is i at this point?

97
00:06:17.179 --> 00:06:19.640
&gt;&gt; Michelle: I is zero.

98
00:06:19.640 --> 00:06:22.722
&gt;&gt; Will Sentance: Zero, already,
I'm liking to hear the hesitation.

99
00:06:22.722 --> 00:06:25.129
That's enough to tell us
there might be a nicer way.

100
00:06:25.129 --> 00:06:30.320
So position zero of numbers is, Michelle?

101
00:06:30.320 --> 00:06:31.259
&gt;&gt; Michelle: 4.
&gt;&gt; Will Sentance: 4, excellent.

102
00:06:31.259 --> 00:06:33.170
&gt;&gt; Michelle: Sorry,
I couldn't tell if that was four or nine.

103
00:06:33.170 --> 00:06:34.830
&gt;&gt; Will Sentance: Next thing to do is i++.

104
00:06:34.830 --> 00:06:37.560
We're gonna increment i to 1.

105
00:06:37.560 --> 00:06:38.370
Is 1 less than 3?

106
00:06:38.370 --> 00:06:41.600
Yes it is, so we come back down here.

107
00:06:41.600 --> 00:06:45.707
Now we get in position
1 of numbers which is?

108
00:06:45.707 --> 00:06:46.915
&gt;&gt; James: 5.

109
00:06:46.915 --> 00:06:49.416
&gt;&gt; Will Sentance: 5, good.

110
00:06:49.416 --> 00:06:52.770
5 plus what incremented to 2.

111
00:06:52.770 --> 00:06:54.650
2 less than 3, yes.

112
00:06:54.650 --> 00:06:58.759
We come back down here now,
now i is what, Victor?

113
00:06:58.759 --> 00:06:59.534
&gt;&gt; Victor: It'll be 6.

114
00:06:59.534 --> 00:07:00.358
&gt;&gt; Will Sentance: So.

115
00:07:00.358 --> 00:07:00.910
&gt;&gt; Victor: I'm sorry.

116
00:07:00.910 --> 00:07:02.191
&gt;&gt; Will Sentance: Perfect, thank you.

117
00:07:02.191 --> 00:07:03.597
&gt;&gt; multiple: [LAUGH]
&gt;&gt; Will Sentance: You see,

118
00:07:03.597 --> 00:07:04.460
thank you Victor.

119
00:07:04.460 --> 00:07:06.299
I is 2.

120
00:07:06.299 --> 00:07:09.430
2, so numbers position 2 is?

121
00:07:09.430 --> 00:07:13.067
&gt;&gt; Victor: 6.
&gt;&gt; Will Sentance: 6, so we console.log 6,

122
00:07:13.067 --> 00:07:18.038
i++ is 3, 3 less than 3, no it's not.

123
00:07:18.038 --> 00:07:19.610
So we come out of our for loop.

124
00:07:20.690 --> 00:07:22.820
Okay, this is the best you can
diagram a for loop, I think.

125
00:07:22.820 --> 00:07:24.554
Honestly, just saying the conditions and

126
00:07:24.554 --> 00:07:26.990
still,
&gt;&gt; Will Sentance: We had a,

127
00:07:26.990 --> 00:07:28.447
thank goodness for
you to make that mistake.

128
00:07:28.447 --> 00:07:29.265
Thank you, ma'am.

129
00:07:29.265 --> 00:07:36.767
We're so busy figuring out how to access
that we can't focus on what we wanna do.

130
00:07:36.767 --> 00:07:41.037
And by the way we're gonna discover, if we
rethink our collections of data as flows

131
00:07:41.037 --> 00:07:44.030
of data, where we grab element by element.

132
00:07:44.030 --> 00:07:48.080
We can dynamically control
those flows of data.

133
00:07:48.080 --> 00:07:49.960
We can even set those flows of data.

134
00:07:49.960 --> 00:07:52.910
We can set what our next element in our
flow of data is gonna look like based

135
00:07:52.910 --> 00:07:57.660
on things that have happened in previous
elements after they've been returned out.

136
00:07:57.660 --> 00:08:00.970
Rethinking our collections
of data as instead flows

137
00:08:00.970 --> 00:08:03.370
of elements we want to grab one by one.

138
00:08:03.370 --> 00:08:06.600
It's gonna give us control over
what those next elements will be.

139
00:08:06.600 --> 00:08:09.450
We'll see that a little bit later on,
really, really cool.

140
00:08:09.450 --> 00:08:13.730
But for now, programs store data and
apply functionality to it.

141
00:08:13.730 --> 00:08:17.480
There are two parts to applying
functionality to collections of data.

142
00:08:17.480 --> 00:08:20.667
One, the process of accessing
each element, and then two,

143
00:08:20.667 --> 00:08:23.280
what we wanna do to each element.

144
00:08:23.280 --> 00:08:28.850
Iterators, this new way of thinking about
accessing data from collections of data,

145
00:08:28.850 --> 00:08:31.690
that means like lists or
arrays or whatever.

146
00:08:31.690 --> 00:08:36.365
Automate the accessing the element, so
we can focus on what we do to each element

147
00:08:36.365 --> 00:08:38.465
and make it available
in a super smooth way.

148
00:08:38.465 --> 00:08:40.495
They make it available so they say,

149
00:08:40.495 --> 00:08:44.767
we got a function that when called with
parens returns out my next element.

150
00:08:44.767 --> 00:08:47.088
Run it again, gives me the next element.

151
00:08:47.088 --> 00:08:48.550
Run it again, gives me the next.

152
00:08:48.550 --> 00:08:50.548
In other words, the function attached and

153
00:08:50.548 --> 00:08:54.445
bundled on it somehow in the background
must be our underlying collection of data.

154
00:08:56.000 --> 00:09:02.330
Plus also, we must somehow hold on
to the information of which element

155
00:09:02.330 --> 00:09:06.540
am I currently at, so that we don't
give me out the same element each time.

156
00:09:06.540 --> 00:09:08.760
But give me out instead the next element.

157
00:09:08.760 --> 00:09:13.105
But we know that when a function runs,
it never remembers its previous running.

158
00:09:13.105 --> 00:09:15.690
Its local memory gets reset every time,
right?

159
00:09:15.690 --> 00:09:18.090
It's empty, you fill it.

160
00:09:18.090 --> 00:09:22.324
So, how the hell am I going to have my
function both be able to be run, give me

161
00:09:22.324 --> 00:09:27.170
the next element, but also therefore have
underlying in it, somehow bundled on it,

162
00:09:27.170 --> 00:09:31.789
my underlying array of data that it's
grabbing the next element from one by one.

163
00:09:31.789 --> 00:09:36.102
And bundled on it the sort of tracking
variable that's tracking which

164
00:09:36.102 --> 00:09:41.100
element have I already given out, so
I know which one to give out next.

165
00:09:41.100 --> 00:09:42.280
How am I gonna bundle that all up?

166
00:09:44.030 --> 00:09:46.700
Imagine if we could create a function
that stored the numbers, and

167
00:09:46.700 --> 00:09:52.180
each time we ran the function, it would
return out our next element from numbers.

168
00:09:52.180 --> 00:09:55.535
Note, you'd have to remember which
element was next up somehow.

169
00:09:55.535 --> 00:09:58.482
That means between the function's
invocations, runnings,

170
00:09:58.482 --> 00:10:02.220
it would somehow have to remember what
was the last element that was passed out.

171
00:10:03.340 --> 00:10:07.860
Hm, but if we could do it,
this would let us think about array,

172
00:10:09.380 --> 00:10:12.850
our list, 4, 5, 6,
as a stream, a flow of data

173
00:10:12.850 --> 00:10:16.030
with our function returning out the next
element and then the next element.

174
00:10:16.030 --> 00:10:19.146
Did everyone get this bit yet,
in the next segment that I say sometimes?

175
00:10:19.146 --> 00:10:23.110
This makes our code more readable, and
we'll see in a minute, more functional.

176
00:10:23.110 --> 00:10:27.980
But it all starts with us returning
a function from another function.

177
00:10:28.990 --> 00:10:33.640
Because all the most beautiful elegant
things, elegant things in JavaScript,

178
00:10:33.640 --> 00:10:37.130
begin with us returning
a function from another function.

179
00:10:37.130 --> 00:10:41.890
Cuz that's gonna give our function
that's returned out superpowers.

180
00:10:41.890 --> 00:10:47.460
My favorite feature in JavaScript
is going to be revealed right now.

181
00:10:47.460 --> 00:10:49.260
But folks, also I'm gonna stress to you,

182
00:10:49.260 --> 00:10:51.700
do not get complacent about
what this code is doing.

183
00:10:51.700 --> 00:10:54.540
This code throws the most
seasoned engineers,

184
00:10:54.540 --> 00:10:57.650
unless we're super precise, line by line.

185
00:10:57.650 --> 00:11:04.190
And remember that we never return
to previous lines of code.

186
00:11:04.190 --> 00:11:06.240
We always finish a line of code.

187
00:11:06.240 --> 00:11:07.020
We're done with it.

188
00:11:07.020 --> 00:11:11.040
We store whatever was the result of the
right hand side in memory, and we move on.

189
00:11:11.040 --> 00:11:12.625
Just wanna start off by saying, okay.

190
00:11:14.579 --> 00:11:21.579
&gt;&gt; Will Sentance: So line 1, Blessing,
what are we doing in line 1?

191
00:11:21.579 --> 00:11:26.073
&gt;&gt; Blessing: We're defining a function,
creating a function, [CROSSTALK].

192
00:11:26.073 --> 00:11:29.890
&gt;&gt; Will Sentance: Excellent,
excellent, very clear.

193
00:11:29.890 --> 00:11:34.230
Create new function, mm-hm,

194
00:11:34.230 --> 00:11:37.610
quite the right casing.

195
00:11:37.610 --> 00:11:41.880
And you go create new function sorting
global memory, next line up, Josh.

196
00:11:46.190 --> 00:11:48.508
&gt;&gt; Will Sentance: So we grab the whole
create new function sorting memory,

197
00:11:48.508 --> 00:11:49.531
what's that next line?

198
00:11:49.531 --> 00:11:53.400
&gt;&gt; Josh: Is it the declare
the constant of the new function?

199
00:11:53.400 --> 00:11:54.837
&gt;&gt; Will Sentance: You're spot on.
&gt;&gt; Josh: As the function

200
00:11:54.837 --> 00:11:56.270
createNewFunction.

201
00:11:57.320 --> 00:11:58.190
&gt;&gt; Will Sentance: Yeah, exactly.

202
00:11:58.190 --> 00:12:00.702
We are not immediately gonna go and
createNewFunction.

203
00:12:00.702 --> 00:12:03.160
Even though it's got another function
inside, we do not go inside.

204
00:12:03.160 --> 00:12:07.850
That's only gonna be reached
if we call createNewFunction.

205
00:12:07.850 --> 00:12:09.581
How do I call createNewFunction, Sean?

206
00:12:09.581 --> 00:12:11.571
&gt;&gt; Sean: Parentheses.
&gt;&gt; Will Sentance: Parenthesis, excellent.

207
00:12:11.571 --> 00:12:14.170
I will never go inside, otherwise.

208
00:12:14.170 --> 00:12:16.905
In fact,
if I never call createNewFunction,

209
00:12:16.905 --> 00:12:21.686
that code inside of there will never be
defined, that stuff will never be saved.

210
00:12:21.686 --> 00:12:24.250
The overall description of
the function body is save.

211
00:12:24.250 --> 00:12:27.536
Think of it almost like a kind of a string
of things that would be done later on,

212
00:12:27.536 --> 00:12:29.470
a string of instructions
to be done later on.

213
00:12:30.490 --> 00:12:35.418
All right, good, we declare newFunction.

214
00:12:35.418 --> 00:12:38.500
You gotta get this piece down,
this is almost an interlude.

215
00:12:38.500 --> 00:12:40.850
This is us understanding what
happens when I return a function for

216
00:12:40.850 --> 00:12:44.920
another function in order, the hard
piece to follow, follows naturally.

217
00:12:44.920 --> 00:12:47.131
All right, new function's declared,

218
00:12:47.131 --> 00:12:50.650
it's gonna be the return value
of calling createNewFunction.

219
00:12:51.760 --> 00:12:55.767
Sony, if I took the parens off
the createNewFunction, I have just const

220
00:12:55.767 --> 00:13:00.380
newFunction = createNewFunction(),
what would I be storing in newFunction?

221
00:13:02.630 --> 00:13:03.766
&gt;&gt; Tony: Build new function.

222
00:13:03.766 --> 00:13:06.650
&gt;&gt; Will Sentance: Spot on,
the entire createNewFunction definition.

223
00:13:06.650 --> 00:13:10.660
I would have just newFunction as
another label for createNewFunction.

224
00:13:10.660 --> 00:13:12.560
It wouldn't be a copy,
it would just be another label for

225
00:13:12.560 --> 00:13:14.700
that underlying function stored in memory.

226
00:13:14.700 --> 00:13:16.510
Very good, Sony, but we're not doing that.

227
00:13:16.510 --> 00:13:20.637
Instead, we're saying go run
createNewFunction, see what comes back,

228
00:13:20.637 --> 00:13:23.594
and that's what's gonna
be stored in NewFunction.

229
00:13:23.594 --> 00:13:30.183
Let's do it, new,
&gt;&gt; Will Sentance: I'll find it,

230
00:13:36.825 --> 00:13:37.540
&gt;&gt; Will Sentance: Aha,

231
00:13:37.540 --> 00:13:41.691
NewFunction is the return value,

232
00:13:41.691 --> 00:13:46.850
the output, of calling createFunction.

233
00:13:46.850 --> 00:13:48.770
And remember, it could be anything,
whatever comes out.

234
00:13:48.770 --> 00:13:54.530
It could be a number, an object,
it could be a function in JavaScript.

235
00:13:54.530 --> 00:13:55.730
So let's create.

236
00:13:55.730 --> 00:13:58.820
Everybody together, when we start start
a studio function, we create a new?

237
00:13:58.820 --> 00:14:00.038
&gt;&gt; multiple: Execution context.

238
00:14:02.195 --> 00:14:04.910
&gt;&gt; Will Sentance: Rick, I'm watching.

239
00:14:04.910 --> 00:14:06.130
We create a new?

240
00:14:06.130 --> 00:14:07.180
&gt;&gt; Rick: Execution context.

241
00:14:08.290 --> 00:14:10.359
&gt;&gt; Will Sentance: That's too fast,
you need to be more measured.

242
00:14:10.359 --> 00:14:13.213
A new execution context, yes,

243
00:14:13.213 --> 00:14:18.940
don't sound like a cult unless
you do it in a sing-songy voice.

244
00:14:18.940 --> 00:14:22.960
That is a sign, and actually I
shouldn't make those sort of jokes.

245
00:14:22.960 --> 00:14:26.271
Good,
&gt;&gt; Will Sentance: I hope you all

246
00:14:26.271 --> 00:14:30.254
feel,
&gt;&gt; Will Sentance: That you can leave at

247
00:14:30.254 --> 00:14:32.286
any time, no, okay, this is not funny.

248
00:14:32.286 --> 00:14:34.370
This is not funny, all right, good.

249
00:14:34.370 --> 00:14:36.995
Okay, so createNewFunction is called,

250
00:14:36.995 --> 00:14:40.825
what's the first thing we do
inside its memory, Michelle?

251
00:14:40.825 --> 00:14:44.374
&gt;&gt; Michelle: We create a new
function called add 2.

252
00:14:44.374 --> 00:14:45.828
&gt;&gt; Will Sentance: Excellent, there it is.

253
00:14:45.828 --> 00:14:48.807
I'm gonna do this function
inside a different color.

254
00:14:48.807 --> 00:14:52.317
Add2,
&gt;&gt; Will Sentance: Here it is.

255
00:14:55.430 --> 00:14:58.484
&gt;&gt; Will Sentance: There it is,
where's my nice new green pen?

256
00:15:00.532 --> 00:15:03.014
&gt;&gt; Will Sentance: Okay,
add2 is this function.

257
00:15:03.014 --> 00:15:07.549
Okay, JavaScript is literally
storing the whole functionality

258
00:15:07.549 --> 00:15:09.970
associated with the label add2.

259
00:15:09.970 --> 00:15:11.802
Do we call that label,
do we call that function?

260
00:15:11.802 --> 00:15:13.515
Are we gonna invoke that function, Abdi?

261
00:15:13.515 --> 00:15:14.497
&gt;&gt; Abdi: Give me
the question one more time.

262
00:15:14.497 --> 00:15:17.158
&gt;&gt; Will Sentance: Are we gonna invoke,
are we gonna execute add2 at this point?

263
00:15:17.158 --> 00:15:17.998
&gt;&gt; Abdi: No.
&gt;&gt; Will Sentance: What are we doing

264
00:15:17.998 --> 00:15:19.460
instead, Abdi?

265
00:15:19.460 --> 00:15:25.170
&gt;&gt; Abdi: We are going down to return add2.

266
00:15:25.170 --> 00:15:28.700
&gt;&gt; Will Sentance: Excellent,
return the entire function definition,

267
00:15:28.700 --> 00:15:31.330
whose current label is add2.

268
00:15:31.330 --> 00:15:33.890
But we're not returning add2.

269
00:15:33.890 --> 00:15:36.920
We're returning the function
that has the label add2.

270
00:15:36.920 --> 00:15:40.641
When JavaScript sees the word return add2,
it goes add2.

271
00:15:40.641 --> 00:15:43.291
Let me go look in memory
what I stored in that label.

272
00:15:43.291 --> 00:15:45.220
It's this function, perfect.

273
00:15:45.220 --> 00:15:50.166
So return out that entire function
definition, the whole thing,

274
00:15:50.166 --> 00:15:53.257
that is literally the words, function,

275
00:15:53.257 --> 00:15:57.076
parens, num, curly braces,
return num plus 2.

276
00:15:58.110 --> 00:16:00.643
&gt;&gt; Will Sentance: And it's returning
all of that function out, and

277
00:16:00.643 --> 00:16:02.580
it's gonna store it where, Victor?

278
00:16:02.580 --> 00:16:05.229
In what global variable or
global label is it gonna store it?

279
00:16:06.460 --> 00:16:08.000
&gt;&gt; Victor: Under new function.

280
00:16:08.000 --> 00:16:13.520
&gt;&gt; Will Sentance: Exactly,
there it is, under new function.

281
00:16:13.520 --> 00:16:18.070
It used to be called,
named add2, not anymore, but

282
00:16:18.070 --> 00:16:20.260
is still that functionality in memory.

283
00:16:20.260 --> 00:16:23.720
We've just posted out, not copied it out,
is the underlying function.

284
00:16:23.720 --> 00:16:25.916
We just posted out and
given a new global label.

285
00:16:25.916 --> 00:16:27.859
New function.

286
00:16:27.859 --> 00:16:30.748
Perfect, by hitting the return statement,

287
00:16:30.748 --> 00:16:33.798
what happens is the execution
context factor?

288
00:16:33.798 --> 00:16:37.270
When we hit the return statement of
an execution context with a function-

289
00:16:37.270 --> 00:16:37.910
&gt;&gt; Victor: It goes away.

290
00:16:37.910 --> 00:16:38.950
&gt;&gt; Will Sentance: It goes away.

291
00:16:38.950 --> 00:16:42.360
It turns back call stack and gets popped
off the call stack, but it's deleted.

292
00:16:42.360 --> 00:16:45.530
All the stuff in it that's not
returned out, it's deleted, but

293
00:16:45.530 --> 00:16:47.910
the function got returned
out through deleted.

294
00:16:47.910 --> 00:16:50.440
You'll give it a new label out here,
so it's not deleted.

295
00:16:50.440 --> 00:16:53.090
Remember, posh word for
deleting stuff from memory is,

296
00:16:53.090 --> 00:16:57.606
was it deleting stuff when we close
out context is automatic garbage.

297
00:16:57.606 --> 00:17:00.740
Anything that wasn't gonna
be used out here is garbage,

298
00:17:00.740 --> 00:17:02.098
wasted memory, collection.

299
00:17:02.098 --> 00:17:04.240
All right, good.

300
00:17:05.560 --> 00:17:08.240
So we're back out now,
in the global execution context.

301
00:17:08.240 --> 00:17:11.430
The last line with new function
is going to be the output

302
00:17:11.430 --> 00:17:13.430
of create function, which it is.

303
00:17:13.430 --> 00:17:16.240
There it is,
the output was a new function called add2.

304
00:17:16.240 --> 00:17:17.740
Well, it was called add 2 in here,

305
00:17:17.740 --> 00:17:20.520
now it's just the definition
of add2 in the new label.

306
00:17:20.520 --> 00:17:24.180
So if I want to now run,
call, invoke, Ben, that in or

307
00:17:24.180 --> 00:17:27.640
add to function out here,
what label do I use for it out here?

308
00:17:27.640 --> 00:17:28.210
&gt;&gt; Ben: New function.

309
00:17:28.210 --> 00:17:30.160
&gt;&gt; Will Sentance: New function, excellent.

310
00:17:30.160 --> 00:17:33.850
And how do I run, call,
invoke new function?

311
00:17:33.850 --> 00:17:34.490
&gt;&gt; Ben: Parentheses.

312
00:17:34.490 --> 00:17:36.680
&gt;&gt; Will Sentance: Parenths, and
because if I look at the definitions.

313
00:17:36.680 --> 00:17:40.920
Now, we visibly
&gt;&gt; Will Sentance: Visibly?

314
00:17:40.920 --> 00:17:44.910
We as developers, we've got to look
back at the definition of add2.

315
00:17:44.910 --> 00:17:47.050
JavaScript is not doing that.

316
00:17:47.050 --> 00:17:51.060
It literally passed the definition out and
stored it in a new function.

317
00:17:51.060 --> 00:17:54.620
So it's gonna look in new function for
the definition of add2.

318
00:17:54.620 --> 00:17:58.050
And what does it see it needs to receive,
Ben?

319
00:17:58.050 --> 00:17:58.700
&gt;&gt; Ben: An argument.

320
00:17:58.700 --> 00:18:01.670
&gt;&gt; Will Sentance: Exactly, an argument,
so let's put, I don't know, 3.

321
00:18:01.670 --> 00:18:04.140
And we're gonna store
the result calling new function

322
00:18:04.140 --> 00:18:06.050
in-
&gt;&gt; Ben: Results.

323
00:18:06.050 --> 00:18:07.950
&gt;&gt; Will Sentance: In result, excellent.

324
00:18:07.950 --> 00:18:12.190
So Paul,
we're gonna create this plan new, box.

325
00:18:12.190 --> 00:18:12.990
What are we gonna create?

326
00:18:12.990 --> 00:18:14.298
When we enter the function.

327
00:18:14.298 --> 00:18:16.020
&gt;&gt; Paul: A local execution context.

328
00:18:16.020 --> 00:18:17.890
&gt;&gt; Will Sentance: Excellent, there it is.

329
00:18:19.050 --> 00:18:24.530
Into it we go, and
pull what's the first thing in our memory?

330
00:18:24.530 --> 00:18:25.420
Or the first pairing?

331
00:18:26.560 --> 00:18:27.390
&gt;&gt; Paul: The parameter.

332
00:18:27.390 --> 00:18:27.890
&gt;&gt; Will Sentance: Which is?

333
00:18:29.150 --> 00:18:30.040
&gt;&gt; Paul: Called num.

334
00:18:30.040 --> 00:18:30.580
&gt;&gt; Will Sentance: Excellent.
&gt;&gt; Paul: And

335
00:18:30.580 --> 00:18:32.460
it's assigned to the integer 3.

336
00:18:32.460 --> 00:18:36.072
&gt;&gt; Will Sentance: Yeah, and so be really
clear, I know I've said this already, but

337
00:18:36.072 --> 00:18:37.750
do not think that JavaScript,

338
00:18:37.750 --> 00:18:40.993
when it sees new function is going,
what's new function?

339
00:18:40.993 --> 00:18:43.420
I better go and check the line before.

340
00:18:43.420 --> 00:18:45.600
Always create new functions outward.

341
00:18:45.600 --> 00:18:48.250
The line before will never be returned to.

342
00:18:48.250 --> 00:18:53.036
The line before create and execution
context inside of which it created

343
00:18:53.036 --> 00:18:57.830
add2 which returned out restored a new
function, and at no point do we ever,

344
00:18:57.830 --> 00:19:03.500
ever, ever, ever, do the function ever
care about create function again.

345
00:19:03.500 --> 00:19:06.640
It only cared about create
function in a sense of I don't yet

346
00:19:06.640 --> 00:19:08.940
know what restore it needs so
I'm undefined while I go and

347
00:19:08.940 --> 00:19:13.890
run createFunction, get an actual value,
this function, install that function here.

348
00:19:13.890 --> 00:19:20.150
Never think that new function is
a command to go and run createFunction.

349
00:19:20.150 --> 00:19:21.160
It isn't.
It's whatever

350
00:19:21.160 --> 00:19:24.850
at that moment you've got out of
createFunction and that's over.

351
00:19:24.850 --> 00:19:26.540
So it's the add two functionality.

352
00:19:26.540 --> 00:19:28.000
So when we call a new
function on the line below,

353
00:19:28.000 --> 00:19:30.860
it is just interested in
the add two functionality.

354
00:19:30.860 --> 00:19:33.060
It never goes back into create function.

355
00:19:33.060 --> 00:19:37.010
Season engineers get muddled about that.

356
00:19:37.010 --> 00:19:38.320
Do not let yourself get muddled.

357
00:19:38.320 --> 00:19:42.360
If we don't get that clear all
the iterator stuff doesn't follow.

358
00:19:42.360 --> 00:19:45.080
Okay, so yeah,
we can now run new functions.

359
00:19:45.080 --> 00:19:46.060
We visually.

360
00:19:46.060 --> 00:19:46.800
That's what I'm gonna say,

361
00:19:46.800 --> 00:19:49.870
visually, we have to walk back in
to see what add to's definition is.

362
00:19:49.870 --> 00:19:51.010
I wish we didn't.

363
00:19:51.010 --> 00:19:54.550
I wish we could just all the put it out
and inspect what new function is, and

364
00:19:54.550 --> 00:19:55.440
we'd see that functionality.

365
00:19:55.440 --> 00:19:56.490
That's what we're looking at.

366
00:19:56.490 --> 00:20:00.130
And you're right.
It says num is a parameter and set to 3.

367
00:20:00.130 --> 00:20:04.097
Where we are then going to return our 3+2,

368
00:20:04.097 --> 00:20:08.310
return out the 5,
into what global variable, Paul?

369
00:20:08.310 --> 00:20:08.830
&gt;&gt; Paul: Result.

370
00:20:08.830 --> 00:20:11.245
&gt;&gt; Will Sentance: Into result,
excellent, there it is.

371
00:20:14.299 --> 00:20:15.380
&gt;&gt; Will Sentance: So
thumbs in a second on,

372
00:20:15.380 --> 00:20:18.930
I create a function called create new
function, I then create a placeholder, and

373
00:20:18.930 --> 00:20:22.160
the new function was whatever was
going to come out of the bottom.

374
00:20:22.160 --> 00:20:22.830
Create new function.

375
00:20:22.830 --> 00:20:28.040
Well, what came out of the bottom was
an entire function definition add two.

376
00:20:28.040 --> 00:20:29.240
Returned out.

377
00:20:29.240 --> 00:20:32.210
I now use the new global
label new function for

378
00:20:32.210 --> 00:20:36.530
that functionality, add2,
forming those add two to run it.

379
00:20:36.530 --> 00:20:39.640
Pass in three, add 2 to it,
get out, 5, and

380
00:20:39.640 --> 00:20:42.430
store it in the global constant result.

381
00:20:42.430 --> 00:20:44.240
Everyone's thumbs you lost me.

382
00:20:44.240 --> 00:20:45.250
I'm totally clear.

383
00:20:45.250 --> 00:20:46.630
I have a clarification.

384
00:20:46.630 --> 00:20:50.675
Your clarification might just be,
why the hell do we do this?

385
00:20:50.675 --> 00:20:52.120
&gt;&gt; multiple: [LAUGH]
&gt;&gt; Will Sentance: Everybody's thumbs out.

386
00:20:54.350 --> 00:20:54.850
Okay.

387
00:20:54.850 --> 00:20:55.694
&gt;&gt; Ben: I have a dumb question.

388
00:20:55.694 --> 00:20:58.372
&gt;&gt; Will Sentance: I do not
approve of this language.

389
00:20:58.372 --> 00:20:59.470
&gt;&gt; Ben: Okay, I have a question.

390
00:20:59.470 --> 00:21:00.770
&gt;&gt; Will Sentance: You have a smart

391
00:21:00.770 --> 00:21:02.560
question that's gonna illuminate
things for other people.

392
00:21:02.560 --> 00:21:06.867
Go ahead.
&gt;&gt; Ben: Can you actually clone a function?

393
00:21:06.867 --> 00:21:10.250
&gt;&gt; Will Sentance: That's not a dumb
question, it is an interesting question.

394
00:21:10.250 --> 00:21:16.360
It is a question that we're going to
hold on because it's not going to,

395
00:21:16.360 --> 00:21:22.460
I can come back to it, if and when we
get through this piece on iterators.

396
00:21:22.460 --> 00:21:24.370
It is an interesting question, all right.

397
00:21:25.820 --> 00:21:27.090
It is an interesting question, but

398
00:21:27.090 --> 00:21:30.170
it's not going to enable
more understanding of this.

399
00:21:30.170 --> 00:21:31.012
If you don't mind me hold on it, ma'am.

