[00:00:00]
>> Will Sentance: We now have a situation here where we create a little function inside another function, returned it out into a new global label, and then use the new global label for that functionality for what possible reason? Why did I not define add2 globally? Who already knows the answer?

[00:00:22]
Right. So I love it when there's lots of people feel cuz I love the big reveals. I love the big reveals. It's gonna turn out when we return a function from another function, we get so much more than just the function. We're gonna get a ton of, well, a single profound bonus.

[00:00:42]
And that's gonna be critical for us to build out our own. Functions that when we call them, give us our next element from our flow of data. And I might call them iterators or what strange name, but it said give us our next element from our flow of name.

[00:00:59]
Let's see it here. So we wanna create a function that holds, you want a great function that has the ability to return our next element from a list of data. 4, 5, 6 for example. But then, also, bundled on that function, it must have the underlying data to grab from, right?

[00:01:19]
Otherwise, where is it getting data from? And it must have the ability to track which element it was on before, so that when we run that function again, it doesn't give us the old element, the previous element. How the hell is it gonna do that? These functions, when they're called, do not remember their prior invocation.

[00:01:37]
They do not remember data that was created in their prior running. The local execution context, if we run this function again, brand new function, add2 created. There's no memory of previous runnings. So how can we have a function, that when run, somehow remembers its previous running that has been run before and had the previous element given out?

[00:01:57]
We shall see. But that's what we gotta try and do. It's gonna start with cooling this create a function that's gonna return out an inner function into return next element. And then, we're going to hopefully get our first element. Who knows how? We shall see. All right, we're gonna walk through this very, very precisely because this is pretty much our main, really our only code on this whole section.

[00:02:23]
But it's very important code. And honestly, it can be considered quite hard for folk, especially who've not seen hard parts before. For folk who have, there might be a section that you remember that this is starting to remind you of involving something called a backpack. All right, good.

[00:02:45]
Line one, I would like to call this instead create flow because it is kind of creating the flow, we will call it create in function here, create function. So what are we doing in line one, Victor?
>> Victor: We're creating a function called create function in memory.
>> Will Sentance: There it is, excellent.

[00:03:04]
Thank you, Victor. Next line, James?
>> James: You're creating a new constant called return next element.
>> Will Sentance: Excellent, do we know what it's gonna be yet? What's gonna be stored there yet?
>> James: Not yet.
>> Will Sentance: So it's gonna default in JavaScript to?
>> James: Undefined.
>> Will Sentance: Undefined, excellent. So here we go, I'm trying to get my board positioning right here.

[00:03:25]
So return next element is going to be the output of calling, create function, where we're passing the array 4, 5, 6 to it. We're gonna create what, Paul? A new?
>> Paul: Local execution context?
>> Will Sentance: New execution context. Excellent, what an old man. I have the same enthusiasm for it as you.

[00:03:51]
There it is. Into it we go. And Sonny, it has of course our thread. Our thread's winded its way in and it has a memory just for stuff that's declared inside this function. And Sonny, what's the first thing that is declared inside this function?
>> Sonny: The array is [INAUDIBLE]

[00:04:15]

>> Will Sentance: Good job, array. Yeah, which is set to what, that's permitted to what argument value?
>> Sonny: 4, 5, 6.
>> Will Sentance: 4, 5, 6.
>> Will Sentance: Thank you. That's very good, Sonny. And what's our next thing inside of our local memory? Yeah. Go ahead.
>> Victor: [INAUDIBLE]
>> Will Sentance: Set 2, 0, good.

[00:04:34]
And Ben, next thing we set up in our local memory?
>> Ben: Declare the function inner.
>> Will Sentance: Excellent, and there it is. Just so we can keep track of it, I'm gonna do it in different color, because it is really weird, I recognize that. It's weird to define functions inside of other functions and return them out.

[00:04:52]
I recognized, so I wanna make sure we're really keeping track of how that's evolving. There's the function. Are we going to call it, Ben? Are we going to evoke it?
>> Ben: No.
>> Will Sentance: No, what are we going to do instead?
>> Ben: We're going to return it.
>> Will Sentance: Return its entire definition out.

[00:05:10]
Now, there it is. Out it returns. And store it where then?
>> Ben: We're gonna store it in return next element.
>> Will Sentance: Exactly, return next element is now a function that was formerly known as what, Ben?
>> Ben: Create function? No.
>> Will Sentance: See how hard it is to keep track of this.

[00:05:29]
It was formerly known as that inner function. Inside of create function, it was known as inner. Now, we've hit the return statement of create function. So all the labels in here, all the data in here, what happens to it?
>> Ben: It goes back in.
>> Will Sentance: Gone. Just the function that got returned out, passed out to return next element.

[00:05:50]
Perfect. We've popped the other call stack and we're back out to return next element. Let's just make sure we keep track of our call stack. Our call stack, we're back in what execution context?
>> [INAUDIBLE]
>> Will Sentance: Global, excellent, into global. So we've done return next element. Okay, so how can we, now, in theory, what do we hope that calling the return next element function's gonna do, in theory, Abdi?

[00:06:17]

>> [INAUDIBLE]
>> Will Sentance: What do we hope in theory, Bryan, it's gonna do?
>> Bryan: It's gonna be 4.
>> Will Sentance: 4, that's what we hope. If we run it again, hope it would return?
>> Bryan: 5.
>> Will Sentance: And again?
>> Bryan: 6.
>> Will Sentance: And again, undefined and so forth. Yeah, okay. That's what we're hoping for desperately.

[00:06:33]
Cuz that allows us to rethink our collection of data as a flow. I'll run a function, and get my next element. I'll run a function, and get my next element. I'll run a function, and get my next element. That's a beautiful way for your data. No more, I have a collection statically of data memory, I gotta go and look at it, get an element, use it.

[00:06:50]
Look at it, get an element, use it. Now, I just run my function and I give in. I'm given my next element. It's a really beautiful way of thinking about my collections of data. As flows of element after element after element. Everyone got that mentality shift? It's a beautiful way of thinking.

[00:07:07]
So you're right. We use to run call return next element. So let's do just that. So left-hand side there, Abdi, it says to do what?
>> Abdi: Const element one.
>> Will Sentance: Okay, element one is declared. Yep, good. Do we know what to assign to it yet?
>> Abdi: No.
>> Will Sentance: What are we going to have to do to figure out what to assign to it?

[00:07:30]

>> Abdi: We're going to have to call it.
>> Will Sentance: Call what?
>> Abdi: Return next element.
>> Will Sentance: Good, yeah. What symbols tell me I've got recall next element?
>> Abdi: Parenthesis.
>> Will Sentance: Excellent. Return next element, call it, I get to create my favorite thing on Earth. So element one, for now, is undefined.

[00:07:51]
My favorite thing on Earth, everyone together.
>> Abdi: [CROSSTALK]
>> Will Sentance: Don't say local, don't ruin the phraseology. A new-
>> Abdi: Execution context.
>> Will Sentance: Yeah, I like the type of slightly tired tone, like a kinda slightly exhausted please stop doing this tone. So you did great. All right, so,
>> Will Sentance: There it is.

[00:08:15]
It has a local memory,
>> Will Sentance: In which we're gonna store anything that gets declared in here. Now we have to visually look back up to inner, but know that that's actually code here in returnNextElement. So maybe even write element equals array[i], i++, return element. That's the code of returnNextElement.

[00:08:40]
But were gonna visually just save ourselves and just look up in there to know what it is. So with that in mind, Shawn, what is the first line of code, or what is the first thing we're going to do inside return x element? Left hand side first.
>> Abdi: Create a constant called element.

[00:08:54]

>> Will Sentance: Excellent, there it is, constant called element. Element is going to be the ith position of array. What the hell are these? Well, let's start to figure it out. Where do we look first for something that we don't have? We called it returnNextElement so it goes in our call stack of course, there it is, returnNextElement.

[00:09:25]
We'll putting it inside the global. So we're inside of here right now. Where do we look first for our array and our i? Local memory. Yeah, Abdi? Sorry, you were correct. Very good. Do we find? Do we find them, James?
>> James: No.
>> Will Sentance: No. I'm calling returnNextElement to global so where are my, all my intuitions implying that I look next?

[00:09:58]
Ben?
>> Ben: That's the definition of-
>> Will Sentance: Okay, stop, stop. The definition of what?
>> Ben: returnNextElement.
>> Will Sentance: Definition hm, yeah okay. Yeah, because you watch, that's okay. All right, raise your hand if you know what Hard Parts are for, cuz those are the people I'm gonna call on. You've never watched Hard Parts before.

[00:10:16]

>> Ben: [LAUGH]
>> Will Sentance: Okay, Rick. Where would everything suggest, I'm calling returnNextElement, so where would everything suggest the next memory is I look at? I don't find it in this local one, where do I look next?
>> Rick: In global.
>> Will Sentance: In global, exactly, into global I go, looking desperately for my array and my i.

[00:10:39]
Do I find them, Rick? No, so I get an error, right, Rick?
>> Will Sentance: Is that the answer's no voice? Okay, I need to get better at that voice, right? That's not much better either. I get an error, okay. I get an error. Now see, that was more convincing, right?

[00:11:01]
Again, error.
>> Will Sentance: Yes I looked for these, not there.
>> Will Sentance: There's another hard part where we focus mainly on this concept, and I'd like to drag it out for a long time. Here, we may not have time. But maybe a little bit of time, you know. I can drag it out for a little bit longer.

[00:11:33]

>> Will Sentance: Do you mind, Brian, passing me my coffee, my mocha? Thank you, I can't walk out of this area otherwise my head gets cut off, my head's been cut off right now.
>> Bryan: [LAUGH]
>> Will Sentance: I just want to sip this for a bit. So I got an error on the horizon here, right?

[00:11:52]

>> Bryan: How long do you want us to wait before we give you the answer?
>> Will Sentance: James has the sound of a confident person about him. Where is that array in i? Cuz I am certain, do not at any point think I can go back into my createFunction execution context.

[00:12:11]
This has long gone. I cannot suddenly I'll just go up and createFunction. That is long gone. So where's my? All right, not gonna drag it out any more. It turns out, in case James shouts out the answer before I get to give the punchline myself. It turns out that,

[00:12:32]

>> Will Sentance: As soon as I define my inner function inside a createFunction, while I was still back in createFunction, before I exited, as soon as I defined it, I got a bond to all the surrounding live memory. The surrounding data, you can call it state, you can the variable environment.

[00:12:52]
The live memory, the data around the function definition. A lot of bombs to it. And then a link, a reference to all the surrounding data. We'll talk about what property in a moment. I got a bond this surrounding data immediately. Meaning, when I return that function out, I brought with it on the back of a function.

[00:13:14]
As the function got returned out, out on the back of it came all that surrounding live data. When I return that function out. Return data use of the label inner into returnNextElement. On the back of the function, I brought all the surrounding data from when it was born.

[00:13:29]
And it got stored in this new label, we got given a new label, globally returnNextElement. But my surrounding data is attached to that very definition, with array literally in the memory as 456. Not it will be, but literally stored in memory. I, as literally storing memory as the number zero, and it's attached to the back of my function.

[00:13:58]
There it is on the definition itself. And so Ben was hinting to this, when I don't find a RNI on my local memory I do not go to global immediately. Instead, I go look at my definition of my function, I see is there a backpack of data that was brought out with the function?

[00:14:18]
And look, there it is. And Ben, what do I grab?
>> Ben: You grab four.
>> Will Sentance: Correct, but specifically my array becomes?
>> [INAUDIBLE]
>> Will Sentance: And my i becomes?
>> Ben: Zero.
>> Will Sentance: Zero. I'm not looking at it from my local memory, I'm looking on the function definition that's being called itself.

[00:14:42]
And there attached to it is my persistent, we'll give it posher names in a moment, but my backpack of data from when the function was returned out from where it was born. As soon as it was born it got a link to all the surrounding data from the memory in which it was defined.

[00:15:00]
When I return the function out that bond didn't break, that bond pulled out on the back of the function all that surrounding data. And when I call that function by it's new global label here and doesn't find some, it refers to labels in the find data of, in the local memory, it doesn't panic.

[00:15:19]
It looks first to the function's definition and finds attach to the function, our persistent live data from where the function was born. All right, which means exactly as Ben said, what am I storing in element? I'm gonna take the zeroth position of array, four five six which is, Ben?

[00:15:39]

>> Ben: Four.
>> Will Sentance: Four. And what am I gonna do as my next line, Ben inside my body of the function?
>> Ben: You're going to increment i.
>> Will Sentance: Right, do I find i in local memory?
>> Ben: No.
>> Will Sentance: Where do I go?
>> Ben: You go to the backend.
>> Will Sentance: Use my name, yes, good.

[00:15:52]
Not my name, sorry.
>> Ben: [LAUGH]
>> Will Sentance: And i goes to One and then we hit return element, which is really return what?
>> Ben: Four.
>> Will Sentance: Four, we return out four into what global constant?
>> Ben: Element one.
>> Will Sentance: Element one and look at that. Look at that, element one is not four, is not one, is four, exactly what we wanted from calling return next element.

[00:16:24]
Let's call it one more time to see what happens, and then we'll talk about what concept this backpack is. You may already know its posher name, or its more unintuitive name, or its name that I'm hoping is going to be replaced with backpack in the spec very soon.

[00:16:43]

>> Will Sentance: I believe it will be. All right, return x element popped off the cool stack. All of it in context cleared, right, so we'd better not be having this information in here because it's all deleted. And we hit our next global line of code, which is what Abdi?

[00:17:03]

>> Abdi: Element two, declaring that in memory.
>> Will Sentance: Yeah, exactly. So let's just try being precise in our telecommunications. So Abdi do you want to give another shot on that, declare the?
>> Abdi: Function.
>> Will Sentance: Declare the constant.
>> Abdi: Declare the constant element two.
>> Will Sentance: Excellent, in global memory. And then we know it's going to be the return value of calling what function, Abdi?

[00:17:28]

>> Abdi: Return next element.
>> Will Sentance: Good, so for now, element 2 will default to, everyone?
>> Abdi: Undefined.
>> Will Sentance: Excellent, so let's create that execution context, people. Almost there, I wanna have a sit down. Let's create execution context. In we go, in our local memory, what's the first thing we declare, Victor?

[00:17:50]

>> Victor: Element.
>> Will Sentance: Element, which is going to be set to a array, these mysterious array(i). What are these mysterious things you might be asking? Well, where do I look for array in (i) first Victor?
>> Victor: In the local execution context.
>> Will Sentance: Always in the local execution context first, nothing there though, right?

[00:18:16]
So do I panic? No, I mean I wouldn't panic anyway. Where might I intuitively look next?
>> Victor: You would intuitively go to global [CROSSTALK].
>> Will Sentance: Right.
>> Victor: But there is a enclosed.
>> Will Sentance: Okay, getting, I like that sort of term, I like that sort of term. There's an enclosed backpack, good, got it.

[00:18:34]

>> Victor: [LAUGH]
>> Will Sentance: Where I find arrays four, five, six, and (i) is?
>> Victor: One.
>> Will Sentance: One, our live data here persists attached to the function definition. It's persisting attached to our function definition here in memory. So (i) is one, so array is four, five, six and (i) is one, because return its elements is stored in global memory, so it's not suddenly deleting all the data attached to it at each stop.

[00:19:05]
It doesn't care about the running of this function, except, what do you store in here? This is like persistent data, just like return next element function is a persistent function, as long as the application's running, can't suddenly be deleted. So too is its attached backpack of data, persistent.

[00:19:18]
That just means it sticks around, it doesn't change. Or we change it, but it doesn't get removed. Okay, so position one vector of [4,5,6] is what?
>> Victor: Five.
>> Will Sentance: Five, good job, five. And then we hit the next line inside the body vector, which is?
>> Victor: Five plus plus?

[00:19:35]

>> Will Sentance: And right here we find it in the backpack and do-
>> Victor: Two.
>> Will Sentance: Two, and then we hit return. Return what vector?
>> Victor: Return 5.
>> Will Sentance: Return 5, the value of element into element 2. Excellent there it is. And look at that. All right, that's pretty beautiful.

[00:19:56]
We have a function now that when born got attached to its very definition. The underlying state, the underlying data from which it's going to extract and return to us on its call, one by one, the individual elements from that underlying collection of data. And it's keeping track of which ones up next using this little tracking value also all bundled up on this returnNextElement function.

[00:20:25]
I think that's very, very beautfiful. We'll talk about it in a second, but I think it's very beautiful that you can have a function return its element that has everything you need. It has the ability when called to return our next element. It has bundled on it the underlying data that it knows to extract from and it has bundled on it the information about what next element to return out.

[00:20:47]
All bundled up in a single function. That's a very, very beautiful design. All right, let's have thumbs and one of the thumbs on medium might be what do we call the backpack of data? Everybody's thumbs out, you lost me, unclear, I have clarifications. Everyone's thumbs out and proud.

[00:21:07]
Everyone knows what the backpack's called? No one has medium thumbs, all right.
>> Victor: What's the backpack called?
>> Will Sentance: Good, good job, Alec.

