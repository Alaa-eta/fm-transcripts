[00:00:00]
>> Will Sentance: We now have a situation here where we create a little function inside another function, returned it out into a new global label, and then use a new global label for that functionality for what possible reason? Why did I not define at two globally? Who already knows the answer, right, so I love it when there's lots of people feel, cuz I love the big reveals, I love the big reveals.

[00:00:28]
It's gonna turn out when we return a function from another function we get so much more than just the function. We're gonna get a ton of well, a single profound bonus. And that's gonna be critical for us to build out our own functions that when we call them, give us our next element from our flow of data.

[00:00:54]
And I like calling them iterators, what a strange name. But instead give us our next element from our flow of data. Let's see it here, so we want to create a function that holds, hold, we want to create a function that has the ability to return our next element from a list of data.

[00:01:10]
4, 5, 6, for example, but then also, bundled on that function, it must have the underlying data to grab from, right? Otherwise, where is it going to draw from? And it must have the ability to track which element it was on before, so that when we run that function again, it doesn't give us the old element.

[00:01:30]
The previous element. How the hell is it gonna do that? Cuz functions when they're called do not remember their prior invocation. They do not remember data that was created in their prior running. The low constitution context, [SOUND] we run this function again, brand new function add two created.

[00:01:46]
There's no memory of previous running. So how can we have a function that when run somehow remembers its previous running that its been run before and had a previous element given out? We shall see, but that's what we've got to try and do. So gonna start calling this create function that's gonna return out an inner function into return next element.

[00:02:07]
And then we're going to hopefully about to get our first element. Who knows how? We shall see. All right, we're gonna walk through this very, very precisely, because this is pretty much our main, really our own code on this whole section. But it's very important code. And honestly can be considered quite hard for folk especially, who've not seen hard parts before.

[00:02:35]
For folks who have, there might be a section that you remember that this is trying to remind you of involving something called a backpack. All right, good, line one. I would like to call this instead create flow, because it's kind of creating the flow but we'll call it create function here, so what are we doing in line one Victor?

[00:02:58]

>> Victor: We're creating a function called create function in memory.
>> Will Sentance: There it is excellent, thank you, Victor. Next line, James.
>> James: You're creating a new constant called return next element.
>> Will Sentance: Excellent. Do we know what it's gonna be yet? It's gonna be stored there yet?
>> James: Not yet.

[00:03:17]

>> Will Sentance: So it's gonna default in JavaScript too.
>> James: Undefined.
>> Will Sentance: Undefined, excellent, so here we go. I'm trying to get my board positioning right here, so return next element is going to be the output of calling. Create function, where we're parsing the array 4, 5, 6 to it, we're going to create what's, Paul, a new.

[00:03:46]

>> Paul: Local execution context.
>> Will Sentance: New execution context, excellent, one on man, I have the same enthusiasm for it as you. There it is, into it we go and Sonny what has of course our thread? Our threads winded its way in and it has a memory just for stuff that's declared inside this function.

[00:04:07]
And Sonny what's the first thing that is declared inside this function?
>> Sonny: Array, the array.
>> Will Sentance: Yeah, sorry, array, good job, array, yeah, which is set that's a parameter to what argument value?
>> Sonny: 4, 5, 6.
>> Will Sentance: 4, 5, 6, thank you, that's very good, Suni, and what's our next thing inside of our local memory?

[00:04:29]
Yeah, go ahead. Set 2, 0 good, and Ben? Next thing we set up in our local memory.
>> Ben: Declare the function inner.
>> Will Sentance: Excellent there it is, just so we can keep track of it, I'm gonna do it in a different color, because it is really weird. I recognized that it's weird to define functions inside other functions, return them out.

[00:04:52]
I recognize it, so I really wanna make sure we're really keeping track of how that's evolving. That's the function are we going to call it, Ben, are we gonna evoke it?
>> Ben: No.
>> Will Sentance: No, what are we going to do instead?
>> Ben: We're going to return it.
>> Will Sentance: Return it's entire definition out, there it is, out at returns.

[00:05:13]
And store it where, Ben?
>> Ben: We're gonna store it in return next element.
>> Will Sentance: Exactly, return next element is now our function that was formally known as what, Ben?
>> Ben: Great function? Or no, inner, yeah.
>> Will Sentance: See how hard it is to keep track of this? It was formerly known as that inner function.

[00:05:32]
Inside of create function it was known as inner, now, we've hit the return statement to create function. So all the labels in here, all the data in here, what happens to it?
>> Ben: [INAUDIBLE]
>> Will Sentance: Gone, adjust the function, they've got returned out, passed out to return next element.

[00:05:50]
Perfect! We've popped out of the call stack and we're back out to return next element. Let's just make sure we keep track of our call stack. Our call stack, we're back in what execution context?
>> Ben: Global.
>> Will Sentance: Global, excellent, into global. So we've done return next element. Okay, so how can we, now, in theory what do we hope that calling the return next element function is gonna do in theory RD?

[00:06:20]

>> Will Sentance: What do we hope in theory Brian is gonna do?
>> Brian: Return 4.
>> Will Sentance: 4, that's what we hope, if we run it again we hope it would return.
>> Brian: 5.
>> Will Sentance: And again?
>> Brian: 6.
>> Will Sentance: And again, undefined at some point, yeah, okay. That's what we're hoping for, desperately, cuz that allows us to rethink our collection of data as a flow.

[00:06:37]

>> Will Sentance: I run a function and get my next element, I run a function, get my next element. I run a function, get my next element, that's a beautiful way of thinking of your data. No more I have a collection statically of data and memory, I've got to go and look at it, get an element, use it.

[00:06:50]
Look at it, get an element, use it, now, I've just run my function, and I'm given, I'm given my next element. It's a really beautiful way of thinking about my collections of data. As flows of element after element after element. Everyone got that mentality shift? It's a beautiful way of thinking.

[00:07:07]
So, you're right. What it is to run call return next element. So let's do just that, so left-hand side there, Abde, tends to be what?
>> Abde: Const to element 1.
>> Will Sentance: Okay, element 1 is declared, yep.
>> Abde: I agree,
>> Will Sentance: Good do we know what to assign to it yet?

[00:07:23]

>> Abde: No.
>> Will Sentance: What are we going to have to do to figure out what to assign to it?
>> Abde: We are going to we are gonna have to call it.
>> Will Sentance: Call what?
>> Abde: returnNextElement.
>> Will Sentance: Good, yeah, what symbol is telling me I've got a call returnNextElement?
>> Abde: Parenthesis.

[00:07:38]

>> Will Sentance: Excellent, returnNextElement(), call it. I get to create my favorite thing on Earth, so element 1 for now is undefined. My favorite thing on earth all together. [CROSSTALK] Execution collection. Don't ruin the phraseology A new?
>> Execution context.
>> Will Sentance: Yeah, I like it to have a slightly tired tone, like a kind of slightly exhausted, please stop doing this tone.

[00:08:08]
So you did great. All right, so,
>> Will Sentance: There it is. It has a local memory,
>> Will Sentance: In which we're gonna store anything that gets declared in here. Now we have to visually look back up to inner, but know that that's actually code here in returnNextElement. So maybe even write element equals=array[i]; i++, return element, that's the code of returnNextElement.

[00:08:40]
But we're gonna visually just save ourselves and just look up to inner to know what it is. So with that in mind Sean, what is the first line of code or what's the first thing we're gonna do inside return x element? Left hand side first.
>> Sean: Create a const called element.

[00:08:54]

>> Will Sentance: Excellent there it is. Const called element. Element is going to be the eighth position of array. What the hell are these? Well, let's start to figure it out. Where do we look first for something that we don't have a, we are calling return next element so it goes on, and I call stack of course.

[00:09:23]
There it is return next element we are calling it inside global. So we're inside of here right now. Where do we look first for our array and our i? That local memory, yeah. Andy.
>> Abde: Right.
>> Will Sentance: Look her over. Very good. All right, do we find them, James?

[00:09:49]

>> James: No.
>> Will Sentance: No. I'm calling into our next element in global so where are my, all my intuitions implying in a lit next. Ben?
>> Ben: Add the definition of-
>> Will Sentance: Okay stop. Stop. The definition of what?
>> Ben: The turn next to.
>> Will Sentance: Definition yeah okay. Yeah because you watch.

[00:10:11]
That's okay. All right. Raise your hand if you never watched Hard Parts before. Those are the people I'm going to call on. You've never watched Hard Parts before? Okay, Rick. Where would everything suggest, I'm calling return its elements out. Where would everything suggest the next memory is, I look at?

[00:10:28]
I don't find it in this local one. Where do I look next?
>> Rick: In global.
>> Will Sentance: In global, exactly. Into global I go. Looking desperately for my array and my i. Do I find them, Rick? No, so I get an error right, Rick?
>> [LAUGH]
>> Will Sentance: Is that my answer's no voice?

[00:10:49]
Okay, I need to get better at that voice, all right. No, that's not much better either. I get an error. Okay I get an error. Now see that was more convincing, right?
>> [LAUGH]
>> Will Sentance: I get an error. Yeah, cuz I look for these, [SOUND] not there. Hm, hm, hm, hm.

[00:11:18]
There's another hard part where we focus mainly on this concept, and I like to drag it out for a long time. Here we may not have time, but maybe a little bit of time. No, I can drag it out for a little bit longer.
>> Will Sentance: Do you mind Brian passing me my coffee?

[00:11:35]
My mocha, thank you.
>> [LAUGH]
>> Will Sentance: I just can't walk out of this area otherwise my head gets cut. My head's being cut off right now.
>> [LAUGH]
>> Will Sentance: So I just want to sip this for a bit while I, so we got an error on the horizon here, right?

[00:11:52]

>> James: How long do you want us to wait before we give you the answer?
>> Will Sentance: James has the sound of a confident person about him. Where is that array in i? Cuz I am certain, do not at any point think I can go back into my createFunction execution context.

[00:12:10]
This has long gone. I cannot suddenly, I'll just go up and create function. That is long gone. So where's my? All right, I'm not gonna drag it out any more. It turns out, in case James shouts out the answer before I get to give the punchline myself. It turns out that,

[00:12:32]

>> Will Sentance: As soon as I define my inner function, inside a createFunction, while I was still back in createFunction, before I exited. As soon as I defined it, I got a bond to all the surrounding live memory, the surrounding data, you can call it state, you can call it the variable environment.

[00:12:52]
The live memory, the data around the function definition, I got a bond to it, a little link, a reference to all the surrounding data. We'll talk about what property in a moment. I got a bond data immediately. Meaning when I return that function out, I brought with it on the back of the function.

[00:13:13]
As the function got returned out, out on the back of it came all that surrounding live data. When I returned that function out, returned out the function that used to the label inner, into return next element. On the back of the function, I brought all the surrounding data from when it was borne.

[00:13:29]
And it got stored in this new label we are given a new label globally written next element. But my surrounding data is attached to that very definition with array literally in the memory as 4, 5, 6, not it will be but literally stored in memory. i as literally stored in memory as the number zero.

[00:13:54]
And it's attached to the back of my function. There is, on the definition itself. And so Ben was hinting this. When I don't find array in i in my local memory, I do not go to global immediately. Instead, I go look at my definition and my function. I see, is there a backpack of data that was brought out with the function?

[00:14:17]
And look, there it is. And then, what do I grab?
>> Ben: You grab a four.
>> Will Sentance: Correct, but specifically my array becomes, my array becomes,
>> Will Sentance: And my i becomes?
>> Ben: 0.
>> Will Sentance: 0. I'm not getting it from my local memory. I'm looking on the function definition that's being called itself and they're attached to it.

[00:14:44]
Is my persistent we'll give it an apostrophe in a moment, but my backpack of data from when the function was returned out from where it was born. As soon as it was born it got a link to all the surrounding data from the memory in which it was defined.

[00:15:00]
When I returned the function out that bond didn't break. That bond pulled out on the back of the function all that surrounding data. And when I call that function by its new global label here, and doesn't find some, the first label doesn't find data of in your local memory, it doesn't panic.

[00:15:19]
It looks first to the function's definition and finds attached to the function,
>> Will Sentance: Our persistent live data from where the function was born. All right, which means exactly as Ben said what am I storing in element? I'm gonna take the zero position of array,4, 5, 6, which is, Ben?

[00:15:39]

>> Ben: Four.
>> Will Sentance: Four and what am I gonna do as my next line Ben, inside my body of the function?
>> Ben: You're going to increment.
>> Will Sentance: Right, do I find i in local memory?
>> Ben: No.
>> Will Sentance: Where do I go?
>> Ben: Go to the [INAUDIBLE]
>> Will Sentance: Use my name, yes good, not my name, sorry.

[00:15:53]

>> [LAUGH]
>> Will Sentance: To this one. And i goes to One, and we then hit return element, which is really return what?
>> Ben: 4.
>> Will Sentance: 4, we return out 4 into what global constant?
>> Ben: Element1.
>> Will Sentance: Element1, and look at that. Look at that, Element 1 is not 4, is 4.

[00:16:20]
Exactly what we wanted from calling return next element. Let's call one more time to see what happens and we'll talk about what concept this backpack is. You may already know its posture name. Or it's more unintuitive name. Or its name that I'm hoping is going to be replaced backpack in the spec very soon.

[00:16:43]

>> Will Sentance: I believe it will be. All right, return this element popped off the cool stack. All of its [INAUDIBLE] context cleared. So we better not be having this information in here, because it's all deleted, and we hit our next global line of code, which is what, Abdi?
>> Abde: Const element2, declaring that in memory.

[00:17:06]

>> Will Sentance: Yeah, exactly, so declare. Let's just try being super precise in identical communication, so Abdi do you want to have another shot on that? Declare the?
>> Abde: Function.
>> Will Sentance: Declare the constant-
>> Abde: Well, declare the constant element2.
>> Will Sentance: Excellent, in global memory, and then we know it's going to be the return value calling what function?

[00:17:27]
Abdi?
>> Abde: Return x-element.
>> Will Sentance: Good, so for now quant2, sorry element2 or default2, everyone?
>> Undefined.
>> Will Sentance: Excellent, so let's create that execution context people, almost there. I wanna have a sit down. It's great execution context. In we go. In our local memory what's the first thing we declare, Victor?

[00:17:50]

>> Victor: Element.
>> Will Sentance: Element, which is gonna be set to a array These mysterious array i. What are these mysterious things, you might be asking? Well, where do I look for, where do I look for array an i first Victor?
>> Victor: In the local execution context.
>> Will Sentance: Always in the local execution context first.

[00:18:14]
Nothing there though right? So, do I panic? No, I mean I wouldn't panic anyway. Where might I intuitively look next?
>> Victor: You would intuitively go to global blank.
>> Will Sentance: Right.
>> Victor: But there is an enclosed.
>> Will Sentance: I like that sort of term. There's an enclosed backpack. Good, got it.

[00:18:35]
Where I find arrays 4, 5, 6 and i is?
>> Victor: 1.
>> Will Sentance: 1! Our live data here persists attached to the function definition. It's persisting attached to our function definition in memory. So i is 1, and so array is 4 5 6 and i is 1 because returnNextElement is stored in global memory.

[00:19:02]
So it's not like suddenly deleting all the data attached to it each shot. It doesn't care about the running of this function except what you have stored here. This is like persistent data just like returnNextElement function is persistent function as long as the application is running. Not suddenly be deleted.

[00:19:15]
So two is its attached backpack of data, persistent. That just means sticks around, doesn't change. Or it changes but it doesn't get removed. Okay, so position one, Victor of 4, 5, 6 is what?
>> Victor: 5.
>> Will Sentance: 5, good job. 5, and then we hit the next line inside the body of vector, which is?

[00:19:34]

>> Victor: i++.
>> Will Sentance: We don't find i here, we find it in the backpack and do.
>> Victor: 2.
>> Will Sentance: 2, and then we hit return. Return what, Victor?
>> Victor: Return 5.
>> Will Sentance: Return 5, the value of element into element2. Excellent, there it is. And look at that. I think that's pretty beautiful.

[00:19:56]
We have a function now that when born, got attached to its very definition. The underlying state; the underlying data from which it's going to extract and return to us on its call, one by one, the individual elements from that underlying collection of data. And its keeping track of which ones up next using this little tracking value also all bundled up on this return next element function.

[00:20:25]
I think it's very, very beautiful. We'll talk about this in a second. But I think it's very beautiful that you can have a function return next element that has everything you need. It has the ability when called to return our next element. It has bundled on it, the underlying data that it knows to extract from.

[00:20:41]
And it has bundled on it, the information about what next element to return out. All bundled up in a single function. That's a very, very beautiful design. Alright, let's have thumbs, and one of the thumbs on media might be, what do we call the backpack of data? Everybody's thumbs out.

[00:21:01]
You lost me, I'm clear, I have clarifications. Everyone's thumbs out and proud. Everyone knows what a backpack's called. No one has medium thumbs? All right.
>> Alec: It's backpack [INAUDIBLE]
>> Will Sentance: Good, good job, Alec.

