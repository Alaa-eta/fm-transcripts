[00:00:03]
>> Will Sentance: Now we move on to iterators. Okay, iterators. Iterators, I said at the very start that we run or we write and run code, what we're typically doing is taking data, storing it, and then functionality that we then apply to that data. Even as simple as I have a score for a player, and I increase that score.

[00:00:31]
Functionality onto data. We call our live data that's stored in our application our state. That just means the labels and the data, the values currently in our application at that moment. But that kind of masks a small part that's actually pretty significant a lot of the time, which is I have my data.

[00:00:49]
I have my functionality, but often my data is a collection of data, maybe an array, a list of data, or a set of data, or a map of data, or an object containing a bunch of properties with data. It's rarely a single element. So actually the process of accessing each of our elements from a collection of data is in itself a task.

[00:01:12]
The data's just not there which we can apply functionality to, we have to go and access that data. And in arrays, we do it using indexes to grab the individual element. We sort of have a static collection of data, and go and grab an element, and actually, that's not a small process in its own right.

[00:01:28]
But it's kind of, and we'll play that out here with a for loop, and we'll discover that actually it's not the most, I think, beautifully designed process. It's not clear that that's the best and necessary, most of the time, when I'm accessing my data, I know I just want my element and I want the next element, and I want the next element.

[00:01:52]
I don't really care about how I go about getting those elements. So wouldn't it be amazing if we could rethink collections of data as instead a sort of stream of elements coming towards me that I could call a function. I could run a function that's just gonna instantly return me the next element from my stream, my flow, of data.

[00:02:15]
So I would run a function. It would return out the next element from my flow. I'd run it, return the next element from my flow. Rethink my data not as a static collection I've got to go and manually get each element in order to run functionality on it.

[00:02:29]
But it said flip and say my data's there and I'm actually gonna have access to it by running a function which kinda turns on the flow of the next element of my data. And that is a paradigm shift in how we think about applying functionality to our data.

[00:02:44]
No longer is there the intermediate step of getting the elements, manually going into the data collection and grabbing the next element. That's not a small thing, and it's not a necessary step, when most of the time all I want is my next element in order. So why not instead rethink my process as being applying functionality to data as the data being given to me, element by element from a sort of flow of that data.

[00:03:12]
Before we see that beautiful new way of thinking about our collections of data and getting them so we can apply functionality to them. We're getting them element by element, one by one. Before we do that we're gonna see the old version where we have a list of data and we're gonna manually go and grab each element.

[00:03:28]
[INAUDIBLE] a beautiful new way of thinking about this using each element one by one but let's first see and by the way it's gonna show us just how kind of imperative procedural, bit by bit, kind of exactly how we're gonna do this, this old fashioned method is. Gives us really manual, fine grain control but at the expense of a clean, readable code.

[00:03:52]
And also at the expense of, I think, a cleaner way for ourselves of thinking of our data as these flows of data. Rather than static collections that we go and grab, element by element. So let's first just at least see this traditional way, and I think it's gonna show us we want a better way.

[00:04:09]
But here's our traditional way, and I'm going to try and diagram this but part of the point to say is that diagramming for loops is an odd, odd thing to do, honestly. When we think about most of our code, we run execution context to run functionality. But our for loops are these funny little things that happen kind of in isolation of our regular way of thinking about code.

[00:04:38]
But there we go. All right, line one, James, what are we doing?
>> James: [COUGH] Declaring a constant called numbers.
>> Will Sentance: Numbers.
>> James: And assigning it a new array containing the values 4, 5, 6.
>> Will Sentance: Excellent, James, spot on. Now, here comes my favorite bit, diagramming for loops. All right, here we go.

[00:05:03]
Check,
>> Will Sentance: This,
>> Will Sentance: Do This. Okay, you can already see why these are problematic, but check this. So what's the check we're gonna do is i less than numbers.length, okay. Is i, which initiated to 0, less than numbers.length which is 3.
>> Will Sentance: Okay, which is 3, and since less it is and therefore do this which is console.log numbers,

[00:05:46]

>> Will Sentance: At position i and then i++. That's our for loop tried to be written up in a slightly more logical sense than the kind of weird check this, do the code, come back, do this, check this, the weird circular flow of an actual for loop. Okay, so, i less than 3 so we are gonna do this.

[00:06:09]
What is numbers at this point, Michelle?
>> Michelle: So numbers is the array 4, 5, 6.
>> Will Sentance: Yep, and what is i at this point?
>> Michelle: I is zero.
>> Will Sentance: Zero, already, I'm liking to hear the hesitation. That's enough to tell us there might be a nicer way. So position zero of numbers is, Michelle?

[00:06:30]

>> Michelle: 4.
>> Will Sentance: 4, excellent.
>> Michelle: Sorry, I couldn't tell if that was four or nine.
>> Will Sentance: Next thing to do is i++. We're gonna increment i to 1. Is 1 less than 3? Yes it is, so we come back down here. Now we get in position 1 of numbers which is?

[00:06:45]

>> James: 5.
>> Will Sentance: 5, good. 5 plus what incremented to 2. 2 less than 3, yes. We come back down here now, now i is what, Victor?
>> Victor: It'll be 6.
>> Will Sentance: So.
>> Victor: I'm sorry.
>> Will Sentance: Perfect, thank you.
>> multiple: [LAUGH]
>> Will Sentance: You see, thank you Victor. I is 2.

[00:07:06]
2, so numbers position 2 is?
>> Victor: 6.
>> Will Sentance: 6, so we console.log 6, i++ is 3, 3 less than 3, no it's not. So we come out of our for loop. Okay, this is the best you can diagram a for loop, I think. Honestly, just saying the conditions and still,

[00:07:26]

>> Will Sentance: We had a, thank goodness for you to make that mistake. Thank you, ma'am. We're so busy figuring out how to access that we can't focus on what we wanna do. And by the way we're gonna discover, if we rethink our collections of data as flows of data, where we grab element by element.

[00:07:44]
We can dynamically control those flows of data. We can even set those flows of data. We can set what our next element in our flow of data is gonna look like based on things that have happened in previous elements after they've been returned out. Rethinking our collections of data as instead flows of elements we want to grab one by one.

[00:08:03]
It's gonna give us control over what those next elements will be. We'll see that a little bit later on, really, really cool. But for now, programs store data and apply functionality to it. There are two parts to applying functionality to collections of data. One, the process of accessing each element, and then two, what we wanna do to each element.

[00:08:23]
Iterators, this new way of thinking about accessing data from collections of data, that means like lists or arrays or whatever. Automate the accessing the element, so we can focus on what we do to each element and make it available in a super smooth way. They make it available so they say, we got a function that when called with parens returns out my next element.

[00:08:44]
Run it again, gives me the next element. Run it again, gives me the next. In other words, the function attached and bundled on it somehow in the background must be our underlying collection of data. Plus also, we must somehow hold on to the information of which element am I currently at, so that we don't give me out the same element each time.

[00:09:06]
But give me out instead the next element. But we know that when a function runs, it never remembers its previous running. Its local memory gets reset every time, right? It's empty, you fill it. So, how the hell am I going to have my function both be able to be run, give me the next element, but also therefore have underlying in it, somehow bundled on it, my underlying array of data that it's grabbing the next element from one by one.

[00:09:31]
And bundled on it the sort of tracking variable that's tracking which element have I already given out, so I know which one to give out next. How am I gonna bundle that all up? Imagine if we could create a function that stored the numbers, and each time we ran the function, it would return out our next element from numbers.

[00:09:52]
Note, you'd have to remember which element was next up somehow. That means between the function's invocations, runnings, it would somehow have to remember what was the last element that was passed out. Hm, but if we could do it, this would let us think about array, our list, 4, 5, 6, as a stream, a flow of data with our function returning out the next element and then the next element.

[00:10:16]
Did everyone get this bit yet, in the next segment that I say sometimes? This makes our code more readable, and we'll see in a minute, more functional. But it all starts with us returning a function from another function. Because all the most beautiful elegant things, elegant things in JavaScript, begin with us returning a function from another function.

[00:10:37]
Cuz that's gonna give our function that's returned out superpowers. My favorite feature in JavaScript is going to be revealed right now. But folks, also I'm gonna stress to you, do not get complacent about what this code is doing. This code throws the most seasoned engineers, unless we're super precise, line by line.

[00:10:57]
And remember that we never return to previous lines of code. We always finish a line of code. We're done with it. We store whatever was the result of the right hand side in memory, and we move on. Just wanna start off by saying, okay.
>> Will Sentance: So line 1, Blessing, what are we doing in line 1?

[00:11:21]

>> Blessing: We're defining a function, creating a function, [CROSSTALK].
>> Will Sentance: Excellent, excellent, very clear. Create new function, mm-hm, quite the right casing. And you go create new function sorting global memory, next line up, Josh.
>> Will Sentance: So we grab the whole create new function sorting memory, what's that next line?

[00:11:49]

>> Josh: Is it the declare the constant of the new function?
>> Will Sentance: You're spot on.
>> Josh: As the function createNewFunction.
>> Will Sentance: Yeah, exactly. We are not immediately gonna go and createNewFunction. Even though it's got another function inside, we do not go inside. That's only gonna be reached if we call createNewFunction.

[00:12:07]
How do I call createNewFunction, Sean?
>> Sean: Parentheses.
>> Will Sentance: Parenthesis, excellent. I will never go inside, otherwise. In fact, if I never call createNewFunction, that code inside of there will never be defined, that stuff will never be saved. The overall description of the function body is save. Think of it almost like a kind of a string of things that would be done later on, a string of instructions to be done later on.

[00:12:30]
All right, good, we declare newFunction. You gotta get this piece down, this is almost an interlude. This is us understanding what happens when I return a function for another function in order, the hard piece to follow, follows naturally. All right, new function's declared, it's gonna be the return value of calling createNewFunction.

[00:12:51]
Sony, if I took the parens off the createNewFunction, I have just const newFunction = createNewFunction(), what would I be storing in newFunction?
>> Tony: Build new function.
>> Will Sentance: Spot on, the entire createNewFunction definition. I would have just newFunction as another label for createNewFunction. It wouldn't be a copy, it would just be another label for that underlying function stored in memory.

[00:13:14]
Very good, Sony, but we're not doing that. Instead, we're saying go run createNewFunction, see what comes back, and that's what's gonna be stored in NewFunction. Let's do it, new,
>> Will Sentance: I'll find it,
>> Will Sentance: Aha, NewFunction is the return value, the output, of calling createFunction. And remember, it could be anything, whatever comes out.

[00:13:48]
It could be a number, an object, it could be a function in JavaScript. So let's create. Everybody together, when we start start a studio function, we create a new?
>> multiple: Execution context.
>> Will Sentance: Rick, I'm watching. We create a new?
>> Rick: Execution context.
>> Will Sentance: That's too fast, you need to be more measured.

[00:14:10]
A new execution context, yes, don't sound like a cult unless you do it in a sing-songy voice. That is a sign, and actually I shouldn't make those sort of jokes. Good,
>> Will Sentance: I hope you all feel,
>> Will Sentance: That you can leave at any time, no, okay, this is not funny.

[00:14:32]
This is not funny, all right, good. Okay, so createNewFunction is called, what's the first thing we do inside its memory, Michelle?
>> Michelle: We create a new function called add 2.
>> Will Sentance: Excellent, there it is. I'm gonna do this function inside a different color. Add2,
>> Will Sentance: Here it is.

[00:14:55]

>> Will Sentance: There it is, where's my nice new green pen?
>> Will Sentance: Okay, add2 is this function. Okay, JavaScript is literally storing the whole functionality associated with the label add2. Do we call that label, do we call that function? Are we gonna invoke that function, Abdi?
>> Abdi: Give me the question one more time.

[00:15:14]

>> Will Sentance: Are we gonna invoke, are we gonna execute add2 at this point?
>> Abdi: No.
>> Will Sentance: What are we doing instead, Abdi?
>> Abdi: We are going down to return add2.
>> Will Sentance: Excellent, return the entire function definition, whose current label is add2. But we're not returning add2. We're returning the function that has the label add2.

[00:15:36]
When JavaScript sees the word return add2, it goes add2. Let me go look in memory what I stored in that label. It's this function, perfect. So return out that entire function definition, the whole thing, that is literally the words, function, parens, num, curly braces, return num plus 2.

[00:15:58]

>> Will Sentance: And it's returning all of that function out, and it's gonna store it where, Victor? In what global variable or global label is it gonna store it?
>> Victor: Under new function.
>> Will Sentance: Exactly, there it is, under new function. It used to be called, named add2, not anymore, but is still that functionality in memory.

[00:16:20]
We've just posted out, not copied it out, is the underlying function. We just posted out and given a new global label. New function. Perfect, by hitting the return statement, what happens is the execution context factor? When we hit the return statement of an execution context with a function-

[00:16:37]

>> Victor: It goes away.
>> Will Sentance: It goes away. It turns back call stack and gets popped off the call stack, but it's deleted. All the stuff in it that's not returned out, it's deleted, but the function got returned out through deleted. You'll give it a new label out here, so it's not deleted.

[00:16:50]
Remember, posh word for deleting stuff from memory is, was it deleting stuff when we close out context is automatic garbage. Anything that wasn't gonna be used out here is garbage, wasted memory, collection. All right, good. So we're back out now, in the global execution context. The last line with new function is going to be the output of create function, which it is.

[00:17:13]
There it is, the output was a new function called add2. Well, it was called add 2 in here, now it's just the definition of add2 in the new label. So if I want to now run, call, invoke, Ben, that in or add to function out here, what label do I use for it out here?

[00:17:27]

>> Ben: New function.
>> Will Sentance: New function, excellent. And how do I run, call, invoke new function?
>> Ben: Parentheses.
>> Will Sentance: Parenths, and because if I look at the definitions. Now, we visibly
>> Will Sentance: Visibly? We as developers, we've got to look back at the definition of add2. JavaScript is not doing that.

[00:17:47]
It literally passed the definition out and stored it in a new function. So it's gonna look in new function for the definition of add2. And what does it see it needs to receive, Ben?
>> Ben: An argument.
>> Will Sentance: Exactly, an argument, so let's put, I don't know, 3. And we're gonna store the result calling new function in-

[00:18:05]

>> Ben: Results.
>> Will Sentance: In result, excellent. So Paul, we're gonna create this plan new, box. What are we gonna create? When we enter the function.
>> Paul: A local execution context.
>> Will Sentance: Excellent, there it is. Into it we go, and pull what's the first thing in our memory? Or the first pairing?

[00:18:26]

>> Paul: The parameter.
>> Will Sentance: Which is?
>> Paul: Called num.
>> Will Sentance: Excellent.
>> Paul: And it's assigned to the integer 3.
>> Will Sentance: Yeah, and so be really clear, I know I've said this already, but do not think that JavaScript, when it sees new function is going, what's new function? I better go and check the line before.

[00:18:43]
Always create new functions outward. The line before will never be returned to. The line before create and execution context inside of which it created add2 which returned out restored a new function, and at no point do we ever, ever, ever, ever, do the function ever care about create function again.

[00:19:03]
It only cared about create function in a sense of I don't yet know what restore it needs so I'm undefined while I go and run createFunction, get an actual value, this function, install that function here. Never think that new function is a command to go and run createFunction.

[00:19:20]
It isn't. It's whatever at that moment you've got out of createFunction and that's over. So it's the add two functionality. So when we call a new function on the line below, it is just interested in the add two functionality. It never goes back into create function. Season engineers get muddled about that.

[00:19:37]
Do not let yourself get muddled. If we don't get that clear all the iterator stuff doesn't follow. Okay, so yeah, we can now run new functions. We visually. That's what I'm gonna say, visually, we have to walk back in to see what add to's definition is. I wish we didn't.

[00:19:51]
I wish we could just all the put it out and inspect what new function is, and we'd see that functionality. That's what we're looking at. And you're right. It says num is a parameter and set to 3. Where we are then going to return our 3+2, return out the 5, into what global variable, Paul?

[00:20:08]

>> Paul: Result.
>> Will Sentance: Into result, excellent, there it is.
>> Will Sentance: So thumbs in a second on, I create a function called create new function, I then create a placeholder, and the new function was whatever was going to come out of the bottom. Create new function. Well, what came out of the bottom was an entire function definition add two.

[00:20:28]
Returned out. I now use the new global label new function for that functionality, add2, forming those add two to run it. Pass in three, add 2 to it, get out, 5, and store it in the global constant result. Everyone's thumbs you lost me. I'm totally clear. I have a clarification.

[00:20:46]
Your clarification might just be, why the hell do we do this?
>> multiple: [LAUGH]
>> Will Sentance: Everybody's thumbs out. Okay.
>> Ben: I have a dumb question.
>> Will Sentance: I do not approve of this language.
>> Ben: Okay, I have a question.
>> Will Sentance: You have a smart question that's gonna illuminate things for other people.

[00:21:02]
Go ahead.
>> Ben: Can you actually clone a function?
>> Will Sentance: That's not a dumb question, it is an interesting question. It is a question that we're going to hold on because it's not going to, I can come back to it, if and when we get through this piece on iterators.

[00:21:22]
It is an interesting question, all right. It is an interesting question, but it's not going to enable more understanding of this. If you don't mind me hold on it, ma'am.

