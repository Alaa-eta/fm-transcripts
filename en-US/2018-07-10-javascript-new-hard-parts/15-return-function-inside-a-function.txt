[00:00:03]
>> Will Sentance: Now we move on to iterators, okay. Iterators. Iterators.
>> Will Sentance: I say the very start that when we run or we write and run code, what we're typically doing is taking data, storing it. And then functionality that we then apply to that data, even as simple as I have a score for a player, and I increase that score, functionality onto data.

[00:00:32]
We call our live data that's stored in our application our state. That just means the labels and the data, the values currently in our application at that moment. But that kind of masks a small part that is actually pretty significant a lot of the time, which I have my data.

[00:00:49]
I have my functionality, but often my data is a collection of data maybe an array a list of data or a set of data or a map of it or of an object containing a bunch of properties with data. It's rarely a single element. So actually, the process of accessing each of our elements from a collection of data is in itself a task.

[00:01:12]
The data's just not there which we can apply functionality to. We have to go and access that data. And in erase, we do it using indexes to grab the individual element. We have a static collection of data and go and grab an element. And actually, that's not a small process in its own right.

[00:01:32]
But we'll play that out here with a for loop, and we'll discover that actually it's not the most, I think beautifully designed process, is not clear that that's the best and necessary. Most of the time when I'm accessing my data, I know I just want my element and I want the next element and I want the next element.

[00:01:52]
I don't really care about how I go about getting those elements. So wouldn't it be amazing if we could rethink collections of data as instead a sort of stream of elements coming towards me that I could call a function, I could run a function that's just gonna instantly return me the next element from my stream, my flow of data.

[00:02:15]
So I would run a function, it would return out the next element for my flow. Rethink my data, not as a static collection I've got to go and manually get each element in order to run functionality on it. But instead flip it, my data's there, and I'm actually gonna have access to it by running a function which turns on the flow of the next element of my data.

[00:02:39]
And that is a paradigm shift in how we think about applying functionality to our data. No longer is there the intermediate step of getting the elements, manually going into the data collection and grabbing the next element. That's not a small thing, and it's not a necessary step when most of the time, all I want is my next element, in order.

[00:02:59]
So why not instead rethink my process as being applying functionality to data as a data being given to me, element by element, from a sort of flow of that data. Before we see that beautiful new way of thinking about our collections of data, and getting them so we can apply functionality to them, or getting them element by element, one by one.

[00:03:21]
Before we do that, we're going to see the old version, but we have a list of data, and we're gonna manually go and grab each element. Beautiful new way of thinking about this, using each element one by one, but let's first see, and by the way, it's gonna show us just how kind of imperative procedural bit by bit, kind of exactly how we're gonna do this, this old-fashioned method is.

[00:03:45]
It gives us really manual, fine-grained control, but at the expense of a clean, readable code, and also at expense of, I think, a cleaner way for ourselves of thinking about data as these flows of data, rather than static collections that we go and grab element by element. So let's first just at least see this traditional way, and I think it's gonna show us, we want a better way.

[00:04:09]
But here's our traditional way. And I'm gonna try and diagram this, but part of the point to say is that diagramming for loops is an old, old thing to do, honestly. When we think about most of our code, we run execution context around functionality. But our for loops, and these funny little things that happen kind of an isolation about regular way of thinking about code.

[00:04:38]
There we go, all right. Line one. James, what are we doing?
>> James: We're declaring a constant called numbers.
>> Will Sentance: Numbers.
>> James: And assigning it a new array containing the values 4, 5, 6.
>> Will Sentance: Excellent, James, spot on. Now here comes my favorite bit diagramming for loops. All right, here we go.

[00:05:03]
Check this.
>> Will Sentance: Do this. Hey, you can already see why these are problematic. But check this, who wants to check we're gonna do is i less than numbers.length, okay. Is i, which is initiated to zero, less than numbers.length which is three. Okay, which is three, this is less, it is.

[00:05:35]
And therefore, do this which is console.log(numbers[i]). And then. That's our for loop, try to be written up in a slightly more logical sense than the kind of weird check this, do the code, come back, do this, check this, a weird circular flow of an actual for loop. Okay, so i is less than 3, so we are gonna do this.

[00:06:09]
What is numbers at this point, Michelle?
>> Michelle: So numbers is the array 4, 5, 6.
>> Will Sentance: Yeah, and what is i at this point?
>> Michelle: i is 0.
>> Will Sentance: 0, already I'm liking to hear the hesitation. That's enough to tell us there might be a nicer way. So position zero of numbers is, Michelle?

[00:06:30]

>> Michelle: 4, sorry.
>> Will Sentance: 4, excellent.
>> Michelle: I couldn't tell if it was 4 or not.
>> Will Sentance: Next thing to do is i++. We're gonna increment i to 1, is 1 less than 3? Yes, it is. So we come back down here. Now we're getting position one of numbers which is?

[00:06:45]

>> Michelle: 5.
>> Will Sentance: 5. Good 5 plus 5, increment it to 2. 2 less than 3, yes we come back down here. Now, i is what, Victor?
>> James: It will be 6.
>> Will Sentance: Perfect, thank you-
>> James: [LAUGH]
>> Will Sentance: Thank you, Victor, i is?
>> James: 2.
>> Will Sentance: 2, so numbers position 2 is?

[00:07:07]

>> James: 6
>> Will Sentance: 6. So we come to a log 6, i++. 3, is 3 less than 3? No it's not. So we come out of our for loop. Okay, this is the best you can dial on a for loop I think. Honestly, just saying the conditions and still, we had a, thank goodness we didn't make that mistake.

[00:07:28]
Thank you, ma'am. Because that, we're so busy figuring out how to access that we can't focus on what we wanna do. And by the way, we're gonna discover, if we rethink our collections of data as flows of data where we grab element by element, we can dynamically control those flows of data.

[00:07:48]
We can even set those flows of, we can set what our next element in our flow of data is going to look like based on things that have happened in previous elements or if they've been returned out. Rethinking our collections of data as instead flows of elements we want to grab one by one.

[00:08:03]
Is gonna give us control over what those next elements will be. We'll see that a little bit later on, really, really cool. But for now, program store data and apply functionality to it. The two parts to apply functionality to collect the data. One, the process of accessing each element, and then two, we wanna do to each element.

[00:08:22]
Iterators, this new way of thinking about accessing data, from collections of data, that means like lists or arrays or whatever, automate the accessing the element. So we can focus on what we do to each element, and make it available in a super smooth way. They make it available, so they say, we've got a function that when called with parens returns out my next element.

[00:08:43]
Run it again, gives me the next element. Run it again, gives me the next. In other words, the function attached and bundled on it somehow in the background must be our underlying collection of data. Plus also you must somehow hold onto the information of which element am I'm currently at, so we don't give me out the same element each time, but give me out instead the next element.

[00:09:07]
But we know that when a function runs, it never remembers its previous running. Its local memory gets reset every time, right? So it empties, you fill it. So how in the hell am I going to have my function both be able to be run, give me the next element, but also therefore have underlying in it, somehow bundled on it?

[00:09:27]
My underlying array of data that it's grabbing the next element from one by one. And bundled on it the sort of tracking variable that's tracking which element have I already given out so I know which one to give out next. How did I bundle all of that up?

[00:09:42]
Imagine if we could create a function that stored the numbers, and each time we ran the function it would return out our next element from numbers. Note you'd have to remember which element was next up somehow. That means between the function's invocations, runnings, we still have to remember what was the last time that was passed out?

[00:10:02]
Hm. But if you can do it this would let us think about array a list four, five, six as a stream, a flow of data, with our function returning out the next element and then the next element. Did everyone get this bit yet and the next element? Did I say this enough times?

[00:10:18]
This makes our code more readable and we'll see in a minute more functional. But it all starts with us returning a function from another function. Because all the most beautiful elegant things in JavaScript begin with us returning a function from another function. Cuz that's gonna give our function that's returned out super powers.

[00:10:41]
My favorite feature in JavaScript is going to be revealed right now. But also I'm gonna stress to you, do not get complacent about what this code is doing. This code throws the most seasoned engineers unless we're super precise line by line. And remember that we never return to previous lines of code.

[00:11:03]
We always finish a line of code, we're done with it, we store whatever was the result on the right side in memory and we move on. So I just wanted to start off by saying. Okay, so, line one. Blessing, what are we doing in line one?
>> Blessing: By defining a function, create new function.

[00:11:23]
So [INAUDIBLE] memory.
>> Will Sentance: Excellent, excellent. Very clear, create new function. Mm-hm, quite the right casing. There you go, create new function, store it in global memory. Next line up. Josh?
>> [INAUDIBLE]
>> Will Sentance: So we grab the whole create new function, stored it in memory. What's our next line?

[00:11:48]

>> Josh: Is it declare the constant of a new function?
>> Will Sentance: Yes, spot on.
>> Josh: Is the function create new function?
>> Will Sentance: Yeah, exactly. We are not immediately gonna go and create a new function. Even though its got another function side we do not go inside. That's only gonna be reached if we call createNewFunction.

[00:12:07]
How do I call create new function, Shawn?
>> Shawn: Parenthesis.
>> Will Sentance: Parenthesis, excellent. I will never go inside, otherwise. In fact, if I never call createNewFuction, that code inside of there would never be defined, that stuff would never be saved. The overall description of the function body is saved, think almost of a kind of a string of things that would be done later on.

[00:12:29]
A string of instructions to be done later on. All right, good, we declare a new function. You gotta get this piece down, it's almost an interlude. This is us understanding what happens when I return a function from another function in order the hard piece to follow, follows naturally.

[00:12:44]
All right, new function's declared, it's gonna be the return value of calling CreateNewFunction. Sony if I took the parens off The createNewFunction. I had just const newFunction = createNewFunction(). What would I be storing in newFunction?
>> Shawn: The createNewFunction.
>> Will Sentance: Spot on, the entire createNewFunction definition. I would have just newFunction is another label for createNewFunction.

[00:13:10]
Wouldn't be a copy. It would just be another label for that underlying function stored in memory. Very good, Sonny. But we're not doing that. Instead we're saying, go run, createNewFunction, see what comes back. And that's what's gonna be sorting new function. Let's do it, new,
>> Will Sentance: Ha, new function is the return value, the output, of calling create function.

[00:13:46]
And remember it could be anything, whatever comes out, it could be a number, an object, it could be a function in JavaScript. So let's create, everybody together. When we start executing a function, we create a new?
>> James: Execution context. [LAUGH]
>> Will Sentance: Rick, you're watching. We create a new?

[00:14:05]

>> Rick: Execution context.
>> Will Sentance: That's too fast, you need to be more measured. A new?
>> Rick: Execution context.
>> Will Sentance: Yes, don't sound like a cult unless you do it in a sing-songy voice. That is a sign, actually I shouldn't make that sort of jokes. Good, I hope you all feel

[00:14:28]

>> Will Sentance: But you can leave it any time. No, okay this is, okay this is not funny. This is not funny. All right. Good okay. So CreateNewFunction is called what's the first thing we do inside its memory, Michelle?
>> Speaker 8: We create a new function called aditude.
>> Will Sentance: Excellent, there it is.

[00:14:44]
I'm gonna do this function aside from a different color @2.
>> Will Sentance: Here it is.
>> Will Sentance: Here it is. [INAUDIBLE] Where's my nice new green pen?
>> Will Sentance: Okay, @2 is this function. Okay, JavaScript is literally storing the whole functionality associated with the label @2.
>> Will Sentance: Do we call that function?

[00:15:10]
We have to invoke that function, Abdi?
>> Abdi: What question was that?
>> Will Sentance: Are we going to envoke, execute add to at this point?
>> Abdi: No.
>> Will Sentance: What are we doing instead, Abdi?
>> Abdi: We are going down to return @2.
>> Will Sentance: Excellent, return the entire function definition whose current label is @2, but we're not returning @2, we're returning the function that has the label add two.

[00:15:35]
When JavaScript sees the label return add two, it goes @2, let me go look in memory what I stored in that label. It's this function, perfect. So return out that entire function definition, the whole thing, that is literally the words function, parens, num, curly braces, return num plus two.

[00:15:56]
And it's returning all of that function out, and it's gonna store it, where Victor? In what global label is it store it?
>> Abdi: New Function.
>> Will Sentance: Exactly, there it is under New Function. It used to be called name add2, not anymore, but it is still that functionality in the memory.

[00:16:20]
We've just post it out, not copied it out, it's the underlying function. We just post it our and give it a new global label New Function, perfect. By hitting the return statement, what happens is execution context vector? When we hit the return statement of an execution context with a function?

[00:16:37]

>> Abdi: It goes away.
>> Will Sentance: It goes away. In terms of our call stack, it gets popped off the call stack, but it's deleted. And all the stuff in it that's not returned out is deleted, but the function got returned out so it ain't deleted. Gonna give it a new label out here, so it's not deleted.

[00:16:50]
Remember a posh word for deleting stuff from memory is, or is it deleting stuff when we close an execution context is, automatic garbage. Anything that wasn't gonna be used out here is garbage, wasted memory, collection, all right. Good, so we're back out now in the global execution context.

[00:17:08]
The last line with New Function is gonna be the output of create function, which it is? There it is, the output was a New Function called add2. Well, it was called add2 in here, now it's just the definition of add2 in the new label. So if I wanna now run, call, invoke, Ben, that inner add2 function out here, what label do I use for it out here?

[00:17:27]

>> Ben: New Function.
>> Will Sentance: New Function, excellent. And how do I run, call, invoke New Function?
>> Ben: Parenthesis.
>> Will Sentance: Parenthesis, and because if I look at the definition, now we visibly
>> Will Sentance: We as developers, we're gonna look back to the definition of add2. JavaScript is not doing that. It literally passed the definition out, and sought it a New Function.

[00:17:51]
So it's gonna look a New Function for the definition of add2. And what does it see it needs to receive, Ben?
>> Ben: An argument.
>> Will Sentance: Exactly, an argument. So let's put ( 3 ) and we're gonna store the result of calling New Function in?
>> Ben: Result.
>> Will Sentance: In result, excellent.

[00:18:07]
So Paul, we're gonna create at this point a new box. What are we gonna create when [CROSSTALK] we execute a new function?
>> Ben: [INAUDIBLE] Your local execution context?
>> Will Sentance: Excellent, there it is. Into it we go and Paul, what's the first thing in our memory? Or the first pairing?

[00:18:26]

>> Paul: The parameter?
>> Will Sentance: Which is?
>> Paul: It's called num.
>> Will Sentance: Excellent.
>> Paul: And it's assigned to the integer 3.
>> Will Sentance: Yeah, and folk, be really clear, I know I've said this already. But do not think that JavaScript, when it sees New Function, is going, what's New Function? I'd better go and check the line before, it's create New Functions.

[00:18:44]
But uh-huh, the line before will never be returned to. The line before creates an execution context inside of which it created add2 was return out, stored in New Function. And at no point do we ever, ever, ever, ever, does the function ever care about create function again. It only cared about create function in the sense of I don't yet know what it's storing me, so I'm undefined.

[00:19:08]
While I go and run createFunction, get an actual value, this function, and store that function here. Never think that it's like, NewFunction is a command to go and run createFunction. It isn't, it's whatever at that moment you got out of createFunction, and that's over. So it's the add2 functionality.

[00:19:26]
So when we call a New Function line below, it is just interested in the add2 functionality. It never goes back into createFfunction. Seasoned engineers get muddled about that. Do not let yourself get muddled. If we don't get that clear, all the iterated stuff doesn't follow. Okay so yeah, we can now run New Function.

[00:19:44]
We visually, visually, that's what I meant to say, visually we have to look back in to see what add2's definition is. I wish we didn't, I wish we could almost literally pull it out and inspect what New Function is and we'd see that functionality. That's what we're looking at.

[00:19:56]
And you're right, it says num is the parameter and set to 3. Where we are then going to return out 3 + 2, return out the 5 into what global variable, Paul?
>> Paul: The result.
>> Will Sentance: Into result, excellent, there it is.
>> Will Sentance: So in a second on, I create a function called createNewFunction.

[00:20:18]
I then create a placeholder, New Function, that was gonna be whatever came out the bottom of running createNewFunction. Well what came out of the bottom was an entire function definition, add2 or turned out. I now used the new global label New Function for that functionality add2, formally known as add2 to run 8 passing (3), add2 to it, get out 5 and store it in the global, constant results.

[00:20:42]
Everyone's thumbs if you lost me I'm totally clear, I have a clarification. Your clarification might just be, why the hell do we do this?
>> James: [LAUGH]
>> Will Sentance: Everybody's thumbs out, okay.
>> James: I have a dumb question.
>> Will Sentance: Go ahead, Victor, I do not approve of this language.
>> James: Okay.

[00:20:59]

>> Will Sentance: You have a smart question that's gonna illuminate things for other people, go ahead.
>> James: Can you actually clone a function?
>> Will Sentance: It's not a dumb question, it is an interesting question. It is a question that we're going to hold on because it's not going to, we can come back to it if and when we get through this piece.

[00:21:22]
It is an interesting question, all right. It is an interesting question but it's not going to enable anymore on deciding any of this. If you don't mind me holding it mam.

