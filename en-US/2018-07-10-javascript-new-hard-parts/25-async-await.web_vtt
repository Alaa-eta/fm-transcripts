WEBVTT

1
00:00:04.040 --> 00:00:09.234
&gt;&gt; Will Sentance: Async Await
simplifies this entire process.

2
00:00:09.234 --> 00:00:16.310
Async/await, I would say finally fixes the
inversion control problem of callbacks.

3
00:00:16.310 --> 00:00:17.380
Actually, this does as well.

4
00:00:18.985 --> 00:00:22.500
Async/await we're not gonna need

5
00:00:23.770 --> 00:00:28.990
to have a function here that
triggers the return back

6
00:00:28.990 --> 00:00:34.000
into the generator functions
execution context, the createFlow.

7
00:00:34.000 --> 00:00:35.520
We're not gonna need that anymore.

8
00:00:35.520 --> 00:00:40.720
Instead, what's gonna be triggered from
here is just come straight back in here.

9
00:00:40.720 --> 00:00:41.690
With a return value.

10
00:00:42.910 --> 00:00:46.290
No more triggering of that
happening via another function.

11
00:00:46.290 --> 00:00:49.500
We're gonna work through it line by line,
and this is our final code.

12
00:00:49.500 --> 00:00:53.846
We're running slightly long,
this is our very,

13
00:00:53.846 --> 00:01:00.373
very final code of all of hard parts,
all of the beauty of asynchronicity.

14
00:01:00.373 --> 00:01:02.616
By the way though,
can we just appreciate for a second,

15
00:01:02.616 --> 00:01:04.164
appreciate yourselves for a second.

16
00:01:04.164 --> 00:01:08.633
You've incorporated
into your mental model,

17
00:01:08.633 --> 00:01:13.110
every hard part of
the JavaScript engine here.

18
00:01:14.190 --> 00:01:18.150
The entire web browser features part,
the micro-task queue, the only person who

19
00:01:18.150 --> 00:01:22.970
talks about microtask queue really is
a guy called Jake Archibald, truly gifted.

20
00:01:22.970 --> 00:01:24.590
I highly recommend him.

21
00:01:24.590 --> 00:01:30.340
Brilliant British speaker
who's a developer at Google.

22
00:01:30.340 --> 00:01:35.730
Truly gifted explainer of concepts and
sharer of entertaining,

23
00:01:35.730 --> 00:01:40.180
humble anecdotes,
as is the wont of my people.

24
00:01:41.230 --> 00:01:45.739
And he talked about the Microsoft queue,
the only person who does.

25
00:01:46.910 --> 00:01:48.892
That's how advanced this stuff is.

26
00:01:48.892 --> 00:01:55.526
And you've combined all that with
a feature of JavaScript just got released.

27
00:01:55.526 --> 00:01:58.310
Generated async/await.

28
00:01:58.310 --> 00:01:59.640
And you built async/await from scratch.

29
00:01:59.640 --> 00:02:01.020
This is async/await built.

30
00:02:01.020 --> 00:02:03.430
If you get a senior dev interview,
the question is gonna come up more and

31
00:02:03.430 --> 00:02:04.700
more I think.

32
00:02:04.700 --> 00:02:07.160
Can you build async/await from scratch?

33
00:02:08.560 --> 00:02:09.060
We just did it.

34
00:02:10.220 --> 00:02:13.120
We just built async/await from scratch.
&gt;&gt; Speaker 2: We just built React Saga,

35
00:02:13.120 --> 00:02:15.620
basically.
&gt;&gt; Will Sentance: Even better,

36
00:02:15.620 --> 00:02:17.790
we just built React Saga from scratch.

37
00:02:17.790 --> 00:02:18.840
Let's try and

38
00:02:18.840 --> 00:02:21.130
inflate our achievement even more.
&gt;&gt; Speaker 2: [LAUGH]

39
00:02:21.130 --> 00:02:22.580
&gt;&gt; Will Sentance: We just built

40
00:02:22.580 --> 00:02:24.440
the JavaScript engine from scratch.
&gt;&gt; Speaker 2: [LAUGH]

41
00:02:24.440 --> 00:02:25.550
&gt;&gt; Will Sentance: There we go.

42
00:02:25.550 --> 00:02:28.100
I feel particularly proud of all of you.

43
00:02:28.100 --> 00:02:32.930
All right, so we're gonna do this
though final code is going to be

44
00:02:34.760 --> 00:02:38.645
doing the nicely prettily
wrapped version of this,

45
00:02:38.645 --> 00:02:44.510
using the async/await or
the async function decoration style,

46
00:02:44.510 --> 00:02:53.380
which is going to just prettify
this slightly more for us.

47
00:02:53.380 --> 00:02:55.530
And this is our final code.

48
00:02:55.530 --> 00:03:01.100
I gotta say, I guess I'm just
feeling exhaustion when I'm.

49
00:03:01.100 --> 00:03:07.270
For the first time, my beautiful people,
for the first time we are able to

50
00:03:07.270 --> 00:03:14.440
return back into a function's
execution context after we've left it.

51
00:03:14.440 --> 00:03:20.310
We'll be able to do so
using our returnNextElement.next method,

52
00:03:20.310 --> 00:03:25.140
that guides us back into
the createFlow's execution context.

53
00:03:25.140 --> 00:03:33.010
We manually do so using our next
method core, which was triggered.

54
00:03:33.010 --> 00:03:38.170
By the triggering of our do
when data received callback.

55
00:03:38.170 --> 00:03:43.150
That was attached to our
future data promise object.

56
00:03:44.740 --> 00:03:50.130
But this flow, inwards and
outwards, and it gets complex.

57
00:03:50.130 --> 00:03:57.660
And so JavaScript gives us a,
async function that's gonna automate

58
00:03:57.660 --> 00:04:03.090
that process of going back
into the createFlow function.

59
00:04:03.090 --> 00:04:07.840
It's gonna say don't worry, we don't
have to trigger going back into it.

60
00:04:07.840 --> 00:04:11.140
Instead, we're gonna go
automatically back into it.

61
00:04:11.140 --> 00:04:16.600
We're gonna pass the response
object value back in,

62
00:04:16.600 --> 00:04:22.300
as the evaluated result
of the yield expression,

63
00:04:22.300 --> 00:04:25.800
and store that straight in data.

64
00:04:25.800 --> 00:04:32.850
It's gonna simplify all of this code for
us with the help of the async functions.

65
00:04:32.850 --> 00:04:35.700
Async/await simplifies all of this and

66
00:04:35.700 --> 00:04:41.480
finally cleans out our inversion
of control problem of callbacks.

67
00:04:41.480 --> 00:04:46.900
We're gonna see that now, for
the first time we don't define a task to

68
00:04:46.900 --> 00:04:52.430
be done beyond our control much later on,
instead we're gonna go into createFlow,

69
00:04:52.430 --> 00:04:55.800
set up some work,
set up a task that takes a long time.

70
00:04:55.800 --> 00:05:00.120
That is our speaking to the web
browser that speaks to the internet,

71
00:05:00.120 --> 00:05:03.560
gets our tweet, 200 milliseconds,
brings it back.

72
00:05:03.560 --> 00:05:07.290
And then we're gonna somehow
get back into createFlow,

73
00:05:07.290 --> 00:05:11.370
to continue running our code sequentially.

74
00:05:11.370 --> 00:05:14.060
No need for triggered function on
the promise resolution, and so

75
00:05:14.060 --> 00:05:17.624
we auto trigger the resumption
of the createFlow execution.

76
00:05:18.850 --> 00:05:22.170
That functionality is still added
to the micro task queue though.

77
00:05:22.170 --> 00:05:24.740
Right, so here we go lessing.

78
00:05:24.740 --> 00:05:25.760
Line one.

79
00:05:25.760 --> 00:05:29.237
What are we doing?
&gt;&gt; Speaker 3: We're going to declare

80
00:05:29.237 --> 00:05:32.500
an async function called createFlow.
&gt;&gt; Will Sentance: Excellent.

81
00:05:32.500 --> 00:05:37.488
createFlow is defined, it is a function,

82
00:05:37.488 --> 00:05:42.752
it is an async,
a brand new type of function,

83
00:05:42.752 --> 00:05:46.926
an asynchronous function, good.

84
00:05:46.926 --> 00:05:52.439
Line two, Blessing.
&gt;&gt; Speaker 3: Are we

85
00:05:52.439 --> 00:05:56.080
going to be invoking the function we just
created which is create from function.

86
00:05:56.080 --> 00:05:57.534
&gt;&gt; Will Sentance: Excellent,

87
00:05:57.534 --> 00:06:01.764
we're gonna invoke createFlow, and

88
00:06:01.764 --> 00:06:08.518
we are going to immediately
enter it's execution context.

89
00:06:08.518 --> 00:06:14.848
Immediately enter it's execution context,
there it is.

90
00:06:14.848 --> 00:06:17.144
And what is the first thing blessing,

91
00:06:17.144 --> 00:06:20.100
that it tells us to do in
this execution context?

92
00:06:20.100 --> 00:06:25.176
Let's say at about 1 millisecond.
&gt;&gt; Speaker 3: To consider log manifest.

93
00:06:25.176 --> 00:06:26.419
&gt;&gt; Will Sentance: Excellent, so

94
00:06:26.419 --> 00:06:30.650
about 1 millisecond,
we hit our console log.

95
00:06:30.650 --> 00:06:33.310
Me first.

96
00:06:33.310 --> 00:06:34.960
So we do go into the crypt.

97
00:06:34.960 --> 00:06:37.740
This is not like our generator function.

98
00:06:37.740 --> 00:06:42.240
We have to trigger going
into using the next method,

99
00:06:42.240 --> 00:06:47.080
the call to the generator function
returned out the next method on that

100
00:06:47.080 --> 00:06:50.230
object, instead we're gonna go
into it directly ourselves.

101
00:06:50.230 --> 00:06:51.430
Just by calling it.

102
00:06:51.430 --> 00:07:00.210
So the first thing we do is indeed
a console log of the string me first.

103
00:07:00.210 --> 00:07:01.710
Perfect.

104
00:07:01.710 --> 00:07:05.250
And in our memory,
what is the next line of code Blessing,

105
00:07:05.250 --> 00:07:09.690
that we are going to encounter?
&gt;&gt; Speaker 3: We declare constant data.

106
00:07:09.690 --> 00:07:11.340
&gt;&gt; Will Sentance: Perfect, there it is,

107
00:07:11.340 --> 00:07:13.580
and for now-
&gt;&gt; Speaker 3: It's undefined.

108
00:07:13.580 --> 00:07:15.160
&gt;&gt; Will Sentance: Undefined, exactly,

109
00:07:15.160 --> 00:07:19.860
so we set data is going to be

110
00:07:19.860 --> 00:07:25.070
the evaluated result of that
expression on the right-hand side.

111
00:07:25.070 --> 00:07:31.150
So there it is on the right hand side,
we say await and

112
00:07:31.150 --> 00:07:37.233
then fetch, ha-ha,
the return of our wonderful,

113
00:07:37.233 --> 00:07:42.487
our final call to our
fetch facade function,

114
00:07:42.487 --> 00:07:47.603
a two pronged function, that in JavaScript

115
00:07:47.603 --> 00:07:52.554
returns out a what, Blessing?
&gt;&gt; Speaker 3: Impromied objects.

116
00:07:52.554 --> 00:07:54.774
&gt;&gt; Will Sentance: Impromised object, but

117
00:07:54.774 --> 00:07:59.960
it also spins out a bunch of
work in the web browser itself.

118
00:07:59.960 --> 00:08:05.341
So let's do the JavaScript piece first,
we are going to return

119
00:08:05.341 --> 00:08:10.213
out a promise object,
just as Blessing said, with two,

120
00:08:10.213 --> 00:08:15.187
we have a few properties, but
two important properties,

121
00:08:15.187 --> 00:08:20.680
value and un-fulfillment,
which is an empty array.

122
00:08:20.680 --> 00:08:23.300
Both right now with nothing
interesting in them yet.

123
00:08:23.300 --> 00:08:26.520
The value is gonna be also filled in

124
00:08:26.520 --> 00:08:30.430
with whatever comes back from the web
browser features background work, and

125
00:08:30.430 --> 00:08:34.590
the own fulfillment array, well we'll
see what's that's going to do here.

126
00:08:36.010 --> 00:08:42.677
Good, but and that object here,
we're gonna hold it here for

127
00:08:42.677 --> 00:08:48.363
now, but in the web browser,
what are we spinning up?

128
00:08:48.363 --> 00:08:56.820
We are spinning up
the background feature XHR.

129
00:08:56.820 --> 00:09:01.040
There it is, XHR is spun up.

130
00:09:01.040 --> 00:09:04.604
And it has some important properties.

131
00:09:04.604 --> 00:09:10.998
The URL, Twitter.com, the path/will/1.

132
00:09:10.998 --> 00:09:12.830
Something like that, whatever it is.

133
00:09:12.830 --> 00:09:15.770
And the type of request we're making.

134
00:09:15.770 --> 00:09:17.254
And it's a git request.

135
00:09:17.254 --> 00:09:20.836
And we are sending off an HTTP.

136
00:09:20.836 --> 00:09:24.805
That's the H in the XHR,

137
00:09:24.805 --> 00:09:30.500
HDP message off to Twitter itself.

138
00:09:30.500 --> 00:09:34.850
Their server.

139
00:09:34.850 --> 00:09:35.640
There it is.

140
00:09:35.640 --> 00:09:38.230
The beautiful Twitter server.

141
00:09:38.230 --> 00:09:41.920
And is it at this moment at
about 1 millisecond Blessing,

142
00:09:41.920 --> 00:09:44.450
is it complete yet?
&gt;&gt; Speaker 3: No.

143
00:09:44.450 --> 00:09:45.680
&gt;&gt; Will Sentance: It is not.

144
00:09:45.680 --> 00:09:47.560
But when our data comes back,
it will be complete.

145
00:09:49.690 --> 00:09:53.280
What do we want to update
on the completion?

146
00:09:53.280 --> 00:09:57.100
We want to update this value property.

147
00:09:57.100 --> 00:10:01.090
Now we have not assigned this
object to any particular place.

148
00:10:01.090 --> 00:10:02.930
It's just a position in memory.

149
00:10:02.930 --> 00:10:06.968
So we know that we are referring
to this object we defined,

150
00:10:06.968 --> 00:10:10.640
its value property.

151
00:10:10.640 --> 00:10:12.810
That's what we're going to update.

152
00:10:12.810 --> 00:10:15.930
We didn't give it a label in JavaScript.

153
00:10:15.930 --> 00:10:20.040
But the web browser knows
where that object is stored.

154
00:10:20.040 --> 00:10:22.890
And that's the value
property is gonna update.

155
00:10:22.890 --> 00:10:24.160
Okay, perfect, good.

156
00:10:25.210 --> 00:10:30.386
And now the all powerful
await is going to throw us

157
00:10:30.386 --> 00:10:36.952
out of our createFlow execution.
&gt;&gt; Will Sentance: Gonna

158
00:10:36.952 --> 00:10:41.360
throw us out of the createFlow
execution context.

159
00:10:41.360 --> 00:10:45.290
You have a very clean eye.

160
00:10:45.290 --> 00:10:48.980
And for that out of our
createFlow execution context,

161
00:10:48.980 --> 00:10:53.243
where we are going to
encounter what line next.

162
00:10:53.243 --> 00:10:56.472
Blessing.
&gt;&gt; Speaker 3: Console.log (me second).

163
00:10:56.472 --> 00:10:59.502
&gt;&gt; Will Sentance: Me second, exactly.

164
00:10:59.502 --> 00:11:04.320
At about let's say maybe 2 milliseconds.

165
00:11:04.320 --> 00:11:06.620
Something like that, about 2 milliseconds.

166
00:11:06.620 --> 00:11:09.520
In other words,
the most important thing we wanted to do

167
00:11:11.890 --> 00:11:17.600
with any asynchronous work, is set up
a task that takes a bunch of time.

168
00:11:17.600 --> 00:11:20.540
That's the web browser feature task.

169
00:11:20.540 --> 00:11:22.600
That doesn't take 200 milliseconds.

170
00:11:22.600 --> 00:11:28.110
Set it up but be able to continue
running our synchronous code afterwards.

171
00:11:28.110 --> 00:11:32.230
But now, do we see to do it we're
stepping out of our function.

172
00:11:32.230 --> 00:11:37.470
And wouldn't it be wonderful if we
could step back in to our function,

173
00:11:37.470 --> 00:11:43.150
to when we get the value from
the request back as a response,

174
00:11:43.150 --> 00:11:44.940
hopefully it's gonna be stored in data,

175
00:11:44.940 --> 00:11:50.220
and we can then continue running our code,
and log that data.

176
00:11:50.220 --> 00:11:53.690
Wouldn't that be wonderful,
let's hope it is possible.

177
00:11:53.690 --> 00:11:58.456
So in JavaScript now,
in JavaScript now we don't really have

178
00:11:58.456 --> 00:12:01.951
much interesting stuff to do, we're done.

179
00:12:01.951 --> 00:12:05.345
We're done.

180
00:12:05.345 --> 00:12:06.500
But, there's our core stack.

181
00:12:07.880 --> 00:12:13.910
But in the background after
about 200 milliseconds,

182
00:12:13.910 --> 00:12:18.070
interesting stuff is happening.

183
00:12:18.070 --> 00:12:19.670
About 200 milliseconds later.

184
00:12:21.340 --> 00:12:26.250
Say 200 more milliseconds,
our background work is complete.

185
00:12:26.250 --> 00:12:30.964
And we get a glorious response.

186
00:12:30.964 --> 00:12:33.360
Pen is already dead.

187
00:12:33.360 --> 00:12:34.930
We got a glorious response.

188
00:12:36.580 --> 00:12:38.210
Let's use red.

189
00:12:42.610 --> 00:12:44.215
A glorious response.

190
00:12:44.215 --> 00:12:47.291
The string hi and

191
00:12:47.291 --> 00:12:52.990
what is that gonna update?

192
00:12:52.990 --> 00:12:59.380
That is gonna update a value property

193
00:12:59.380 --> 00:13:04.740
of the promised object that's being
stored in memory, and referred to its

194
00:13:04.740 --> 00:13:10.010
position in memory from the web browser
feature ready to update that value.

195
00:13:10.010 --> 00:13:13.009
At which point, what are we gonna do?

196
00:13:14.414 --> 00:13:19.450
We are going to trigger, and we can
think of in our own fulfillment array

197
00:13:19.450 --> 00:13:25.910
as effectively the continuation of
our createFlow execution context.

198
00:13:25.910 --> 00:13:31.400
We're gonna trigger at that moment
the continuation of our createFlow

199
00:13:31.400 --> 00:13:36.768
institution context and
at about 201 milliseconds,

200
00:13:36.768 --> 00:13:41.170
re-enter where we effectively paused.

201
00:13:42.690 --> 00:13:48.020
We're gonna get to re-enter and
createFlow back on our call stack

202
00:13:49.350 --> 00:13:53.830
and come back in, and
await was super powerful.

203
00:13:53.830 --> 00:13:55.180
It threw us straight out.

204
00:13:55.180 --> 00:13:57.660
We never even got to
assign anything to data.

205
00:13:57.660 --> 00:13:58.892
That's not a bad thing.

206
00:13:58.892 --> 00:14:03.420
We're hoping that data is gonna
be filled with whatever this

207
00:14:03.420 --> 00:14:05.918
right-hand side evaluates to.

208
00:14:05.918 --> 00:14:09.340
And what does it evaluate it to, Blessing?
&gt;&gt; Speaker 4: Hi.

209
00:14:09.340 --> 00:14:11.820
&gt;&gt; Will Sentance: To the value from

210
00:14:11.820 --> 00:14:16.940
the request of the Internet
that came back with hi.

211
00:14:16.940 --> 00:14:20.690
That is what our await
expression evaluates to, hi.

212
00:14:20.690 --> 00:14:23.550
And we assign it to what label?

213
00:14:23.550 --> 00:14:27.110
To data, exactly.

214
00:14:27.110 --> 00:14:33.025
And so when we hit our next line in
the body of our createFlow function,

215
00:14:33.025 --> 00:14:38.120
console.log(data), data

216
00:14:38.120 --> 00:14:42.940
is going to be evaluated to high and
look at that.

217
00:14:42.940 --> 00:14:47.170
At about 200, no 202 milliseconds,

218
00:14:47.170 --> 00:14:52.820
we get to continue running
the rest of our code.

219
00:14:54.110 --> 00:15:01.282
We get to continue running the rest of
our code inside our createFlow function.

220
00:15:01.282 --> 00:15:06.943
All that work of returning a value or
the response object that

221
00:15:06.943 --> 00:15:13.272
we saw before into the promise object
that we stored in future data.

222
00:15:13.272 --> 00:15:17.912
That we then triggered a do
when data receive function,

223
00:15:17.912 --> 00:15:23.739
that then triggered .next on
the return next element call, or return

224
00:15:23.739 --> 00:15:30.400
its element object next function that
triggered us to go back into createFlow.

225
00:15:30.400 --> 00:15:33.960
All of that automated,

226
00:15:33.960 --> 00:15:37.980
the async function definition is
gonna handle all of that for us.

227
00:15:37.980 --> 00:15:41.390
The await still behaves
similar to a yield, so

228
00:15:41.390 --> 00:15:44.980
await is similar to a yield, that we're
going to hold on storing anything in

229
00:15:44.980 --> 00:15:48.390
the left-hand side until we get something
back from this background work.

230
00:15:48.390 --> 00:15:50.670
But now when the value comes back,

231
00:15:50.670 --> 00:15:54.500
we're just gonna go straight down
in createFlow and store it in data.

232
00:15:54.500 --> 00:16:00.190
This is a beautifully cleaned up version
of that highly complex set up we had,

233
00:16:00.190 --> 00:16:04.440
but we've nevertheless
a very powerful set up.

234
00:16:04.440 --> 00:16:08.630
But now, we have a cleaned up version,
and by the way,

235
00:16:08.630 --> 00:16:14.470
these cleaned up version behind
the scenes, is doing all of this.

236
00:16:14.470 --> 00:16:19.964
So if you want to emulate,
if you wanna emulate the async/await

237
00:16:19.964 --> 00:16:26.480
function definition and call,
we can do it ourselves with generators.

238
00:16:26.480 --> 00:16:32.670
And this is the senior dev interview
question of the next few years.

