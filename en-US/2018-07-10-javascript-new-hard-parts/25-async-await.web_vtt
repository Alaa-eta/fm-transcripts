WEBVTT

1
00:00:03.836 --> 00:00:08.623
&gt;&gt; Will Sentance: Async Await
simplifies this entire process.

2
00:00:08.623 --> 00:00:13.903
Async Await, I would say,
finally fixes the inversion control

3
00:00:13.903 --> 00:00:18.609
problem with callbacks,
actually this does, as well.

4
00:00:18.609 --> 00:00:23.037
Async Await, we're not gonna need to have

5
00:00:23.037 --> 00:00:28.203
a function here that triggers
the return back into

6
00:00:28.203 --> 00:00:32.878
the generator function execution context.

7
00:00:32.878 --> 00:00:35.242
The create flow,
we all don't need that anymore.

8
00:00:35.242 --> 00:00:40.028
Instead, what's gonna be triggered from
here is just come straight back in

9
00:00:40.028 --> 00:00:41.690
here with a return value.

10
00:00:42.910 --> 00:00:46.094
No more triggering of that
happening via another function.

11
00:00:46.094 --> 00:00:49.239
We're gonna walk through it line by line,
and this our final code,

12
00:00:49.239 --> 00:00:51.240
we're running slightly long.

13
00:00:51.240 --> 00:00:56.725
This is our very,
very final code of all of hard parts,

14
00:00:56.725 --> 00:01:00.470
all of the beauty of asynchronous.

15
00:01:00.470 --> 00:01:03.250
By the way, can we just appreciate for
a second, or appreciate yourselves for

16
00:01:03.250 --> 00:01:04.220
a second.

17
00:01:04.220 --> 00:01:07.990
You've incorporated into your mental model

18
00:01:10.410 --> 00:01:13.110
every hard part of
the JavaScript engine here.

19
00:01:14.190 --> 00:01:18.515
The entire web browsers feature part,
the Microtask Queue, the only person that

20
00:01:18.515 --> 00:01:22.970
looks at Microtask Queue, really is
the guy who Drake Archibald, truly gifted.

21
00:01:22.970 --> 00:01:28.377
I highly recommend him,
brilliant, British speaker.

22
00:01:28.377 --> 00:01:34.775
Who is a developer evangelist at Google,
truly gifted, explainer of concepts,

23
00:01:34.775 --> 00:01:40.817
and sharer of entertaining, humble
anecdotes, as is the want of my people.

24
00:01:40.817 --> 00:01:46.265
And he talks about the Microtask Queue,
the only person who does.

25
00:01:46.265 --> 00:01:48.675
That's how advanced this stuff is.

26
00:01:48.675 --> 00:01:52.415
And you've combined all that
with a feature of JavaScript in

27
00:01:52.415 --> 00:01:54.540
ES7 that only just got released,

28
00:01:54.540 --> 00:01:58.219
generating an Async Await.
&gt;&gt; Will Sentance: And

29
00:01:58.219 --> 00:02:00.874
you build Async Await from scratch,
this is Async Await.

30
00:02:00.874 --> 00:02:04.278
If you get a senior dev interview,
the question is gonna come up more and

31
00:02:04.278 --> 00:02:07.189
more I think, can you build for
me Async Await from scratch?

32
00:02:08.560 --> 00:02:09.392
We just did it,

33
00:02:09.392 --> 00:02:12.040
we just built Async Await from scratch.
&gt;&gt; Speaker 2: We

34
00:02:12.040 --> 00:02:15.620
just built redux saga basically.
&gt;&gt; Will Sentance: Even better,

35
00:02:15.620 --> 00:02:17.790
we just built redux saga from scratch.

36
00:02:17.790 --> 00:02:21.130
Let's try to inflate our
achievements even more.

37
00:02:21.130 --> 00:02:25.520
We just built the JavaScript
engine from scratch, there we go.

38
00:02:25.520 --> 00:02:28.100
I feel particularly proud of all of you.

39
00:02:28.100 --> 00:02:30.370
All right, so we're gonna do this though.

40
00:02:30.370 --> 00:02:36.010
Final code is going to
be doing the nicely,

41
00:02:36.010 --> 00:02:38.646
prettily wrapped version of this,

42
00:02:38.646 --> 00:02:44.510
using the Async Await, or
the Async function declaration style.

43
00:02:44.510 --> 00:02:49.270
Which is going to just
prettify this slightly more

44
00:02:51.670 --> 00:02:55.740
for us and this is our final code.

45
00:02:55.740 --> 00:02:59.648
I guess I just fight the feeling
of exhaustion when I'm.

46
00:02:59.648 --> 00:03:04.484
All right, for the first time,
my beautiful people,

47
00:03:04.484 --> 00:03:08.900
for the first time,
we are able to return back into

48
00:03:08.900 --> 00:03:13.859
a function's execution
context after we've left it.

49
00:03:13.859 --> 00:03:20.155
We're able to do so
using our returnNext element .next method

50
00:03:20.155 --> 00:03:26.234
that guides us back into
the create flow execution context.

51
00:03:26.234 --> 00:03:31.361
We manually do so
using our next method call which was

52
00:03:31.361 --> 00:03:37.887
triggered by the triggering of our
due when data received callback

53
00:03:37.887 --> 00:03:43.150
that was attached to our
future data promise object.

54
00:03:44.740 --> 00:03:50.200
But this flow inwards and
outwards and inwards gets complex.

55
00:03:50.200 --> 00:03:55.257
So JavaScript gives us
an Async function that's

56
00:03:55.257 --> 00:04:02.920
gonna automate that process of going
back into the create flow function.

57
00:04:02.920 --> 00:04:07.734
It's gonna say, don't worry, we don't
have to trigger going back into it.

58
00:04:07.734 --> 00:04:11.126
Instead, we're gonna go
automatically back into it.

59
00:04:11.126 --> 00:04:16.229
We're gonna pass the response
object value back

60
00:04:16.229 --> 00:04:21.705
in as the evaluated result
of the yield expression,

61
00:04:21.705 --> 00:04:25.800
and store that straight in data.

62
00:04:25.800 --> 00:04:28.060
It's gonna simplify all of this code for

63
00:04:28.060 --> 00:04:32.899
us, with the help of
the new Async functions.

64
00:04:32.899 --> 00:04:35.700
Async Awaits simplifies all of this, and

65
00:04:35.700 --> 00:04:41.480
finally cleans up our inversion
of control problem of callbacks.

66
00:04:41.480 --> 00:04:46.900
We're gonna see that now, for
the first time we don't define a task to

67
00:04:46.900 --> 00:04:52.430
be done beyond our control much later on,
instead we're gonna go into create flow.

68
00:04:52.430 --> 00:04:55.800
Setup some work,
setup a task that takes a long time.

69
00:04:55.800 --> 00:05:00.120
That is our speaking to the browser
that speaks to the Internet,

70
00:05:00.120 --> 00:05:03.560
gets that tweet,
200 milliseconds brings it back.

71
00:05:03.560 --> 00:05:08.380
And then, we're gonna somehow to get
back in to create flow to continue

72
00:05:08.380 --> 00:05:11.370
running our code sequentially.

73
00:05:11.370 --> 00:05:14.060
No need for a triggered function
on the promise resolution and so

74
00:05:14.060 --> 00:05:17.630
we auto trigger the resumption
of the create flow execution.

75
00:05:18.850 --> 00:05:22.120
That functionality is still added
to the microtask queue though.

76
00:05:22.120 --> 00:05:23.870
All right, so here we go,

77
00:05:23.870 --> 00:05:29.075
Blessing line one what are we doing?
&gt;&gt; Blessing: We are going to declare Async

78
00:05:29.075 --> 00:05:35.242
function called CreateFlow.
&gt;&gt; Will Sentance: Excellent CreateFlow

79
00:05:35.242 --> 00:05:37.800
is defined.

80
00:05:37.800 --> 00:05:44.530
It is a function,
it is a brand new type of function.

81
00:05:44.530 --> 00:05:48.337
An asynchronous function,

82
00:05:48.337 --> 00:05:53.023
good, line two, Blessing.
&gt;&gt; Blessing: We are going to

83
00:05:53.023 --> 00:05:55.954
invoke the function we just
created which is CreateFlow-

84
00:05:55.954 --> 00:05:57.100
&gt;&gt; Will Sentance: Excellent,

85
00:05:57.100 --> 00:06:00.226
we're gonna invoke CreateFlow and

86
00:06:00.226 --> 00:06:05.341
we are going to immediately
enter its execution context.

87
00:06:05.341 --> 00:06:12.425
Immediately, enter its execution context.

88
00:06:12.425 --> 00:06:15.742
There it is and what is the first thing,

89
00:06:15.742 --> 00:06:20.072
Blessing tells us to do in
this execution context?

90
00:06:20.072 --> 00:06:24.909
It said about one millisecond.
&gt;&gt; Blessing: To consider

91
00:06:24.909 --> 00:06:27.439
that log Me Fisrt.
&gt;&gt; Will Sentance: Excellent, so

92
00:06:27.439 --> 00:06:31.550
about one millisecond
we hit our console log,

93
00:06:31.550 --> 00:06:34.930
Me First, so we do go into the create.

94
00:06:34.930 --> 00:06:37.740
This isn't like our generator function.

95
00:06:37.740 --> 00:06:42.130
We have to trigger going
into using the next method

96
00:06:42.130 --> 00:06:46.140
that the call to the generator
function returned out.

97
00:06:46.140 --> 00:06:48.310
The next method on that object, instead,

98
00:06:48.310 --> 00:06:51.430
we're gonna go into it directly
ourselves just by calling it.

99
00:06:51.430 --> 00:06:56.285
So the first thing we
do is indeed a console

100
00:06:56.285 --> 00:07:01.710
log of the string Me First, perfect.

101
00:07:01.710 --> 00:07:05.094
And in our memory,
what is the next sign of code blessing

102
00:07:05.094 --> 00:07:09.690
that we are going to encounter?
&gt;&gt; Blessing: We'll declare constant data.

103
00:07:09.690 --> 00:07:11.440
&gt;&gt; Will Sentance: Perfect, there it is and

104
00:07:11.440 --> 00:07:14.610
for now, undefined.

105
00:07:14.610 --> 00:07:19.921
Exactly, so
we set data is going to be the evaluated

106
00:07:19.921 --> 00:07:25.118
result of that expression
on the right hand side.

107
00:07:25.118 --> 00:07:29.996
So there it is on
the right hand side we say,

108
00:07:29.996 --> 00:07:33.529
await, and then fetch, aha!

109
00:07:33.529 --> 00:07:38.449
The return of about our wonderful,

110
00:07:38.449 --> 00:07:44.687
our final call to our
fetch facade function.

111
00:07:44.687 --> 00:07:50.141
A two-pronged function that in
JavaScript returns out a what,

112
00:07:50.141 --> 00:07:52.389
Blessing?
&gt;&gt; Blessing: A promise object.

113
00:07:52.389 --> 00:07:54.311
&gt;&gt; Will Sentance: A promise object.

114
00:07:54.311 --> 00:07:59.928
But it also spins out a bunch of
a work in the web browser itself.

115
00:07:59.928 --> 00:08:05.081
So let's do the JavaScript piece first,
we are going to return

116
00:08:05.081 --> 00:08:10.428
out a promise object,
just as Blessing said, with two, I mean,

117
00:08:10.428 --> 00:08:16.100
has few properties, but
two important properties, values.

118
00:08:16.100 --> 00:08:20.548
And OnFulfillment which is an empty array,
both right now,

119
00:08:20.548 --> 00:08:23.300
nothing interesting in them yet.

120
00:08:23.300 --> 00:08:27.991
The value that's gonna be auto-filled in
with whatever comes back from the web

121
00:08:27.991 --> 00:08:31.983
browser features background work,
and the OnFulfillment array,

122
00:08:31.983 --> 00:08:34.590
well we'll see what that's gonna do here.

123
00:08:36.010 --> 00:08:40.710
Good, but, and that object here.

124
00:08:40.710 --> 00:08:43.090
We're gonna hold it here for now.

125
00:08:43.090 --> 00:08:47.410
But in the web browser,
what are we spinning up?

126
00:08:48.540 --> 00:08:54.770
We are spinning up
the background feature XHR.

127
00:08:57.000 --> 00:09:04.498
There it is, XHR is spun up and
it has some important properties.

128
00:09:04.498 --> 00:09:11.401
The URL, twitter.com, the path /will/1.

129
00:09:11.401 --> 00:09:15.486
Something whatever it is and
the type of request we're making and

130
00:09:15.486 --> 00:09:17.350
it's a get request.

131
00:09:17.350 --> 00:09:21.089
And we are sending off an HTTP.

132
00:09:21.089 --> 00:09:25.529
That's the H in the XHR,

133
00:09:25.529 --> 00:09:30.394
HTTP message off to Twitter

134
00:09:30.394 --> 00:09:34.850
itself, their server.

135
00:09:34.850 --> 00:09:38.230
There it is, the beautiful Twitter server.

136
00:09:38.230 --> 00:09:42.340
And is it at this moment at
about one millisecond, Blessing,

137
00:09:42.340 --> 00:09:44.450
is it complete yet?
&gt;&gt; Blessing: No.

138
00:09:44.450 --> 00:09:45.810
&gt;&gt; Will Sentance: It is not, but

139
00:09:45.810 --> 00:09:47.560
when that data comes back,
it'll be complete.

140
00:09:49.660 --> 00:09:53.250
What do we want to update
on the completion?

141
00:09:53.250 --> 00:09:57.100
You wanna update this value property.

142
00:09:57.100 --> 00:10:01.090
Now, we have not assigned this
object to any particular place,

143
00:10:01.090 --> 00:10:02.930
it's just a position in memory.

144
00:10:02.930 --> 00:10:06.968
So we know that we're referring
to this object we defined,

145
00:10:06.968 --> 00:10:10.640
it's value property.

146
00:10:10.640 --> 00:10:12.810
That's what we're going to update.

147
00:10:12.810 --> 00:10:15.520
We didn't give it a label in JavaScript,

148
00:10:15.520 --> 00:10:20.040
but the web browser knows
where that object is stored.

149
00:10:20.040 --> 00:10:22.890
And that's the value
property it's gonna update.

150
00:10:22.890 --> 00:10:24.160
Okay, perfect, good.

151
00:10:25.210 --> 00:10:33.210
And now the all powerful await is going to
throw us out of our create flow execution.

152
00:10:33.210 --> 00:10:38.110
We can't, it will throw us out of

153
00:10:38.110 --> 00:10:43.888
the create flow, execution context.

154
00:10:43.888 --> 00:10:45.111
I have a very clean eye.

155
00:10:45.111 --> 00:10:49.848
Confer that out of our create
flow exclusion context where

156
00:10:49.848 --> 00:10:53.770
we are going to encounter what line next?

157
00:10:53.770 --> 00:10:56.470
Blessing.
&gt;&gt; Blessing: Console.log Me Second.

158
00:10:56.470 --> 00:10:59.064
&gt;&gt; Will Sentance: Me Second, exactly,

159
00:10:59.064 --> 00:11:04.280
at about let's say maybe two milliseconds.

160
00:11:04.280 --> 00:11:06.660
Something like that, about two.

161
00:11:06.660 --> 00:11:11.847
In other words, the most important
thing we wanted to do with

162
00:11:11.847 --> 00:11:17.600
an asynchronous work is setup
a task that takes a bunch of time.

163
00:11:17.600 --> 00:11:21.039
That's the web browser feature
task to speak to the Internet and

164
00:11:21.039 --> 00:11:22.600
take 200 milliseconds.

165
00:11:22.600 --> 00:11:28.110
Set it up, but be able to continue
running our synchronous code afterwards.

166
00:11:28.110 --> 00:11:32.344
But now do we see, to do it,
we're stepping out of our function.

167
00:11:32.344 --> 00:11:37.231
And wouldn't it be wonderful if
we could step back in to our

168
00:11:37.231 --> 00:11:43.150
function when we get the value from
the request back as a response.

169
00:11:43.150 --> 00:11:44.940
Hopefully it's gonna be stored in data,

170
00:11:44.940 --> 00:11:50.220
and we can then continue running
our code and log that data.

171
00:11:50.220 --> 00:11:51.700
Wouldn't that be wonderful?

172
00:11:51.700 --> 00:11:53.690
Let's hope it is possible.

173
00:11:53.690 --> 00:12:00.030
So in JavaScript now we don't really
have much interesting stuff to do.

174
00:12:00.030 --> 00:12:05.474
We're done, but as our call stack, but

175
00:12:05.474 --> 00:12:12.682
in the background after
about 200 milliseconds,

176
00:12:12.682 --> 00:12:18.070
interesting stuff is happening.

177
00:12:18.070 --> 00:12:24.521
About 200 milliseconds later,
say 201 milliseconds our

178
00:12:24.521 --> 00:12:30.674
background work is complete and
we get a glorious response.

179
00:12:30.674 --> 00:12:33.360
That pen is now thoroughly dead.

180
00:12:33.360 --> 00:12:34.930
We get a glorious response.

181
00:12:36.580 --> 00:12:41.903
Let's use red, a glorious

182
00:12:41.903 --> 00:12:49.055
response.
&gt;&gt; Will Sentance: The string Hi,

183
00:12:49.055 --> 00:12:52.990
and what is that gonna update?

184
00:12:52.990 --> 00:12:58.439
That is gonna update our value
property of the promised object

185
00:12:58.439 --> 00:13:04.830
that's been stored in memory, and
referred to its position in memory,

186
00:13:04.830 --> 00:13:10.092
from the web browser feature,
ready to update that value.

187
00:13:10.092 --> 00:13:13.336
At which point, what are we gonna do?

188
00:13:13.336 --> 00:13:19.619
We are going to trigger, and we can
think of in our OnFulfillment array as

189
00:13:19.619 --> 00:13:25.910
effectively the continuation of
our create flow execution context.

190
00:13:25.910 --> 00:13:31.016
We're gonna trigger at that
moment the continuation

191
00:13:31.016 --> 00:13:36.349
of our create flow execution context and
at about 201

192
00:13:36.349 --> 00:13:41.468
milliseconds reenter where
we effectively paused.

193
00:13:41.468 --> 00:13:46.446
We're gonna get to reenter,
add create flow

194
00:13:46.446 --> 00:13:51.034
back on our call stack, and come back in.

195
00:13:51.034 --> 00:13:53.690
And the await fetch,
await was super powerful.

196
00:13:53.690 --> 00:13:55.144
It threw us straight out.

197
00:13:55.144 --> 00:13:59.070
We never even got to assign anything
to data, that's not a bad thing.

198
00:13:59.070 --> 00:14:03.928
We're hoping that data is gonna be
filled in with whatever this right

199
00:14:03.928 --> 00:14:05.693
hand side evaluates to.

200
00:14:05.693 --> 00:14:09.340
And what does it evaluate to, Blessing?
&gt;&gt; Blessing: Hi.

201
00:14:09.340 --> 00:14:11.820
&gt;&gt; Will Sentance: To the value from

202
00:14:11.820 --> 00:14:16.940
the request to the Internet
that came back with Hi.

203
00:14:16.940 --> 00:14:20.919
That is what our await
expression evaluates to, Hi.

204
00:14:20.919 --> 00:14:23.550
And we assign it to what label?

205
00:14:23.550 --> 00:14:28.878
To data, exactly and
so when we hit our next

206
00:14:28.878 --> 00:14:34.502
line in the body of our
create flow function,

207
00:14:34.502 --> 00:14:41.606
console.log data,
data is going to be evaluated to Hi.

208
00:14:41.606 --> 00:14:48.593
And look at that at about 200,
and 202 milliseconds,

209
00:14:48.593 --> 00:14:54.077
we get to continue running
the rest of our code.

210
00:14:54.077 --> 00:15:01.460
We get to continue running the rest of
our code inside our CreateFlow function.

211
00:15:01.460 --> 00:15:06.686
All that work of returning a value,
or the response object

212
00:15:06.686 --> 00:15:13.204
that we saw before into the promise
object that we stored in future data.

213
00:15:13.204 --> 00:15:19.954
That we then triggered a do when
data received function that then

214
00:15:19.954 --> 00:15:25.339
triggered .next on the return
next element call.

215
00:15:25.339 --> 00:15:30.110
Or return next element object next
function that triggered us to go

216
00:15:30.110 --> 00:15:33.960
back into create flow
all of that automated.

217
00:15:33.960 --> 00:15:37.980
The async function definition is
gonna handle all of that for us.

218
00:15:37.980 --> 00:15:41.320
The await still behaves
similar to a yield.

219
00:15:41.320 --> 00:15:45.060
So await is similar to a yield that
we're going to hold on store anything on

220
00:15:45.060 --> 00:15:48.390
the left hand side until we get something
back from this background work.

221
00:15:48.390 --> 00:15:50.313
But now when the value comes back,

222
00:15:50.313 --> 00:15:54.374
we're just gonna go straight back
into CreateFlow and store it in data.

223
00:15:54.374 --> 00:15:59.822
This is a beautifully cleaned up
version of that highly complex

224
00:15:59.822 --> 00:16:04.858
setup we had that was nevertheless
a very powerful setup,

225
00:16:04.858 --> 00:16:08.072
but now we have a cleaned up version.

226
00:16:08.072 --> 00:16:14.470
And by the way, this cleaned up version
behind the scenes is doing all of this.

227
00:16:14.470 --> 00:16:20.025
So if you want to emulate,
if you want to emulate the async await,

228
00:16:20.025 --> 00:16:26.480
function definition and call,
we can do it ourselves with generators.

229
00:16:26.480 --> 00:16:32.670
And this is the senior dev interview
question of the next few years.

