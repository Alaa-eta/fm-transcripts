[00:00:03]
>> Will Sentance: Async Await simplifies this entire process. Async Await, I would say, finally fixes the inversion control problem with callbacks, actually this does, as well. Async Await, we're not gonna need to have a function here that triggers the return back into the generator function execution context. The create flow, we all don't need that anymore.

[00:00:35]
Instead, what's gonna be triggered from here is just come straight back in here with a return value. No more triggering of that happening via another function. We're gonna walk through it line by line, and this our final code, we're running slightly long. This is our very, very final code of all of hard parts, all of the beauty of asynchronous.

[00:01:00]
By the way, can we just appreciate for a second, or appreciate yourselves for a second. You've incorporated into your mental model every hard part of the JavaScript engine here. The entire web browsers feature part, the Microtask Queue, the only person that looks at Microtask Queue, really is the guy who Drake Archibald, truly gifted.

[00:01:22]
I highly recommend him, brilliant, British speaker. Who is a developer evangelist at Google, truly gifted, explainer of concepts, and sharer of entertaining, humble anecdotes, as is the want of my people. And he talks about the Microtask Queue, the only person who does. That's how advanced this stuff is.

[00:01:48]
And you've combined all that with a feature of JavaScript in ES7 that only just got released, generating an Async Await.
>> Will Sentance: And you build Async Await from scratch, this is Async Await. If you get a senior dev interview, the question is gonna come up more and more I think, can you build for me Async Await from scratch?

[00:02:08]
We just did it, we just built Async Await from scratch.
>> Speaker 2: We just built redux saga basically.
>> Will Sentance: Even better, we just built redux saga from scratch. Let's try to inflate our achievements even more. We just built the JavaScript engine from scratch, there we go. I feel particularly proud of all of you.

[00:02:28]
All right, so we're gonna do this though. Final code is going to be doing the nicely, prettily wrapped version of this, using the Async Await, or the Async function declaration style. Which is going to just prettify this slightly more for us and this is our final code. I guess I just fight the feeling of exhaustion when I'm.

[00:02:59]
All right, for the first time, my beautiful people, for the first time, we are able to return back into a function's execution context after we've left it. We're able to do so using our returnNext element .next method that guides us back into the create flow execution context. We manually do so using our next method call which was triggered by the triggering of our due when data received callback that was attached to our future data promise object.

[00:03:44]
But this flow inwards and outwards and inwards gets complex. So JavaScript gives us an Async function that's gonna automate that process of going back into the create flow function. It's gonna say, don't worry, we don't have to trigger going back into it. Instead, we're gonna go automatically back into it.

[00:04:11]
We're gonna pass the response object value back in as the evaluated result of the yield expression, and store that straight in data. It's gonna simplify all of this code for us, with the help of the new Async functions. Async Awaits simplifies all of this, and finally cleans up our inversion of control problem of callbacks.

[00:04:41]
We're gonna see that now, for the first time we don't define a task to be done beyond our control much later on, instead we're gonna go into create flow. Setup some work, setup a task that takes a long time. That is our speaking to the browser that speaks to the Internet, gets that tweet, 200 milliseconds brings it back.

[00:05:03]
And then, we're gonna somehow to get back in to create flow to continue running our code sequentially. No need for a triggered function on the promise resolution and so we auto trigger the resumption of the create flow execution. That functionality is still added to the microtask queue though.

[00:05:22]
All right, so here we go, Blessing line one what are we doing?
>> Blessing: We are going to declare Async function called CreateFlow.
>> Will Sentance: Excellent CreateFlow is defined. It is a function, it is a brand new type of function. An asynchronous function, good, line two, Blessing.
>> Blessing: We are going to invoke the function we just created which is CreateFlow-

[00:05:55]

>> Will Sentance: Excellent, we're gonna invoke CreateFlow and we are going to immediately enter its execution context. Immediately, enter its execution context. There it is and what is the first thing, Blessing tells us to do in this execution context? It said about one millisecond.
>> Blessing: To consider that log Me Fisrt.

[00:06:26]

>> Will Sentance: Excellent, so about one millisecond we hit our console log, Me First, so we do go into the create. This isn't like our generator function. We have to trigger going into using the next method that the call to the generator function returned out. The next method on that object, instead, we're gonna go into it directly ourselves just by calling it.

[00:06:51]
So the first thing we do is indeed a console log of the string Me First, perfect. And in our memory, what is the next sign of code blessing that we are going to encounter?
>> Blessing: We'll declare constant data.
>> Will Sentance: Perfect, there it is and for now, undefined. Exactly, so we set data is going to be the evaluated result of that expression on the right hand side.

[00:07:25]
So there it is on the right hand side we say, await, and then fetch, aha! The return of about our wonderful, our final call to our fetch facade function. A two-pronged function that in JavaScript returns out a what, Blessing?
>> Blessing: A promise object.
>> Will Sentance: A promise object. But it also spins out a bunch of a work in the web browser itself.

[00:07:59]
So let's do the JavaScript piece first, we are going to return out a promise object, just as Blessing said, with two, I mean, has few properties, but two important properties, values. And OnFulfillment which is an empty array, both right now, nothing interesting in them yet. The value that's gonna be auto-filled in with whatever comes back from the web browser features background work, and the OnFulfillment array, well we'll see what that's gonna do here.

[00:08:36]
Good, but, and that object here. We're gonna hold it here for now. But in the web browser, what are we spinning up? We are spinning up the background feature XHR. There it is, XHR is spun up and it has some important properties. The URL, twitter.com, the path /will/1.

[00:09:11]
Something whatever it is and the type of request we're making and it's a get request. And we are sending off an HTTP. That's the H in the XHR, HTTP message off to Twitter itself, their server. There it is, the beautiful Twitter server. And is it at this moment at about one millisecond, Blessing, is it complete yet?

[00:09:43]

>> Blessing: No.
>> Will Sentance: It is not, but when that data comes back, it'll be complete. What do we want to update on the completion? You wanna update this value property. Now, we have not assigned this object to any particular place, it's just a position in memory. So we know that we're referring to this object we defined, it's value property.

[00:10:10]
That's what we're going to update. We didn't give it a label in JavaScript, but the web browser knows where that object is stored. And that's the value property it's gonna update. Okay, perfect, good. And now the all powerful await is going to throw us out of our create flow execution.

[00:10:33]
We can't, it will throw us out of the create flow, execution context. I have a very clean eye. Confer that out of our create flow exclusion context where we are going to encounter what line next? Blessing.
>> Blessing: Console.log Me Second.
>> Will Sentance: Me Second, exactly, at about let's say maybe two milliseconds.

[00:11:04]
Something like that, about two. In other words, the most important thing we wanted to do with an asynchronous work is setup a task that takes a bunch of time. That's the web browser feature task to speak to the Internet and take 200 milliseconds. Set it up, but be able to continue running our synchronous code afterwards.

[00:11:28]
But now do we see, to do it, we're stepping out of our function. And wouldn't it be wonderful if we could step back in to our function when we get the value from the request back as a response. Hopefully it's gonna be stored in data, and we can then continue running our code and log that data.

[00:11:50]
Wouldn't that be wonderful? Let's hope it is possible. So in JavaScript now we don't really have much interesting stuff to do. We're done, but as our call stack, but in the background after about 200 milliseconds, interesting stuff is happening. About 200 milliseconds later, say 201 milliseconds our background work is complete and we get a glorious response.

[00:12:30]
That pen is now thoroughly dead. We get a glorious response. Let's use red, a glorious response.
>> Will Sentance: The string Hi, and what is that gonna update? That is gonna update our value property of the promised object that's been stored in memory, and referred to its position in memory, from the web browser feature, ready to update that value.

[00:13:10]
At which point, what are we gonna do? We are going to trigger, and we can think of in our OnFulfillment array as effectively the continuation of our create flow execution context. We're gonna trigger at that moment the continuation of our create flow execution context and at about 201 milliseconds reenter where we effectively paused.

[00:13:41]
We're gonna get to reenter, add create flow back on our call stack, and come back in. And the await fetch, await was super powerful. It threw us straight out. We never even got to assign anything to data, that's not a bad thing. We're hoping that data is gonna be filled in with whatever this right hand side evaluates to.

[00:14:05]
And what does it evaluate to, Blessing?
>> Blessing: Hi.
>> Will Sentance: To the value from the request to the Internet that came back with Hi. That is what our await expression evaluates to, Hi. And we assign it to what label? To data, exactly and so when we hit our next line in the body of our create flow function, console.log data, data is going to be evaluated to Hi.

[00:14:41]
And look at that at about 200, and 202 milliseconds, we get to continue running the rest of our code. We get to continue running the rest of our code inside our CreateFlow function. All that work of returning a value, or the response object that we saw before into the promise object that we stored in future data.

[00:15:13]
That we then triggered a do when data received function that then triggered .next on the return next element call. Or return next element object next function that triggered us to go back into create flow all of that automated. The async function definition is gonna handle all of that for us.

[00:15:37]
The await still behaves similar to a yield. So await is similar to a yield that we're going to hold on store anything on the left hand side until we get something back from this background work. But now when the value comes back, we're just gonna go straight back into CreateFlow and store it in data.

[00:15:54]
This is a beautifully cleaned up version of that highly complex setup we had that was nevertheless a very powerful setup, but now we have a cleaned up version. And by the way, this cleaned up version behind the scenes is doing all of this. So if you want to emulate, if you want to emulate the async await, function definition and call, we can do it ourselves with generators.

[00:16:26]
And this is the senior dev interview question of the next few years.

