[00:00:00]
>> Will Sentance: Here we are, Hard Parts of JavaScript. The foundations we have to understand though to get to the Hard Parts are gonna feel at times a little bit trite, a little bit trivial. And have a few of you've been to Hard Parts before, you're even gonna feel, hold on I've seen this stuff before.

[00:00:19]
Our first about 30 minutes or so, is gonna be material, that if you've been to Hard Parts before, you'll recognize. Because, that is the JavaScript engine and how it works. It's a universal, but we've gotta lay these foundations out. And by the way, you're gonna see Coby and you're gonna go, yeah, yeah, thanks.

[00:00:40]
I get how this code is running, I get what its doing. But we're gonna see it, and it's gonna empower us to then solve all the hard parts to come. All right, let's go, here it is. We're gonna whiteboard through all of our code's execution, just as the JavaScript engine runs it.

[00:01:01]
We do that, there can be no gaps in our understanding. We're gonna step through line by line, and we're gonna map it up on the whiteboard the whole time. So, with that it mind, what happens when JavaScript executes runs my codes? There's two halves, I'll tell you straight away.

[00:01:18]
It's two halves to the process of executing code. One, is literally the ability to walk through the code, line by line by line. That is known as the thread of execution. All that is is the processing ability. Take line one, do it, whatever it says to do. Take line two, do it, whatever it says to do.

[00:01:40]
Take line three, do it, whatever. It's executing doing the code and it's threading its way down our code. By the way, in order, top to bottom. Simultaneously, the other part that's required to run our code, is a place to store the bits of data that we announced as we go through our codes execution.

[00:02:02]
So you can see in line one, we're announcing that we're gonna store num as a label for sum data three. And so we're gonna map these on the whiteboard, which will be a fascinating experience. Let's see how it goes, line by line. Starting with line one. I'm gonna call on Paul.

[00:02:22]
What are we doing here in line one? What are we actually doing?
>> Paul: We're saying allocate some data to a constant called num, and then toss an integer three onto that?
>> Will Sentance: Well, that seems like a very intuitive description. So we are, in our memory, in our memory, we are declaring a constant.

[00:02:48]
Just remember, that means a piece of data where we're not allowed to change its position and memories. We can't suddenly replace numbers value with full. It's now set for the running of our application, num is set to the value 3, excellent. Michelle, what is our next line of code here [INAUDIBLE] to do?

[00:03:07]

>> Michelle: The next line of code is also creating something in memory that we're calling-
>> Will Sentance: All right, but be very precise, just [INAUDIBLE] [LAUGH] saying that, go on, what is it called? Excellent. The name multiplied by 2, we're declaring the function multiplied by 2. In JavaScript functions, that means the entire functionality are assigned as values.

[00:03:33]
Just like the number 3, we're storing in memory, the functionality, the function definition of multiplied by two. I'm not gonna write the whole function definition out on the right-hand side here, instead, I'm gonna represent it with this little box, with an f in it. That represents my entire function definition.

[00:03:49]
If I go into my console, now log multiplied by 2, what would I see James?
>> James: You would see the actual source code for-
>> Will Sentance: Yeah, exactly, I'd see the block of code itself, function multiplied by 2. I'd see the whole thing with the code in my console.

[00:04:12]
That is what we mean when we say declare a function. We are literally, sometimes we think, or we're just sort of going, there's a function in code. No, no, the keyword function literally means, go save in memory, go save in memory, this particular functionality. All right, excellent, what's our third line of code that executes, Shawn?

[00:04:35]

>> Shawn: It's doing the same thing as our first constant declaration.
>> Will Sentance: Yep.
>> Shawn: Just creating a piece of memory called name sending it to-
>> Will Sentance: Excellent, Shawn, what was not our third line of code?
>> Shawn: Constant results.
>> Will Sentance: Right, why not?
>> Shawn: Because that's not being called yet.

[00:04:52]

>> Will Sentance: Exactly, we do not go into the body of a function until what, Shawn?
>> Shawn: Until it's called.
>> Will Sentance: Until it's called, excellent, all right. Shawn is spot on there, and folk, this may seem profoundly trivial. Okay, I get how to store stuff in memory. But this foundation is what we need, there's a level of precision that is absolutely vital for everything that follows.

[00:05:17]
All the way up to rebuilding a with generators. It all in the end depends on these foundations. All right, excellent, so as soon as we start running our code, we spin up two things. One, the ability to go through our code line by line. ThatÂ´s our thread of execution.

[00:05:35]
Remember, threading its way through, and executing the code line by line. And simultaneously, we spin up, [INAUDIBLE] student policy, and student code alike. A live memory of variables with a live store of labels with data. Posh name for that is a variable environment. We can call this a variable environment.

[00:05:55]
Think of it as being, environment is the things around me. These are the variables around me, the variable environment. Now, these two halves together are known. These two halves together, the thread of it, we're gonna walk through. We didn't copy out the lines and the thread, there's no point.

[00:06:15]
But these two halves together are known as an execution context. That is, a context is a space to do something, a space of context in which we do something, or it's a space in which we execute our code. It's an execution context. And it's the global one, who's gonna discover whenever we run our own code.

[00:06:36]
Including, for example, when we wanna execute the code inside a function. We're gonna create a little baby local execution context. Just or running the code inside a function. We call it the local one. Just for the stuff inside a function. So this though is for our overall code.

[00:06:53]
It's called the global execution context. All right people, let's see what's next? All right, as Shawn rightly said, we did not execute, we did not call, we did not invoke multiply by two. So we stayed in which execution context, Shawn?
>> Shawn: Global.
>> Will Sentance: Global, excellent. But now, we are going to execute a function, and see what happens.

[00:07:21]
So, we've declared num is 3, declared multiply by 2 as a function, what is our next line of code? Mr. Henderson.
>> Brian: Yes.
>> Will Sentance: What is our next line of code, Brian.
>> Brian: We are creating a new label in memory called output.
>> Will Sentance: Excellent. Do we know what to assign to it yet?

[00:07:40]

>> Brian: Undefined at this point.
>> Will Sentance: Very good. Because, what's the right-hand side, is the right-hand side a value that we can store?
>> Brian: Yeah, no, it's calling the execution of-
>> Will Sentance: Exactly, it's a command to go and do something. There's absolutely not a value we can store on the right-hand side.

[00:07:56]
Output has zero interest in multiple by 2. That is a command to go and run some code, whatever gets returned out, known as the, what Brian? What's the generic name for what gets returned out of a function?
>> Brian: The return value.
>> Will Sentance: The return value, exactly. Quite literal, the returned value.

[00:08:14]
That's what's gonna be assigned to output. All right, let's do it. So output is going to be the result, the return value of calling multiplied by 2 with the input of 4. There we go so. So, what did I say we create whenever we have code to execute?

[00:08:38]
Blessing?
>> Blessing: Look like an execution context.
>> Will Sentance: An execution context. I'm gonna represent that. This is a big old box with two parts. I'm gonna represent that with a little box with two parts. Here it is. And we're taking it slowly, cuz these are genuinely, over the next ten, 15 minutes, we're gonna see the three pieces of synchronous Javas from execution.

[00:08:57]
And if we don't get these pieces down, nothing else follows. So, into this execution context, we go. And just like that global one for running the main code, now we're gonna run the code just inside multiplied by 2, but we're gonna have a little memory just for the code.

[00:09:15]
Just for the things that get announced, get declared, the variables and functions, and parameters, and arguments that get declared inside of multiply by two's body. They're just going to be stored in here. By the way, when this function finishes executing, all those pieces unless they're returned out, will be deleted.

[00:09:36]
Automatically, garbage collected. It's stuff that we can't access again. We can't reference those names again. So it's garbage. It's memory that's being wasted. We're gonna automatically clean it out in JavaScript, okay, except in one special condition, which we'll see a little bit later on. Because my favorite thing in JavaScript, there's times when all our data is not necessarily deleted, when we answer a function.

[00:10:03]
The most beautiful concept in Javascript. And even though we're not gonna go through it, as the focal point, inevitably, we have to come to it in iterators. So in we go, and what is the first thing, Rich, inside our local execution context that we're gonna do?
>> Rich: Defining a constant variable called result.

[00:10:26]

>> Will Sentance: So that's our second thing, Rick. What's the very first thing we put in our local memory?
>> Rich: The function?
>> Will Sentance: Not the function, Michelle?
>> Michelle: The input number.
>> Will Sentance: Exactly, input number, which is known as our parameter. Remember, the placeholder, we defined a function, which is to say, we will run this thing later on.

[00:10:46]
When you run me, better make sure you fill in that blank, that placeholder input number with an argument. Parameter is the placeholder, argument's, the actual value that gets passed in. Michelle, what's the argument?
>> Michelle: Argument is 4.
>> Will Sentance: 4, excellent. And so the result is 8. And the final line in the body of the function says do what, Josh?

[00:11:08]

>> Josh: To return 8?
>> Will Sentance: To return 8, I like that. Return the value of result, 8. It's not returning result. It returns the value of result, which is a number, 8. I don't like saying return result. It kind of implies the whole fit. JavaScript sees return result and goes, what's result?

[00:11:23]
8, okay, perfect. Return it out. To where, what's your name dude?
>> Brady: Brady.
>> Will Sentance: Brady, sorry, Brady. Brady, return out to where?
>> Brady: To the label output.
>> Will Sentance: To the but to which execution context?
>> Brady: To the global.
>> Will Sentance: To the global, exactly. Return out 8 into the global execution context, where it's stored in output.

[00:11:51]
Perfect, so I know this may seem procedural. But I know you can see this and go, yeah, yeah, well, I get that output's gonna be 8. I got that. But we need to have the precision. So now, notice by the way, that we weren't allowed to move on to the next line in global, declaring new output until we'd finished running multiply by 2, the input of 4.

[00:12:18]
At thread of execution, the ability to go through the code line by line.
>> Will Sentance: It's weigh in to the column multiply by 2, where it spend time going through the code line by line, and then hit what keyword to the exit? What keyword, Mike, so to exit?
>> Mike: Return.

[00:12:40]

>> Will Sentance: Return, and if there's no return statement there, the closing curly brace, which implies an implicit return is gonna insert return for us. And out be returned. In other words, JavaScript, how many things can it do at a time? One, its thread is singular. It's not going to continue down in global code, while simultaneously [INAUDIBLE].

[00:13:02]
Okay, let's keep going down here and continue in here simultaneously. Uh-huh, one of the beautiful things about Javascript is it's so predictable, because it's always one thing after another, in order, top to bottom, at least in its core synchronous nature. We will see when that doesn't apply, of course.

[00:13:19]
So JavaScript is synchronous in order top to bottom, and single threaded. We can't simply do two things at the same time. Excellent, so now we do return out to the global execution context, where we encounter declaring new output. Which is gonna be the return value of another function call to multiply by 2.

[00:13:39]
We're gonna create an execution context for it. Into it we go. What is the first thing, Rick, in our local memory?
>> Rich: The input number.
>> Will Sentance: Which is known as our? Are we postulating for a placeholder?
>> Rich: Argument?
>> Will Sentance: So that's the argument, that's the?
>> Rich: Parameter.
>> Will Sentance: Parameter.

[00:14:01]
Okay so, Rick, what is our argument? You're right to say our parameter's input number. What's our argument here?
>> Rich: 10.
>> Will Sentance: 10, excellent. All right, and then result will be 20. And we return that out, back out to global. The 20 is returned out to the global constant.

[00:14:26]
New output is 20. So our thread went this way in, and went this way back out again. Okay, but there's a final piece to this synchronous JavaScript model. We have our memory, posh name, variable environment. We have our thread of execution, the ability to go through the code line by line.

[00:14:49]
These together are known as an execution context. The two things we need to execute code, the context in which we need the context of things we need to execute code. But we got a whole bunch of these execution context being created, deleted, created, and then we run another function inside of that one.

[00:15:09]
It's another little mini one being created inside of there. Keeping track of those, to us is visually easy. I've finished calling multiply by 2, I come out of it, and I'm back where I was before. When I started coding multi-property, we can visually see that very easily. JavaScript doesn't have that same ability to visually see.

[00:15:30]
I was previously, I called this function in global, and that I was in the big box when I moved into the little box. When I finish in the little box, I go back out to the big box. JavaScript doesn't have that ability. It needs to keep track of where it is in the code right now, where it was before it started being inside this function.

[00:15:50]
Where it's gonna go back to when it finishes inside this function. What, this is a knowledge thing, does anyone know what data. I guess all that store information in any format, but there's a particularly nice structure, way of structuring data that will store that information very cleanly. Anyone know what that structure might be?

[00:16:10]

>> Paul: Stack.
>> Will Sentance: It is a stack, exactly. In fact, it's gonna be a stack of code. You have arrays, arrays, say a list of data, I wanna be able to grab an element at any random position. That's not reflecting what we wanna do here. Here, we wanna say just like a stack of plates.

[00:16:28]
I put the first one, and I start off in the global execution context. That's on my first element in my stack. And then, when I start running multiply by 2, I had it on top. And that's adding my next plate. If I had to run another function inside of that, I would have that one on top.

[00:16:44]
When I am finishing that one, all I care is that when I take that one away, the previous one that was there before was still there. And that is the essence of a stag. When I take the last thing that was there off, I'm back to where I was before.

[00:16:56]
And so our stack is gonna be a stack of calls to functions. Starting off, here is the pool stack, the stack of pools, the functions. Starting off with a kind of representation of our overall, think of our whole code base of a function called global, that as soon as we start running our code, we're running global.

[00:17:19]
So starting off with global, as soon as we start running our code. When we start running multiply by two, Paul what would it make sense to do to our callstack?
>> Paul: Add on the new execution context.
>> Will Sentance: Add on the new execution context, exactly. Add on the call to multiply by 2, with the input of 4.

[00:17:39]
Meaning, well, I am in my multiply by 2 function. My thread is in my multiply by 2 function. Multiply by 2 is gonna be top of my stack, of course. My one simple rule is, whatever stuff is in my callstack, that's where I am right now. And then as soon as I return out, what's gonna happen Paul to my call stack?

[00:18:02]

>> Paul: Multiply by two, that execution, context disappears, you go back into the global, and then you-
>> Will Sentance: Excellent, I'm gonna get rid of multiply by two of my callstack. And we may know, therefore, return out to global execution context and output, but doesn't, knows that. Because look, what's in my callstack now?

[00:18:20]
Don't panic, it's global, and back out to global. This allows JavaScript to keep track of where is it in its code, what line is running. And then, when I finish in the current execution context, where am I going to return back to when I get rid of where I was?

[00:18:36]
And the next layer down is where I'm returning back to. All right, by the way, posh name for adding to a stack is not to add, is not to throw on. It's to what Shawn? Victor? What's important to add to a stack? Anyone know?
>> Paul: [LAUGH]
>> Will Sentance: Push, that's the computer science technical term for adding to a stack.

[00:18:57]
And what's a posh name? Josh, you know about getting something off a stack?
>> Josh: A pop?
>> Will Sentance: Pop, exactly. Push and pop. Excellent, all right, good. Yeah, we talked about this. So let's have thumbs on these core foundations. Thumbs is a widely used pedagogical technique to indicate one's understanding.

[00:19:17]
You lost me, I'm very clear, I have a clarification question, everybody's thumbs out right now. It's okay to have clarifications. Nobody? Mm, very frustrating. All right, good.
>> Paul: [LAUGH]
>> Will Sentance: Good.

