[00:00:00]
>> Will Sentance: But before we get to that, you lost me. And it's okay. I'm clear, I have some clarification questions on this new model of execution. Everybody, thumbs proudly out. It's okay to have. Alec has a clarification.
>> Will Sentance: Abdee has more than a clarification. Brian has a clarification. Brian, do you wanna go first?

[00:00:20]

>> Brian: Yeah, so this is still asynchronous when you get down to the, that we're still adding everything to the microtask used before it.
>> Will Sentance: It is.
>> Brian: So, it was a console log after that, that would go first.
>> Will Sentance: Absolutely, if I had, I should have done that.

[00:00:36]
If I had a console log straight after storing the do when data received on the then, on the future data unfulfillment array. And a console log straight after. All to happen. If I were to block my thread here, after this assignment of the do when data received to future.data's unfulfillment array.

[00:00:55]
If I were to have a blocking task there or a while that was infinite, then my do when data received that triggers inside of it, entering back into createFlow, I've never reached that because that's on my micro task queue. So, it's still absolutely asynchronous. All this is doing, you can almost think of the code console log.

[00:01:16]
You can almost think of everything after the yield statement that threw out the tasks, threw out the promise of [INAUDIBLE] Data. Think of everything like this as being like the functionality we want to run on the data coming back. Almost think of this as being the function we pass here.

[00:01:34]
Right, think of it as being this here is our function that you run later, but now we get to go and run it. We get to write it as though it's synchronous code in a function. We just come back to it only when we trigger running doWhenDataReceived, which we then get to manually set.

[00:01:54]
Now I get to go back and run this code. It's the most control we've had probably over when our deferred functionality runs. But in the end it's still, as by the very nature of a synchronicity in a language, beyond our control. Because what triggers returnNextElement.next running that takes it back in here, what triggers it?

[00:02:15]
It's the beyond our control setting your value property. Beyond that control triggered doWhenDataReceived. But now when we trigger that, we just write inside a command that we did get to control writing that takes us back in this function. But the very nature of a single thread in asynchronous language is that you throw out tasks in a single thread.

[00:02:37]
You throw them out, and then they come back in and run functionality on the returned values beyond your control. That's their very nature, and that's why in the end, solution two, which was the call back model, in the end it's also true. It's not a wrong model. Under the hood it's the same thing.

[00:02:54]
Under the hood we're not doing profoundly more here. You're just increasing readability more and more. And in a sense by doing so, hiding the underlying engine more and more, and that's arguably a problem if you don't understand the underlying engine. If you do, now you get best of both worlds.

[00:03:12]
Increased readability, and the ability to understand how it's truly working. All right, Alec.
>> Alec: Maybe someone has asked this already, but can the generator functions be anonymous?
>> Will Sentance: Go play with that. There's interesting questions around arrow functions and how you can define these. Go play with these.
>> Alec: Okay.

[00:03:34]

>> Will Sentance: And we'll talk about that after you've experimented. Abdee, you want to try and phrase it as a question?
>> Speaker 4: I get it, but I need to have a little bit more time to really have it sink in, but I kinda [CROSSTALK]
>> Will Sentance: I appreciate it, man.

