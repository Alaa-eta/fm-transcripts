[00:00:00]
>> Will Sentance: But before we get to that, you lost me, and it's okay, I'm clear. I have some clarification questions on this new model of execution. Everybody's thumbs proudly out, it's okay to have, Alec has a clarification, Avdi has more than a clarification, Brian has a clarification. Brian, do you wanna go first?

[00:00:20]

>> Brian: Yeah, so this is still asynchronous when you get down to that we're still adding everything to the micro task through before it.
>> Will Sentance: It is.
>> Brian: So if there was a console log after that would go first.
>> Will Sentance: Absolutely, I should have done that. If I had a console log straight after storing the due end dates received under then, on the future data on fulfillment array, and the console loads straight after, all to happen.

[00:00:47]
If I were to block my thread here, after that assignment to do when they to receive the future.data's on fulfillment array. Followed of, have a blocking task there for a while loop that's infinite, then my do and data receive that triggers inside of it entering back into create flow.

[00:01:07]
I've never reached that, because that's on my micro task queue. So it's still absolutely asynchronous. All this is doing, you can almost think of the code, console log, you can almost think of everything after the yield statement throughout the tasks, throughout the promise object if you date it.

[00:01:23]
Everything like this as being the functionality we want to run on the data coming back. Almost think of this as being we pass here, think of it as being, this here is our functionality run later. But now we get to go and run it, we get to write it as though it's synchronous code in a function.

[00:01:46]
We just come back to it only when we trigger running due when dates are received, which we then get to manually set. Now, I get to go back and run this code. It's the most control we've had probably over when our deferred functionality runs. But in the end, it's still, as by the very nature of asynchronicity in a language, beyond our control.

[00:02:09]
Because what triggers return nextElement.next running that takes us back in here, what triggers it? It's beyond our control setting a value property. But beyond our control triggered due when dates received. But now, when we trigger that we just write inside a command that we did get to control writing that takes us back to the function.

[00:02:30]
But the very nature of sing thread in a synchronous language is that you throw out tasks in a single thread, you throw them out. And then they come back in and run functionality on the return values beyond your control. That's the very nature and that's why in the end, solution two which was the call back model, in the end it's also true.

[00:02:51]
It's not a wrong model, under the hood is the same thing. Under the hood we're not doing profoundly more here. You're just increasing readability more and more, and in a sense, by doing so, hiding the underlying engine more and more. And that's arguably a problem, if you don't understand the underlying engine.

[00:03:10]
If you do, now you get best of both worlds, increased readability and the ability to understand how it's truly working. All right, Alec?
>> Alex: Maybe someone asked this already. But can the generator functions be anonymous?
>> Will Sentance: Go play with that. There's interesting questions around arrow functions and how you can define these.

[00:03:31]
Go play with these.
>> Alex: Okay.
>> Will Sentance: And we'll talk about it after you've experimented.
>> Will Sentance: Avdi, you want to try and phrase it as a question?
>> Abdi: I did it but it's just I need a little bit more time to really have it sink in. But I kinda, I get to it.

[00:03:48]

>> Will Sentance: I appreciate it, man.

