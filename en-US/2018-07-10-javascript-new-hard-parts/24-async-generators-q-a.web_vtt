WEBVTT

1
00:00:00.043 --> 00:00:04.822
&gt;&gt; Will Sentance: But before we get
to that, you lost me, and it's okay,

2
00:00:04.822 --> 00:00:05.952
I'm clear.

3
00:00:05.952 --> 00:00:08.689
I have some clarification questions
on this new model of execution.

4
00:00:08.689 --> 00:00:14.449
Everybody's thumbs proudly out, it's
okay to have, Alec has a clarification,

5
00:00:14.449 --> 00:00:18.991
Avdi has more than a clarification,
Brian has a clarification.

6
00:00:18.991 --> 00:00:20.957
Brian, do you wanna go first?
&gt;&gt; Brian: Yeah, so

7
00:00:20.957 --> 00:00:26.842
this is still asynchronous when you get
down to that we're still adding everything

8
00:00:26.842 --> 00:00:29.676
to the micro task through before it.
&gt;&gt; Will Sentance: It

9
00:00:29.676 --> 00:00:30.284
is.
&gt;&gt; Brian: So

10
00:00:30.284 --> 00:00:34.226
if there was a console log
after that would go first.

11
00:00:34.226 --> 00:00:34.905
&gt;&gt; Will Sentance: Absolutely,

12
00:00:34.905 --> 00:00:36.094
I should have done that.

13
00:00:36.094 --> 00:00:41.060
If I had a console log straight after
storing the due end dates received under

14
00:00:41.060 --> 00:00:44.474
then, on the future data
on fulfillment array, and

15
00:00:44.474 --> 00:00:47.826
the console loads straight after,
all to happen.

16
00:00:47.826 --> 00:00:52.518
If I were to block my thread here, after
that assignment to do when they to receive

17
00:00:52.518 --> 00:00:55.145
the future.data's on fulfillment array.

18
00:00:55.145 --> 00:00:58.482
Followed of,
have a blocking task there for

19
00:00:58.482 --> 00:01:01.908
a while loop that's infinite,
then my do and

20
00:01:01.908 --> 00:01:07.419
data receive that triggers inside of
it entering back into create flow.

21
00:01:07.419 --> 00:01:10.754
I've never reached that,
because that's on my micro task queue.

22
00:01:10.754 --> 00:01:12.857
So it's still absolutely asynchronous.

23
00:01:12.857 --> 00:01:16.441
All this is doing, you can almost
think of the code, console log,

24
00:01:16.441 --> 00:01:20.985
you can almost think of everything after
the yield statement throughout the tasks,

25
00:01:20.985 --> 00:01:23.491
throughout the promise
object if you date it.

26
00:01:23.491 --> 00:01:28.090
Everything like this as being
the functionality we want to run on

27
00:01:28.090 --> 00:01:29.716
the data coming back.

28
00:01:29.716 --> 00:01:34.613
Almost think of this as being we
pass here, think of it as being,

29
00:01:34.613 --> 00:01:37.888
this here is our functionality run later.

30
00:01:37.888 --> 00:01:40.498
But now we get to go and run it,

31
00:01:40.498 --> 00:01:46.261
we get to write it as though it's
synchronous code in a function.

32
00:01:46.261 --> 00:01:50.584
We just come back to it only
when we trigger running due when

33
00:01:50.584 --> 00:01:54.746
dates are received,
which we then get to manually set.

34
00:01:54.746 --> 00:01:57.829
Now, I get to go back and run this code.

35
00:01:57.829 --> 00:02:04.297
It's the most control we've had probably
over when our deferred functionality runs.

36
00:02:04.297 --> 00:02:08.630
But in the end, it's still, as by the very
nature of asynchronicity in a language,

37
00:02:08.630 --> 00:02:09.738
beyond our control.

38
00:02:09.738 --> 00:02:13.527
Because what triggers return
nextElement.next running that takes us

39
00:02:13.527 --> 00:02:15.303
back in here, what triggers it?

40
00:02:15.303 --> 00:02:20.312
It's beyond our control
setting a value property.

41
00:02:20.312 --> 00:02:24.189
But beyond our control triggered
due when dates received.

42
00:02:24.189 --> 00:02:28.007
But now, when we trigger that we just
write inside a command that we did get to

43
00:02:28.007 --> 00:02:30.647
control writing that takes
us back to the function.

44
00:02:30.647 --> 00:02:35.645
But the very nature of sing thread in
a synchronous language is that you throw

45
00:02:35.645 --> 00:02:38.939
out tasks in a single thread,
you throw them out.

46
00:02:38.939 --> 00:02:40.475
And then they come back in and

47
00:02:40.475 --> 00:02:43.812
run functionality on the return
values beyond your control.

48
00:02:43.812 --> 00:02:46.951
That's the very nature and
that's why in the end,

49
00:02:46.951 --> 00:02:51.338
solution two which was the call back
model, in the end it's also true.

50
00:02:51.338 --> 00:02:54.741
It's not a wrong model,
under the hood is the same thing.

51
00:02:54.741 --> 00:02:57.996
Under the hood we're not
doing profoundly more here.

52
00:02:57.996 --> 00:03:02.547
You're just increasing readability
more and more, and in a sense,

53
00:03:02.547 --> 00:03:06.402
by doing so, hiding the underlying
engine more and more.

54
00:03:06.402 --> 00:03:10.458
And that's arguably a problem, if you
don't understand the underlying engine.

55
00:03:10.458 --> 00:03:14.057
If you do, now you get best of both
worlds, increased readability and

56
00:03:14.057 --> 00:03:16.745
the ability to understand
how it's truly working.

57
00:03:16.745 --> 00:03:20.830
All right, Alec?
&gt;&gt; Alex: Maybe someone asked this already.

58
00:03:20.830 --> 00:03:26.766
But can the generator
functions be anonymous?

59
00:03:26.766 --> 00:03:27.700
&gt;&gt; Will Sentance: Go play with that.

60
00:03:27.700 --> 00:03:31.444
There's interesting questions around arrow
functions and how you can define these.

61
00:03:31.444 --> 00:03:34.738
Go play with these.
&gt;&gt; Alex: Okay.

62
00:03:34.738 --> 00:03:35.280
&gt;&gt; Will Sentance: And we'll talk

63
00:03:35.280 --> 00:03:40.223
about it after you've experimented.
&gt;&gt; Will Sentance: Avdi, you want to

64
00:03:40.223 --> 00:03:43.373
try and phrase it as a question?
&gt;&gt; Abdi: I did it but

65
00:03:43.373 --> 00:03:46.844
it's just I need a little bit more
time to really have it sink in.

66
00:03:46.844 --> 00:03:48.879
But I kinda, I get to it.
&gt;&gt; Will Sentance: I appreciate it, man.

