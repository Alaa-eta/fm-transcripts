WEBVTT

1
00:00:00.000 --> 00:00:04.504
[MUSIC]

2
00:00:04.504 --> 00:00:07.456
&gt;&gt; Speaker 1: We've been throwing around
some concepts and we wanna come back and

3
00:00:07.456 --> 00:00:10.730
layer those in if there have been
some things that maybe were missed.

4
00:00:10.730 --> 00:00:15.692
If I have the value 42,
&gt;&gt; Speaker 1: And another way

5
00:00:15.692 --> 00:00:19.899
of expressing a value that looks very
similar is to put some quotes around it.

6
00:00:21.110 --> 00:00:25.260
These two values look like
they are roughly the same.

7
00:00:26.580 --> 00:00:30.640
If we were to print out both of them,
they would both print out in the same way.

8
00:00:30.640 --> 00:00:31.600
They'd both say 42.

9
00:00:31.600 --> 00:00:36.000
They'd have the literal characters 4 and
2 after each other.

10
00:00:36.000 --> 00:00:40.070
But they are gonna behave differently
in our JavaScript program.

11
00:00:40.070 --> 00:00:43.059
And that is because these values
are intrinsically of different types.

12
00:00:44.790 --> 00:00:45.760
And that word type,

13
00:00:45.760 --> 00:00:49.980
we don't mean physically putting
your fingers on keys on a keyboard.

14
00:00:49.980 --> 00:00:56.010
We mean it is an intrinsic behavior
of the value as expressed.

15
00:00:56.010 --> 00:01:00.018
So this 42 that we see
on line one is a number.

16
00:01:00.018 --> 00:01:04.520
And the quote 42 quote Is
what we call a string.

17
00:01:06.670 --> 00:01:12.120
And numbers have different behavior
associated with them than strings do.

18
00:01:12.120 --> 00:01:14.423
So for example,
numbers are what we do math with.

19
00:01:14.423 --> 00:01:18.610
We can say 42 / 2 and that gives us 21.

20
00:01:18.610 --> 00:01:20.982
Strings are what we do input and
output with.

21
00:01:20.982 --> 00:01:24.970
Strings are also how we
deal with characters.

22
00:01:24.970 --> 00:01:30.210
So if I wanted to say what is the first
character of the string 42 that

23
00:01:30.210 --> 00:01:35.090
bracket 0 could tell me that the first
character of it is the character 4.

24
00:01:35.090 --> 00:01:41.240
So the character 4 is the first
character in the string 42.

25
00:01:41.240 --> 00:01:46.520
Just like if I had the string abc,
the character

26
00:01:46.520 --> 00:01:50.570
at the one position is the character b,
okay?

27
00:01:50.570 --> 00:01:53.356
So, strings are accessing
things character by character,

28
00:01:53.356 --> 00:01:54.891
numbers are what we do math with.

29
00:01:54.891 --> 00:01:58.842
And these different intrinsic behaviors
are important to keep in mind.

30
00:01:58.842 --> 00:02:02.990
Because if I express the number
f42orty two in my JavaScript program,

31
00:02:02.990 --> 00:02:07.330
I am signaling that I intend to
use that in a mathematic way.

32
00:02:07.330 --> 00:02:10.716
And if I instead express
quote 42 in my program,

33
00:02:10.716 --> 00:02:15.000
I am expressing that I intend to
use that in a string way, okay?

34
00:02:15.000 --> 00:02:16.040
Yeah?

35
00:02:16.040 --> 00:02:18.875
&gt;&gt; Speaker 2: Is the use of single
versus double quotes important?

36
00:02:20.320 --> 00:02:25.300
&gt;&gt; Speaker 1: In JavaScript, strings can
either be double quotes or single quotes,

37
00:02:25.300 --> 00:02:26.480
you can't mix.

38
00:02:26.480 --> 00:02:28.390
You can't have a double
quote in the beginning and

39
00:02:28.390 --> 00:02:30.570
single quote in the end it has to match.

40
00:02:30.570 --> 00:02:33.280
But they can either be all
you know double quotes or

41
00:02:33.280 --> 00:02:36.420
single quotes in terms of your
delimiting of a string literal.

42
00:02:36.420 --> 00:02:39.900
There is no difference whatsoever
functionally in JavaScript.

43
00:02:41.250 --> 00:02:44.210
In fact stylistically,
the only arguments that it

44
00:02:44.210 --> 00:02:46.900
can ever be made are some
people prefer the single quote.

45
00:02:46.900 --> 00:02:50.230
Because it's less keystrokes for
them, they don't have to hit Shift.

46
00:02:50.230 --> 00:02:53.430
Other people prefer the double quote
because it's more natural that they've

47
00:02:53.430 --> 00:02:57.110
done that in other languages and
it's purely a stylistic thing.

48
00:02:57.110 --> 00:03:00.240
Here's what I would say never ever mix.

49
00:03:01.570 --> 00:03:04.710
Do not have part of your
program using single quotes and

50
00:03:04.710 --> 00:03:07.250
part of your program using double quotes.

51
00:03:07.250 --> 00:03:10.960
Pick one and I really don't care which
you can pick whichever one you want.

52
00:03:10.960 --> 00:03:13.860
There's no difference, but pick one and

53
00:03:13.860 --> 00:03:16.530
stick with that consistently
throughout your program.

54
00:03:16.530 --> 00:03:20.940
You will see that I prefer double quotes,
I used double quotes.

55
00:03:23.294 --> 00:03:24.591
&gt;&gt; Speaker 1: Okay [COUGH].

56
00:03:26.705 --> 00:03:28.010
&gt;&gt; Speaker 1: So, these numbers.

57
00:03:28.010 --> 00:03:30.370
I mean these values have
these different types.

58
00:03:30.370 --> 00:03:35.070
So, if I said var a = 42,
I've got 42 that's in a variable.

59
00:03:35.070 --> 00:03:37.570
Let me take off the var part
just to not confuse that now.

60
00:03:37.570 --> 00:03:41.520
So, I'm just making an assignment,
the a variable is gonna have the 42 in it.

61
00:03:41.520 --> 00:03:48.220
And if I wanted to print it out,
I can say console.log A and

62
00:03:48.220 --> 00:03:51.410
you'll notice that the JavaScript
engine duly does print that out.

63
00:03:51.410 --> 00:03:57.534
If we try this program
&gt;&gt; Speaker 1: You'll notice I see 42,

64
00:03:57.534 --> 00:04:00.933
but what happens if I send a a = quote 42?

65
00:04:00.933 --> 00:04:02.221
And I say console.log(a)?

66
00:04:08.251 --> 00:04:10.901
&gt;&gt; Speaker 1: It's very subtle and
difficult even on the projector to tell,

67
00:04:10.901 --> 00:04:12.801
but this one is printed
in blue characters and

68
00:04:12.801 --> 00:04:14.555
this one is printed in black characters.

69
00:04:14.555 --> 00:04:19.763
Because the console is giving you
a very subtle hint that underline

70
00:04:19.763 --> 00:04:24.420
what it's done it was dealing
with a different value type.

71
00:04:25.520 --> 00:04:28.916
So it's important understand and
this is actually there's,

72
00:04:28.916 --> 00:04:31.102
it's not really incorrect in the book.

73
00:04:31.102 --> 00:04:35.397
But there is a slightly misleading thing
that I'm gonna correct in a second

74
00:04:35.397 --> 00:04:36.018
edition.

75
00:04:36.018 --> 00:04:37.958
When it talks about console.log,

76
00:04:37.958 --> 00:04:41.880
it suggests that console.log
changes everything to a string.

77
00:04:41.880 --> 00:04:45.500
Actually it doesn't really change it to a
string when you're running inside of your

78
00:04:45.500 --> 00:04:48.890
JavaScript engine,
it just prints out whatever thing you had.

79
00:04:48.890 --> 00:04:51.210
So that's why we see a slightly
different representation there.

80
00:04:52.650 --> 00:04:56.390
There are other contexts which is what I
meant there are other contexts that change

81
00:04:56.390 --> 00:04:57.160
things into strings.

82
00:04:57.160 --> 00:05:03.390
So for example, saying alert (42) or
a variable with that number in it.

83
00:05:03.390 --> 00:05:05.900
Changes it into a strings that
it can printed in the box.

84
00:05:07.090 --> 00:05:10.200
So we can't tell any difference inside
of an alert box whether it had a number

85
00:05:10.200 --> 00:05:10.760
or a string.

86
00:05:10.760 --> 00:05:13.540
But we know under the covers it
needed a string to do it, so

87
00:05:13.540 --> 00:05:14.800
I actually converted it to a string.

88
00:05:17.976 --> 00:05:22.333
&gt;&gt; [COUGH]
&gt;&gt; Speaker 1: So

89
00:05:22.333 --> 00:05:26.702
if I wanted the string
representation of this value,

90
00:05:26.702 --> 00:05:31.760
if I had it as a number and
maybe then I later did some division.

91
00:05:31.760 --> 00:05:34.200
I said a = a / 2.

92
00:05:34.200 --> 00:05:36.844
So now we know a is holding the value 21.

93
00:05:37.860 --> 00:05:41.190
And if I then wanted to do
something string oriented with it,

94
00:05:41.190 --> 00:05:45.600
like output or
getting at its character or whatever.

95
00:05:45.600 --> 00:05:51.460
I would need to convert it into a string,
convert from one type to another.

96
00:05:51.460 --> 00:05:52.505
And this conversion,

97
00:05:52.505 --> 00:05:56.540
it's common in all programming languages
all programming language has it.

98
00:05:56.540 --> 00:05:59.590
Programing languages have
a notion of conversion.

99
00:05:59.590 --> 00:06:03.160
In JavaScript, the word that
we use is slightly different.

100
00:06:03.160 --> 00:06:06.050
It's not come version, it is coercion.

101
00:06:08.140 --> 00:06:10.590
And some people like to nitpick and
say, well,

102
00:06:10.590 --> 00:06:15.030
there's one thing that's conversion in
JavaScript and another thing is coercion.

103
00:06:15.030 --> 00:06:18.130
I find it much easier to
actually distinguish.

104
00:06:18.130 --> 00:06:21.360
Between explicit and implicit

105
00:06:21.360 --> 00:06:24.990
rather than conversion in coercion
that one's marking confusing to me.

106
00:06:24.990 --> 00:06:30.330
So an explicit conversion, one that it's
obvious that that's what I'm trying to do.

107
00:06:30.330 --> 00:06:34.490
If I wanted to turn a into
a string representation,

108
00:06:34.490 --> 00:06:36.700
I could literally use the string function.

109
00:06:38.912 --> 00:06:42.547
&gt;&gt; Speaker 1: And that's gonna convert and
that might look if you have any experience

110
00:06:42.547 --> 00:06:45.697
in another programming language
where they do type casting or

111
00:06:45.697 --> 00:06:48.800
other forms of conversion
that looks very similar.

112
00:06:48.800 --> 00:06:53.430
So I'm explicitly saying take the thing
that's in a now and if it's not a string,

113
00:06:53.430 --> 00:06:54.710
make it look like a string.

114
00:06:54.710 --> 00:06:56.360
And then assign that value back into a.

115
00:07:00.170 --> 00:07:04.545
&gt;&gt; Speaker 1: So if we took this program
if we put a console.log on it and

116
00:07:04.545 --> 00:07:07.200
we took that program and we ran it.

117
00:07:09.710 --> 00:07:14.880
Are we expecting a blue number for the 21,
which would be that it's a number or

118
00:07:14.880 --> 00:07:19.180
are we expecting a black characters for
21 because it's a string?

119
00:07:20.370 --> 00:07:22.200
We'd be expecting black
because it's a string.

120
00:07:22.200 --> 00:07:24.300
And in fact, we get black.

121
00:07:24.300 --> 00:07:26.240
Again, it's really subtle on
the projector on the screen.

122
00:07:26.240 --> 00:07:31.900
But this is black 21 because it's actually
a string representation there printed out.

123
00:07:31.900 --> 00:07:36.867
Exactly the same as if I
had said console.log hello.

124
00:07:41.827 --> 00:07:43.282
&gt;&gt; Speaker 1: Okay?

125
00:07:43.282 --> 00:07:49.320
All right, so strings serve a purpose in
programs differently than numbers do and

126
00:07:49.320 --> 00:07:52.780
converting between the two
is almost always required.

127
00:07:54.010 --> 00:08:00.060
We saw that we could say a = String(a)
to convert from anything into a string.

128
00:08:01.320 --> 00:08:05.010
If we wanted to go the other direction,
like go from a string to a number.

129
00:08:05.010 --> 00:08:07.150
Like if we had another variable
called b and we said b.

130
00:08:07.150 --> 00:08:09.540
Then we could do the same thing but

131
00:08:09.540 --> 00:08:11.675
with the number of function
we could say a Number (a).

132
00:08:12.910 --> 00:08:17.615
So now b is gonna be the number 21 and
a is gonna be the string quote 21.

133
00:08:22.707 --> 00:08:25.420
&gt;&gt; Speaker 1: There's a question in
the chat room about changing things.

134
00:08:25.420 --> 00:08:27.820
This is a subtle point which I
don't want to believe or too much.

135
00:08:27.820 --> 00:08:31.650
But which we'll actually get
much more into when we talk

136
00:08:31.650 --> 00:08:34.920
in the morning session of day two.

137
00:08:34.920 --> 00:08:38.050
When we talk about coercions and
all that stuff and much much more detail,

138
00:08:38.050 --> 00:08:39.860
but just as a brief answer.

139
00:08:39.860 --> 00:08:40.670
In JavaScript,

140
00:08:40.670 --> 00:08:45.340
variables do not have types, there's no
such thing as a variable having a type.

141
00:08:45.340 --> 00:08:48.830
In JavaScript, the value has the type, so

142
00:08:48.830 --> 00:08:53.270
the value 42 or the value quote
42 is the thing with a type.

143
00:08:53.270 --> 00:08:55.510
And the variable,
the thing that we call a or

144
00:08:55.510 --> 00:08:59.340
b, it has no type,
it can have any value of any type in it.

145
00:09:00.410 --> 00:09:04.140
Whereas in other languages that
are called static languages.

146
00:09:04.140 --> 00:09:06.950
Those languages you don't
declare a type on the value so

147
00:09:06.950 --> 00:09:10.710
much as you declare a type
on the variable itself.

148
00:09:10.710 --> 00:09:14.640
So in c for example if I say int a,

149
00:09:14.640 --> 00:09:19.720
I'm saying this variable container
must hold only ints, integers.

150
00:09:19.720 --> 00:09:23.990
So I'm typing the variable itself rather
than worrying about the type of the value.

151
00:09:23.990 --> 00:09:27.970
Such as the distinction in JavaScript and
another dynamic value languages,

152
00:09:27.970 --> 00:09:32.370
like JavaScript,
we don't have a type for the variable,

153
00:09:32.370 --> 00:09:35.690
we have a type for the value.

154
00:09:41.698 --> 00:09:43.960
&gt;&gt; Speaker 1: The return of
a variable color code matters.

155
00:09:43.960 --> 00:09:47.230
The only point that we're making here
is to understand if you're gonna

156
00:09:47.230 --> 00:09:50.720
program inside of the console,
understanding what the console's doing.

157
00:09:50.720 --> 00:09:56.140
It has special behaviors that are outside
of what JavaScript itself is doing.

158
00:09:56.140 --> 00:09:59.420
So here, I'm just helping you
understand that the console if you see

159
00:09:59.420 --> 00:10:02.100
blue characters, then the console's
telling you, you had a number.

160
00:10:02.100 --> 00:10:05.840
And if you see black characters, the
console's telling you, you had a string.

161
00:10:05.840 --> 00:10:08.170
That's just a subtle nuance
of working with the console.

162
00:10:08.170 --> 00:10:10.390
It does not matter actually
to the JavaScript engine.

163
00:10:14.208 --> 00:10:15.250
&gt;&gt; Speaker 1: Okay?

164
00:10:16.410 --> 00:10:19.930
So we're not gonna do much more
about coercions, except for

165
00:10:19.930 --> 00:10:22.690
me to suggest that those two
that I showed you before.

166
00:10:23.800 --> 00:10:28.950
These are explicit and
there are ways to do implicit coercions.

167
00:10:28.950 --> 00:10:36.400
A way to go from a number to a string that
is sort of a side effect of some other

168
00:10:36.400 --> 00:10:40.440
operation, that's what I mean by implicit
it's not obvious that you're doing it.

169
00:10:40.440 --> 00:10:43.506
If I said something like right
now we know a is the number 21.

170
00:10:43.506 --> 00:10:47.695
If I said a = a + and an empty string.

171
00:10:51.089 --> 00:10:53.798
&gt;&gt; Speaker 1: Again, without getting
too much into the weeds about

172
00:10:53.798 --> 00:10:55.310
how the plus operator works.

173
00:10:55.310 --> 00:10:59.570
In this case, the plus operator
wants to do string concatenation

174
00:10:59.570 --> 00:11:02.150
instead of mathematic addition.

175
00:11:02.150 --> 00:11:06.350
And because one of these things
is not already a string.

176
00:11:06.350 --> 00:11:09.220
It has to make it into a string, so

177
00:11:09.220 --> 00:11:12.850
under the covers it's gonna do that
string a thing that I was showing you.

178
00:11:12.850 --> 00:11:15.660
But it's not obvious to
us that that's happening.

179
00:11:15.660 --> 00:11:22.320
And yet if we try this program and
do a console that log on that a variable.

180
00:11:24.230 --> 00:11:26.909
If we try this program will
notice that we gonna get those

181
00:11:26.909 --> 00:11:30.453
black characters because it's going
to have made it into a string value.

182
00:11:34.957 --> 00:11:37.744
&gt;&gt; Speaker 1: Try that in your
own console to verify whether or

183
00:11:37.744 --> 00:11:40.030
not you have that third line in or not.

184
00:11:40.030 --> 00:11:43.498
You'll notice the difference between
getting black characters in your console

185
00:11:43.498 --> 00:11:44.780
or getting blue characters.

186
00:11:44.780 --> 00:11:46.170
Your question back there?

187
00:11:46.170 --> 00:11:49.820
&gt;&gt; Speaker 3: Would there ever be a time
where you would want something to

188
00:11:49.820 --> 00:11:52.350
not change, so it would be final?

189
00:11:52.350 --> 00:11:56.650
And so even in the midst it's like that,
it would give

190
00:11:56.650 --> 00:12:01.430
you an error let's say instead of
converting it behind the scenes?

191
00:12:01.430 --> 00:12:02.640
You don't want that to.

192
00:12:04.090 --> 00:12:08.020
&gt;&gt; Speaker 1: There's a question in
the live room here about whether or not

193
00:12:08.020 --> 00:12:13.400
there's a notion of wanting a a variable
to have sort of a final value in it.

194
00:12:13.400 --> 00:12:15.545
That is if you tried to
do something else and

195
00:12:15.545 --> 00:12:18.358
assign it a different value
it would throw you an error.

196
00:12:18.358 --> 00:12:22.510
And there is actually that notion
as of ES6, the newest latest and

197
00:12:22.510 --> 00:12:25.189
greatest JavaScript that's coming out.

198
00:12:25.189 --> 00:12:29.249
There's a notion instead of using that var
keyword that I've talked about a couple

199
00:12:29.249 --> 00:12:33.040
times, you can use const to
create what's called a constant.

200
00:12:33.040 --> 00:12:35.680
And other various other programming
languages also have a notion of

201
00:12:35.680 --> 00:12:36.280
a constant.

202
00:12:36.280 --> 00:12:39.270
So that's getting a little
out of our topic, but

203
00:12:39.270 --> 00:12:41.250
just to make sure we're clear on it.

204
00:12:41.250 --> 00:12:46.480
If I said var a = 42, I'm making an a that
can be changed as many times as I want.

205
00:12:46.480 --> 00:12:53.110
But if I said const a = 42, I'm making
an a that can never be changed again.

206
00:12:53.110 --> 00:12:57.930
And if I do a = 10, it will either
silently fail or actually throw me

207
00:12:57.930 --> 00:13:02.440
an error and that depends on strict mode,
which we may cover later.

208
00:13:02.440 --> 00:13:06.200
But const is the way you make
a variable that can't be changed later.

209
00:13:06.200 --> 00:13:08.980
And that's only in the newest
versions of JavaScript.

