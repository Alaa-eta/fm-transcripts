WEBVTT

1
00:00:00.000 --> 00:00:03.783
[MUSIC]

2
00:00:03.783 --> 00:00:05.760
&gt;&gt; Kyle Simpson: Okay, so
let's go back to the text.

3
00:00:05.760 --> 00:00:10.130
I know I kind of jumped around a little
bit and I'll, well, let's get ourselves

4
00:00:10.130 --> 00:00:14.330
back on track and make sure we understand
or that we track back with the text.

5
00:00:14.330 --> 00:00:17.480
So [COUGH] we'll come back to and

6
00:00:17.480 --> 00:00:22.110
the next topic that's addressed is
what we've only talked about so

7
00:00:22.110 --> 00:00:27.050
far is how to think about what
a program is structured in.

8
00:00:27.050 --> 00:00:30.910
And maybe start to think in our brains
about what we'd do if we wanted to do it.

9
00:00:30.910 --> 00:00:34.750
But it turns out that it's much more
important for the computer to run our

10
00:00:34.750 --> 00:00:37.770
program [LAUGH] in the end than it is for
us to run our program.

11
00:00:37.770 --> 00:00:41.190
So it is that duality,
as was brought up before,

12
00:00:41.190 --> 00:00:44.950
between needing to be able to look at a
program and understand what it should do.

13
00:00:44.950 --> 00:00:49.780
And then being able to rely upon the
computer to do what it actually must do.

14
00:00:49.780 --> 00:00:54.740
And those are two really important
halves of the brain, if you will.

15
00:00:54.740 --> 00:00:56.380
So executing a program
what does that mean?

16
00:00:56.380 --> 00:01:01.360
Well essentially, it means turning
the statements that we've written, like

17
00:01:01.360 --> 00:01:07.170
a = b * 2, into low level instructions
that a computer can do something with.

18
00:01:07.170 --> 00:01:11.440
The computer itself would look at a = b
* 2 and have no idea what that meant.

19
00:01:11.440 --> 00:01:13.130
JavaScript knows what it means.

20
00:01:13.130 --> 00:01:15.990
JavaScript needs to translate
it into something else

21
00:01:15.990 --> 00:01:19.510
that then can be translated and translated
further and further down the stack.

22
00:01:19.510 --> 00:01:22.520
Until eventually you get to that
series of ones and zeroes, and

23
00:01:22.520 --> 00:01:25.130
the computer says,
I know what to do with that.

24
00:01:25.130 --> 00:01:28.470
The one means put an electrical charge
in and the zero means turn it off.

25
00:01:28.470 --> 00:01:32.100
And I can switch back and forth between
ones and zeroes really fast and

26
00:01:32.100 --> 00:01:35.760
run all those things through
the circuitry in my computer's CPU and

27
00:01:35.760 --> 00:01:37.590
out pops a number, right?

28
00:01:37.590 --> 00:01:41.692
So it's this process of getting
something from this high level language,

29
00:01:41.692 --> 00:01:42.985
like JavaScript.

30
00:01:42.985 --> 00:01:47.530
This a = b * 2,
which isn't exactly like natural language.

31
00:01:47.530 --> 00:01:52.670
It's not like I said it'd be
interesting if there was a programming

32
00:01:52.670 --> 00:01:59.330
language where I could say set
the variable a to the value 2, right?

33
00:01:59.330 --> 00:02:00.540
&gt;&gt; Speaker 2: COBOL!
&gt;&gt; Kyle Simpson: Right,

34
00:02:00.540 --> 00:02:06.820
there are languages that are even
higher level than JavaScript is.

35
00:02:06.820 --> 00:02:12.830
And so understanding that, what we call it
in programming, we call it abstraction.

36
00:02:12.830 --> 00:02:15.800
At this level,
it looks like an English sentence.

37
00:02:17.340 --> 00:02:20.150
There would have to be a translation
from that into something

38
00:02:20.150 --> 00:02:22.910
lower level because the computer would
look at that and equally be confused.

39
00:02:22.910 --> 00:02:29.092
So a translation level would go from that
to maybe something like a = 2, right?

40
00:02:31.150 --> 00:02:34.830
And then, something would have to go
from a = 2 down into another layer.

41
00:02:34.830 --> 00:02:37.290
And we might be getting
to too far a field but,

42
00:02:37.290 --> 00:02:38.550
I just want to make sure you understand.

43
00:02:38.550 --> 00:02:43.700
So the next layer down might be something
that people refer to as assembly language,

44
00:02:43.700 --> 00:02:46.410
which is still a high level language.

45
00:02:46.410 --> 00:02:48.850
It's not a one and zero,
but it's lower level.

46
00:02:48.850 --> 00:02:53.129
And I don't even remember
my assembly language, But

47
00:02:53.129 --> 00:02:58.290
it's something like mov a, 2 or
something like that or 2, a.

48
00:02:58.290 --> 00:02:59.920
I think it's 2, a or something like that.

49
00:02:59.920 --> 00:03:04.230
But that lower level thing is like I got
these two different registers in memory or

50
00:03:04.230 --> 00:03:05.890
whatever and
move one into the other, right?

51
00:03:05.890 --> 00:03:09.110
And then finally,
at the lowest level of the stack,

52
00:03:09.110 --> 00:03:13.150
it's taken that thing down into
a series of ones and zeros.

53
00:03:13.150 --> 00:03:14.340
That's really really long and

54
00:03:14.340 --> 00:03:17.229
that that one in zero string
tells the computer what to do.

55
00:03:18.420 --> 00:03:21.040
So what we want is we wanna
figure out to execute my

56
00:03:21.040 --> 00:03:24.802
program of course we don't need this top
level but we definitely need the top.

57
00:03:24.802 --> 00:03:28.490
This a = 2 level we need
something to convert it from

58
00:03:28.490 --> 00:03:30.980
that layer down into the next layer.

59
00:03:30.980 --> 00:03:33.260
They'll be something else that
handles that on and on and on and

60
00:03:33.260 --> 00:03:34.730
on however many steps it needs to take.

61
00:03:34.730 --> 00:03:36.830
But we need something to
do that first step and

62
00:03:36.830 --> 00:03:39.810
that something is the Java script engine.

63
00:03:39.810 --> 00:03:41.940
The thing that's built into our browser.

64
00:03:41.940 --> 00:03:44.380
The thing that you can invoke
in the developer console.

65
00:03:44.380 --> 00:03:46.880
If you were doing programming on a server,

66
00:03:46.880 --> 00:03:49.860
there's an environment where
JavaScript can run on a server.

67
00:03:49.860 --> 00:03:54.020
I mean there's all kinds of different
places JavaScript can run on watches and

68
00:03:54.020 --> 00:03:55.630
inside of light bulbs and whatever.

69
00:03:55.630 --> 00:03:58.720
But in every place that there
is there's a JavaScript engine

70
00:03:58.720 --> 00:04:01.190
that takes something like a = 2.

71
00:04:01.190 --> 00:04:04.600
And turns it into something that that
environment knows what to do with.

72
00:04:04.600 --> 00:04:06.970
And that's what we mean
by executing a program,

73
00:04:06.970 --> 00:04:09.920
is taking that source code that
we've written in text form,

74
00:04:11.100 --> 00:04:15.120
converting it into something that the next
layer down knows what to do with, okay?

75
00:04:17.110 --> 00:04:20.530
Now quick little kind
of myth busting thing.

76
00:04:20.530 --> 00:04:23.820
It is often said of languages,
like JavaScript,

77
00:04:23.820 --> 00:04:25.780
that they are scripting languages.

78
00:04:25.780 --> 00:04:27.920
Of course,
the Word script shows up in JavaScript, so

79
00:04:27.920 --> 00:04:31.500
it's natural to assume that
it's a scripting language.

80
00:04:31.500 --> 00:04:36.090
And it's also often said that
scripting languages are interpreted.

81
00:04:38.110 --> 00:04:41.580
In other words, one statement at a time.

82
00:04:41.580 --> 00:04:43.960
It works on that statement and
then it goes to the next statement, and

83
00:04:43.960 --> 00:04:44.750
then in the next statement.

84
00:04:44.750 --> 00:04:47.550
So when it's working on
the statement on line three,

85
00:04:47.550 --> 00:04:51.290
it has no idea what to expect of line
four because it hasn't gotten there yet.

86
00:04:51.290 --> 00:04:54.580
As like if you're working through
a to-do list, I don't even care about.

87
00:04:54.580 --> 00:04:57.260
item two yet
because I'm on top item on my to-do list,

88
00:04:57.260 --> 00:04:58.900
the only thing I'm thinking about, right?

89
00:04:58.900 --> 00:05:00.450
Well, that's what we mean by interpreting.

90
00:05:00.450 --> 00:05:04.310
And there are languages that
are in fact interpreted like that,

91
00:05:04.310 --> 00:05:07.150
that are interpreted line by line by line.

92
00:05:07.150 --> 00:05:10.280
An example of that might be something
like a command line scripting like

93
00:05:10.280 --> 00:05:11.450
bash or whatever.

94
00:05:11.450 --> 00:05:12.910
It's not fully interpreted.

95
00:05:12.910 --> 00:05:17.550
There's a little bit of nuance there but
it's essentially interpreted line by line.

96
00:05:17.550 --> 00:05:21.260
And it's oftentimes assumed that
JavaScript is the same way.

97
00:05:21.260 --> 00:05:25.100
It's often times assume that JavaScript
is interpreted with line one and

98
00:05:25.100 --> 00:05:26.510
then line two and line three.

99
00:05:26.510 --> 00:05:30.450
There are many books that have said that
and it is true that in the very earliest

100
00:05:30.450 --> 00:05:33.690
days of JavaScript it worked
a lot more like that.

101
00:05:33.690 --> 00:05:37.810
It's definitely true that when Brendan
was first inventing it as a prototype.

102
00:05:37.810 --> 00:05:41.230
He didn't really have all the time to
go through all the sophisticated stuff,

103
00:05:41.230 --> 00:05:44.130
so he had to make just bang
something out quickly and

104
00:05:44.130 --> 00:05:45.500
it had to cut a lot of corners.

105
00:05:45.500 --> 00:05:48.410
So it essentially in the very beginning,
it was kind of that way.

106
00:05:48.410 --> 00:05:51.380
But very quickly JavaScript matured and
then by very quickly.

107
00:05:51.380 --> 00:05:53.740
I mean within those first couple of years.

108
00:05:53.740 --> 00:05:56.520
JavaScript matured to the point
where interpreting it wasn't

109
00:05:56.520 --> 00:05:58.780
really practical anymore.

110
00:05:58.780 --> 00:06:02.630
And yet that myth propagates, even today
people say JavaScript is a scripting

111
00:06:02.630 --> 00:06:04.320
language, it's interpreted, it's not.

112
00:06:05.820 --> 00:06:09.570
And the other option if it's
not an interpreted language,

113
00:06:09.570 --> 00:06:12.870
the other thing that we talk about is
what's called a compiled language.

114
00:06:12.870 --> 00:06:16.680
And what are compiled language and
an interpreted language,

115
00:06:16.680 --> 00:06:21.150
the way that they primarily differ Is not
the way you might think that they differ.

116
00:06:23.000 --> 00:06:25.970
Most people think about the difference
between an interpreted language and

117
00:06:25.970 --> 00:06:28.600
a compiled language as

118
00:06:28.600 --> 00:06:32.520
that a compiled language gives you
this physical binary file thing.

119
00:06:32.520 --> 00:06:35.570
Like on Windows, it's a .exd file.

120
00:06:35.570 --> 00:06:39.250
Or on a Mac, it's on and
you know what it is on the Mac.

121
00:06:39.250 --> 00:06:43.030
But there's some like executable
file on the Mac that you can run or

122
00:06:43.030 --> 00:06:45.780
of what I compile
something in Visual Studio.

123
00:06:45.780 --> 00:06:50.850
And I put my program on a, nobody does,
this put on CD or DVD anymore.

124
00:06:50.850 --> 00:06:53.890
But that's the way you used to do
distribute in the old days of programming.

125
00:06:53.890 --> 00:06:57.180
You'd put your program on a CD and
sell it to people.

126
00:06:57.180 --> 00:07:01.900
So most people think of compilation as I'm
producing some physical series of ones and

127
00:07:01.900 --> 00:07:05.060
zeros and putting those into a file.

128
00:07:05.060 --> 00:07:07.230
That I can send that series of ones and
zeros to other people and

129
00:07:07.230 --> 00:07:09.250
they don't need to process it,
they just need to run it.

130
00:07:10.450 --> 00:07:13.030
And they think about interpreted
languages as not doing that,

131
00:07:13.030 --> 00:07:16.409
that every time you want to run it
has to reprocess from the beginning.

132
00:07:18.130 --> 00:07:20.790
So that's one way of thinking about
the difference between interpreted and

133
00:07:20.790 --> 00:07:24.510
compiled but,
the more important distinction.

134
00:07:24.510 --> 00:07:28.140
The one that matters to JavaScript is that

135
00:07:28.140 --> 00:07:32.760
compilation means that there's more
than one pass through your program.

136
00:07:34.590 --> 00:07:35.820
What do I mean by a pass?

137
00:07:35.820 --> 00:07:39.100
Let me try to illustrate that because I
could be getting off field very quickly.

138
00:07:39.100 --> 00:07:43.643
So, if I have a = 2, and
then I have something down here like.

139
00:07:46.082 --> 00:07:47.045
&gt;&gt; Kyle Simpson: That.
Well,

140
00:07:47.045 --> 00:07:52.080
2() kinda looks like a function call,
but it's not valid.

141
00:07:52.080 --> 00:07:55.270
Because you can't have a number
in the place of an identifier, so

142
00:07:55.270 --> 00:07:59.480
as JavaScript language is
concerned lying to is an error.

143
00:07:59.480 --> 00:08:00.150
It's invalid.

144
00:08:00.150 --> 00:08:03.430
It's actually syntactically invalid.

145
00:08:03.430 --> 00:08:08.000
It's not a runtime problem it's an actual
author time problem I was an idiot.

146
00:08:08.000 --> 00:08:12.100
and I put the number 2 in a position
where I meant to put a letter, okay?

147
00:08:12.100 --> 00:08:17.180
So in an interpreted language if I was
purely running line by line by line and

148
00:08:17.180 --> 00:08:19.120
I wasn't doing multiple passes.

149
00:08:19.120 --> 00:08:23.770
I'd run line one first, and then I would
discover that line two had a problem and

150
00:08:23.770 --> 00:08:24.400
I'd throw an error.

151
00:08:25.790 --> 00:08:27.680
But in a compiled language.

152
00:08:27.680 --> 00:08:30.840
The first pass is not concerned
with executing the program,

153
00:08:30.840 --> 00:08:33.790
it's concerned with
understanding the program.

154
00:08:33.790 --> 00:08:38.590
It makes a pass through this program and
it figures out of the program is valid.

155
00:08:38.590 --> 00:08:40.170
Does it match all of the rules?

156
00:08:40.170 --> 00:08:42.940
It would be like scanning
through a novel and

157
00:08:42.940 --> 00:08:46.190
looking at all the things to make sure all
the sentences had their periods on them.

158
00:08:46.190 --> 00:08:49.610
And then going back and reading
the book to understand its content.

159
00:08:49.610 --> 00:08:50.860
That's the difference here.

160
00:08:50.860 --> 00:08:53.970
So compiled language would
say line two is a problem and

161
00:08:53.970 --> 00:08:58.330
it would flag you with that error
before it ever tried to run line one.

162
00:08:58.330 --> 00:09:01.480
Does everybody understand
the difference there?

163
00:09:01.480 --> 00:09:05.600
Make sure that people, hopefully,
people aren't missing that distinction.

164
00:09:05.600 --> 00:09:07.740
So JavaScript,

165
00:09:07.740 --> 00:09:13.130
in that respect, is more a compiled
language than an interpreted language.

166
00:09:13.130 --> 00:09:17.040
Because JavaScript definitely
does look at line two first

167
00:09:17.040 --> 00:09:18.630
before it's ever tried to run line one.

168
00:09:18.630 --> 00:09:24.650
It looked at line one to understand what
line one was about, but it didn't run it.

169
00:09:24.650 --> 00:09:26.290
It just looked at it to understand it, and

170
00:09:26.290 --> 00:09:28.370
then it looked at line
two to understand it.

171
00:09:28.370 --> 00:09:30.200
And when it saw that line two was invalid,

172
00:09:30.200 --> 00:09:33.209
it said I'm not even to try to run the
program because it's not a valid program.

173
00:09:35.620 --> 00:09:37.130
So when you put a program like this.

174
00:09:37.130 --> 00:09:40.790
If that was in a file and you loaded that
up into a browser, line one would never

175
00:09:40.790 --> 00:09:43.700
run, you'd immediately get an error
saying line two is invalid.

176
00:09:44.800 --> 00:09:48.060
Whereas, if you put this into a scripting
language like a Bash or something.

177
00:09:48.060 --> 00:09:51.960
Line one would run and then you'd get
an error on line two, and that's the major

178
00:09:51.960 --> 00:09:56.040
distinction that we wanna make between
this compilation versus interpreting.

179
00:09:56.040 --> 00:10:00.650
The good news is that because JavaScript
compiled a lot of these mistakes

180
00:10:00.650 --> 00:10:04.450
that you can make in your programming are
going to get caught at the very beginning.

181
00:10:04.450 --> 00:10:07.170
Before you've had a chance to
mess something up [LAUGH].

182
00:10:07.170 --> 00:10:11.300
You try to run your program on the first
thing that happens as it gets compiled.

183
00:10:11.300 --> 00:10:15.530
And if the compilation throws an error and
says hey you messed up.

184
00:10:15.530 --> 00:10:16.940
That's not good.

185
00:10:16.940 --> 00:10:18.170
Then you know what you need to fix.

186
00:10:18.170 --> 00:10:21.890
It will tell you line two is invalid,
two is not a function or whatever.

187
00:10:24.080 --> 00:10:28.640
Okay, so that's the distinction we'll
make and we'll kind of leave it there.

188
00:10:28.640 --> 00:10:32.620
There's definitely more details and
I expound upon that a lot more in

189
00:10:32.620 --> 00:10:36.180
the scope and closures book in the series,
but what kind of leave it for there.

190
00:10:36.180 --> 00:10:40.490
Think of JavaScript more like a compiled
language, then an interpreted language.

191
00:10:40.490 --> 00:10:44.180
And it doesn't really matter
that JavaScript doesn't get

192
00:10:44.180 --> 00:10:47.880
put into binary form and
distributed the way .exe files are.

193
00:10:47.880 --> 00:10:51.670
What matters is that JavaScript
gets compiled for error checking.

