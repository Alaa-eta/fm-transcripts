WEBVTT

1
00:00:00.390 --> 00:00:02.372
&gt;&gt; Kyle Simpson: Okay, so
let's go back to the texts.

2
00:00:02.372 --> 00:00:04.860
I know I kinda jumped around a little bit.

3
00:00:04.860 --> 00:00:08.560
Let's get ourselves back on track,
and make sure we understand.

4
00:00:08.560 --> 00:00:10.750
Or that we track back the text.

5
00:00:10.750 --> 00:00:17.530
So, we'll come back, in the next
topic that's addressed is, we've

6
00:00:17.530 --> 00:00:23.540
only talked about, so far, is how to think
about what a program is structured in.

7
00:00:23.540 --> 00:00:27.400
And maybe start to think in our brains
about what we'd do if we wanted to do it.

8
00:00:27.400 --> 00:00:30.050
But it turns out that it's
much more important for

9
00:00:30.050 --> 00:00:34.260
the computer to run our program in the
end, than it is for us to run our program.

10
00:00:34.260 --> 00:00:38.360
So, it is that duality, as was
brought up before, between you needing

11
00:00:38.360 --> 00:00:41.550
to be able to look at a program and
understand what it should do, and

12
00:00:41.550 --> 00:00:46.260
then being able to rely upon the computer
to do what it actually must do.

13
00:00:46.260 --> 00:00:51.200
And those are two really important
halves of the brain, if you will.

14
00:00:51.200 --> 00:00:52.880
So executing a program,
what does that mean?

15
00:00:52.880 --> 00:00:58.010
Well, essentially it means turning the
statements that we've written, like a =

16
00:00:58.010 --> 00:01:03.660
b x 2, into low level instructions
that a computer can do something with.

17
00:01:03.660 --> 00:01:07.930
The computer itself would look at a = b
x 2, and have no idea what that meant.

18
00:01:07.930 --> 00:01:09.620
JavaScript knows what it means.

19
00:01:09.620 --> 00:01:12.480
JavaScript needs to translate
it into something else,

20
00:01:12.480 --> 00:01:15.040
that then can then be translated and
translated further and

21
00:01:15.040 --> 00:01:18.498
further down the stack until eventually,
you get to that series of ones and

22
00:01:18.498 --> 00:01:21.620
zeros, and the computer says
I know what to do with that.

23
00:01:21.620 --> 00:01:24.950
The one means put an electrical charge in,
and the zero means turn it off,

24
00:01:24.950 --> 00:01:28.840
and I can switch back and forth between
ones and zeroes really fast, and run all

25
00:01:28.840 --> 00:01:33.370
those things through the circuitry in my
computer's CPU, and out pops a number.

26
00:01:33.370 --> 00:01:34.080
Right?

27
00:01:34.080 --> 00:01:38.980
So, it's this process of getting something
from this high level language like

28
00:01:38.980 --> 00:01:44.020
JavaScript, this a = b * 2,
which isn't exactly like natural language.

29
00:01:44.020 --> 00:01:49.160
It's not like I said, it'd be
interesting if there was a programming

30
00:01:49.160 --> 00:01:54.420
language where I could say,
set the variable a to the value two.

31
00:01:54.420 --> 00:01:54.960
&gt;&gt; Speaker 2: Cool.

32
00:01:54.960 --> 00:02:00.035
&gt;&gt; Kyle Simpson: Right,
there are languages that are even

33
00:02:00.035 --> 00:02:04.250
higher level than JavaScript is.

34
00:02:04.250 --> 00:02:07.810
And so, understanding that sort of,
what we call it in programming,

35
00:02:07.810 --> 00:02:09.310
we call it abstraction.

36
00:02:09.310 --> 00:02:12.530
At this level,
it looks like an English sentence.

37
00:02:13.830 --> 00:02:17.270
There would have to be a translation
from that into something lower level,

38
00:02:17.270 --> 00:02:19.640
cuz the computer would look at that and
equally be confused.

39
00:02:19.640 --> 00:02:25.380
So a translation level would go from
that to maybe something like a = 2.

40
00:02:25.380 --> 00:02:25.880
Right?

41
00:02:27.130 --> 00:02:30.351
&gt;&gt; Kyle Simpson: And then something
would have to go from a = 2 down into

42
00:02:30.351 --> 00:02:31.340
another layer.

43
00:02:31.340 --> 00:02:35.040
And we might be getting too far afield,
but I just wanna make sure you understand.

44
00:02:35.040 --> 00:02:40.180
So, the next layer down might be something
that people refer to as assembly language.

45
00:02:40.180 --> 00:02:43.950
Which is still a high level language,
it's not a one and a zero,

46
00:02:43.950 --> 00:02:45.180
but it's lower level.

47
00:02:45.180 --> 00:02:48.279
And I don't even remember
my assembly language,

48
00:02:48.279 --> 00:02:52.409
but it's something like move a comma 2,
or something like that,

49
00:02:52.409 --> 00:02:56.344
or two comma, I think It's two comma a or
something like that.

50
00:02:56.344 --> 00:02:58.430
But that lower level thing is like,

51
00:02:58.430 --> 00:03:03.030
I have these two registers in memory or
whatever, and move one into the other.

52
00:03:03.030 --> 00:03:05.682
And then finally,
at the lowest level of the stack,

53
00:03:05.682 --> 00:03:09.490
it is taking that thing down into
a series of one's and zeros.

54
00:03:09.490 --> 00:03:10.880
That's really really long.

55
00:03:10.880 --> 00:03:13.755
And that one and
zero string tells the computer what to do.

56
00:03:13.755 --> 00:03:17.870
So what we want is we want to figure out,
to execute my program,

57
00:03:17.870 --> 00:03:19.190
of course we don't need this top level.

58
00:03:19.190 --> 00:03:22.442
But we definitely need this a = 2 level.

59
00:03:22.442 --> 00:03:27.120
We need something to convert it from
that layer down into the next layer.

60
00:03:27.120 --> 00:03:29.930
There will be something else
that handles it on and on,

61
00:03:29.930 --> 00:03:33.210
however many steps it needs to take, but
we need something to do that first step,

62
00:03:33.210 --> 00:03:36.290
and that something is
the JavaScript engine.

63
00:03:36.290 --> 00:03:38.420
The thing that's built into our browser,

64
00:03:38.420 --> 00:03:40.880
the thing that you can invoke
in the developer console.

65
00:03:40.880 --> 00:03:45.160
If you were doing programming on a server,
there's an environment where JavaScript

66
00:03:45.160 --> 00:03:48.220
can run on a server, and I mean,
there's all kinds of different places.

67
00:03:48.220 --> 00:03:52.120
JavaScript can run on watches, and
inside of lightbulbs, and whatever.

68
00:03:52.120 --> 00:03:56.262
But in every place that there is, there's
a JavaScript engine that takes something

69
00:03:56.262 --> 00:04:01.080
like a=2, and turns it into something that
that environment knows what to do with.

70
00:04:01.080 --> 00:04:03.460
And that's what we mean
by executing a program,

71
00:04:03.460 --> 00:04:06.460
is taking that source code that
we've written in text form,

72
00:04:07.580 --> 00:04:11.420
converting into something that the next
layer down knows what to do with.

73
00:04:11.420 --> 00:04:17.330
Okay, now, quick little kind
of myth busting thing, it is

74
00:04:17.330 --> 00:04:22.270
often said of languages like JavaScript
that they are scripting languages.

75
00:04:22.270 --> 00:04:24.410
Of course,
the word script shows up in JavaScript, so

76
00:04:24.410 --> 00:04:27.800
it's natural to assume that
it's a scripting language.

77
00:04:27.800 --> 00:04:32.580
And it's also often said that
scripting languages are interpreted.

78
00:04:34.370 --> 00:04:39.350
In other words, one statement at a time,
it works on that statement and

79
00:04:39.350 --> 00:04:41.240
then goes from that statement and
the next statement.

80
00:04:41.240 --> 00:04:43.640
So when it's working on
the statement on line three,

81
00:04:43.640 --> 00:04:47.780
it has no idea what to expect of line
four, cuz it hasn't gotten there yet.

82
00:04:47.780 --> 00:04:49.810
It's like if you're working through
a to do list and you're like,

83
00:04:49.810 --> 00:04:53.740
I don't even care about item two yet,
cuz the top item on my to do list,

84
00:04:53.740 --> 00:04:55.380
the only thing I'm thinking about, right?

85
00:04:55.380 --> 00:04:59.420
Well, that's what we mean by interpreting,
and there are languages that are, in fact,

86
00:04:59.420 --> 00:05:03.230
interpretive like that,
that are interpreted line by line.

87
00:05:03.230 --> 00:05:06.600
An example of that might be something
like a command line scripting,

88
00:05:06.600 --> 00:05:07.515
like Bash, or whatever.

89
00:05:07.515 --> 00:05:11.180
It's not fully interpreted,
there's a little bit of nuance there.

90
00:05:11.180 --> 00:05:14.040
But it's essentially
interpreted line by line.

91
00:05:14.040 --> 00:05:18.290
And, it's often times assumed
that JavaScript is the same way.

92
00:05:18.290 --> 00:05:21.520
It's often times assumed that JavaScript
is interpreted with line one,

93
00:05:21.520 --> 00:05:23.000
then line two, and line three.

94
00:05:23.000 --> 00:05:24.830
That in many books, they have said that.

95
00:05:24.830 --> 00:05:27.950
And, it is true that in the very
earliest days of JavaScript,

96
00:05:27.950 --> 00:05:30.170
it worked a lot more like that.

97
00:05:30.170 --> 00:05:33.992
It's definitely true that when Brendan
was first inventing it as a prototype,

98
00:05:33.992 --> 00:05:37.869
he didn't really have all the time to go
through all the sophisticated stuff, so

99
00:05:37.869 --> 00:05:40.435
he had to make,
just bang something out quickly, and

100
00:05:40.435 --> 00:05:41.880
he had to cut a lot of corners.

101
00:05:41.880 --> 00:05:44.890
And so, essentially, at the very
beginning, it was kinda that way.

102
00:05:44.890 --> 00:05:46.920
But very quickly, JavaScript matured.

103
00:05:46.920 --> 00:05:50.230
And by very quickly,
I mean within those first couple of years.

104
00:05:50.230 --> 00:05:52.990
JavaScript matured to the point
where interpreting it wasn't

105
00:05:52.990 --> 00:05:55.270
really practical anymore.

106
00:05:55.270 --> 00:05:57.620
And yet, that myth propagates even today.

107
00:05:57.620 --> 00:06:00.600
People say JavaScript's a scripting
language, it's interpreted.

108
00:06:02.000 --> 00:06:06.060
And the other option,
if it's not an interpreted language,

109
00:06:06.060 --> 00:06:10.560
the other thing that we talk about is
what's called a compiled language.

110
00:06:10.560 --> 00:06:13.160
And what a compiled language and
an interpreted language,

111
00:06:13.160 --> 00:06:17.660
the way that they primarily differ, is not
the way you might think that they differ.

112
00:06:19.480 --> 00:06:22.450
Most people think about the difference
between an interpreted language and

113
00:06:22.450 --> 00:06:26.960
a compiled language as,
that a compiled language gives you this

114
00:06:26.960 --> 00:06:32.050
physical binary file thing,
like on Windows it's a .exe file,

115
00:06:32.050 --> 00:06:35.860
or on a Mac it's,
I don't know what it on the Mac, but

116
00:06:35.860 --> 00:06:39.180
there's some like executable file
on the Mac that you can run.

117
00:06:39.180 --> 00:06:42.370
Or when I compile something
in Visual Studio and

118
00:06:42.370 --> 00:06:47.340
I put my program on, nobody does this,
put on CD or DVD anymore,

119
00:06:47.340 --> 00:06:50.400
but that's the way you used to distribute
in the old days of programming.

120
00:06:50.400 --> 00:06:53.680
You'd put your program on a CD,
and sell it to people.

121
00:06:53.680 --> 00:06:55.830
So most people think of compilation as,

122
00:06:55.830 --> 00:07:00.890
I'm producing some physical series of ones
and zeros, and putting those into a file.

123
00:07:00.890 --> 00:07:03.500
That I can send that series of ones and
zeros to other people,

124
00:07:03.500 --> 00:07:06.600
and they don't need to process it,
they just need to run it.

125
00:07:06.600 --> 00:07:09.500
And they think about interpreted
languages as not doing that.

126
00:07:09.500 --> 00:07:12.899
That every time you wanna run it,
it has to reprocess from the beginning.

127
00:07:14.620 --> 00:07:17.200
So that's one way of thinking about
the difference between interpreted

128
00:07:17.200 --> 00:07:17.790
and compiled.

129
00:07:17.790 --> 00:07:23.540
But the more important distinction,
the one that matters to JavaScript,

130
00:07:23.540 --> 00:07:29.260
is that compilation means that there's
more than one pass through your program.

131
00:07:31.080 --> 00:07:32.360
What do I mean by a pass?

132
00:07:32.360 --> 00:07:35.590
Let me try to illustrate that, cuz I
could be getting off field very quickly.

133
00:07:35.590 --> 00:07:37.813
So if I have a = 2, and

134
00:07:37.813 --> 00:07:43.591
then I have something down here like
&gt;&gt; Kyle Simpson: That.

135
00:07:43.591 --> 00:07:48.460
Well, 2() kind of looks like
a function call, but it's not valid,

136
00:07:48.460 --> 00:07:51.550
because you can't have a number
in the place of an identifier.

137
00:07:51.550 --> 00:07:55.970
So, as JavaScript language is concerned,
line two is an error.

138
00:07:55.970 --> 00:07:57.230
It's invalid.

139
00:07:57.230 --> 00:07:59.910
It's actually syntactically invalid.

140
00:07:59.910 --> 00:08:03.420
It's not a run time problem,
it's an actual author time problem.

141
00:08:03.420 --> 00:08:04.590
I was an idiot, and

142
00:08:04.590 --> 00:08:08.600
I put the number 2 in a position
where I meant to put a letter, okay?

143
00:08:08.600 --> 00:08:13.660
So in an interpreted language, if I was
purely running line by line by line, and

144
00:08:13.660 --> 00:08:17.760
I wasn't doing multiple passes,
I'd run line one first, and

145
00:08:17.760 --> 00:08:22.270
then I would discover that line two
had a problem and I'd throw an error.

146
00:08:22.270 --> 00:08:26.190
But in a compiled language,
the first pass is not concerned with

147
00:08:26.190 --> 00:08:30.280
executing the program, it's concerned
with understanding the program.

148
00:08:30.280 --> 00:08:35.080
It makes a pass through this program, and
it figures out if the program is valid.

149
00:08:35.080 --> 00:08:36.580
Does it match all of the rules?

150
00:08:36.580 --> 00:08:39.420
It would be like scanning through a novel,
and

151
00:08:39.420 --> 00:08:42.680
looking at all the things to make sure all
the sentences had their periods on them,

152
00:08:42.680 --> 00:08:46.100
and then going back and reading
the book to understand its content.

153
00:08:46.100 --> 00:08:47.330
That's the difference here.

154
00:08:47.330 --> 00:08:50.440
So a compiled language would say,
line two is a problem, and

155
00:08:50.440 --> 00:08:54.730
it would flag you with that error
before it ever tried to run line one.

156
00:08:56.070 --> 00:08:57.970
Does everybody understand
the difference there?

157
00:08:57.970 --> 00:09:02.070
Make sure that hopefully people
aren't missing that distinction.

158
00:09:02.070 --> 00:09:04.230
So, JavaScript,

159
00:09:04.230 --> 00:09:09.620
in that respect, is more a compiled
language than an interpreted language.

160
00:09:09.620 --> 00:09:13.510
Because JavaScript definitely
does look at line two first,

161
00:09:13.510 --> 00:09:15.110
before it's ever tried to run line one.

162
00:09:15.110 --> 00:09:18.539
It looked at line one to understand
what line one was about.

163
00:09:19.540 --> 00:09:21.140
But it didn't run it.

164
00:09:21.140 --> 00:09:23.680
It just looked at it to understand it,
and then it looked at line two

165
00:09:23.680 --> 00:09:26.940
to understand it, and when it saw
that line two was invalid it said,

166
00:09:26.940 --> 00:09:29.750
I'm not even going to try to run the
program because it's not a valid program.

167
00:09:32.100 --> 00:09:34.630
So when you put a program like this,
if that was in a file and

168
00:09:34.630 --> 00:09:37.890
you loaded that up into a browser,
line one would never run.

169
00:09:37.890 --> 00:09:40.089
You'd immediately get an error
saying line two is invalid.

170
00:09:41.290 --> 00:09:43.880
Whereas if you put this into
a scripting language like a bash or

171
00:09:43.880 --> 00:09:47.080
something, line one would run, and
then you'd get an error on line two.

172
00:09:47.080 --> 00:09:50.940
And that's the major distinction that we
want to make between this compilation

173
00:09:50.940 --> 00:09:52.520
versus interpreting.

174
00:09:52.520 --> 00:09:57.140
The good news is that because JavaScript's
compiled, a lot of these mistakes

175
00:09:57.140 --> 00:10:00.940
that you can make in your programming are
gonna get caught st the very beginning,

176
00:10:00.940 --> 00:10:03.650
before you've had a chance
to mess something up.

177
00:10:03.650 --> 00:10:07.790
You try to run your program, and the first
thing that happens is it gets compiled.

178
00:10:07.790 --> 00:10:12.020
And if the compilation throws an error,
and says hey, you've messed up,

179
00:10:12.020 --> 00:10:13.420
that's not good.

180
00:10:13.420 --> 00:10:14.920
Then you know what you need to fix.

181
00:10:14.920 --> 00:10:18.390
It'll tell you line two is invalid,
two is not a function or whatever.

182
00:10:20.560 --> 00:10:25.130
Okay, so that's the distinction we'll
make, and we'll kind of leave it there,

183
00:10:25.130 --> 00:10:26.610
there's definitely more details and

184
00:10:26.610 --> 00:10:30.890
I expound upon that a lot more in the
Scope and Closures book in this series.

185
00:10:30.890 --> 00:10:32.670
But, we'll kind of leave it for there.

186
00:10:32.670 --> 00:10:36.980
Think of Java Script more like a compile
language than an interpretive language.

187
00:10:36.980 --> 00:10:41.550
And that is, it doesn't really matter that
JavaScript doesn't get put into binary

188
00:10:41.550 --> 00:10:44.340
form and
distributed the way exe files are.

189
00:10:44.340 --> 00:10:48.150
What matters is that JavaScript
gets compiled for error checking.

