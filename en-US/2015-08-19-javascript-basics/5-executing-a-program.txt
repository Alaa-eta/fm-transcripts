[00:00:00]
>> [MUSIC]

[00:00:03]
>> Kyle Simpson: Okay, so let's go back to the text. I know I kind of jumped around a little bit and I'll, well, let's get ourselves back on track and make sure we understand or that we track back with the text. So [COUGH] we'll come back to and the next topic that's addressed is what we've only talked about so far is how to think about what a program is structured in.

[00:00:27]
And maybe start to think in our brains about what we'd do if we wanted to do it. But it turns out that it's much more important for the computer to run our program [LAUGH] in the end than it is for us to run our program. So it is that duality, as was brought up before, between needing to be able to look at a program and understand what it should do.

[00:00:44]
And then being able to rely upon the computer to do what it actually must do. And those are two really important halves of the brain, if you will. So executing a program what does that mean? Well essentially, it means turning the statements that we've written, like a = b * 2, into low level instructions that a computer can do something with.

[00:01:07]
The computer itself would look at a = b * 2 and have no idea what that meant. JavaScript knows what it means. JavaScript needs to translate it into something else that then can be translated and translated further and further down the stack. Until eventually you get to that series of ones and zeroes, and the computer says, I know what to do with that.

[00:01:25]
The one means put an electrical charge in and the zero means turn it off. And I can switch back and forth between ones and zeroes really fast and run all those things through the circuitry in my computer's CPU and out pops a number, right? So it's this process of getting something from this high level language, like JavaScript.

[00:01:42]
This a = b * 2, which isn't exactly like natural language. It's not like I said it'd be interesting if there was a programming language where I could say set the variable a to the value 2, right?
>> Speaker 2: COBOL!
>> Kyle Simpson: Right, there are languages that are even higher level than JavaScript is.

[00:02:06]
And so understanding that, what we call it in programming, we call it abstraction. At this level, it looks like an English sentence. There would have to be a translation from that into something lower level because the computer would look at that and equally be confused. So a translation level would go from that to maybe something like a = 2, right?

[00:02:31]
And then, something would have to go from a = 2 down into another layer. And we might be getting to too far a field but, I just want to make sure you understand. So the next layer down might be something that people refer to as assembly language, which is still a high level language.

[00:02:46]
It's not a one and zero, but it's lower level. And I don't even remember my assembly language, But it's something like mov a, 2 or something like that or 2, a. I think it's 2, a or something like that. But that lower level thing is like I got these two different registers in memory or whatever and move one into the other, right?

[00:03:05]
And then finally, at the lowest level of the stack, it's taken that thing down into a series of ones and zeros. That's really really long and that that one in zero string tells the computer what to do. So what we want is we wanna figure out to execute my program of course we don't need this top level but we definitely need the top.

[00:03:24]
This a = 2 level we need something to convert it from that layer down into the next layer. They'll be something else that handles that on and on and on and on however many steps it needs to take. But we need something to do that first step and that something is the Java script engine.

[00:03:39]
The thing that's built into our browser. The thing that you can invoke in the developer console. If you were doing programming on a server, there's an environment where JavaScript can run on a server. I mean there's all kinds of different places JavaScript can run on watches and inside of light bulbs and whatever.

[00:03:55]
But in every place that there is there's a JavaScript engine that takes something like a = 2. And turns it into something that that environment knows what to do with. And that's what we mean by executing a program, is taking that source code that we've written in text form, converting it into something that the next layer down knows what to do with, okay?

[00:04:17]
Now quick little kind of myth busting thing. It is often said of languages, like JavaScript, that they are scripting languages. Of course, the Word script shows up in JavaScript, so it's natural to assume that it's a scripting language. And it's also often said that scripting languages are interpreted.

[00:04:38]
In other words, one statement at a time. It works on that statement and then it goes to the next statement, and then in the next statement. So when it's working on the statement on line three, it has no idea what to expect of line four because it hasn't gotten there yet.

[00:04:51]
As like if you're working through a to-do list, I don't even care about. item two yet because I'm on top item on my to-do list, the only thing I'm thinking about, right? Well, that's what we mean by interpreting. And there are languages that are in fact interpreted like that, that are interpreted line by line by line.

[00:05:07]
An example of that might be something like a command line scripting like bash or whatever. It's not fully interpreted. There's a little bit of nuance there but it's essentially interpreted line by line. And it's oftentimes assumed that JavaScript is the same way. It's often times assume that JavaScript is interpreted with line one and then line two and line three.

[00:05:26]
There are many books that have said that and it is true that in the very earliest days of JavaScript it worked a lot more like that. It's definitely true that when Brendan was first inventing it as a prototype. He didn't really have all the time to go through all the sophisticated stuff, so he had to make just bang something out quickly and it had to cut a lot of corners.

[00:05:45]
So it essentially in the very beginning, it was kind of that way. But very quickly JavaScript matured and then by very quickly. I mean within those first couple of years. JavaScript matured to the point where interpreting it wasn't really practical anymore. And yet that myth propagates, even today people say JavaScript is a scripting language, it's interpreted, it's not.

[00:06:05]
And the other option if it's not an interpreted language, the other thing that we talk about is what's called a compiled language. And what are compiled language and an interpreted language, the way that they primarily differ Is not the way you might think that they differ. Most people think about the difference between an interpreted language and a compiled language as that a compiled language gives you this physical binary file thing.

[00:06:32]
Like on Windows, it's a .exd file. Or on a Mac, it's on and you know what it is on the Mac. But there's some like executable file on the Mac that you can run or of what I compile something in Visual Studio. And I put my program on a, nobody does, this put on CD or DVD anymore.

[00:06:50]
But that's the way you used to do distribute in the old days of programming. You'd put your program on a CD and sell it to people. So most people think of compilation as I'm producing some physical series of ones and zeros and putting those into a file. That I can send that series of ones and zeros to other people and they don't need to process it, they just need to run it.

[00:07:10]
And they think about interpreted languages as not doing that, that every time you want to run it has to reprocess from the beginning. So that's one way of thinking about the difference between interpreted and compiled but, the more important distinction. The one that matters to JavaScript is that compilation means that there's more than one pass through your program.

[00:07:34]
What do I mean by a pass? Let me try to illustrate that because I could be getting off field very quickly. So, if I have a = 2, and then I have something down here like.
>> Kyle Simpson: That. Well, 2() kinda looks like a function call, but it's not valid.

[00:07:52]
Because you can't have a number in the place of an identifier, so as JavaScript language is concerned lying to is an error. It's invalid. It's actually syntactically invalid. It's not a runtime problem it's an actual author time problem I was an idiot. and I put the number 2 in a position where I meant to put a letter, okay?

[00:08:12]
So in an interpreted language if I was purely running line by line by line and I wasn't doing multiple passes. I'd run line one first, and then I would discover that line two had a problem and I'd throw an error. But in a compiled language. The first pass is not concerned with executing the program, it's concerned with understanding the program.

[00:08:33]
It makes a pass through this program and it figures out of the program is valid. Does it match all of the rules? It would be like scanning through a novel and looking at all the things to make sure all the sentences had their periods on them. And then going back and reading the book to understand its content.

[00:08:49]
That's the difference here. So compiled language would say line two is a problem and it would flag you with that error before it ever tried to run line one. Does everybody understand the difference there? Make sure that people, hopefully, people aren't missing that distinction. So JavaScript, in that respect, is more a compiled language than an interpreted language.

[00:09:13]
Because JavaScript definitely does look at line two first before it's ever tried to run line one. It looked at line one to understand what line one was about, but it didn't run it. It just looked at it to understand it, and then it looked at line two to understand it.

[00:09:28]
And when it saw that line two was invalid, it said I'm not even to try to run the program because it's not a valid program. So when you put a program like this. If that was in a file and you loaded that up into a browser, line one would never run, you'd immediately get an error saying line two is invalid.

[00:09:44]
Whereas, if you put this into a scripting language like a Bash or something. Line one would run and then you'd get an error on line two, and that's the major distinction that we wanna make between this compilation versus interpreting. The good news is that because JavaScript compiled a lot of these mistakes that you can make in your programming are going to get caught at the very beginning.

[00:10:04]
Before you've had a chance to mess something up [LAUGH]. You try to run your program on the first thing that happens as it gets compiled. And if the compilation throws an error and says hey you messed up. That's not good. Then you know what you need to fix.

[00:10:18]
It will tell you line two is invalid, two is not a function or whatever. Okay, so that's the distinction we'll make and we'll kind of leave it there. There's definitely more details and I expound upon that a lot more in the scope and closures book in the series, but what kind of leave it for there.

[00:10:36]
Think of JavaScript more like a compiled language, then an interpreted language. And it doesn't really matter that JavaScript doesn't get put into binary form and distributed the way .exe files are. What matters is that JavaScript gets compiled for error checking.

