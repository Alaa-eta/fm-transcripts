WEBVTT

1
00:00:00.320 --> 00:00:03.800
&gt;&gt; Kyle Simpson: A function is a way to
logically group a piece of code together,

2
00:00:03.800 --> 00:00:05.630
kind of like a block is.

3
00:00:05.630 --> 00:00:10.900
But a function also makes that block
of code something that you can call

4
00:00:10.900 --> 00:00:12.370
more than once.

5
00:00:12.370 --> 00:00:16.750
So it's kind of like a loop, and
it's kind of like a block, but

6
00:00:16.750 --> 00:00:19.740
it's not gonna run
forever like a loop does.

7
00:00:19.740 --> 00:00:23.140
And it's not gonna run only once
right now, like a regular block does.

8
00:00:23.140 --> 00:00:26.610
So it's kind of a third
different concept here.

9
00:00:26.610 --> 00:00:33.120
It's like putting a set of stuff into this
special location and being able to say,

10
00:00:33.120 --> 00:00:36.550
as many times as I need it I can just
call out to that stuff and it'll run.

11
00:00:37.720 --> 00:00:41.860
I might need it once I might need it five
times, I might need to do it over and

12
00:00:41.860 --> 00:00:42.700
over and over again.

13
00:00:42.700 --> 00:00:44.480
It doesn't really matter.

14
00:00:44.480 --> 00:00:48.680
We use the function to logically
group a set of tasks together.

15
00:00:49.760 --> 00:00:52.000
So I have kind of a silly
running example in the book.

16
00:00:52.000 --> 00:00:55.490
If you've read any of the book,
I have this silly example of

17
00:00:55.490 --> 00:00:58.850
the phone store where you're
purchasing a phone or whatever,

18
00:00:58.850 --> 00:01:02.570
so if you haven't read it you can go back
and understand what I'm talking about.

19
00:01:02.570 --> 00:01:07.350
Here [COUGH] in this running silly
example, I have the phone store employee,

20
00:01:07.350 --> 00:01:12.840
doesn't want to calculate all of
the taxes for your final purchase amount.

21
00:01:12.840 --> 00:01:16.390
You're talking to her and you're saying,
I wanna buy this phone and this accessory.

22
00:01:16.390 --> 00:01:19.740
She doesn't wanna redo that
on her calculator every time.

23
00:01:19.740 --> 00:01:24.370
That's a set of tasks that's repetitive
that's gonna need to happen for

24
00:01:24.370 --> 00:01:26.810
pretty much every customer
that buys something.

25
00:01:26.810 --> 00:01:31.110
And so, there's almost certainly
a program that does that for her,

26
00:01:31.110 --> 00:01:33.890
the check out program,
she can swipe your credit card and

27
00:01:33.890 --> 00:01:36.910
automatically calculates how
much the charge and all of that.

28
00:01:36.910 --> 00:01:39.005
And that's conceptually
the same thing as a function.

29
00:01:39.005 --> 00:01:41.571
It's taking a specific set of tasks and

30
00:01:41.571 --> 00:01:45.380
putting it into a thing that
I can repeat on demand.

31
00:01:45.380 --> 00:01:49.380
Whenever I want it, I can just invoke
it and say do that set of things, and

32
00:01:49.380 --> 00:01:50.546
it'll just happen, okay?

33
00:01:50.546 --> 00:01:55.700
So, [COUGH] the example
that we see here is,

34
00:01:55.700 --> 00:01:58.720
I have a variable that I'm
declaring with the value 99.99.

35
00:01:58.720 --> 00:02:02.830
That's the price of a phone,
and I wanna print the amount.

36
00:02:04.240 --> 00:02:06.580
I could've put a console dot
log statement here right?

37
00:02:06.580 --> 00:02:11.060
I could have said consul dot log dot
amount and then I would have printed it.

38
00:02:11.060 --> 00:02:14.320
And then I said amount equals amount
times two which doubles the value, and

39
00:02:14.320 --> 00:02:16.480
then I could have put
another consul dot log.

40
00:02:16.480 --> 00:02:22.120
But as soon as I did that twice, as soon
as I typed that twice into a program

41
00:02:22.120 --> 00:02:24.610
I might start ask myself
why am I repeating myself.

42
00:02:26.410 --> 00:02:30.970
Could I take that set of
statements that I repeated, and

43
00:02:30.970 --> 00:02:36.300
put that into a location and
give that location a special name.

44
00:02:36.300 --> 00:02:39.850
And whenever I want that stuff to happen,
just call it by name.

45
00:02:39.850 --> 00:02:41.200
That's what a function is doing.

46
00:02:41.200 --> 00:02:42.560
So what is my set of statements?

47
00:02:42.560 --> 00:02:44.790
It's just one statement in this case.

48
00:02:44.790 --> 00:02:49.140
But it's slightly more complex than
just calling console.log amount.

49
00:02:49.140 --> 00:02:52.430
You notice that I'm also saying toFixed.

50
00:02:54.024 --> 00:02:58.230
Now, toFixed is a method that is available
to all numbers in Java script and

51
00:02:58.230 --> 00:03:00.940
essentially formats them as a strength

52
00:03:00.940 --> 00:03:03.070
with a certain number of
decimal places on it.

53
00:03:04.300 --> 00:03:07.310
Kind of like dollars, right?

54
00:03:07.310 --> 00:03:08.420
U.S dollars.

55
00:03:08.420 --> 00:03:14.400
So if I wanted to take the number 99.99,
or the number 199.98, and make it into

56
00:03:14.400 --> 00:03:20.330
a string that absolutely had exactly two
digits, then I could use the toFixed.

57
00:03:20.330 --> 00:03:21.340
Let me illustrate.

58
00:03:21.340 --> 00:03:26.037
What if I had the number
&gt;&gt; Kyle Simpson: 3.141519,

59
00:03:26.037 --> 00:03:26.730
I can't remember.

60
00:03:26.730 --> 00:03:28.028
That's all I remember.

61
00:03:28.028 --> 00:03:33.349
1415926 or something like that, right?

62
00:03:33.349 --> 00:03:39.735
So that's the first several digits of pi.

63
00:03:39.735 --> 00:03:43.920
You'll notice I didn't win any pi
digit memory contest as a kid.

64
00:03:43.920 --> 00:03:46.540
Okay, that's the first
several digits of pi.

65
00:03:46.540 --> 00:03:51.020
But what if I wanted to print out that,
let's assign that to some variable.

66
00:03:51.020 --> 00:03:51.900
Let's assign it to A.

67
00:03:51.900 --> 00:03:57.200
What if I wanted to print out that value,
but only to 2 decimal places?

68
00:03:57.200 --> 00:04:01.976
Or let's actually say to 3 decimal places.
&gt;&gt; Kyle Simpson: Well,

69
00:04:01.976 --> 00:04:05.789
I could say a.toFixed(3), and

70
00:04:05.789 --> 00:04:10.999
you'll notice that I'm
not gonna get a number,

71
00:04:10.999 --> 00:04:14.100
I'm now gonna get a string.

72
00:04:14.100 --> 00:04:20.370
The string 3.142.
&gt;&gt; Kyle Simpson: So we rounded that digit.

73
00:04:20.370 --> 00:04:22.740
We rounded it by the fourth digit.

74
00:04:22.740 --> 00:04:25.974
We rounded that third digit up to 2.

75
00:04:25.974 --> 00:04:29.850
So toFixed is another way to get
a number to a particular precision,

76
00:04:29.850 --> 00:04:32.280
to a particular number of decimal places.

77
00:04:32.280 --> 00:04:33.520
It's nice and helpful.

78
00:04:33.520 --> 00:04:37.970
I almost always use this when I'm,
the only place

79
00:04:37.970 --> 00:04:43.330
I hardly ever use it is for
printing out dollars and cents.

80
00:04:43.330 --> 00:04:47.867
Cuz another observation that we can make
is, what if I had the variable A equals

81
00:04:47.867 --> 00:04:52.500
3.5, and
I wanted to print that out as dollars.

82
00:04:52.500 --> 00:04:54.780
Well, it's missing a zero on the end,
right?

83
00:04:54.780 --> 00:05:01.280
If I just said console.log[a].

84
00:05:01.280 --> 00:05:05.450
I only get 3.5,
which isn't as friendly for US dollars.

85
00:05:05.450 --> 00:05:11.680
So if I said console.log(a.toFixed(2)) And
I said give me two decimal places.

86
00:05:12.740 --> 00:05:13.630
You'll notice I get 3.50.

87
00:05:13.630 --> 00:05:20.480
That's how I typically use it.

88
00:05:20.480 --> 00:05:22.640
I use it to format US dollars.

89
00:05:25.230 --> 00:05:29.350
But that printAmount function is a utility
that I can repeat multiple times.

90
00:05:29.350 --> 00:05:34.010
And imagine how much more useful it would
be if instead of just one statement if I

91
00:05:34.010 --> 00:05:40.350
had 3 or 4 or 10 or 20 or 100 statements
that were logically connected together.

92
00:05:40.350 --> 00:05:45.605
If it took five different things to do
to print out my amount I would put all

93
00:05:45.605 --> 00:05:50.690
five of those in a function, and then I
would only be repeating the function call,

94
00:05:50.690 --> 00:05:53.160
rather than repeating all of its
contents over and over again.

95
00:05:54.160 --> 00:05:56.740
So that's our primary
benefit to a function,

96
00:05:56.740 --> 00:05:59.850
is being able to take
a block of statements and

97
00:05:59.850 --> 00:06:04.160
collect it together into a repeatable
sort of named label, if you will.

98
00:06:07.450 --> 00:06:11.290
So little 60 second homework.

99
00:06:11.290 --> 00:06:13.260
Declare yourself a function.

100
00:06:13.260 --> 00:06:15.120
Put a couple of statements in it.

101
00:06:15.120 --> 00:06:16.140
Whatever statements you want.

102
00:06:16.140 --> 00:06:18.730
Like, assign it statements or whatever.

103
00:06:18.730 --> 00:06:22.210
And repeat it a couple of
times in your console.

104
00:06:24.530 --> 00:06:28.620
You might have called your function
foo like I'm in the habit of doing.

105
00:06:28.620 --> 00:06:33.630
And that might take a is
equal to a times two,

106
00:06:33.630 --> 00:06:39.980
and a is equal to a plus three.

107
00:06:39.980 --> 00:06:42.980
So we're gonna multiply it by two and
then add three to it.

108
00:06:42.980 --> 00:06:44.560
Those are my two statements.

109
00:06:44.560 --> 00:06:48.260
Now if I start off with
an a is equal to ten and

110
00:06:48.260 --> 00:06:53.020
I call foo once and then I console.log(a).

111
00:06:53.020 --> 00:06:56.880
What would I be expecting
the output of this to be?

112
00:06:57.960 --> 00:07:01.010
Hopefully you're awake enough
to do some basic math here.

113
00:07:01.010 --> 00:07:03.710
A starts out at as ten.

114
00:07:03.710 --> 00:07:07.670
The first time I call foo it's
going to say ten times two.

115
00:07:07.670 --> 00:07:11.150
So now a is going to be 20 and
then we're gonna add 3 to it.

116
00:07:11.150 --> 00:07:13.390
So now a is going to be equal to 23.

117
00:07:13.390 --> 00:07:16.140
So it expected to print out the value 23.

118
00:07:16.140 --> 00:07:21.360
Now if I call foo two more times and

119
00:07:21.360 --> 00:07:27.299
then I print out a again,
I'll spare you the mental acrobatics.

120
00:07:28.730 --> 00:07:31.600
Let's just run it, and
let's see what happens.

121
00:07:35.310 --> 00:07:38.510
So, we know this one's gonna print out 23.

122
00:07:38.510 --> 00:07:40.650
This next one, what's it gonna print out?

123
00:07:40.650 --> 00:07:43.660
101.

124
00:07:43.660 --> 00:07:50.764
So it was 23 times 2,
which was 46 plus 3, was 49.

125
00:07:52.220 --> 00:07:56.590
And then 49 times 2 is 98 plus 3 is 101.

126
00:07:56.590 --> 00:08:01.017
Question?
&gt;&gt; Kyle Simpson: The question was about

127
00:08:01.017 --> 00:08:07.710
putting our functions
before our variables.

128
00:08:07.710 --> 00:08:11.490
Like did it matter if I did that or
I did that?

129
00:08:11.490 --> 00:08:12.890
No difference to JavaScript.

130
00:08:13.930 --> 00:08:17.080
It goes back to that topic that
we kind of skirted by earlier,

131
00:08:17.080 --> 00:08:20.370
the topic of hoisting,
topic of lexical scope.

132
00:08:20.370 --> 00:08:23.217
[COUGH] Scope enclosures
books covers at in-depth,

133
00:08:23.217 --> 00:08:25.790
the advanced JavaScript
covers it in-depth but for

134
00:08:25.790 --> 00:08:29.870
our purposes, you can put declarations
in any place in your program.

135
00:08:29.870 --> 00:08:33.500
I typically put all of my declarations
at the top of my programs.

136
00:08:33.500 --> 00:08:36.630
I put all my functions at the top,
and then I put all my variables.

137
00:08:36.630 --> 00:08:38.580
That's my preferred style.

138
00:08:38.580 --> 00:08:41.620
But as long as all your variables are at
the top, you won't have any surprises.

139
00:08:41.620 --> 00:08:44.750
I mean, as long as all your
declarations are at the top,

140
00:08:44.750 --> 00:08:47.280
you won't have any surprises.
&gt;&gt; Speaker 2: If you consistently do that,

141
00:08:47.280 --> 00:08:50.090
it makes it easier to
maintain the program later.

142
00:08:50.090 --> 00:08:51.080
&gt;&gt; Kyle Simpson: It's generally a good

143
00:08:51.080 --> 00:08:54.880
rule to have a consistent style,
whatever it is.

144
00:08:54.880 --> 00:08:57.150
If your style is to put your
functions at the bottom and

145
00:08:57.150 --> 00:08:59.370
your variables at the top, that's fine.

146
00:08:59.370 --> 00:09:02.550
But it's a good idea to always
be consistent with that and

147
00:09:02.550 --> 00:09:07.016
your program.
&gt;&gt; Kyle Simpson: Okay,

148
00:09:07.016 --> 00:09:13.640
now functions can also receive
what are called parameters.

149
00:09:13.640 --> 00:09:16.210
So here you notice I didn't
receive any parameter, but

150
00:09:16.210 --> 00:09:17.500
what if I received a parameter.

151
00:09:17.500 --> 00:09:19.630
If I had a parameter called b,

152
00:09:21.280 --> 00:09:25.870
that becomes a variable that's
accessible to me inside of the function.

153
00:09:25.870 --> 00:09:29.380
So I could take this value right here and

154
00:09:29.380 --> 00:09:32.490
instead of it being the literal value 3,
I could have it be the variable b.

155
00:09:34.540 --> 00:09:37.770
So when I run this
function now it's behavior

156
00:09:37.770 --> 00:09:41.090
is partially dependent
on what value I pass in.

157
00:09:41.090 --> 00:09:41.980
Does everybody see that?

158
00:09:43.390 --> 00:09:46.450
If I pass in a different value of
b I get a different result out.

159
00:09:46.450 --> 00:09:47.580
Let's try it.

160
00:09:47.580 --> 00:09:52.459
If I start out with a = 10 and
I say foo(3) and then I say,

161
00:09:52.459 --> 00:09:56.210
console.Log(a), what are we expecting?

162
00:10:03.040 --> 00:10:04.284
&gt;&gt; Kyle Simpson: Same thing as before,

163
00:10:04.284 --> 00:10:05.400
we'd expect 23.

164
00:10:05.400 --> 00:10:08.960
Right?
A went from 10 to 20 and

165
00:10:08.960 --> 00:10:10.590
then we added three to it and
it became 23.

166
00:10:10.590 --> 00:10:14.390
But what happens if I put in 100 here?

167
00:10:17.750 --> 00:10:21.400
Now, we're expecting 120.
So everybody see that?

168
00:10:21.400 --> 00:10:24.620
So what I pass into my
function changes its behavior,

169
00:10:24.620 --> 00:10:27.330
because there's a parameter
that I'm passing in.

170
00:10:27.330 --> 00:10:28.390
By the way, a little nuance.

171
00:10:28.390 --> 00:10:32.840
It's not a big deal, but
terminology is, I think,

172
00:10:32.840 --> 00:10:36.410
if you're learning things, it's
important to learn correct terminology.

173
00:10:36.410 --> 00:10:40.650
When we call the function here we
are passing in what's called an argument.

174
00:10:42.120 --> 00:10:43.235
&gt;&gt; Kyle Simpson: So you can have one or

175
00:10:43.235 --> 00:10:46.270
more arguments that you
pass into a function.

176
00:10:46.270 --> 00:10:51.110
But when we declare the function and
we have these names like I

177
00:10:51.110 --> 00:10:56.540
can say B and bar and zaz and whatever.

178
00:10:56.540 --> 00:11:00.650
These variables here
are called parameters.

179
00:11:01.970 --> 00:11:05.220
So in other words, there's a match,
a one-to-one match between an argument

180
00:11:05.220 --> 00:11:08.730
that gets passed in and
the parameter in that position.

181
00:11:10.360 --> 00:11:14.770
A lot of people use arguments and
parameters interchangeably

182
00:11:14.770 --> 00:11:18.150
as meaning the same thing because
they get assigned to each other.

183
00:11:18.150 --> 00:11:21.290
So, it seems like there could
be considerably the same thing.

184
00:11:21.290 --> 00:11:26.380
To be completely specific on terminology,
it's an argument when you pass it in,

185
00:11:26.380 --> 00:11:27.765
it's a parameter when you declare it.

186
00:11:29.590 --> 00:11:35.870
So this parameter b that we've got,
got assigned the argument 100 and

187
00:11:35.870 --> 00:11:40.860
then we use that parameter as a variable,
and we printed it out.

188
00:11:40.860 --> 00:11:42.790
So let's try this again.

189
00:11:42.790 --> 00:11:46.228
If I said foo(5), and

190
00:11:46.228 --> 00:11:50.660
foo(25), and foo 100.

191
00:11:50.660 --> 00:11:55.070
So I called foo 3 different
times with 3 different variables

192
00:11:55.070 --> 00:11:57.960
all accumulating my results into this a.

193
00:11:57.960 --> 00:12:02.010
What's my end result going to be?
&gt;&gt; Kyle Simpson: Oops.

194
00:12:04.370 --> 00:12:07.781
My end result,
&gt;&gt; Kyle Simpson: The suspense is

195
00:12:07.781 --> 00:12:08.623
killing me.

196
00:12:08.623 --> 00:12:13.273
250.
&gt;&gt; Kyle Simpson: Is there

197
00:12:13.273 --> 00:12:17.372
a question?
&gt;&gt; Speaker 3: Asking about passing

198
00:12:17.372 --> 00:12:23.200
a function as a parameter
of another function?

199
00:12:23.200 --> 00:12:25.290
&gt;&gt; Kyle Simpson: So yes, you can, and

200
00:12:25.290 --> 00:12:29.840
then the next question that was asked
might be slightly, or the next answer that

201
00:12:29.840 --> 00:12:34.500
was given might be slightly misleading,
so let me just quickly divert into that.

202
00:12:36.220 --> 00:12:40.850
If I called foo, let's say I had
two different functions here.

203
00:12:40.850 --> 00:12:45.480
And it doesn't matter
what's in bar right now.

204
00:12:45.480 --> 00:12:51.750
If I said foo, and
I gave it the name bar, I passed in bar.

205
00:12:51.750 --> 00:12:55.060
What I'm doing is getting the value
that is currently in bar.

206
00:12:55.060 --> 00:12:59.886
What is the value that's currently in bar?
&gt;&gt; Kyle Simpson: It's a function,

207
00:12:59.886 --> 00:13:01.660
it's a function value.

208
00:13:01.660 --> 00:13:04.662
So I'm passing the function
as an argument, and

209
00:13:04.662 --> 00:13:07.890
it's getting assigned to the parameter b.

210
00:13:07.890 --> 00:13:10.050
So if I said plus b here.

211
00:13:10.050 --> 00:13:10.680
What is b?

212
00:13:11.820 --> 00:13:16.170
B is a function, that's not what we really
want we want the thing to be called.

213
00:13:16.170 --> 00:13:21.630
I could call it here and whatever
it returned I would get that value.

214
00:13:21.630 --> 00:13:25.620
But if you pass a function as
a value is just a function.

215
00:13:25.620 --> 00:13:33.180
If you call it, then what it returns
is what gets past in as the argument,

216
00:13:33.180 --> 00:13:37.760
so there is a difference between passing
of function and passing the result of

217
00:13:37.760 --> 00:13:43.339
a function call.
&gt;&gt; Kyle Simpson: So hopefully that clears

218
00:13:43.339 --> 00:13:46.620
up the questions that were happening,
are being asked in the chat room.

219
00:13:49.990 --> 00:13:58.380
Okay, one last detail on this function,
let me back up.

220
00:13:58.380 --> 00:14:00.120
One last detail on this functions.

221
00:14:00.120 --> 00:14:03.700
These functions can return values as well,
they can pass in the values,

222
00:14:03.700 --> 00:14:05.260
they can return values.

223
00:14:05.260 --> 00:14:08.807
So if I said return a /

224
00:14:08.807 --> 00:14:14.416
2.
&gt;&gt; Kyle Simpson: If I

225
00:14:14.416 --> 00:14:19.114
say var a =10; [COUGH] and
I call foo with (3),

226
00:14:19.114 --> 00:14:27.350
we know a is going to become what?
&gt;&gt; Kyle Simpson: It's 23, right?

227
00:14:28.720 --> 00:14:32.590
But what if we took that return value and
assigned it to another variable.

228
00:14:34.900 --> 00:14:38.950
You see, when I invoke foo,
it's going to run.

229
00:14:38.950 --> 00:14:41.560
But then it's going to
return me a different value.

230
00:14:42.800 --> 00:14:45.660
In this case,
it's gonna computer 23 divided by 2,

231
00:14:45.660 --> 00:14:50.938
which is
&gt;&gt; Kyle Simpson: 11.5, [LAUGH] So

232
00:14:50.938 --> 00:14:57.770
11.5 is the thing that's going to come
back and get assigned into the variable b.

233
00:14:57.770 --> 00:15:03.765
So if I console.log b, I'm expecting 11.5.

234
00:15:03.765 --> 00:15:09.870
So if we take that program and
put it into our console.

235
00:15:12.740 --> 00:15:17.060
We're expecting both 23 and
11.5 to be printed out, and in fact that's

236
00:15:18.880 --> 00:15:23.700
what we get.
&gt;&gt; Speaker 2: So in the second example,

237
00:15:23.700 --> 00:15:25.930
what does it do with variable a?

238
00:15:25.930 --> 00:15:29.973
Is variable a left alone?
&gt;&gt; Kyle Simpson: Here we're not assigning

239
00:15:29.973 --> 00:15:33.070
to anything, we're computing something and
returning it.

240
00:15:33.070 --> 00:15:34.270
Here we are assigning, so

241
00:15:34.270 --> 00:15:36.760
we're making changes to a variable.
&gt;&gt; Speaker 2: Yes.

242
00:15:36.760 --> 00:15:37.580
&gt;&gt; Kyle Simpson: We're actually having

243
00:15:37.580 --> 00:15:40.860
outside side effects on that variable.

