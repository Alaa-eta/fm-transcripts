WEBVTT

1
00:00:00.000 --> 00:00:03.827
[MUSIC]

2
00:00:03.827 --> 00:00:07.636
&gt;&gt; Kyle Simpson: A function is a way to
logically group a piece of code together

3
00:00:07.636 --> 00:00:09.190
like a block is.

4
00:00:09.190 --> 00:00:13.216
But a function also makes
that block of code something

5
00:00:13.216 --> 00:00:15.728
that you can call more than once.

6
00:00:15.728 --> 00:00:21.140
So it's like a loop and it's like a block,
but it's not gonna run forever like

7
00:00:21.140 --> 00:00:26.650
a loop does and it's not gonna run only
once right now like a regular block does.

8
00:00:26.650 --> 00:00:30.120
So it's a third different concept here.

9
00:00:30.120 --> 00:00:35.440
It's like putting a set of stuff in to
this special location and being able

10
00:00:35.440 --> 00:00:40.025
to say, as many times as I need it, I can
just call out to that stuff and it'll run.

11
00:00:41.240 --> 00:00:44.230
I might need it once,
I might need it five times.

12
00:00:44.230 --> 00:00:46.360
I might need to do it over and
over and over again.

13
00:00:46.360 --> 00:00:48.000
It doesn't really matter.

14
00:00:48.000 --> 00:00:52.210
We use the function to logically
group a set of tasks together.

15
00:00:53.280 --> 00:00:55.520
So I have a silly running
example in the book.

16
00:00:55.520 --> 00:00:59.010
If you've read any of the book,
I have this silly example of

17
00:00:59.010 --> 00:01:02.330
the phone store where you're
purchasing a phone or whatever.

18
00:01:02.330 --> 00:01:04.164
So, if you haven't read it,
then you can go back and

19
00:01:04.164 --> 00:01:05.514
understand what I'm talking about.

20
00:01:05.514 --> 00:01:10.807
But here [COUGH] in this running silly
example I have, the phone store employee

21
00:01:10.807 --> 00:01:16.055
doesn't want to calculate all of
the taxes for your final purchase amount.

22
00:01:16.055 --> 00:01:18.764
And you're talking to her and
you're saying, I wanna buy this phone and

23
00:01:18.764 --> 00:01:19.900
this accessory or whatever.

24
00:01:19.900 --> 00:01:23.250
She doesn't wanna redo that
on her calculator every time.

25
00:01:23.250 --> 00:01:27.790
That's a set of tasks that's repetitive
that's going to need to happen [COUGH] for

26
00:01:27.790 --> 00:01:30.340
pretty much every customer
that buys something.

27
00:01:30.340 --> 00:01:34.620
And so there's almost certainly
a program that does that for her.

28
00:01:34.620 --> 00:01:35.660
It's a checkout program.

29
00:01:35.660 --> 00:01:37.410
She can swipe your credit card,

30
00:01:37.410 --> 00:01:39.970
it automatically calculates how
much to charge and all of that.

31
00:01:39.970 --> 00:01:42.412
And that's conceptually
the same thing as a function.

32
00:01:42.412 --> 00:01:44.969
It's taking a specific set of tasks and

33
00:01:44.969 --> 00:01:48.900
putting it into a thing that
I can repeat on demand.

34
00:01:48.900 --> 00:01:53.076
Whenever I want it, I can just invoke it,
say, do that sort of things and

35
00:01:53.076 --> 00:01:54.320
it'll just happen.

36
00:01:54.320 --> 00:01:57.652
So [COUGH] the example
that we see here is,

37
00:01:57.652 --> 00:02:02.650
I have a variable I'm declaring
with the value 99.99,

38
00:02:02.650 --> 00:02:07.554
that's the price of a phone,
and I wanna print the amount.

39
00:02:07.554 --> 00:02:10.210
I could have put a console.log
statement here, right?

40
00:02:10.210 --> 00:02:14.570
I could have said console.log amount and
it would have printed it.

41
00:02:14.570 --> 00:02:17.634
And then I said, amount = amount * 2,
which doubles the value,

42
00:02:17.634 --> 00:02:19.895
and then I could have
put another console.log.

43
00:02:19.895 --> 00:02:23.863
But as soon as I did that twice,
as soon as I typed the same thing twice

44
00:02:23.863 --> 00:02:28.130
into a program, I might start to ask
myself, why am I repeating myself?

45
00:02:29.930 --> 00:02:34.490
Could I take that set of
statements that I repeated and

46
00:02:34.490 --> 00:02:39.820
put that into a location and
give that location a special name?

47
00:02:39.820 --> 00:02:43.370
And whenever I want that stuff to happen,
just call it by name.

48
00:02:43.370 --> 00:02:44.591
That's what a function is doing.

49
00:02:44.591 --> 00:02:45.847
So what is my set of statements?

50
00:02:45.847 --> 00:02:48.250
It's just one statement in this case, but

51
00:02:48.250 --> 00:02:52.650
it's slightly more complex than
just calling console.log amount.

52
00:02:52.650 --> 00:02:55.506
You'll notice that I'm
also saying toFixed.

53
00:02:55.506 --> 00:03:01.479
Now toFixed is a method that's
available to all numbers in JavaScript.

54
00:03:01.479 --> 00:03:06.540
And it essentially formats them
as a string with a certain

55
00:03:06.540 --> 00:03:11.930
number of decimal places on it,
like dollars, US dollars.

56
00:03:11.930 --> 00:03:17.460
So if I wanted to take the number 99.99 or
the number 199.98 and make it

57
00:03:17.460 --> 00:03:23.850
into a string that absolutely had exactly
two digits, then I could use the toFixed.

58
00:03:23.850 --> 00:03:24.746
Let me illustrate.

59
00:03:24.746 --> 00:03:32.454
What if I had the number,
&gt;&gt; Kyle Simpson: 3.141519,

60
00:03:32.454 --> 00:03:34.909
I can't remember.

61
00:03:34.909 --> 00:03:40.647
That's all I remember, 1415926 or
something like that, right?

62
00:03:40.647 --> 00:03:42.974
So that's the first several digits of pi.

63
00:03:42.974 --> 00:03:46.663
You'll notice I didn't win any pi
digit memory contest as a kid.

64
00:03:46.663 --> 00:03:50.060
[LAUGH] Okay,
that's the first several digits of pi.

65
00:03:50.060 --> 00:03:52.930
But what if I wanted to print out that?

66
00:03:52.930 --> 00:03:55.623
Let's assign that to some variable,
so let's assign it to a.

67
00:03:55.623 --> 00:04:00.137
What if I wanted to print out that value
but only to two decimal places, or

68
00:04:00.137 --> 00:04:03.030
let's actually say to
three decimal places?

69
00:04:04.900 --> 00:04:09.025
Well, I could say a.toFixed(3), and

70
00:04:09.025 --> 00:04:14.340
you'll notice that I'm
not gonna get a number.

71
00:04:14.340 --> 00:04:18.985
I'm now gonna get a string,
the string 3.142.

72
00:04:21.686 --> 00:04:26.381
&gt;&gt; Kyle Simpson: So we rounded that digit,
we rounded it by the fourth digit,

73
00:04:26.381 --> 00:04:29.245
we rounded that third digit up to 2.

74
00:04:29.245 --> 00:04:32.852
So toFixed is a way to get a number
to a particular precision,

75
00:04:32.852 --> 00:04:35.420
to a particular number of decimal places.

76
00:04:35.420 --> 00:04:39.510
So nice and helpful,
I almost always use this.

77
00:04:39.510 --> 00:04:46.460
The only place I hardly ever use it is for
printing out dollars and cents.

78
00:04:46.460 --> 00:04:49.942
Cuz another observation
that we can make is,

79
00:04:49.942 --> 00:04:55.909
what if I had the variable a = 3.5 and
I wanted to print that out as dollars?

80
00:04:55.909 --> 00:04:58.290
Well, it's missing a zero on the end,
right?

81
00:04:58.290 --> 00:05:04.880
If I just said console.log(a),
&gt;&gt; Kyle Simpson: And

82
00:05:04.880 --> 00:05:08.970
only get 3.5,
which isn't as friendly for US dollars.

83
00:05:08.970 --> 00:05:13.088
So if I said console.log(a.toFixed) and
I say,

84
00:05:13.088 --> 00:05:17.869
give me two decimal places,
you'll notice I get 3.50.

85
00:05:22.490 --> 00:05:27.384
&gt;&gt; Kyle Simpson: So that's how I typically
use it as I use it to format US dollars.

86
00:05:27.384 --> 00:05:27.989
[COUGH] But

87
00:05:27.989 --> 00:05:32.684
that print amount function is a utility
that I can repeat multiple times.

88
00:05:32.684 --> 00:05:37.904
And imagine how much more useful it would
be if, instead of just one statement, if I

89
00:05:37.904 --> 00:05:43.665
had 3 or 4 or 10 or 20 or 100 statements,
that were logically connected together.

90
00:05:43.665 --> 00:05:48.422
If it took five different things to do to
print out my amount, I would put all five

91
00:05:48.422 --> 00:05:52.753
of those in a function and then I would
only be repeating the function call

92
00:05:52.753 --> 00:05:56.519
rather than repeating all of its
contents over and over again.

93
00:05:57.670 --> 00:06:02.611
So that's our primary benefit to a
function, is being able to take a block of

94
00:06:02.611 --> 00:06:07.878
statements and collect it together into
a repeatable named label, if you will.

95
00:06:10.855 --> 00:06:16.770
&gt;&gt; Kyle Simpson: So, little 60-second
homework, declare yourself a function.

96
00:06:16.770 --> 00:06:18.630
Put a couple of statements in it.

97
00:06:18.630 --> 00:06:22.260
Whatever statements you want,
like assignment statements or whatever.

98
00:06:22.260 --> 00:06:25.907
And repeat it a couple of
times in your console.

99
00:06:27.903 --> 00:06:32.484
&gt;&gt; Kyle Simpson: You might
have called your function

100
00:06:32.484 --> 00:06:37.521
foo like I'm in the habit of doing, and

101
00:06:37.521 --> 00:06:43.520
that might take a = a * 2 and a = a + 3.

102
00:06:43.520 --> 00:06:46.500
So we're gonna multiply it by 2,
and then add 3 to it.

103
00:06:46.500 --> 00:06:48.070
Those are my two statements.

104
00:06:48.070 --> 00:06:53.020
Now if I start off with an a = 10 and
I call foo once and

105
00:06:53.020 --> 00:07:00.290
then I console.log(a), what would I be
expecting the output of this to be?

106
00:07:01.470 --> 00:07:05.424
Hopefully, you're awake enough
to do some basic math here,

107
00:07:05.424 --> 00:07:07.182
a [COUGH] starts out as 10.

108
00:07:07.182 --> 00:07:10.220
The first time I call foo,
it's going to say 10 times 2.

109
00:07:10.220 --> 00:07:14.660
So now a is gonna be 20, and
then we're gonna add 3 to it.

110
00:07:14.660 --> 00:07:16.660
So now a is gonna be equal to 23.

111
00:07:16.660 --> 00:07:19.990
So we'd expect it to
print out the value 23.

112
00:07:19.990 --> 00:07:24.970
Now, if I call foo two more times, and

113
00:07:24.970 --> 00:07:30.850
then I print out a again,
I'll spare you the mental acrobatics.

114
00:07:32.250 --> 00:07:35.104
Let's just run it, and
let's see what happens.

115
00:07:38.576 --> 00:07:41.800
&gt;&gt; Kyle Simpson: So
we know this one's gonna print out 23.

116
00:07:41.800 --> 00:07:45.382
This next one, what's it gonna print out?

117
00:07:45.382 --> 00:07:49.721
101,
&gt;&gt; Kyle Simpson: So

118
00:07:49.721 --> 00:07:55.518
it was 23 times 2,
which was 46 plus 3 was 49.

119
00:07:55.518 --> 00:08:04.130
And then 49 times 2 is 98 plus 3 is 101,
question?

120
00:08:07.580 --> 00:08:11.390
Question was about putting our
functions before our variables like,

121
00:08:11.390 --> 00:08:15.020
did it matter if I did that or I did that?

122
00:08:15.020 --> 00:08:16.219
No difference to JavaScript.

123
00:08:17.450 --> 00:08:20.590
It goes back to that topic
that we skirted by earlier,

124
00:08:20.590 --> 00:08:23.580
the topic of hoisting,
the topic of lexical scope.

125
00:08:23.580 --> 00:08:27.070
[COUGH] Scope and
Closures book covers it in depth.

126
00:08:27.070 --> 00:08:29.110
The Advanced JavaScript training
covers it in depth, but

127
00:08:29.110 --> 00:08:33.390
for our purposes, you can put declarations
in any place in your program.

128
00:08:33.390 --> 00:08:36.680
I typically put all my declarations
at the top of my programs.

129
00:08:36.680 --> 00:08:40.140
I put all my functions at the top and
then I put all of my variables,

130
00:08:40.140 --> 00:08:41.460
that's my preferred style.

131
00:08:41.460 --> 00:08:45.809
But as long as all your variables are at
the top, you won't have any surprises.

132
00:08:45.809 --> 00:08:49.750
As long as all your declarations are at
the top, you won't have any surprises.

133
00:08:49.750 --> 00:08:51.026
&gt;&gt; Speaker 2: You consistently do that,

134
00:08:51.026 --> 00:08:53.360
it makes it easier to
maintain the program later.

135
00:08:53.360 --> 00:08:57.073
&gt;&gt; Kyle Simpson: It's generally a good
rule to have a consistent style,

136
00:08:57.073 --> 00:08:58.183
whatever it is.

137
00:08:58.183 --> 00:09:01.996
If your style is to put your
functions at the bottom and

138
00:09:01.996 --> 00:09:05.301
your variables at the top,
that's fine, But

139
00:09:05.301 --> 00:09:10.160
it's a good idea to always be
consistent with that in your program.

140
00:09:10.160 --> 00:09:17.196
Okay, now functions can also
receive what are called parameters.

141
00:09:17.196 --> 00:09:19.730
So here you'll notice I didn't
receive any parameter, but

142
00:09:19.730 --> 00:09:21.010
what if I received a parameter?

143
00:09:21.010 --> 00:09:23.130
If I had a parameter called b

144
00:09:24.790 --> 00:09:28.310
that becomes a variable that's
accessible to me inside of the function.

145
00:09:29.400 --> 00:09:32.350
So I could take this value right here,

146
00:09:32.350 --> 00:09:35.960
and instead of it being the literal value
3, I can have it to be the variable b.

147
00:09:38.050 --> 00:09:39.760
So when I run this function now,

148
00:09:39.760 --> 00:09:44.600
its behavior is partially
dependent on what value I pass in.

149
00:09:44.600 --> 00:09:45.480
Does everybody see that?

150
00:09:46.900 --> 00:09:49.960
If I pass in a different value of b,
I get a different result out.

151
00:09:49.960 --> 00:09:51.090
Let's try it.

152
00:09:51.090 --> 00:09:55.455
If I start out with a = 10,
and I say foo(3), and

153
00:09:55.455 --> 00:10:00.017
then I say console.log(a),
what are we expecting?

154
00:10:06.865 --> 00:10:10.228
&gt;&gt; Kyle Simpson: Same thing as before,
we'd expect 23, right,

155
00:10:10.228 --> 00:10:14.777
a went from 10 to 20, and
then we added 3 to it and it became 23.

156
00:10:14.777 --> 00:10:18.525
But what happens if I put in 100 here?

157
00:10:21.023 --> 00:10:23.719
&gt;&gt; Kyle Simpson: Now we're expecting 120.

158
00:10:23.719 --> 00:10:24.930
So everybody see that?

159
00:10:24.930 --> 00:10:29.240
So what I pass into my function changes
its behavior because there's a parameter

160
00:10:29.240 --> 00:10:30.840
that I'm passing in.

161
00:10:30.840 --> 00:10:31.720
By the way, a little nuance.

162
00:10:31.720 --> 00:10:36.766
It's not a big deal, but terminologies,
I think if you're learning things,

163
00:10:36.766 --> 00:10:39.867
it's important to learn
correct terminology.

164
00:10:39.867 --> 00:10:44.191
When we call the function here, we
are passing in what's called an argument.

165
00:10:45.901 --> 00:10:46.925
&gt;&gt; Kyle Simpson: So you can have one or

166
00:10:46.925 --> 00:10:49.780
more arguments that you
pass into a function.

167
00:10:49.780 --> 00:10:54.250
But when we declare the function,
and we have these names,

168
00:10:54.250 --> 00:10:59.250
like I can say b and bar and zaz and

169
00:10:59.250 --> 00:11:04.170
whatever, these variables
here are called parameters.

170
00:11:05.520 --> 00:11:08.730
So in other words, there's a match,
a one to one match between an argument

171
00:11:08.730 --> 00:11:12.240
that gets passed in and
the parameter in that position.

172
00:11:13.840 --> 00:11:18.270
A lot of people use arguments and
parameters interchangeably

173
00:11:18.270 --> 00:11:22.100
as meaning the same thing because
they get assigned to each other so

174
00:11:22.100 --> 00:11:24.790
it seems like they could be
considered the same thing.

175
00:11:24.790 --> 00:11:29.910
To be completely specific on terminology,
it's an argument when you pass it in,

176
00:11:29.910 --> 00:11:31.340
it's a parameter when you declare it.

177
00:11:33.106 --> 00:11:38.921
So this parameter b that we've got,
got assigned to the argument 100,

178
00:11:38.921 --> 00:11:44.113
and then we used that parameter as
a variable and we printed it out.

179
00:11:44.113 --> 00:11:46.139
So, let's try this again.

180
00:11:46.139 --> 00:11:51.194
If I said foo(5) and foo(25) and foo(100),

181
00:11:51.194 --> 00:11:56.355
so I called foo three different
times with three different

182
00:11:56.355 --> 00:12:01.215
variables, all accumulating
my results into this a.

183
00:12:01.215 --> 00:12:02.912
What's my end result gonna be?

184
00:12:07.716 --> 00:12:12.066
&gt;&gt; Kyle Simpson: My end result,
&gt;&gt; Kyle Simpson: The suspense is

185
00:12:12.066 --> 00:12:14.133
killing me, 250.

186
00:12:18.810 --> 00:12:19.550
&gt;&gt; Kyle Simpson: Is there a question?

187
00:12:20.840 --> 00:12:25.544
&gt;&gt; Speaker 3: Asking about passing
a function as a parameter of another

188
00:12:25.544 --> 00:12:26.525
function?

189
00:12:26.525 --> 00:12:27.920
&gt;&gt; Kyle Simpson: [COUGH] So,
yes you can, and

190
00:12:27.920 --> 00:12:31.564
then the next question that was asked
might be slightly misleading, or

191
00:12:31.564 --> 00:12:34.740
the next answer that was given
might be slightly misleading.

192
00:12:34.740 --> 00:12:37.960
So, let me just quickly divert into that.

193
00:12:39.730 --> 00:12:44.350
If I called foo, let's say I had
two different functions here.

194
00:12:46.970 --> 00:12:48.990
And it doesn't matter
what's in bar right now.

195
00:12:48.990 --> 00:12:55.260
If I said foo and
I gave it the name bar, I passed in bar,

196
00:12:55.260 --> 00:12:58.580
what I'm doing is getting the value
that is currently in bar.

197
00:12:58.580 --> 00:13:02.204
What is the value that's currently in bar?

198
00:13:02.204 --> 00:13:05.180
It's a function, it's a function value.

199
00:13:05.180 --> 00:13:09.170
So I'm passing the function
as an argument and

200
00:13:09.170 --> 00:13:11.400
it's getting assigned to the parameter b.

201
00:13:11.400 --> 00:13:14.040
So if I said + b here, what is b?

202
00:13:15.376 --> 00:13:18.200
b is a function,
which that's not really what we want,

203
00:13:18.200 --> 00:13:19.680
we wanted the thing to be called.

204
00:13:19.680 --> 00:13:25.116
I could call it here, and
whatever it returned, I'd get that value.

205
00:13:25.116 --> 00:13:29.130
But if you pass a function as a value,
it's just a function.

206
00:13:29.130 --> 00:13:36.445
If you call it, then what it returns
is what gets passed in as the argument.

207
00:13:36.445 --> 00:13:40.044
So there's the difference
between passing a function and

208
00:13:40.044 --> 00:13:42.476
passing the result of a function call.

209
00:13:45.636 --> 00:13:48.543
&gt;&gt; Kyle Simpson: So hopefully, that clears
up the questions that were happening and

210
00:13:48.543 --> 00:13:50.175
that are being asked in the chatroom.

211
00:13:53.230 --> 00:13:59.032
&gt;&gt; Kyle Simpson: Okay,
&gt;&gt; Kyle Simpson: One

212
00:13:59.032 --> 00:14:00.673
last detail on this function.

213
00:14:00.673 --> 00:14:01.910
Let me back up.

214
00:14:01.910 --> 00:14:03.630
One last detail on those functions.

215
00:14:03.630 --> 00:14:06.150
These functions can return values as well.

216
00:14:06.150 --> 00:14:08.762
They can pass in values,
they can return values.

217
00:14:08.762 --> 00:14:12.879
So if I said, return a / 2.

218
00:14:17.586 --> 00:14:22.517
&gt;&gt; Kyle Simpson: If I say var a =
10 [COUGH] and I call foo(3),

219
00:14:22.517 --> 00:14:25.982
we know a is going to become what?

220
00:14:29.723 --> 00:14:30.870
&gt;&gt; Kyle Simpson: It's 23, right?

221
00:14:32.240 --> 00:14:36.252
But what if we took that return value and
assigned it to another variable?

222
00:14:38.159 --> 00:14:41.519
&gt;&gt; Kyle Simpson: You see when I
invoke foo, it's going to run but

223
00:14:41.519 --> 00:14:44.970
then it's going to return
me a different value.

224
00:14:46.310 --> 00:14:49.718
In this case,
it's gonna compute 23 divided by 2 which

225
00:14:49.718 --> 00:14:54.375
is,
&gt;&gt; Kyle Simpson: 11.5, [LAUGH] so

226
00:14:54.375 --> 00:15:01.280
11.5 is the thing that's gonna come back
and get assigned into the variable b.

227
00:15:01.280 --> 00:15:07.840
So if I say console.log(b),
I'm expecting here 11.5.

228
00:15:07.840 --> 00:15:14.637
So if we take that program and
put it into our console,

229
00:15:14.637 --> 00:15:22.206
we're expecting both 23 and
11.5 to be printed out.

230
00:15:22.206 --> 00:15:23.778
And in fact, that's what we get.

231
00:15:25.865 --> 00:15:29.334
&gt;&gt; Speaker 2: So in the second example,
what does it do with variable a?

232
00:15:29.334 --> 00:15:30.670
Is the variable a left alone?

233
00:15:32.660 --> 00:15:35.240
&gt;&gt; Kyle Simpson: Here we're not assigning
to anything, we're computing something and

234
00:15:35.240 --> 00:15:36.600
returning it.

235
00:15:36.600 --> 00:15:40.280
Here, we are assigning so
we're making changes to a variable.

236
00:15:40.280 --> 00:15:44.310
We're actually having outside
side effects on that variable.

