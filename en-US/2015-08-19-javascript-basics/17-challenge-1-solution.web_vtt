WEBVTT

1
00:00:00.000 --> 00:00:03.891
[MUSIC]

2
00:00:03.891 --> 00:00:06.964
&gt;&gt; Kyle Simpson: One of the items stated
that we wanted to set ourselves up a few

3
00:00:06.964 --> 00:00:10.680
variables and I indicated that
some of them should be constants.

4
00:00:10.680 --> 00:00:14.125
If you have the advantage
of using a ES6 which

5
00:00:14.125 --> 00:00:17.765
is at the moment going to
require using a transpiler,

6
00:00:17.765 --> 00:00:20.925
it's a tool that converts your code so
it'll run in browsers.

7
00:00:20.925 --> 00:00:23.505
So, it's possible to do and
a lot of people are doing it.

8
00:00:23.505 --> 00:00:25.475
I encourage it if you're
writing JavaScript,

9
00:00:25.475 --> 00:00:28.665
but might be slightly overkill for
what we're talking about.

10
00:00:28.665 --> 00:00:32.709
So either a var here or a const if
you were using ES6 would have worked.

11
00:00:34.110 --> 00:00:37.160
If we put a var here instead of a const,
the only difference is we're not gonna get

12
00:00:37.160 --> 00:00:39.880
an error if we were to
accidentally change the variable.

13
00:00:39.880 --> 00:00:44.860
But by convention, if you say var and
you have an uppercase variable like that,

14
00:00:44.860 --> 00:00:48.610
by convention people know
don't ever assign to a thing.

15
00:00:48.610 --> 00:00:52.040
So it's the difference between

16
00:00:52.040 --> 00:00:56.550
a convention that signals what you want
versus the language actually enforcing it.

17
00:00:56.550 --> 00:00:59.030
So even without the enforcement
we can still get a long way.

18
00:00:59.030 --> 00:01:01.080
So you could have taken these as vars.

19
00:01:01.080 --> 00:01:01.800
Of course,

20
00:01:01.800 --> 00:01:07.350
my bank balance is something that you
would typically think of as changing.

21
00:01:07.350 --> 00:01:11.040
Biggest reason why make this a variable
instead of a constant, it's a constant for

22
00:01:11.040 --> 00:01:15.120
the purposes of our program, that is
that we don't change our bank balance.

23
00:01:15.120 --> 00:01:18.070
But the biggest reason why I'd make
it a variable is because it might be

24
00:01:18.070 --> 00:01:21.520
the kind of thing that you'd
want to prompt the user for.

25
00:01:21.520 --> 00:01:24.380
So, if you were gonna try the prompting,
you wanna do it and

26
00:01:24.380 --> 00:01:30.400
it's an important note, by the way,
that constants have to have an assignment.

27
00:01:30.400 --> 00:01:33.480
So you can't say something like,
if you're doing a real const,

28
00:01:33.480 --> 00:01:36.280
you can't say something like const foo.

29
00:01:36.280 --> 00:01:40.360
Because it doesn't have an assignment and
it could never be given an assignment, so

30
00:01:40.360 --> 00:01:43.530
there has to be an explicit thing
that's getting assigned to it.

31
00:01:44.711 --> 00:01:45.745
&gt;&gt; Kyle Simpson: All right, so

32
00:01:45.745 --> 00:01:50.530
here's my bank balance that
would be considered a variable.

33
00:01:50.530 --> 00:01:53.866
Now my amount is going to be kind
of my running total, if you will,

34
00:01:53.866 --> 00:01:55.151
of how much I've spent.

35
00:01:55.151 --> 00:01:57.027
We'll come back to
the functions in a minute.

36
00:01:57.027 --> 00:02:00.589
But the main meat of what I wanna
do is I wanna loop through,

37
00:02:00.589 --> 00:02:02.643
as I hinted in that description.

38
00:02:02.643 --> 00:02:06.504
I wanna loop through and
keep doing something for

39
00:02:06.504 --> 00:02:08.770
as long as I'm able to do it.

40
00:02:08.770 --> 00:02:11.940
So basically, I'm figuring out
what my purchase amount is and

41
00:02:11.940 --> 00:02:12.842
I am being somewhat irresponsible.

42
00:02:14.216 --> 00:02:18.030
I'm just gonna keep spending until I don't
have any more in my bank account, right?

43
00:02:18.030 --> 00:02:24.340
So here I'm gonna say, why all the amount
is less than my bank balance, okay?

44
00:02:24.340 --> 00:02:28.973
So amount = amount + PHONE_PRICE
is buying a new phone and

45
00:02:28.973 --> 00:02:32.940
you notice my usage of comments here.

46
00:02:32.940 --> 00:02:37.740
In this comment I didn't say,
add the phone price to my current amount

47
00:02:37.740 --> 00:02:40.060
cuz that would be repeating
what the code already said.

48
00:02:40.060 --> 00:02:44.486
This was more a why or a how kind of an
explanation or sort of a meta explanation,

49
00:02:44.486 --> 00:02:47.722
so I'm indicating here that
you're buying a new phone.

50
00:02:47.722 --> 00:02:50.475
Now, we want to know if we
can afford the accessory?

51
00:02:50.475 --> 00:02:54.255
I indicated in that problem statement that
you would want to be able to purchase

52
00:02:54.255 --> 00:02:56.930
an accessory like an extra charge or
whatever.

53
00:02:56.930 --> 00:03:01.090
You want to purchase the phone
accessory for each phone assuming

54
00:03:01.090 --> 00:03:05.350
that you haven't gone over a certain
threshold of your spending limit.

55
00:03:05.350 --> 00:03:08.771
So we had a threshold that
we declared is $200 and

56
00:03:08.771 --> 00:03:14.350
after that we might buy phones but
we won't buy anymore accessories, okay?

57
00:03:14.350 --> 00:03:15.449
So just a simple little

58
00:03:16.960 --> 00:03:20.950
expression in code of how we might be
thinking about things in our mind.

59
00:03:20.950 --> 00:03:24.000
So as long as the running total amount
is less than our spending threshold,

60
00:03:24.000 --> 00:03:26.770
we do wanna add in the accessory price.

61
00:03:26.770 --> 00:03:32.165
Otherwise we would just
keep going until the amount

62
00:03:32.165 --> 00:03:38.635
went greater than the bank balance.
&gt;&gt; Kyle Simpson: Now,

63
00:03:38.635 --> 00:03:42.919
we don't wanna forget to pay
the government, [LAUGH] so

64
00:03:42.919 --> 00:03:48.990
we now say amount = amount + and here
I call a function, I say calculateTax.

65
00:03:50.540 --> 00:03:55.480
So that's a set of things
that I might do only once or

66
00:03:55.480 --> 00:03:59.300
I might do multiple times, in this
program, I'm only doing it once but

67
00:03:59.300 --> 00:04:03.660
there's still value in putting it
in a function because this code

68
00:04:03.660 --> 00:04:09.040
is more understandable than if I drop
that same code directly in here.

69
00:04:09.040 --> 00:04:12.510
Because the name of the function
explains something about what I'm doing.

70
00:04:13.510 --> 00:04:16.585
I'm taking advantage of the fact that I
can name this function something like

71
00:04:16.585 --> 00:04:22.380
calculateTax, whereas if I
took just amount times 1.0 or

72
00:04:22.380 --> 00:04:26.402
whatever I did, that would look less
reasonable or it would make less sense.

73
00:04:26.402 --> 00:04:34.058
So another virtue of using functions
is that you could put in a name for

74
00:04:34.058 --> 00:04:41.054
that section of code that makes
the code more understandable.

75
00:04:41.054 --> 00:04:44.493
So our calculateTax,
we take in an amount and

76
00:04:44.493 --> 00:04:50.028
we multiply it by the TAX_RATE,
so TAX_RATE being set up as 0.08.

77
00:04:50.028 --> 00:04:54.376
So this tax amount is just the tax,
$12 or $8 or

78
00:04:54.376 --> 00:05:00.360
whatever it would mean, [COUGH] and
we add that to our existing amount.

79
00:05:00.360 --> 00:05:05.463
And now we then say your purchase amount,
so this is like the cash register,

80
00:05:05.463 --> 00:05:09.692
your purchase amount and
I call formatAmount and the reason for

81
00:05:09.692 --> 00:05:13.950
that is I wanted to print out
a nicely printed US dollar figure.

82
00:05:13.950 --> 00:05:18.535
So we're going to put the $ in front
of it and then we want to call

83
00:05:18.535 --> 00:05:22.250
that to toFixed method to round it to
a certain number of decimal places.

84
00:05:23.720 --> 00:05:28.610
So I'm calling that formatAmount and
then finally as kind of an extra

85
00:05:28.610 --> 00:05:34.230
little flourish here, I would ask,
did I go over my bank balance and

86
00:05:34.230 --> 00:05:38.150
if I did, I'm gonna print out,
you can't afford this.

87
00:05:38.150 --> 00:05:42.012
Now the way I setup the program,
of course, I've gone over my bank balance

88
00:05:42.012 --> 00:05:44.772
because I didn't stop until
I already went over it and

89
00:05:44.772 --> 00:05:46.385
then I had to add tax on, okay?

90
00:05:46.385 --> 00:05:49.992
So, thankfully I'm preventing
myself from completely

91
00:05:49.992 --> 00:05:52.404
running my bank account down to zero.

92
00:05:52.404 --> 00:05:55.584
But that just illustrates some of
these concepts that we talked about,

93
00:05:55.584 --> 00:05:58.552
you can see that there are conditionals
to help us make a decision,

94
00:05:58.552 --> 00:06:00.380
should we do something or not?

95
00:06:00.380 --> 00:06:02.710
In this case, the decision is whether or
not we print something.

96
00:06:05.300 --> 00:06:06.550
Here the conditional is whether or

97
00:06:06.550 --> 00:06:10.410
not we do something extra inside
of this loop that's happening.

98
00:06:10.410 --> 00:06:14.070
Here, the conditional is deciding
if it's time to stop the loop or

99
00:06:14.070 --> 00:06:15.576
if we should keep going.

100
00:06:15.576 --> 00:06:17.890
These functions are things
that we can call one or

101
00:06:17.890 --> 00:06:23.010
many times, they're a collection of things
we can pass values in as we are doing,

102
00:06:23.010 --> 00:06:26.220
we can pass arguments in that
get set to these parameters.

103
00:06:26.220 --> 00:06:29.799
We can also take advantage of
return values to return things out.

104
00:06:29.799 --> 00:06:33.735
You'll notice that these two
functions don't make any changes to

105
00:06:33.735 --> 00:06:35.639
the variables outside of them.

106
00:06:35.639 --> 00:06:40.415
And that's actually an intentional design
decision on my part rather than me

107
00:06:40.415 --> 00:06:45.117
saying in here instead of saying return,
I could have said something like,

108
00:06:45.117 --> 00:06:49.470
amount = amount + the TAX_RATE,
I could have done that.

109
00:06:49.470 --> 00:06:50.640
But if I'd done it that way,

110
00:06:50.640 --> 00:06:54.138
I'd be making what's called
a side effect of a function call.

111
00:06:54.138 --> 00:06:57.719
Which would work, we saw several examples
of that earlier with the foo and

112
00:06:57.719 --> 00:06:58.860
bar functions.

113
00:06:58.860 --> 00:07:04.100
But it's typically considered to be
a less graceful form of programming for

114
00:07:04.100 --> 00:07:06.190
your functions to have those side effects.

115
00:07:06.190 --> 00:07:10.840
You typically will think about a function
as being entirely self-contained.

116
00:07:10.840 --> 00:07:16.340
You pass in a value or multiple values if
you need to, you get one return value out.

117
00:07:16.340 --> 00:07:19.900
And everything that happens inside of
the function is sort of self-contained and

118
00:07:19.900 --> 00:07:21.930
you don't make any changes outside.

119
00:07:21.930 --> 00:07:25.850
And you try not to rely upon stuff
outside of the function as well,

120
00:07:25.850 --> 00:07:29.320
although there are cases where it's
inconvenient to pass in everything.

121
00:07:29.320 --> 00:07:33.680
So, these are not hard and fast rules but
just stylistically you typically wanna

122
00:07:33.680 --> 00:07:37.440
design your functions to have as little
impact to the outside world as possible.

123
00:07:38.710 --> 00:07:43.030
There's one big caveat to that which
is not a topic that we're gonna go

124
00:07:43.030 --> 00:07:46.420
heavily into right now, but
there's one caveat to that and

125
00:07:46.420 --> 00:07:50.860
that's the caveat that closure is
when you intentionally want for

126
00:07:50.860 --> 00:07:54.890
a function to remember stuff outside so
that it can keep track of its state.

127
00:07:54.890 --> 00:07:59.930
So there is a design style or a feature
in JavaScript called closure, and

128
00:07:59.930 --> 00:08:01.620
we intentionally do that sort of stuff.

129
00:08:01.620 --> 00:08:05.315
And I cover that in basic detail
in chapter two of the book.

130
00:08:05.315 --> 00:08:07.559
So you can go further from this class and

131
00:08:07.559 --> 00:08:11.375
read about a basic expression of
how closure works in chapter two.

132
00:08:11.375 --> 00:08:13.510
And I also have a full book about closure,

133
00:08:13.510 --> 00:08:16.560
the Scope &amp; Closures book is
really kind of all about that.

134
00:08:16.560 --> 00:08:20.090
So there's plenty more to go if you
wanna learn more about how that works,

135
00:08:20.090 --> 00:08:22.100
we definitely won't
worry too much about it.

136
00:08:22.100 --> 00:08:25.680
But there are places,
just advice to say there are places where

137
00:08:25.680 --> 00:08:29.880
you intentionally do decide to have
a function rely on outside variables.

138
00:08:29.880 --> 00:08:32.431
Yeah, let's see the question is.
&gt;&gt; Speaker 2: 2,

139
00:08:32.431 --> 00:08:35.337
that just came in there at the bottom.
&gt;&gt; Kyle Simpson: Should have function

140
00:08:35.337 --> 00:08:40.870
always return a value even if you
don't have return in the function.

141
00:08:40.870 --> 00:08:45.730
Functions only return an explicit
value if you actually say return,

142
00:08:45.730 --> 00:08:46.809
normal functions that is.

143
00:08:48.050 --> 00:08:50.910
If you call a function and
you do not have a return,

144
00:08:50.910 --> 00:08:54.660
it sort of implies that there is
a return undefined at the end.

145
00:08:56.340 --> 00:09:00.360
But there's always, a result from
a function call is either that implied

146
00:09:00.360 --> 00:09:03.090
undefined, or
whatever you explicitly return.

147
00:09:05.930 --> 00:09:08.600
And the question of should
a function always return?

148
00:09:09.600 --> 00:09:12.224
There are many functions that I
write that it doesn't make sense for

149
00:09:12.224 --> 00:09:13.440
them to have return value.

150
00:09:13.440 --> 00:09:16.640
So there's no should it have a return or
not.

151
00:09:16.640 --> 00:09:18.290
It should have a return
if that makes sense.

152
00:09:18.290 --> 00:09:22.029
In this case, it makes sense for both of
my functions to compute something and

153
00:09:22.029 --> 00:09:22.841
return a value.

154
00:09:22.841 --> 00:09:26.621
Sometimes you just have a function doing
something, that's a function that maybe

155
00:09:26.621 --> 00:09:29.598
has a side effect like it's calling
something or whatever or so.

156
00:09:29.598 --> 00:09:33.200
There's plenty of places where
return values don't make sense.

157
00:09:33.200 --> 00:09:34.723
Then the next question was,

158
00:09:34.723 --> 00:09:39.038
in the program the amount is always going
to be greater than the bank accounts, so

159
00:09:39.038 --> 00:09:42.220
both the console logs will be printed,
why are we doing it?

160
00:09:42.220 --> 00:09:43.754
It's just a simple demo,

161
00:09:43.754 --> 00:09:48.089
I wanted to show you that there's
a way to decide whether we're looping.

162
00:09:48.089 --> 00:09:51.833
We could have been more nuanced
about it and said, well,

163
00:09:51.833 --> 00:09:55.190
amount is less than bank
balance minus threshold.

164
00:09:55.190 --> 00:10:00.076
Or something like we could have said,
I wanna spend until I have spent to

165
00:10:00.076 --> 00:10:04.560
where my threshold is under
$100 left in my bank account.

166
00:10:04.560 --> 00:10:07.010
We could have done it that way and
then of course, but

167
00:10:07.010 --> 00:10:10.460
the point here was just to illustrate the
different ways that conditionals can be

168
00:10:11.830 --> 00:10:13.110
woven together in our program.

169
00:10:16.060 --> 00:10:19.785
The next question,
why are you returning amount.toFixed?

170
00:10:19.785 --> 00:10:23.976
If you make purchase more than 1K or
a 100,

171
00:10:23.976 --> 00:10:29.034
I guess you meant,
how the amount will be printed?

172
00:10:29.034 --> 00:10:33.669
So it's important to
understand toFixed( 2 ),

173
00:10:33.669 --> 00:10:39.360
that indicates decimal places
not digits in your number.

174
00:10:39.360 --> 00:10:46.190
So, this only means that I wanna round and
pad my decimals to two decimal places.

175
00:10:46.190 --> 00:10:49.164
The amount on the left hand side,
if I had gone all the way up to $5,000 or

176
00:10:49.164 --> 00:10:53.400
$5 million or whatever, we're gonna have
as many digits on the left hand side.

177
00:10:53.400 --> 00:10:56.770
There's another method called
toPrecision if you want to

178
00:10:56.770 --> 00:10:59.520
actually restrict the number of
digits that show up in a number.

179
00:11:00.680 --> 00:11:02.920
For those of you that had science classes,

180
00:11:02.920 --> 00:11:05.350
you know about the difference
between precision.

181
00:11:05.350 --> 00:11:09.340
And not so, there's a toPrecision method
that can be used for that purpose.

182
00:11:09.340 --> 00:11:14.290
But here, toFixed is only dealing with the
number of decimal places that we get out.

