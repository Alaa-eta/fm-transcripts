WEBVTT

1
00:00:00.000 --> 00:00:04.668
[MUSIC]

2
00:00:04.668 --> 00:00:07.900
&gt;&gt; Kyle Simpson: All right now, back to
variables, we've we've mentioned this many

3
00:00:07.900 --> 00:00:11.020
times but we didn't we didn't
explicitly define that.

4
00:00:11.020 --> 00:00:14.590
And here is where it matters,
if you put a varon in front of something.

5
00:00:14.590 --> 00:00:19.785
So, if I have a program where
the very first line says a equals

6
00:00:19.785 --> 00:00:24.940
42, I'm assigning to a variable that
has never been formally declared.

7
00:00:26.730 --> 00:00:31.490
And assigning to a variable that's never
been formally declared is a really,

8
00:00:31.490 --> 00:00:32.750
really bad idea.

9
00:00:34.450 --> 00:00:38.599
Every variable that you use in your
program should be formally declared.

10
00:00:40.110 --> 00:00:43.960
And it should be formally declared
before the first time you use it.

11
00:00:45.950 --> 00:00:46.590
Okay.

12
00:00:46.590 --> 00:00:52.080
Technically, this program
formally declares a and

13
00:00:52.080 --> 00:00:57.200
uses it, but it makes use of this concept
which we won't really get into here,

14
00:00:57.200 --> 00:00:59.010
and it makes use of this
concept called hoisting.

15
00:01:00.760 --> 00:01:04.820
And it's a more confusing program
even though it's a correctly

16
00:01:04.820 --> 00:01:08.592
running program.
&gt;&gt; Speaker 2: [INAUDIBLE] if clears it

17
00:01:08.592 --> 00:01:11.271
after the scope [INAUDIBLE].
&gt;&gt; Kyle Simpson: Yeah, I cover hoisting

18
00:01:11.271 --> 00:01:15.138
a lot more in the book on scope enclosures
so if you want to get into the nuances of

19
00:01:15.138 --> 00:01:19.064
it.ued It has to do with the fact that
this program is gonna get compiled first,

20
00:01:19.064 --> 00:01:22.990
so it's going to find that var
a before it tries to run anything.

21
00:01:22.990 --> 00:01:25.970
But this is a more confusing
version of the program.

22
00:01:25.970 --> 00:01:30.560
You would always want to prefer for
less confusing programs

23
00:01:30.560 --> 00:01:34.610
to write var a first before
you do an assignment and

24
00:01:34.610 --> 00:01:38.110
you can optionally combine
those two into the same thing.

25
00:01:39.940 --> 00:01:42.490
But you would always want to
formally declare every variable and

26
00:01:42.490 --> 00:01:46.700
the way we typically do that in JavaScript
up to this point is with the var keyword.

27
00:01:46.700 --> 00:01:48.430
There's two more coming in ES6.

28
00:01:48.430 --> 00:01:54.270
One is called let and the other
one we mentioned earlier is const.

29
00:01:57.270 --> 00:02:01.000
And const are block scoping
declarations rather

30
00:02:01.000 --> 00:02:03.540
than functions coping
declaration like var is.

31
00:02:04.700 --> 00:02:10.090
What that means has a whole chapter in the
book so I won't get into that too much but

32
00:02:10.090 --> 00:02:13.880
those are the three ways that you formally
declare a variable in JavaScript.

33
00:02:15.210 --> 00:02:18.620
There's one other way to formally declare
an identifier and that is to declare it as

34
00:02:18.620 --> 00:02:24.220
a function and we haven't talked about
functions yet, but if I said function A,

35
00:02:24.220 --> 00:02:28.070
I'm declaring a variable called
A which has this function value in it.

36
00:02:30.010 --> 00:02:32.710
So you always want to formally declare

37
00:02:32.710 --> 00:02:36.170
your variables in one of
the ways that I just showed.

38
00:02:36.170 --> 00:02:44.444
Let me put those other ones back.
&gt;&gt; Kyle Simpson: Those

39
00:02:44.444 --> 00:02:46.667
are the ways to formally
declare variables and

40
00:02:46.667 --> 00:02:49.750
you're always going to want to do
one of those in your programs.

41
00:02:52.750 --> 00:02:54.450
What's the use of hoisting?

42
00:02:54.450 --> 00:02:57.780
Again, I have a whole section in
the scope enclosures book about

43
00:02:57.780 --> 00:02:59.760
what hoisting's about.

44
00:02:59.760 --> 00:03:01.430
Hoisting is actually not a real thing.

45
00:03:01.430 --> 00:03:03.140
It's a metaphor for the real thing and

46
00:03:03.140 --> 00:03:05.910
the real thing is the compiler.
&gt;&gt; Speaker 2: Will you also discuss

47
00:03:05.910 --> 00:03:07.706
it in Advanced JavaScript?
&gt;&gt; Kyle Simpson: I do.

48
00:03:07.706 --> 00:03:09.690
We'll upsell here [LAUGH].

49
00:03:09.690 --> 00:03:13.540
I do extensively cover this topic
in the advanced JavaScript course

50
00:03:13.540 --> 00:03:15.268
that's available from Front End Masters.

51
00:03:15.268 --> 00:03:20.800
[COUGH] Okay.
&gt;&gt; Speaker 2: A question about using let.

52
00:03:20.800 --> 00:03:24.310
What's the difference between using let to

53
00:03:24.310 --> 00:03:27.530
declare a variable?
&gt;&gt; Kyle Simpson: I don't want to get too

54
00:03:27.530 --> 00:03:29.130
much into the weeds, so

55
00:03:29.130 --> 00:03:33.630
let puts it inside of a block,
var puts it inside of a function.

56
00:03:33.630 --> 00:03:35.130
That's all I'll say about that.

57
00:03:35.130 --> 00:03:38.640
There's much more about that in
the Scope and Closures book and

58
00:03:38.640 --> 00:03:40.140
in the advanced JavaScript course.

59
00:03:40.140 --> 00:03:43.870
For your basic learning purposes in
JavaScript you don't need to worry about

60
00:03:43.870 --> 00:03:46.360
let in columns,
to var is more than enough.

61
00:03:46.360 --> 00:03:49.850
But there are nuances to their
behaviors that are available to you.

62
00:03:49.850 --> 00:03:57.450
If you work in ECMA Script ES6.

63
00:03:57.450 --> 00:04:07.113
Okay, moving along.
&gt;&gt; Kyle Simpson: There's

64
00:04:07.113 --> 00:04:10.930
a notion in many programming languages and
JavaScript is no different.

65
00:04:10.930 --> 00:04:15.414
That if I had a collection of
statements like var a = 42 and

66
00:04:15.414 --> 00:04:18.480
foo(a / 2), these are statements.

67
00:04:18.480 --> 00:04:22.678
And if I had a collection
of statements that

68
00:04:22.678 --> 00:04:27.807
represented a logical unit
together then I could put

69
00:04:27.807 --> 00:04:32.705
those statements together
inside of a curly brace

70
00:04:32.705 --> 00:04:38.290
pair like we see there and
that's called a block.

71
00:04:38.290 --> 00:04:42.360
A block essentially is a pairing
of curly braces with one or

72
00:04:42.360 --> 00:04:44.880
more statements inside of it.

73
00:04:44.880 --> 00:04:51.470
Now this block is a completely standalone
empty block it doesn't mean anything.

74
00:04:51.470 --> 00:04:52.990
The way we've expressed it.

75
00:04:52.990 --> 00:04:55.070
It's a stylistic thing.

76
00:04:55.070 --> 00:04:58.610
It says, these two things belong together
and they're separate from other stuff.

77
00:04:58.610 --> 00:05:03.640
Like if you had a program that looked
like this, and you had stuff up here, and

78
00:05:03.640 --> 00:05:08.932
you had stuff down here.
&gt;&gt; Kyle Simpson: You're

79
00:05:08.932 --> 00:05:13.010
stylistically signalling these two things
in between, they're kind of special.

80
00:05:13.010 --> 00:05:15.100
They're shut off there in their own deal.

81
00:05:15.100 --> 00:05:18.890
So there's not much, there's not
any functional difference here.

82
00:05:18.890 --> 00:05:22.990
But most of the time blocks are not
appearing by themselves like that.

83
00:05:22.990 --> 00:05:27.780
Most of the time they appear associated
with another kind of a statement.

84
00:05:27.780 --> 00:05:31.590
So there's different kinds of statements
that have blocks associated with them.

85
00:05:31.590 --> 00:05:34.590
For example,
which we'll get into in a little bit.

86
00:05:34.590 --> 00:05:35.480
The if statement.

87
00:05:36.540 --> 00:05:41.579
So, if I wrote a statement
where I wanted to say, if (a

88
00:05:41.579 --> 00:05:46.990
&gt; 10) and attach a block to it, then

89
00:05:46.990 --> 00:05:51.540
what I'm saying is look at this statement
and figure out if that's true or false.

90
00:05:53.020 --> 00:05:57.550
Is the value currently in a greater
than ten or not, it's only one or

91
00:05:57.550 --> 00:05:59.430
two possible answers here.

92
00:05:59.430 --> 00:06:03.090
In our program, we would have had to
declare the var a and give it some

93
00:06:03.090 --> 00:06:06.829
useful value like the value 42.
&gt;&gt; Kyle Simpson: And

94
00:06:06.829 --> 00:06:10.150
then give it some other value down here.

95
00:06:10.150 --> 00:06:14.500
So if I said, if a is greater than ten,
is the answer yes or

96
00:06:14.500 --> 00:06:17.565
no?
&gt;&gt; Speaker 2: It's greater

97
00:06:17.565 --> 00:06:18.340
than ten.
&gt;&gt; Kyle Simpson: Yes,

98
00:06:18.340 --> 00:06:19.580
it's greater than ten.

99
00:06:19.580 --> 00:06:23.330
So we would go into the block,
only if we answered yes to this question.

100
00:06:23.330 --> 00:06:25.920
This asked a question we
go into that block and

101
00:06:25.920 --> 00:06:29.530
do these things only if
the question answered yes.

102
00:06:29.530 --> 00:06:31.580
In programming terms yes and

103
00:06:31.580 --> 00:06:35.100
no are actually what are called
the values true and false.

104
00:06:36.180 --> 00:06:41.210
So the question is, is that statement
true and the answer is yes it is true.

105
00:06:41.210 --> 00:06:44.820
So we would execute the stuff inside
of the block, otherwise we don't.

106
00:06:44.820 --> 00:06:48.940
So that's one way to attach a block
to something is to an if statement.

107
00:06:48.940 --> 00:06:54.610
Another way to attach a block to
a statement is to have a loop, like

108
00:06:54.610 --> 00:06:59.850
a while loop or a for loop or whatever and
we'll come to loops in just a moment but

109
00:06:59.850 --> 00:07:04.150
you notice that this block, again,
it belongs to that statement and

110
00:07:04.150 --> 00:07:08.210
it's only going to get executed
in the context of that statement.

111
00:07:08.210 --> 00:07:11.800
So, it will only get executed
if this loop is going to happen.

112
00:07:12.800 --> 00:07:16.690
In this case the loop
is going to happen once

113
00:07:16.690 --> 00:07:19.790
because the first time we
enter a is greater than 42.

114
00:07:21.130 --> 00:07:23.570
But, immediately we set it to ten.

115
00:07:23.570 --> 00:07:25.870
So, the next time we try to do this loop,

116
00:07:25.870 --> 00:07:29.060
it's not gonna keep going because a will
no longer be the greater than ten.

117
00:07:29.060 --> 00:07:32.410
It will just be the ten itself.
&gt;&gt; Speaker 2: So, Kyle.

118
00:07:32.410 --> 00:07:35.260
You have the bracket on the up.

119
00:07:35.260 --> 00:07:38.380
At the end where some people bring
it null then have it to begin.

120
00:07:38.380 --> 00:07:39.420
&gt;&gt; Kyle Simpson: Some people like

121
00:07:39.420 --> 00:07:40.930
it there.
&gt;&gt; Speaker 2: What kind of person

122
00:07:40.930 --> 00:07:41.540
likes that?

123
00:07:41.540 --> 00:07:43.961
Is that a-
&gt;&gt; Kyle Simpson: [LAUGH] [CROSSTALK] I'm

124
00:07:43.961 --> 00:07:47.510
tempted to answer that but I can't.
&gt;&gt; Speaker 2: Answer it.

125
00:07:47.510 --> 00:07:48.010
Go ahead.
&gt;&gt; Kyle Simpson: No.

126
00:07:48.010 --> 00:07:51.370
&gt;&gt; Speaker 2: Cuz I do that.

127
00:07:51.370 --> 00:07:52.830
&gt;&gt; Kyle Simpson: It's a perfectly valid

128
00:07:52.830 --> 00:07:54.430
style of programming.
&gt;&gt; Speaker 2: I've only seen

129
00:07:54.430 --> 00:07:58.650
enterprise java developers do that.
&gt;&gt; Kyle Simpson: I don't know that I would

130
00:07:58.650 --> 00:08:02.849
associate it with any particular group of
people or even any particular language.

131
00:08:05.620 --> 00:08:09.570
It is a stylistic choice only.
&gt;&gt; Speaker 2: Is it a bad choice to do

132
00:08:09.570 --> 00:08:11.970
it the other way?
&gt;&gt; Kyle Simpson: It's not a bad choice.

133
00:08:11.970 --> 00:08:15.050
It's a choice, not a bad or a good one.

134
00:08:15.050 --> 00:08:18.410
The vast majority of open source
developers do what's called cuddling,

135
00:08:19.540 --> 00:08:22.470
which is that they put the curly brace
on the same line as the statement, so.

136
00:08:22.470 --> 00:08:24.030
&gt;&gt; Speaker 2: Called cuddling?

137
00:08:24.030 --> 00:08:25.330
Okay.
&gt;&gt; Kyle Simpson: [LAUGH]

138
00:08:25.330 --> 00:08:25.830
&gt;&gt; Speaker 2: Now I know it.

139
00:08:25.830 --> 00:08:26.730
&gt;&gt; Kyle Simpson: That's how most people

140
00:08:26.730 --> 00:08:29.160
do it, but there's nothing
wrong with doing it that way.

141
00:08:29.160 --> 00:08:32.160
They are functionally exactly the same.
&gt;&gt; Speaker 2: Okay.

142
00:08:33.820 --> 00:08:35.440
&gt;&gt; Kyle Simpson: So, we have a block

143
00:08:35.440 --> 00:08:39.060
that's not associated with anything,
means it's gonna run every time or

144
00:08:39.060 --> 00:08:42.180
we can attach a block to something and
it means it's only gonna run

145
00:08:42.180 --> 00:08:47.390
conditionally if that statement actually
results in something that we wanna do.

146
00:08:47.390 --> 00:08:49.960
There's lots of places
where blocks can appear,

147
00:08:49.960 --> 00:08:52.730
blocks can also appear as
part of a function statement.

148
00:08:53.950 --> 00:08:59.480
So here, that block of statements
only happens for this foo function,

149
00:09:01.160 --> 00:09:04.910
probably don't wanna call recursive,
we saw call a different function.

150
00:09:04.910 --> 00:09:08.290
Now this block only happens
if foo ever gets called.

151
00:09:08.290 --> 00:09:12.940
So it doesn't run right away but if later
in a program, I try to invoke the function

152
00:09:12.940 --> 00:09:15.930
then it would find that block
it would run that block of code.

153
00:09:15.930 --> 00:09:17.130
Okay.

154
00:09:17.130 --> 00:09:18.240
So just think conceptually,

155
00:09:18.240 --> 00:09:22.560
if I wrap a curly brace pair around a set
of code I'm putting that as a collection

156
00:09:22.560 --> 00:09:26.950
of code and then I can attach that block
to various different kinds of statements.

157
00:09:26.950 --> 00:09:31.590
And that will change how, and if,
and when that block gets executed,

158
00:09:31.590 --> 00:09:36.260
that's the major take away.
&gt;&gt; Speaker 2: There is a question there at

159
00:09:36.260 --> 00:09:41.390
the bottom if you want to use it.
&gt;&gt; Kyle Simpson: The question was

160
00:09:41.390 --> 00:09:46.370
essentially there's,
you can declare a function like that or

161
00:09:46.370 --> 00:09:51.820
you can declare a function-
&gt;&gt; Kyle Simpson: Like that.

162
00:09:51.820 --> 00:09:54.280
And technically there's a third variation,

163
00:09:54.280 --> 00:09:59.300
which is to give it a name itself,
which doesn't have to be the same.

164
00:09:59.300 --> 00:10:01.010
Those are all functions.

165
00:10:01.010 --> 00:10:03.580
Those are not all function declarations.

166
00:10:03.580 --> 00:10:06.360
The first line is a function declaration.

167
00:10:06.360 --> 00:10:11.180
The next two are function expressions
attached to a variable declaration.

168
00:10:12.380 --> 00:10:15.640
There's a variety of
differences between these and

169
00:10:15.640 --> 00:10:19.140
we get too far off track if we worry too
much about those nuanced differences.

170
00:10:19.140 --> 00:10:23.770
So there's a variety of differences
between them but the major takeaway here

171
00:10:23.770 --> 00:10:31.025
that you would want to not
forget is that in all three of

172
00:10:31.025 --> 00:10:37.540
these [COUGH] in all three of these cases
the block is associated to a function and

173
00:10:37.540 --> 00:10:40.100
the block will not run unless
you execute the function.

174
00:10:43.140 --> 00:10:46.730
So the nuance differences between
function declarations and

175
00:10:46.730 --> 00:10:49.570
variable declarations of
function expression assignments,

176
00:10:49.570 --> 00:10:52.900
those nuanced differences are outside
of our scope of discussion here.

177
00:10:52.900 --> 00:10:56.440
They are covered in depth
in the book series.

178
00:10:56.440 --> 00:10:59.290
So, next steps you would want
to pay more attention to

179
00:10:59.290 --> 00:11:00.780
that reading through the books.

180
00:11:00.780 --> 00:11:03.569
They're also covered in my training,
my advanced JavaScript training.

