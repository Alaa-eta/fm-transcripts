[00:00:00]
>> [MUSIC]

[00:00:03]
>> Kyle Simpson: A function is a way to logically group a piece of code together like a block is. But a function also makes that block of code something that you can call more than once. So it's like a loop and it's like a block, but it's not gonna run forever like a loop does and it's not gonna run only once right now like a regular block does.

[00:00:26]
So it's a third different concept here. It's like putting a set of stuff in to this special location and being able to say, as many times as I need it, I can just call out to that stuff and it'll run. I might need it once, I might need it five times.

[00:00:44]
I might need to do it over and over and over again. It doesn't really matter. We use the function to logically group a set of tasks together. So I have a silly running example in the book. If you've read any of the book, I have this silly example of the phone store where you're purchasing a phone or whatever.

[00:01:02]
So, if you haven't read it, then you can go back and understand what I'm talking about. But here [COUGH] in this running silly example I have, the phone store employee doesn't want to calculate all of the taxes for your final purchase amount. And you're talking to her and you're saying, I wanna buy this phone and this accessory or whatever.

[00:01:19]
She doesn't wanna redo that on her calculator every time. That's a set of tasks that's repetitive that's going to need to happen [COUGH] for pretty much every customer that buys something. And so there's almost certainly a program that does that for her. It's a checkout program. She can swipe your credit card, it automatically calculates how much to charge and all of that.

[00:01:39]
And that's conceptually the same thing as a function. It's taking a specific set of tasks and putting it into a thing that I can repeat on demand. Whenever I want it, I can just invoke it, say, do that sort of things and it'll just happen. So [COUGH] the example that we see here is, I have a variable I'm declaring with the value 99.99, that's the price of a phone, and I wanna print the amount.

[00:02:07]
I could have put a console.log statement here, right? I could have said console.log amount and it would have printed it. And then I said, amount = amount * 2, which doubles the value, and then I could have put another console.log. But as soon as I did that twice, as soon as I typed the same thing twice into a program, I might start to ask myself, why am I repeating myself?

[00:02:29]
Could I take that set of statements that I repeated and put that into a location and give that location a special name? And whenever I want that stuff to happen, just call it by name. That's what a function is doing. So what is my set of statements? It's just one statement in this case, but it's slightly more complex than just calling console.log amount.

[00:02:52]
You'll notice that I'm also saying toFixed. Now toFixed is a method that's available to all numbers in JavaScript. And it essentially formats them as a string with a certain number of decimal places on it, like dollars, US dollars. So if I wanted to take the number 99.99 or the number 199.98 and make it into a string that absolutely had exactly two digits, then I could use the toFixed.

[00:03:23]
Let me illustrate. What if I had the number,
>> Kyle Simpson: 3.141519, I can't remember. That's all I remember, 1415926 or something like that, right? So that's the first several digits of pi. You'll notice I didn't win any pi digit memory contest as a kid. [LAUGH] Okay, that's the first several digits of pi.

[00:03:50]
But what if I wanted to print out that? Let's assign that to some variable, so let's assign it to a. What if I wanted to print out that value but only to two decimal places, or let's actually say to three decimal places? Well, I could say a.toFixed(3), and you'll notice that I'm not gonna get a number.

[00:04:14]
I'm now gonna get a string, the string 3.142.
>> Kyle Simpson: So we rounded that digit, we rounded it by the fourth digit, we rounded that third digit up to 2. So toFixed is a way to get a number to a particular precision, to a particular number of decimal places.

[00:04:35]
So nice and helpful, I almost always use this. The only place I hardly ever use it is for printing out dollars and cents. Cuz another observation that we can make is, what if I had the variable a = 3.5 and I wanted to print that out as dollars?

[00:04:55]
Well, it's missing a zero on the end, right? If I just said console.log(a),
>> Kyle Simpson: And only get 3.5, which isn't as friendly for US dollars. So if I said console.log(a.toFixed) and I say, give me two decimal places, you'll notice I get 3.50.
>> Kyle Simpson: So that's how I typically use it as I use it to format US dollars.

[00:05:27]
[COUGH] But that print amount function is a utility that I can repeat multiple times. And imagine how much more useful it would be if, instead of just one statement, if I had 3 or 4 or 10 or 20 or 100 statements, that were logically connected together. If it took five different things to do to print out my amount, I would put all five of those in a function and then I would only be repeating the function call rather than repeating all of its contents over and over again.

[00:05:57]
So that's our primary benefit to a function, is being able to take a block of statements and collect it together into a repeatable named label, if you will.
>> Kyle Simpson: So, little 60-second homework, declare yourself a function. Put a couple of statements in it. Whatever statements you want, like assignment statements or whatever.

[00:06:22]
And repeat it a couple of times in your console.
>> Kyle Simpson: You might have called your function foo like I'm in the habit of doing, and that might take a = a * 2 and a = a + 3. So we're gonna multiply it by 2, and then add 3 to it.

[00:06:46]
Those are my two statements. Now if I start off with an a = 10 and I call foo once and then I console.log(a), what would I be expecting the output of this to be? Hopefully, you're awake enough to do some basic math here, a [COUGH] starts out as 10.

[00:07:07]
The first time I call foo, it's going to say 10 times 2. So now a is gonna be 20, and then we're gonna add 3 to it. So now a is gonna be equal to 23. So we'd expect it to print out the value 23. Now, if I call foo two more times, and then I print out a again, I'll spare you the mental acrobatics.

[00:07:32]
Let's just run it, and let's see what happens.
>> Kyle Simpson: So we know this one's gonna print out 23. This next one, what's it gonna print out? 101,
>> Kyle Simpson: So it was 23 times 2, which was 46 plus 3 was 49. And then 49 times 2 is 98 plus 3 is 101, question?

[00:08:07]
Question was about putting our functions before our variables like, did it matter if I did that or I did that? No difference to JavaScript. It goes back to that topic that we skirted by earlier, the topic of hoisting, the topic of lexical scope. [COUGH] Scope and Closures book covers it in depth.

[00:08:27]
The Advanced JavaScript training covers it in depth, but for our purposes, you can put declarations in any place in your program. I typically put all my declarations at the top of my programs. I put all my functions at the top and then I put all of my variables, that's my preferred style.

[00:08:41]
But as long as all your variables are at the top, you won't have any surprises. As long as all your declarations are at the top, you won't have any surprises.
>> Speaker 2: You consistently do that, it makes it easier to maintain the program later.
>> Kyle Simpson: It's generally a good rule to have a consistent style, whatever it is.

[00:08:58]
If your style is to put your functions at the bottom and your variables at the top, that's fine, But it's a good idea to always be consistent with that in your program. Okay, now functions can also receive what are called parameters. So here you'll notice I didn't receive any parameter, but what if I received a parameter?

[00:09:21]
If I had a parameter called b that becomes a variable that's accessible to me inside of the function. So I could take this value right here, and instead of it being the literal value 3, I can have it to be the variable b. So when I run this function now, its behavior is partially dependent on what value I pass in.

[00:09:44]
Does everybody see that? If I pass in a different value of b, I get a different result out. Let's try it. If I start out with a = 10, and I say foo(3), and then I say console.log(a), what are we expecting?
>> Kyle Simpson: Same thing as before, we'd expect 23, right, a went from 10 to 20, and then we added 3 to it and it became 23.

[00:10:14]
But what happens if I put in 100 here?
>> Kyle Simpson: Now we're expecting 120. So everybody see that? So what I pass into my function changes its behavior because there's a parameter that I'm passing in. By the way, a little nuance. It's not a big deal, but terminologies, I think if you're learning things, it's important to learn correct terminology.

[00:10:39]
When we call the function here, we are passing in what's called an argument.
>> Kyle Simpson: So you can have one or more arguments that you pass into a function. But when we declare the function, and we have these names, like I can say b and bar and zaz and whatever, these variables here are called parameters.

[00:11:05]
So in other words, there's a match, a one to one match between an argument that gets passed in and the parameter in that position. A lot of people use arguments and parameters interchangeably as meaning the same thing because they get assigned to each other so it seems like they could be considered the same thing.

[00:11:24]
To be completely specific on terminology, it's an argument when you pass it in, it's a parameter when you declare it. So this parameter b that we've got, got assigned to the argument 100, and then we used that parameter as a variable and we printed it out. So, let's try this again.

[00:11:46]
If I said foo(5) and foo(25) and foo(100), so I called foo three different times with three different variables, all accumulating my results into this a. What's my end result gonna be?
>> Kyle Simpson: My end result,
>> Kyle Simpson: The suspense is killing me, 250.
>> Kyle Simpson: Is there a question?
>> Speaker 3: Asking about passing a function as a parameter of another function?

[00:12:26]

>> Kyle Simpson: [COUGH] So, yes you can, and then the next question that was asked might be slightly misleading, or the next answer that was given might be slightly misleading. So, let me just quickly divert into that. If I called foo, let's say I had two different functions here. And it doesn't matter what's in bar right now.

[00:12:48]
If I said foo and I gave it the name bar, I passed in bar, what I'm doing is getting the value that is currently in bar. What is the value that's currently in bar? It's a function, it's a function value. So I'm passing the function as an argument and it's getting assigned to the parameter b.

[00:13:11]
So if I said + b here, what is b? b is a function, which that's not really what we want, we wanted the thing to be called. I could call it here, and whatever it returned, I'd get that value. But if you pass a function as a value, it's just a function.

[00:13:29]
If you call it, then what it returns is what gets passed in as the argument. So there's the difference between passing a function and passing the result of a function call.
>> Kyle Simpson: So hopefully, that clears up the questions that were happening and that are being asked in the chatroom.

[00:13:53]

>> Kyle Simpson: Okay,
>> Kyle Simpson: One last detail on this function. Let me back up. One last detail on those functions. These functions can return values as well. They can pass in values, they can return values. So if I said, return a / 2.
>> Kyle Simpson: If I say var a = 10 [COUGH] and I call foo(3), we know a is going to become what?

[00:14:29]

>> Kyle Simpson: It's 23, right? But what if we took that return value and assigned it to another variable?
>> Kyle Simpson: You see when I invoke foo, it's going to run but then it's going to return me a different value. In this case, it's gonna compute 23 divided by 2 which is,

[00:14:52]

>> Kyle Simpson: 11.5, [LAUGH] so 11.5 is the thing that's gonna come back and get assigned into the variable b. So if I say console.log(b), I'm expecting here 11.5. So if we take that program and put it into our console, we're expecting both 23 and 11.5 to be printed out.

[00:15:22]
And in fact, that's what we get.
>> Speaker 2: So in the second example, what does it do with variable a? Is the variable a left alone?
>> Kyle Simpson: Here we're not assigning to anything, we're computing something and returning it. Here, we are assigning so we're making changes to a variable.

[00:15:40]
We're actually having outside side effects on that variable.

