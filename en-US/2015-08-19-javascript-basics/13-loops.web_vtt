WEBVTT

1
00:00:00.000 --> 00:00:03.886
[MUSIC]

2
00:00:03.886 --> 00:00:06.316
&gt;&gt; Kyle Simpson: Conditionals are how
you make decisions in programs and

3
00:00:06.316 --> 00:00:07.820
they're incredibly important.

4
00:00:09.060 --> 00:00:11.930
They show up in more places
than just the if statement.

5
00:00:11.930 --> 00:00:15.550
The if statement is the most common
place that you see a conditional.

6
00:00:15.550 --> 00:00:17.610
But there's other places
that conditionals are used.

7
00:00:17.610 --> 00:00:22.290
For example, I mentioned earlier
loops like the while loop.

8
00:00:22.290 --> 00:00:27.400
The while loop tests
this as a conditional,

9
00:00:27.400 --> 00:00:28.750
the same way an if statement does.

10
00:00:28.750 --> 00:00:30.730
And it tests it every time.

11
00:00:30.730 --> 00:00:33.860
It's gonna keep repeating itself until

12
00:00:33.860 --> 00:00:37.028
the thing tests false.
&gt;&gt; Kyle Simpson: So

13
00:00:37.028 --> 00:00:40.880
this brings us now into
a discussion of loops.

14
00:00:40.880 --> 00:00:45.280
And here's one of those places where,
when I describe to you what a loop does,

15
00:00:45.280 --> 00:00:49.440
it may be slightly conceptually different
than what you've thought of before.

16
00:00:49.440 --> 00:00:55.634
So a lot of people intuit
that a loop does something

17
00:00:55.634 --> 00:01:00.954
like If I say a while
a is greater than 10.

18
00:01:00.954 --> 00:01:05.838
A lot of people interpret
this as saying that it is,

19
00:01:05.838 --> 00:01:11.291
while the thing,
let me try to figure out how to say this,

20
00:01:11.291 --> 00:01:15.740
when the thing becomes false,
stop doing it.

21
00:01:17.850 --> 00:01:22.029
Or another way of looking at it is,
while the thing is true, keep doing it.

22
00:01:23.580 --> 00:01:27.250
And those two conceptual ways, that's
two different sides of the same coin.

23
00:01:27.250 --> 00:01:30.750
The end result is the same,
but the way you think about it

24
00:01:30.750 --> 00:01:35.230
can actually be different depending on
the different loop forms that you try.

25
00:01:35.230 --> 00:01:41.530
So there's a loop form called the for
loop, and this is a highly compressed

26
00:01:41.530 --> 00:01:45.810
loop and I'm gonna show you the version,
it's a highly compressed syntax form.

27
00:01:45.810 --> 00:01:48.840
I'm gonna show you the three
parts to how the for loop works.

28
00:01:48.840 --> 00:01:52.910
But then I'm going to show you
conceptually how the for loop works.

29
00:01:52.910 --> 00:01:59.720
So this for loop,
I can have a thing like a = 5.

30
00:01:59.720 --> 00:02:02.380
That first clause,

31
00:02:02.380 --> 00:02:06.150
this first expression is what we
call the initialization expression.

32
00:02:09.880 --> 00:02:11.440
The second clause in a for

33
00:02:11.440 --> 00:02:16.790
loop is what we call the conditional
expression or the test expression.

34
00:02:16.790 --> 00:02:18.700
So a less than 10.

35
00:02:22.020 --> 00:02:24.260
Every time I run the loop,
I'm gonna do that conditional.

36
00:02:25.300 --> 00:02:28.290
And if that conditional is still true,
I'm gonna keep going, and

37
00:02:28.290 --> 00:02:29.970
if it's no longer true, I'm gonna stop.

38
00:02:31.700 --> 00:02:33.680
The third and final clause in a for

39
00:02:33.680 --> 00:02:38.400
loop declaration is what
we call the update clause.

40
00:02:38.400 --> 00:02:42.893
So I can say I can say
something like a = a + 1,

41
00:02:42.893 --> 00:02:47.520
which is to,
say increment it by one each time.

42
00:02:50.850 --> 00:02:56.300
A lot of people shorten a = a + 1 to this
shorthand operator, the ++ operator.

43
00:02:56.300 --> 00:03:00.610
It's gonna accomplish the same goal here.

44
00:03:00.610 --> 00:03:03.920
It's gonna update a, or
it's gonna increment a by 1 each time.

45
00:03:03.920 --> 00:03:09.030
I'll leave it in the more verbose form,
just so we don't lose track.

46
00:03:09.030 --> 00:03:12.880
So if I make that for loop,
let's think about what it's going to do.

47
00:03:12.880 --> 00:03:15.940
It's gonna start a at the value 5.

48
00:03:15.940 --> 00:03:19.740
And each time the loop finishes,
it's gonna update a by 1.

49
00:03:19.740 --> 00:03:25.050
And if a is still less than 10, it's gonna
do the loop again and again and again.

50
00:03:28.600 --> 00:03:35.340
So if the statement inside of here was
a console.log statement, try that.

51
00:03:35.340 --> 00:03:40.050
Try putting that into your browser,
into your console.

52
00:03:47.581 --> 00:03:49.303
&gt;&gt; Kyle Simpson: You'll notice that I

53
00:03:49.303 --> 00:03:54.752
printed up the value 5, the value 6,
the value 7, the value 8,

54
00:03:54.752 --> 00:03:59.359
and the value 9, but
I didn't print out the value 10.

55
00:03:59.359 --> 00:04:04.261
And the reason I didn't is that
when a got to 10, that is,

56
00:04:04.261 --> 00:04:10.320
after this loop iteration,
I updated the a value by adding 1 to it.

57
00:04:10.320 --> 00:04:12.890
And when I did that, a became 10.

58
00:04:12.890 --> 00:04:14.370
Is 10 less than 10?

59
00:04:15.510 --> 00:04:16.060
Clearly, no.

60
00:04:17.080 --> 00:04:18.800
So that's when we stop the loop.

61
00:04:22.260 --> 00:04:24.330
Try to let that set in for a moment.

62
00:04:24.330 --> 00:04:30.440
Essentially, we were waiting for something
to tell us when to stop the loop,

63
00:04:30.440 --> 00:04:35.250
and the thing that told us when to
stop the loop is when a got too big.

64
00:04:35.250 --> 00:04:38.191
Yeah.
&gt;&gt; Speaker 2: You said the a = a + 1 is

65
00:04:38.191 --> 00:04:40.886
like the update something.
&gt;&gt; Kyle Simpson: It's called

66
00:04:40.886 --> 00:04:41.830
the update clause.
&gt;&gt; Speaker 2: Okay,

67
00:04:41.830 --> 00:04:43.960
what are the two clauses?
&gt;&gt; Kyle Simpson: The first one is

68
00:04:43.960 --> 00:04:45.560
called the initialization clause.

69
00:04:47.560 --> 00:04:52.100
The second one is called the test
clause of the conditional clause,

70
00:04:54.190 --> 00:04:56.571
and the third one is called
the [COUGH] update clause.

71
00:04:57.710 --> 00:05:01.350
In for loops,
all three of these clauses are optional.

72
00:05:03.550 --> 00:05:07.910
That is, you can have all three or
any combination of two of them, or

73
00:05:07.910 --> 00:05:13.282
just one of them, or none of them.
&gt;&gt; Kyle Simpson: In other words,

74
00:05:13.282 --> 00:05:15.970
you could write,
although it would be silly.

75
00:05:15.970 --> 00:05:19.930
You could write for, and

76
00:05:19.930 --> 00:05:24.395
then put a block on it and
leave those clauses out.

77
00:05:24.395 --> 00:05:29.076
You wouldn't do any initialization,
you wouldn't do any testing, and

78
00:05:29.076 --> 00:05:31.121
you wouldn't do any updating.

79
00:05:31.121 --> 00:05:32.391
But it'd still run.

80
00:05:32.391 --> 00:05:36.200
In this case,
this is a loop that's gonna run forever.

81
00:05:37.500 --> 00:05:42.145
Why is it gonnarun forever?
&gt;&gt; Kyle Simpson: This is

82
00:05:42.145 --> 00:05:45.690
the major conceptual observation I
want to make out of the section.

83
00:05:45.690 --> 00:05:47.130
Why would this loop run forever?
&gt;&gt; Speaker 3: The condition will

84
00:05:47.130 --> 00:05:49.770
never be met.
&gt;&gt; Kyle Simpson: It's because

85
00:05:49.770 --> 00:05:51.690
a conditional would never fail.

86
00:05:51.690 --> 00:05:53.310
That's why, okay.

87
00:05:53.310 --> 00:05:57.420
So this loop is not running because
a conditional always stays true.

88
00:05:58.790 --> 00:06:02.810
It's running forever because there's
never a conditional that fails.

89
00:06:05.082 --> 00:06:06.439
&gt;&gt; Kyle Simpson: Let me say that again,

90
00:06:06.439 --> 00:06:08.296
this loop would run forever but

91
00:06:08.296 --> 00:06:12.350
it doesn't run forever because
a conditional is always true.

92
00:06:12.350 --> 00:06:15.790
Like for example,
if my test was the value true.

93
00:06:17.000 --> 00:06:19.697
This one's gonna run forever because
the condition's always, always,

94
00:06:19.697 --> 00:06:20.520
always true, right?

95
00:06:22.530 --> 00:06:26.970
This one, there is no condition and
it's still gonna run forever.

96
00:06:28.590 --> 00:06:30.110
So why does it run forever?

97
00:06:30.110 --> 00:06:32.410
Conceptually, the reason it runs forever,

98
00:06:32.410 --> 00:06:36.880
is cuz there is no conditional that fails,
that tells it to stop running.

99
00:06:38.734 --> 00:06:42.750
Okay, this is different than how almost
all developers that I come across

100
00:06:42.750 --> 00:06:44.660
think about what a loop really means.

101
00:06:44.660 --> 00:06:53.720
So, what I wanna illustrate is that
this loop compared to this loop,

102
00:06:53.720 --> 00:06:57.620
the difference is that we filled
in a clause here that can fail.

103
00:06:57.620 --> 00:06:59.890
It doesn't have to fail.

104
00:06:59.890 --> 00:07:03.094
What would happen if I said a =

105
00:07:03.094 --> 00:07:07.590
6?
&gt;&gt; Kyle Simpson: Would

106
00:07:07.590 --> 00:07:09.110
this loop run forever?
&gt;&gt; Speaker 4: Yes.

107
00:07:13.010 --> 00:07:13.562
&gt;&gt; Kyle Simpson: Of course,

108
00:07:13.562 --> 00:07:16.323
it would run forever because
the first time we would run it,

109
00:07:16.323 --> 00:07:19.710
we would set it to 6, and we'd print
out 6, and then we'd add 1 to it.

110
00:07:19.710 --> 00:07:25.390
And then we'd say, is 7 less than 10?

111
00:07:25.390 --> 00:07:29.510
Of course it is, so we'd run the loop
again, which sets a back to 6,

112
00:07:29.510 --> 00:07:32.370
and we print 6 again, update it to 7.

113
00:07:32.370 --> 00:07:34.710
7's less than 10, and
we just keep going forever and ever.

114
00:07:34.710 --> 00:07:36.610
So this loop would run forever.

115
00:07:36.610 --> 00:07:39.200
Because there's no way for
this to ever fail.

116
00:07:40.800 --> 00:07:42.930
We're forcibly making it so
that thing can't fail.

117
00:07:42.930 --> 00:07:46.800
So that loop that I've written there,

118
00:07:48.100 --> 00:07:51.840
if we're trying to think about
the conceptual of what a loop means,

119
00:07:51.840 --> 00:07:56.740
I think it's more appropriate not to say
a loop runs while something is true.

120
00:07:56.740 --> 00:08:00.715
I think it's more appropriate to say
a loop runs until something is false,

121
00:08:00.715 --> 00:08:03.470
until something stops it from running.

122
00:08:03.470 --> 00:08:07.508
Its natural state is to go forever
until something tells it, stop going.

123
00:08:07.508 --> 00:08:13.177
Okay, and the way I could write
that is with a while loop.

124
00:08:13.177 --> 00:08:15.234
A while true loop.

125
00:08:15.234 --> 00:08:17.510
Would that loop run forever?

126
00:08:20.050 --> 00:08:22.370
Unless something stopped it,
that loop would run forever, right?

127
00:08:23.760 --> 00:08:27.250
There are ways to stop the loop which
we're gonna show here in a moment, but

128
00:08:27.250 --> 00:08:32.239
let's conceptually think about
how to make this loop that's

129
00:08:32.239 --> 00:08:34.370
on top using only a while loop.

130
00:08:35.420 --> 00:08:37.708
So we need an up,
we need an initialization clause right,

131
00:08:37.708 --> 00:08:39.168
so we could do that at the beginning.

132
00:08:39.168 --> 00:08:42.460
We could say a = 5.

133
00:08:42.460 --> 00:08:45.670
Then we need a test clause
to let us know when to stop.

134
00:08:46.940 --> 00:08:53.500
So one way of writing that test clause
is to invert the a less than 10.

135
00:08:53.500 --> 00:09:01.230
I can say if negation of a less than 10,

136
00:09:01.230 --> 00:09:06.580
which looks really weird and complicated.

137
00:09:06.580 --> 00:09:11.310
So I could say if a greater than 10,

138
00:09:11.310 --> 00:09:13.155
actually, the negation is greater than or
equal to 10.

139
00:09:13.155 --> 00:09:17.943
Does everybody see why that is my
condition that would let me know it's time

140
00:09:17.943 --> 00:09:23.290
to stop?
&gt;&gt; Kyle Simpson: So how do I stop a loop?

141
00:09:24.310 --> 00:09:31.534
The break statement.
&gt;&gt; Kyle Simpson: So

142
00:09:31.534 --> 00:09:35.020
I'm gonna test to see whether or
not I should stop the loop,

143
00:09:35.020 --> 00:09:40.060
and if I do wanna stop the loop,
I call break, which stops it immediately.

144
00:09:40.060 --> 00:09:44.460
If I don't wanna stop the loop,
what do I do next?

145
00:09:45.470 --> 00:09:48.533
Let's take out that a = 6 part because
we don't think want that there.

146
00:09:48.533 --> 00:09:52.484
What do we do next?
We console.log.

147
00:09:55.657 --> 00:09:56.218
&gt;&gt; Kyle Simpson: (a), and

148
00:09:56.218 --> 00:09:57.850
what's the very last thing we do?

149
00:09:57.850 --> 00:10:02.000
a = a + 1.

150
00:10:03.140 --> 00:10:11.665
We do the update clause.
&gt;&gt; Kyle Simpson: This,

151
00:10:11.665 --> 00:10:16.290
conceptually, is how a for loop actually
works, and it's really how all loops work.

152
00:10:17.980 --> 00:10:20.560
They run until something
tells them to stop running.

153
00:10:22.690 --> 00:10:26.055
Now I am not endorsing
writing your loops like that.

154
00:10:26.055 --> 00:10:27.970
&gt;&gt; [LAUGH]

155
00:10:27.970 --> 00:10:28.820
&gt;&gt; Kyle Simpson: That loop is more

156
00:10:28.820 --> 00:10:33.550
complicated to understand if you
already understand how loops work.

157
00:10:33.550 --> 00:10:37.320
The only thing that I'm doing here
is to illustrate to you the concept

158
00:10:37.320 --> 00:10:39.660
that a loop runs until something
stops it from running.

159
00:10:41.620 --> 00:10:44.660
There's lots of ways to
make a loop stop running.

160
00:10:44.660 --> 00:10:49.840
You can throw an error, you can break,
you can call continue to an outside label.

161
00:10:49.840 --> 00:10:52.100
There's lots of ways to stop
a loop from running, but

162
00:10:52.100 --> 00:10:56.990
however you stop a loop from running,
that's the same thing as the test

163
00:10:56.990 --> 00:11:04.161
failing.
&gt;&gt; Speaker 5: Can a person put

164
00:11:04.161 --> 00:11:08.140
a semicolon on the end of the incremental?
&gt;&gt; Kyle Simpson: You're not

165
00:11:08.140 --> 00:11:08.946
supposed to.
&gt;&gt; Speaker 5: Okay.

166
00:11:08.946 --> 00:11:13.444
&gt;&gt; Kyle Simpson: It's not allowed.

167
00:11:13.444 --> 00:11:20.530
[COUGH] So, once you learn the concept
of what it looks like on lines 5 to 12.

168
00:11:20.530 --> 00:11:24.740
Now, writing the for loop in a more
compact fashion is much more attractive.

169
00:11:27.150 --> 00:11:29.970
I think the reason, the thing that I'm
trying to get across here is that a lot of

170
00:11:29.970 --> 00:11:32.100
people skip to writing
these loops with for

171
00:11:32.100 --> 00:11:35.850
loop syntax without understanding
how it actually works.

172
00:11:35.850 --> 00:11:40.240
And then you run into off by one errors
and all kinds of other things like that.

173
00:11:40.240 --> 00:11:43.780
So, I think it's better to start
by thinking about the concepts as

174
00:11:43.780 --> 00:11:44.540
expressed here.

175
00:11:45.790 --> 00:11:48.770
Because they illustrate what
to do with the for loop.

176
00:11:49.770 --> 00:11:50.540
What do we do first?

177
00:11:50.540 --> 00:11:51.475
We say a = 5.

178
00:11:51.475 --> 00:11:53.340
What do we do next?

179
00:11:53.340 --> 00:11:57.740
We start running and we're gonna keep
going forever, so that's the while true.

180
00:11:57.740 --> 00:11:58.810
What do we do next?

181
00:11:58.810 --> 00:12:00.640
We check to see if this is false.

182
00:12:00.640 --> 00:12:02.270
Which is another way of inverting it.

183
00:12:02.270 --> 00:12:04.650
We can say a greater than or equal to 10.

184
00:12:04.650 --> 00:12:07.999
If it's false, then we stop,
we don't do the loop.

185
00:12:09.000 --> 00:12:12.650
If it's true, we keep going,
we do the loop body, and

186
00:12:12.650 --> 00:12:16.970
finally, after the loop is successfully
processed through, then we update.

