[00:00:00]
>> [MUSIC]

[00:00:03]
>> Kyle Simpson: One of the items stated that we wanted to set ourselves up a few variables and I indicated that some of them should be constants. If you have the advantage of using a ES6 which is at the moment going to require using a transpiler, it's a tool that converts your code so it'll run in browsers.

[00:00:20]
So, it's possible to do and a lot of people are doing it. I encourage it if you're writing JavaScript, but might be slightly overkill for what we're talking about. So either a var here or a const if you were using ES6 would have worked. If we put a var here instead of a const, the only difference is we're not gonna get an error if we were to accidentally change the variable.

[00:00:39]
But by convention, if you say var and you have an uppercase variable like that, by convention people know don't ever assign to a thing. So it's the difference between a convention that signals what you want versus the language actually enforcing it. So even without the enforcement we can still get a long way.

[00:00:59]
So you could have taken these as vars. Of course, my bank balance is something that you would typically think of as changing. Biggest reason why make this a variable instead of a constant, it's a constant for the purposes of our program, that is that we don't change our bank balance.

[00:01:15]
But the biggest reason why I'd make it a variable is because it might be the kind of thing that you'd want to prompt the user for. So, if you were gonna try the prompting, you wanna do it and it's an important note, by the way, that constants have to have an assignment.

[00:01:30]
So you can't say something like, if you're doing a real const, you can't say something like const foo. Because it doesn't have an assignment and it could never be given an assignment, so there has to be an explicit thing that's getting assigned to it.
>> Kyle Simpson: All right, so here's my bank balance that would be considered a variable.

[00:01:50]
Now my amount is going to be kind of my running total, if you will, of how much I've spent. We'll come back to the functions in a minute. But the main meat of what I wanna do is I wanna loop through, as I hinted in that description. I wanna loop through and keep doing something for as long as I'm able to do it.

[00:02:08]
So basically, I'm figuring out what my purchase amount is and I am being somewhat irresponsible. I'm just gonna keep spending until I don't have any more in my bank account, right? So here I'm gonna say, why all the amount is less than my bank balance, okay? So amount = amount + PHONE_PRICE is buying a new phone and you notice my usage of comments here.

[00:02:32]
In this comment I didn't say, add the phone price to my current amount cuz that would be repeating what the code already said. This was more a why or a how kind of an explanation or sort of a meta explanation, so I'm indicating here that you're buying a new phone.

[00:02:47]
Now, we want to know if we can afford the accessory? I indicated in that problem statement that you would want to be able to purchase an accessory like an extra charge or whatever. You want to purchase the phone accessory for each phone assuming that you haven't gone over a certain threshold of your spending limit.

[00:03:05]
So we had a threshold that we declared is $200 and after that we might buy phones but we won't buy anymore accessories, okay? So just a simple little expression in code of how we might be thinking about things in our mind. So as long as the running total amount is less than our spending threshold, we do wanna add in the accessory price.

[00:03:26]
Otherwise we would just keep going until the amount went greater than the bank balance.
>> Kyle Simpson: Now, we don't wanna forget to pay the government, [LAUGH] so we now say amount = amount + and here I call a function, I say calculateTax. So that's a set of things that I might do only once or I might do multiple times, in this program, I'm only doing it once but there's still value in putting it in a function because this code is more understandable than if I drop that same code directly in here.

[00:04:09]
Because the name of the function explains something about what I'm doing. I'm taking advantage of the fact that I can name this function something like calculateTax, whereas if I took just amount times 1.0 or whatever I did, that would look less reasonable or it would make less sense.

[00:04:26]
So another virtue of using functions is that you could put in a name for that section of code that makes the code more understandable. So our calculateTax, we take in an amount and we multiply it by the TAX_RATE, so TAX_RATE being set up as 0.08. So this tax amount is just the tax, $12 or $8 or whatever it would mean, [COUGH] and we add that to our existing amount.

[00:05:00]
And now we then say your purchase amount, so this is like the cash register, your purchase amount and I call formatAmount and the reason for that is I wanted to print out a nicely printed US dollar figure. So we're going to put the $ in front of it and then we want to call that to toFixed method to round it to a certain number of decimal places.

[00:05:23]
So I'm calling that formatAmount and then finally as kind of an extra little flourish here, I would ask, did I go over my bank balance and if I did, I'm gonna print out, you can't afford this. Now the way I setup the program, of course, I've gone over my bank balance because I didn't stop until I already went over it and then I had to add tax on, okay?

[00:05:46]
So, thankfully I'm preventing myself from completely running my bank account down to zero. But that just illustrates some of these concepts that we talked about, you can see that there are conditionals to help us make a decision, should we do something or not? In this case, the decision is whether or not we print something.

[00:06:05]
Here the conditional is whether or not we do something extra inside of this loop that's happening. Here, the conditional is deciding if it's time to stop the loop or if we should keep going. These functions are things that we can call one or many times, they're a collection of things we can pass values in as we are doing, we can pass arguments in that get set to these parameters.

[00:06:26]
We can also take advantage of return values to return things out. You'll notice that these two functions don't make any changes to the variables outside of them. And that's actually an intentional design decision on my part rather than me saying in here instead of saying return, I could have said something like, amount = amount + the TAX_RATE, I could have done that.

[00:06:49]
But if I'd done it that way, I'd be making what's called a side effect of a function call. Which would work, we saw several examples of that earlier with the foo and bar functions. But it's typically considered to be a less graceful form of programming for your functions to have those side effects.

[00:07:06]
You typically will think about a function as being entirely self-contained. You pass in a value or multiple values if you need to, you get one return value out. And everything that happens inside of the function is sort of self-contained and you don't make any changes outside. And you try not to rely upon stuff outside of the function as well, although there are cases where it's inconvenient to pass in everything.

[00:07:29]
So, these are not hard and fast rules but just stylistically you typically wanna design your functions to have as little impact to the outside world as possible. There's one big caveat to that which is not a topic that we're gonna go heavily into right now, but there's one caveat to that and that's the caveat that closure is when you intentionally want for a function to remember stuff outside so that it can keep track of its state.

[00:07:54]
So there is a design style or a feature in JavaScript called closure, and we intentionally do that sort of stuff. And I cover that in basic detail in chapter two of the book. So you can go further from this class and read about a basic expression of how closure works in chapter two.

[00:08:11]
And I also have a full book about closure, the Scope & Closures book is really kind of all about that. So there's plenty more to go if you wanna learn more about how that works, we definitely won't worry too much about it. But there are places, just advice to say there are places where you intentionally do decide to have a function rely on outside variables.

[00:08:29]
Yeah, let's see the question is.
>> Speaker 2: 2, that just came in there at the bottom.
>> Kyle Simpson: Should have function always return a value even if you don't have return in the function. Functions only return an explicit value if you actually say return, normal functions that is. If you call a function and you do not have a return, it sort of implies that there is a return undefined at the end.

[00:08:56]
But there's always, a result from a function call is either that implied undefined, or whatever you explicitly return. And the question of should a function always return? There are many functions that I write that it doesn't make sense for them to have return value. So there's no should it have a return or not.

[00:09:16]
It should have a return if that makes sense. In this case, it makes sense for both of my functions to compute something and return a value. Sometimes you just have a function doing something, that's a function that maybe has a side effect like it's calling something or whatever or so.

[00:09:29]
There's plenty of places where return values don't make sense. Then the next question was, in the program the amount is always going to be greater than the bank accounts, so both the console logs will be printed, why are we doing it? It's just a simple demo, I wanted to show you that there's a way to decide whether we're looping.

[00:09:48]
We could have been more nuanced about it and said, well, amount is less than bank balance minus threshold. Or something like we could have said, I wanna spend until I have spent to where my threshold is under $100 left in my bank account. We could have done it that way and then of course, but the point here was just to illustrate the different ways that conditionals can be woven together in our program.

[00:10:16]
The next question, why are you returning amount.toFixed? If you make purchase more than 1K or a 100, I guess you meant, how the amount will be printed? So it's important to understand toFixed( 2 ), that indicates decimal places not digits in your number. So, this only means that I wanna round and pad my decimals to two decimal places.

[00:10:46]
The amount on the left hand side, if I had gone all the way up to $5,000 or $5 million or whatever, we're gonna have as many digits on the left hand side. There's another method called toPrecision if you want to actually restrict the number of digits that show up in a number.

[00:11:00]
For those of you that had science classes, you know about the difference between precision. And not so, there's a toPrecision method that can be used for that purpose. But here, toFixed is only dealing with the number of decimal places that we get out.

