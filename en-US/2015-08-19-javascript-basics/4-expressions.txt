[00:00:00]
>> [MUSIC]

[00:00:04]
>> Kyle Simpson: Now statements are comprised of phrases like they are in English and these phrases are what we call expressions. So going back to this a = b * 2. There are essentially several expressions going on. The first expression is that literal value. A literal value expressed is a literal value expression, okay?

[00:00:27]
And then there's an identifier expression which is the character b. And then we take b * 2, we put those things together. There's an operator in between and two things on either side, and that is called an arithmetic expression, in this case a multiplication expression. So you can see there was an inner expression, an outer expression and I could sort of make that more obvious if I used the parentheses and sort of a grouping thing.

[00:00:53]
So I'm gonna use parenthesis to illustrate this idea of where the expressions are. So there's an expression here, the parentheses wrapping around (2). There's an expression here, the parentheses wrapping around (b). There's another set of parentheses that wrap around this expression which is a mathematic and arithmetic expression, a multiplication expression.

[00:01:14]
And there's one more expression, which is called an assignment expression. So all of this stuff, you notice I did not include the semicolon, all of that stuff is both an expression and a statement. It's an expression from here to here. And then it's the last thing to go out, there's nothing else outside of it.

[00:01:34]
So it's also a statement. Does that make sense? There's an expression, an expression, an expression and finally we get to what we call an expression statement where they become one in the same. So this grouping can kind of help you visualize where those things are and that's actually a good practice.

[00:01:51]
So that's the first thing that we'll try to do. I'm going to write a slightly more complex statement. And don't let it intimidate you if you're just starting out programming. But just from the perspective of trying to get your feet wet with understanding the difference between statements and expressions, kind of like when your English teacher had you go up on the board and underline all the verbs and circle all the nouns or whatever, I'm gonna have you do that with this.

[00:02:12]
I'm gonna write a slightly more complex statement, I'm literally just gonna make it up on the fly so it might make no sense at all. But I'm gonna write a statement and then I want you to take that same statement and put in those parenthesis like I just did.

[00:02:23]
Identifying all the different places that there are expressions. So, let me just start out by saying something like.
>> Kyle Simpson: a = b * 2 +, then I'm gonna make a function call, which you haven't seen those before, and then I'm going to pass in an argument (c * 3), and there's my statement.

[00:02:51]
So, copy that down first, you can copy this in to your own code editor, you can type it into your console or something like that. It's a nonsense statement because we haven't assigned values to foo b and c yet. But just from the perspective of finding those expressions, go in and put your parenthesis or brackets or whatever if you want, but take just a moment and try to find all the different places where there are expressions and then we'll come back and solidify that.

[00:03:16]
All right, so [COUGH] hopefully you had a chance to try your hand at that. Let's see how you did, so I'm gonna walk through from the smallest to the sort of outer and identify all those different places that are expressions that make up this statement. So, because I already have a set of parentheses in here that means syntax, I'm actually gonna use brackets instead of parentheses, the square brackets.

[00:03:37]
But conceptually again we're not doing anything syntactic. What we're doing here is just identifying visually. So, I'm gonna put square brackets around all our expressions. So, here we know that we have an expression for the literal value 3. I'm not making that an array 3, I'm just identifying that thing as a 3.

[00:03:53]
We also have another expression, the value 2. And we have another expression for B. And we have another expression for A. I think in my previous example I forgot to indicate that the left hand side is also its own expression. So the left hand side is an expression, the c is an expression, the foo of course, is an expression.

[00:04:14]
So all those are sort of our first level expressions. Now let's start doing some grouping of stuff. We know that the ([c] * [3]) is an expression, it's a multiplication expression so we should put a bracket around that to identify that that is an expression. We know that this thing, we haven't really talked about what a function call is but we know that it's an inseparable unit, there is this whole thing like when we put the parentheses together with the identifier in front of it, that's called a call expression.

[00:04:41]
So there's a set of brackets that need to go around the call expression because that's one coherent unit of stuff that happens. So we've got our bracket around those, we do a little cleanup of my whitespace here so that's an expression. Now, we have kind of an interesting question to ask.

[00:04:57]
Which is, would the programming language, would the computer, think of these two things as an expression first, or would it think of these two things as an expression? Cuz we have two different operators, they're called binary operators. That's a fancy way of saying it's an operator that requires two different sides.

[00:05:18]
So it's a binary operator plus that requires one thing on the left and one thing on the right and puts them together. And then the multiplication operator is the same way. So, it can't do both of them at the same time. It's gotta do one and then the other and that leads us into a discussion of what we'd call operator precedents, okay?

[00:05:34]
Now this is not necessarily a critical set of rules that you have to learn but awareness that there is such a thing is the important part, not actually knowing each individual nuanced thing. There's a set of rules that tells the programming language how to know what to do first.

[00:05:52]
It doesn't always work in left to right fashion. Sometimes it could work from the right hand side and then move its way backwards. Now, I accidentally and literally, I just made it up, and I accidentally chose this multiplication to happen first which happens to matter because multiplication is what is said to be more precedent.

[00:06:12]
Multiplication happens before addition if there's a question as to which one should happen first, pick multiplication before addition and that's what I mean by precedence. So, we could say that this thing is an expression, because it is the thing that the computer would do first before considering what's happening on the plus.

[00:06:33]
So now if you're not getting lost in the sea of brackets, you can see that I have one expression here and I have one expression here. Those two are the binary operands, another fancy word to say the values that go into the plus operator. So now we have one more wrapping of brackets, this is getting out of hand, of course.

[00:06:52]
But we now have a wrapping around that entire thing. Now this is one big complicated evaluation to take [ [b] * [2] ] and add it to the result of calling [ [foo] ( [ [c] * [3] ] past them. So we put all of that together to be an expression value and that expression value of course then gets assigned to the left hand side, to the a variable that's over there and finally one last set of crazy brackets around the entire assignment expression.

[00:07:20]
And now we've identified all those different little pieces that nest themselves together to become what we call a statement. Of course, it looks a lot easier to read when we don't have all those brackets in, right? So if I go back to the original statement without all those crazy brackets in.

[00:07:41]

>> Kyle Simpson: We can come back to that same understanding. We can say hey, I know I need to do (c * 3) cuz that's gotta get passed in. So find out what c is currently, whatever value it is, and multiply it by 3. And then pass that into the function foo.

[00:07:54]
And again, we'll cover call expressions, what functions are, and we'll cover that in a little bit. And then whatever that valve is, add that to the value of b * 2. So compute b * 2, now I have two different things, add those together and whatever that final result is assign it into a.

[00:08:10]
By the way, the reason why operator precedence matters is that because mathematically this could mean two different things. If I was to simplify it and I was to say, 2 * 3 + 4. Mathematically it matters which one you do first, 2 * 3 + 4 is 10, 2 * 3 + 4 is 14.

[00:08:34]
So mathematically it matters and that's why this ambiguity has to be resolved by the programming language. The way we resolve that in programming languages is to understand a basic concept of operator precedence. Now, what if you were in the scenario where you wanted to sort of override that precedence.

[00:08:53]
Yeah?
>> Speaker 2: You wanted to add parenthesis.
>> Kyle Simpson: You wanted to add parenthesis. Yeah.
>> Speaker 2: And you want to add them in your code just so that you could accentuate what you're trying to do.
>> Kyle Simpson: That's exactly the point that I was going to, great segue. So if I wanted to suggest that this program should do 2 + foo the and then multiply that by b, then I could forcibly do that by putting in the parentheses.

[00:09:16]
These here are not made up syntax, made up visual things, these are actually things that matter to the program. The parentheses here says do the stuff inside of the parentheses first before working your way out. So now I have forcibly changed that rule, if you will, of precedence by forcibly saying that the plus should happen before the multiplication.

[00:09:37]
Exactly the same as in the 2 * 3 + 4. I could have done that by saying, no what I really want you to do is come up with 7 first and then multiply by 2. So those parenthesis in this case they matter, they matter to the end result.

[00:09:51]
But what if I did want the b * 2 and I didn't want the 2+? I want it to happen the same way as operator precedence. To the point that was just brought up, I can still put in a set of parentheses here. They're not necessary to the functioning of the program, they don't change the outcome of the program, it's still gonna do exactly the same thing as if I had left them out.

[00:10:17]
But here's that point that we were talking about earlier where it's this balance, this goal to try to make sure that your code is understandable. If we put something into a program that the computer doesn't care about then the only other reason for it could be that a developer cares about it.

[00:10:32]
So developer here not needing to know the rules of operator precedence, doesn't have to understand whether times or plus happens first. If all they understand is the fact that parentheses wrap together then they can process through this program and say, clearly I should do this thing first, and this thing and then add them together.

[00:10:55]
So for readability sake you would probably tend to want to put the parentheses in. Basically the takeaway here is that even if you know intricately all the rules of operator precedence, you don't always want to write a program that relies on it. Sometimes it's helpful. But sometimes it's more appropriate to add additional things to your program like in this case, an optional set of parentheses to make the code make more sense.

[00:11:23]
Question?
>> Speaker 3: My question was without the parentheses, we'll get the value of the function first or the variable b?
>> Kyle Simpson: That's a great question. So, if I didn't put this parentheses here, what's gonna actually happen? Well, the rules of operator precedence say which operator, if two different operators show up in a line like this without any other kind of grouping, it's gonna say which thing happens first.

[00:11:46]
So from a left to right perspective, the b * 2 is going to happen first before calling the foo function. If the foo function had been in the left position then the foo function would have been called and then the b * 2 would have happened. So the programming language does typically and generally move in a left to right fashion.

[00:12:07]
Meaning that something on the left is typically gonna happen before something on the right, even if we looked only at this expression right here, the b * 2 expression. We could say that the programming language will evaluate the thing on the left first before evaluating the thing on the right.

[00:12:22]
So typically it's gonna work in a left to right fashion. The only time when that is broken is if there's something like operator precedence. Or there's another related concept called associativity, which we don't need to get into, but if precedence or associativity overrides that left to right behavior, and in those cases it could force something to happen.

[00:12:39]
So, if I were to simply reverse these two.
>> Kyle Simpson: And say b+2*foo. Now we know that operator precedence is gonna say, don't, I mean we are gonna evaluate the b part first and evaluate the 2 part first. But here we're going to call this foo function before we add it to b, because we've got to compute that whole expression expression first.

[00:13:08]
So operator precedence can work to sort of tweak the way this normal left or right processing happens. But overall you still see that even inside of each expression, it still works in a left to right fashion. So, it's a great question. Yeah, I like what's said in the chat room, be kind to your future more elderly self, that's definitely true.

[00:13:31]

>> Speaker 4: I probably getting way ahead of myself but is there any difference between specifying as 2 or 2.0, does it matter?
>> Kyle Simpson: In some languages it matters, in JavaScript it doesn't. In JavaScript 2 and 2.0 are all the same value because there is just one number value.

