WEBVTT

1
00:00:00.000 --> 00:00:04.362
[MUSIC]

2
00:00:04.362 --> 00:00:07.783
&gt;&gt; Kyle Simpson: Now statements
are comprised of phrases like they are in

3
00:00:07.783 --> 00:00:11.570
English and these phrases
are what we call expressions.

4
00:00:11.570 --> 00:00:14.750
So going back to this a = b * 2.

5
00:00:15.960 --> 00:00:20.170
There are essentially
several expressions going on.

6
00:00:20.170 --> 00:00:22.780
The first expression
is that literal value.

7
00:00:22.780 --> 00:00:27.282
A literal value expressed is
a literal value expression, okay?

8
00:00:27.282 --> 00:00:30.010
And then there's an identifier
expression which is the character b.

9
00:00:30.010 --> 00:00:35.800
And then we take b * 2,
we put those things together.

10
00:00:35.800 --> 00:00:39.150
There's an operator in between and
two things on either side, and

11
00:00:39.150 --> 00:00:45.500
that is called an arithmetic expression,
in this case a multiplication expression.

12
00:00:45.500 --> 00:00:49.170
So you can see there was an inner
expression, an outer expression and

13
00:00:49.170 --> 00:00:52.390
I could sort of make that more
obvious if I used the parentheses and

14
00:00:52.390 --> 00:00:53.380
sort of a grouping thing.

15
00:00:53.380 --> 00:00:58.480
So I'm gonna use parenthesis to illustrate
this idea of where the expressions are.

16
00:00:58.480 --> 00:01:02.340
So there's an expression here,
the parentheses wrapping around (2).

17
00:01:02.340 --> 00:01:05.940
There's an expression here,
the parentheses wrapping around (b).

18
00:01:05.940 --> 00:01:09.240
There's another set of parentheses
that wrap around this expression

19
00:01:10.290 --> 00:01:14.800
which is a mathematic and arithmetic
expression, a multiplication expression.

20
00:01:14.800 --> 00:01:18.710
And there's one more expression,
which is called an assignment expression.

21
00:01:18.710 --> 00:01:22.070
So all of this stuff, you notice
I did not include the semicolon,

22
00:01:22.070 --> 00:01:26.630
all of that stuff is both
an expression and a statement.

23
00:01:26.630 --> 00:01:30.160
It's an expression from here to here.

24
00:01:30.160 --> 00:01:34.910
And then it's the last thing to go out,
there's nothing else outside of it.

25
00:01:34.910 --> 00:01:36.850
So it's also a statement.

26
00:01:36.850 --> 00:01:37.590
Does that make sense?

27
00:01:37.590 --> 00:01:41.640
There's an expression, an expression,
an expression and finally we get to

28
00:01:41.640 --> 00:01:45.520
what we call an expression statement
where they become one in the same.

29
00:01:45.520 --> 00:01:49.251
So this grouping can kind of help you
visualize where those things are and

30
00:01:49.251 --> 00:01:51.094
that's actually a good practice.

31
00:01:51.094 --> 00:01:53.138
So that's the first thing
that we'll try to do.

32
00:01:53.138 --> 00:01:55.940
I'm going to write a slightly
more complex statement.

33
00:01:55.940 --> 00:01:59.620
And don't let it intimidate you if
you're just starting out programming.

34
00:01:59.620 --> 00:02:02.910
But just from the perspective of
trying to get your feet wet with

35
00:02:02.910 --> 00:02:06.070
understanding the difference between
statements and expressions, kind of like

36
00:02:06.070 --> 00:02:09.650
when your English teacher had you go up on
the board and underline all the verbs and

37
00:02:09.650 --> 00:02:12.350
circle all the nouns or whatever,
I'm gonna have you do that with this.

38
00:02:12.350 --> 00:02:13.946
I'm gonna write a slightly
more complex statement,

39
00:02:13.946 --> 00:02:17.680
I'm literally just gonna make it up on
the fly so it might make no sense at all.

40
00:02:17.680 --> 00:02:21.150
But I'm gonna write a statement and then I
want you to take that same statement and

41
00:02:21.150 --> 00:02:23.260
put in those parenthesis like I just did.

42
00:02:23.260 --> 00:02:26.318
Identifying all the different
places that there are expressions.

43
00:02:26.318 --> 00:02:31.514
So, let me just start out
by saying something like.

44
00:02:32.523 --> 00:02:34.076
&gt;&gt; Kyle Simpson: a = b * 2 +,

45
00:02:34.076 --> 00:02:38.227
then I'm gonna make a function call,

46
00:02:38.227 --> 00:02:42.898
which you haven't seen those before, and

47
00:02:42.898 --> 00:02:48.345
then I'm going to pass
in an argument (c * 3),

48
00:02:48.345 --> 00:02:51.750
and there's my statement.

49
00:02:51.750 --> 00:02:55.420
So, copy that down first, you can
copy this in to your own code editor,

50
00:02:55.420 --> 00:02:58.430
you can type it into your console or
something like that.

51
00:02:58.430 --> 00:03:01.670
It's a nonsense statement because
we haven't assigned values to foo b

52
00:03:01.670 --> 00:03:02.530
and c yet.

53
00:03:02.530 --> 00:03:06.030
But just from the perspective of
finding those expressions, go in and

54
00:03:06.030 --> 00:03:08.970
put your parenthesis or brackets or
whatever if you want, but

55
00:03:08.970 --> 00:03:11.570
take just a moment and try to find
all the different places where there

56
00:03:11.570 --> 00:03:14.560
are expressions and
then we'll come back and solidify that.

57
00:03:16.425 --> 00:03:20.155
All right, so [COUGH] hopefully you
had a chance to try your hand at that.

58
00:03:20.155 --> 00:03:21.355
Let's see how you did, so

59
00:03:21.355 --> 00:03:25.775
I'm gonna walk through from the smallest
to the sort of outer and identify all

60
00:03:25.775 --> 00:03:29.175
those different places that are
expressions that make up this statement.

61
00:03:29.175 --> 00:03:33.250
So, because I already have a set of
parentheses in here that means syntax,

62
00:03:33.250 --> 00:03:37.732
I'm actually gonna use brackets instead
of parentheses, the square brackets.

63
00:03:37.732 --> 00:03:39.460
But conceptually again we're
not doing anything syntactic.

64
00:03:39.460 --> 00:03:42.810
What we're doing here is
just identifying visually.

65
00:03:42.810 --> 00:03:45.790
So, I'm gonna put square brackets
around all our expressions.

66
00:03:45.790 --> 00:03:49.740
So, here we know that we have
an expression for the literal value 3.

67
00:03:49.740 --> 00:03:53.630
I'm not making that an array 3,
I'm just identifying that thing as a 3.

68
00:03:53.630 --> 00:03:55.600
We also have another expression,
the value 2.

69
00:03:55.600 --> 00:03:58.160
And we have another expression for B.

70
00:03:58.160 --> 00:04:00.710
And we have another expression for A.

71
00:04:00.710 --> 00:04:05.058
I think in my previous example I
forgot to indicate that the left

72
00:04:05.058 --> 00:04:07.700
hand side is also its own expression.

73
00:04:07.700 --> 00:04:12.780
So the left hand side is an expression,
the c is an expression, the foo of course,

74
00:04:12.780 --> 00:04:13.570
is an expression.

75
00:04:14.580 --> 00:04:16.970
So all those are sort of our
first level expressions.

76
00:04:16.970 --> 00:04:19.360
Now let's start doing
some grouping of stuff.

77
00:04:19.360 --> 00:04:23.320
We know that the ([c] *
[3]) is an expression,

78
00:04:23.320 --> 00:04:24.750
it's a multiplication expression so

79
00:04:24.750 --> 00:04:29.050
we should put a bracket around that to
identify that that is an expression.

80
00:04:29.050 --> 00:04:32.560
We know that this thing, we haven't really
talked about what a function call is but

81
00:04:32.560 --> 00:04:36.630
we know that it's an inseparable unit,
there is this whole thing like

82
00:04:36.630 --> 00:04:39.450
when we put the parentheses together
with the identifier in front of it,

83
00:04:39.450 --> 00:04:41.780
that's called a call expression.

84
00:04:41.780 --> 00:04:45.550
So there's a set of brackets that
need to go around the call expression

85
00:04:45.550 --> 00:04:48.630
because that's one coherent
unit of stuff that happens.

86
00:04:48.630 --> 00:04:51.170
So we've got our bracket around those,

87
00:04:51.170 --> 00:04:54.250
we do a little cleanup of my whitespace
here so that's an expression.

88
00:04:54.250 --> 00:04:57.420
Now, we have kind of
an interesting question to ask.

89
00:04:57.420 --> 00:05:01.130
Which is, would the programming language,
would the computer,

90
00:05:02.150 --> 00:05:06.870
think of these two things
as an expression first, or

91
00:05:06.870 --> 00:05:10.940
would it think of these two
things as an expression?

92
00:05:10.940 --> 00:05:13.880
Cuz we have two different operators,
they're called binary operators.

93
00:05:13.880 --> 00:05:16.580
That's a fancy way of saying it's
an operator that requires two

94
00:05:16.580 --> 00:05:17.380
different sides.

95
00:05:18.460 --> 00:05:21.780
So it's a binary operator plus that
requires one thing on the left and

96
00:05:21.780 --> 00:05:23.720
one thing on the right and
puts them together.

97
00:05:23.720 --> 00:05:26.520
And then the multiplication
operator is the same way.

98
00:05:26.520 --> 00:05:28.968
So, it can't do both of
them at the same time.

99
00:05:28.968 --> 00:05:30.939
It's gotta do one and then the other and

100
00:05:30.939 --> 00:05:34.960
that leads us into a discussion of what
we'd call operator precedents, okay?

101
00:05:34.960 --> 00:05:39.498
Now this is not necessarily a critical
set of rules that you have to learn but

102
00:05:39.498 --> 00:05:43.100
awareness that there is such
a thing is the important part,

103
00:05:43.100 --> 00:05:46.740
not actually knowing each
individual nuanced thing.

104
00:05:46.740 --> 00:05:49.850
There's a set of rules that
tells the programming language

105
00:05:49.850 --> 00:05:52.110
how to know what to do first.

106
00:05:52.110 --> 00:05:54.549
It doesn't always work in
left to right fashion.

107
00:05:55.810 --> 00:05:59.400
Sometimes it could work from the right
hand side and then move its way backwards.

108
00:05:59.400 --> 00:06:02.340
Now, I accidentally and
literally, I just made it up, and

109
00:06:02.340 --> 00:06:06.660
I accidentally chose this
multiplication to happen first which

110
00:06:06.660 --> 00:06:11.130
happens to matter because multiplication
is what is said to be more precedent.

111
00:06:12.150 --> 00:06:14.800
Multiplication happens before

112
00:06:14.800 --> 00:06:19.500
addition if there's a question as
to which one should happen first,

113
00:06:19.500 --> 00:06:23.040
pick multiplication before addition and
that's what I mean by precedence.

114
00:06:23.040 --> 00:06:29.820
So, we could say that this thing is
an expression, because it is the thing

115
00:06:29.820 --> 00:06:33.920
that the computer would do first before
considering what's happening on the plus.

116
00:06:33.920 --> 00:06:36.790
So now if you're not getting
lost in the sea of brackets,

117
00:06:36.790 --> 00:06:40.520
you can see that I have one expression
here and I have one expression here.

118
00:06:40.520 --> 00:06:43.770
Those two are the binary operands,

119
00:06:43.770 --> 00:06:47.650
another fancy word to say the values
that go into the plus operator.

120
00:06:47.650 --> 00:06:50.710
So now we have one more
wrapping of brackets,

121
00:06:50.710 --> 00:06:52.180
this is getting out of hand, of course.

122
00:06:52.180 --> 00:06:55.090
But we now have a wrapping
around that entire thing.

123
00:06:55.090 --> 00:07:00.217
Now this is one big complicated
evaluation to take [ [b] * [2] ] and

124
00:07:00.217 --> 00:07:05.455
add it to the result of calling [
[foo] ( [ [c] * [3] ] past them.

125
00:07:05.455 --> 00:07:09.700
So we put all of that together
to be an expression value and

126
00:07:09.700 --> 00:07:13.180
that expression value of course then
gets assigned to the left hand side,

127
00:07:13.180 --> 00:07:15.140
to the a variable that's over there and

128
00:07:15.140 --> 00:07:20.830
finally one last set of crazy brackets
around the entire assignment expression.

129
00:07:20.830 --> 00:07:24.042
And now we've identified
all those different little

130
00:07:24.042 --> 00:07:28.476
pieces that nest themselves together
to become what we call a statement.

131
00:07:28.476 --> 00:07:29.275
Of course, it looks a lot easier to read
when we don't have all those brackets in,

132
00:07:29.275 --> 00:07:33.060
right?
So if I go back to the original statement

133
00:07:33.060 --> 00:07:36.196
without all those crazy brackets

134
00:07:36.196 --> 00:07:41.793
in.
&gt;&gt; Kyle Simpson: We

135
00:07:41.793 --> 00:07:43.340
can come back to that same understanding.

136
00:07:43.340 --> 00:07:48.070
We can say hey, I know I need to do (c
* 3) cuz that's gotta get passed in.

137
00:07:48.070 --> 00:07:52.298
So find out what c is currently, whatever
value it is, and multiply it by 3.

138
00:07:52.298 --> 00:07:54.470
And then pass that into the function foo.

139
00:07:54.470 --> 00:07:56.900
And again, we'll cover call expressions,
what functions are, and

140
00:07:56.900 --> 00:07:57.829
we'll cover that in a little bit.

141
00:07:59.070 --> 00:08:03.460
And then whatever that valve is,
add that to the value of b * 2.

142
00:08:03.460 --> 00:08:07.020
So compute b * 2, now I have two
different things, add those together and

143
00:08:07.020 --> 00:08:10.560
whatever that final result
is assign it into a.

144
00:08:10.560 --> 00:08:14.230
By the way,
the reason why operator precedence matters

145
00:08:14.230 --> 00:08:17.990
is that because mathematically this
could mean two different things.

146
00:08:17.990 --> 00:08:22.250
If I was to simplify it and
I was to say, 2 * 3 + 4.

147
00:08:23.630 --> 00:08:29.626
Mathematically it matters
which one you do first,

148
00:08:29.626 --> 00:08:34.660
2 * 3 + 4 is 10, 2 * 3 + 4 is 14.

149
00:08:34.660 --> 00:08:35.910
So mathematically it matters and

150
00:08:35.910 --> 00:08:40.350
that's why this ambiguity has to be
resolved by the programming language.

151
00:08:40.350 --> 00:08:43.960
The way we resolve that in programming
languages is to understand

152
00:08:43.960 --> 00:08:47.180
a basic concept of operator precedence.

153
00:08:47.180 --> 00:08:52.580
Now, what if you were in the scenario
where you wanted to sort of override

154
00:08:52.580 --> 00:08:53.910
that precedence.

155
00:08:53.910 --> 00:08:54.850
Yeah?
&gt;&gt; Speaker 2: You wanted to add

156
00:08:54.850 --> 00:08:55.700
parenthesis.
&gt;&gt; Kyle Simpson: You wanted to

157
00:08:55.700 --> 00:08:56.490
add parenthesis.

158
00:08:56.490 --> 00:08:57.790
Yeah.
&gt;&gt; Speaker 2: And you want to add

159
00:08:57.790 --> 00:09:01.550
them in your code just so that you could
accentuate what you're trying to do.

160
00:09:01.550 --> 00:09:02.470
&gt;&gt; Kyle Simpson: That's exactly the point

161
00:09:02.470 --> 00:09:04.190
that I was going to, great segue.

162
00:09:04.190 --> 00:09:10.550
So if I wanted to suggest that this
program should do 2 + foo the and then

163
00:09:10.550 --> 00:09:15.019
multiply that by b, then I could forcibly
do that by putting in the parentheses.

164
00:09:16.820 --> 00:09:20.680
These here are not made up syntax,
made up visual things,

165
00:09:20.680 --> 00:09:22.890
these are actually things
that matter to the program.

166
00:09:22.890 --> 00:09:26.840
The parentheses here says do the stuff
inside of the parentheses first before

167
00:09:26.840 --> 00:09:27.960
working your way out.

168
00:09:27.960 --> 00:09:32.820
So now I have forcibly changed that rule,
if you will, of precedence

169
00:09:32.820 --> 00:09:37.140
by forcibly saying that the plus should
happen before the multiplication.

170
00:09:37.140 --> 00:09:40.680
Exactly the same as in the 2 * 3 + 4.

171
00:09:40.680 --> 00:09:42.540
I could have done that by saying,

172
00:09:42.540 --> 00:09:47.000
no what I really want you to do is come
up with 7 first and then multiply by 2.

173
00:09:47.000 --> 00:09:51.580
So those parenthesis in this case they
matter, they matter to the end result.

174
00:09:51.580 --> 00:09:56.970
But what if I did want the b * 2 and
I didn't want the 2+?

175
00:09:56.970 --> 00:10:00.090
I want it to happen the same
way as operator precedence.

176
00:10:00.090 --> 00:10:02.330
To the point that was just brought up,

177
00:10:02.330 --> 00:10:05.120
I can still put in a set
of parentheses here.

178
00:10:07.110 --> 00:10:10.335
They're not necessary to
the functioning of the program,

179
00:10:10.335 --> 00:10:13.730
they don't change
the outcome of the program,

180
00:10:13.730 --> 00:10:17.220
it's still gonna do exactly the same
thing as if I had left them out.

181
00:10:17.220 --> 00:10:22.495
But here's that point that we were talking
about earlier where it's this balance,

182
00:10:22.495 --> 00:10:26.446
this goal to try to make sure
that your code is understandable.

183
00:10:26.446 --> 00:10:29.868
If we put something into a program that
the computer doesn't care about then

184
00:10:29.868 --> 00:10:32.980
the only other reason for it could
be that a developer cares about it.

185
00:10:32.980 --> 00:10:38.653
So developer here not needing to know
the rules of operator precedence,

186
00:10:38.653 --> 00:10:44.710
doesn't have to understand whether
times or plus happens first.

187
00:10:44.710 --> 00:10:48.090
If all they understand is the fact
that parentheses wrap together

188
00:10:48.090 --> 00:10:50.630
then they can process
through this program and

189
00:10:50.630 --> 00:10:55.480
say, clearly I should do this thing first,
and this thing and then add them together.

190
00:10:55.480 --> 00:11:00.150
So for readability sake you would probably
tend to want to put the parentheses in.

191
00:11:01.500 --> 00:11:06.850
Basically the takeaway here is that even
if you know intricately all the rules

192
00:11:06.850 --> 00:11:11.570
of operator precedence, you don't always
want to write a program that relies on it.

193
00:11:11.570 --> 00:11:13.300
Sometimes it's helpful.

194
00:11:13.300 --> 00:11:18.700
But sometimes it's more appropriate to add
additional things to your program like in

195
00:11:18.700 --> 00:11:23.170
this case, an optional set of parentheses
to make the code make more sense.

196
00:11:23.170 --> 00:11:24.814
Question?
&gt;&gt; Speaker 3: My question was without

197
00:11:24.814 --> 00:11:27.976
the parentheses, we'll get
the value of the function first or

198
00:11:27.976 --> 00:11:30.450
the variable b?
&gt;&gt; Kyle Simpson: That's a great question.

199
00:11:30.450 --> 00:11:35.110
So, if I didn't put this parentheses here,
what's gonna actually happen?

200
00:11:35.110 --> 00:11:40.120
Well, the rules of operator
precedence say which operator,

201
00:11:40.120 --> 00:11:43.670
if two different operators show up in
a line like this without any other kind of

202
00:11:43.670 --> 00:11:46.026
grouping, it's gonna say
which thing happens first.

203
00:11:46.026 --> 00:11:48.760
So from a left to right perspective,

204
00:11:48.760 --> 00:11:52.590
the b * 2 is going to happen first
before calling the foo function.

205
00:11:54.170 --> 00:11:57.840
If the foo function had been in the left
position then the foo function would have

206
00:11:57.840 --> 00:12:00.920
been called and
then the b * 2 would have happened.

207
00:12:00.920 --> 00:12:04.020
So the programming language
does typically and

208
00:12:04.020 --> 00:12:06.500
generally move in a left to right fashion.

209
00:12:07.920 --> 00:12:10.780
Meaning that something on the left is
typically gonna happen before something on

210
00:12:10.780 --> 00:12:13.640
the right, even if we looked only
at this expression right here,

211
00:12:13.640 --> 00:12:15.220
the b * 2 expression.

212
00:12:15.220 --> 00:12:19.770
We could say that the programming language
will evaluate the thing on the left first

213
00:12:19.770 --> 00:12:22.160
before evaluating the thing on the right.

214
00:12:22.160 --> 00:12:24.510
So typically it's gonna work
in a left to right fashion.

215
00:12:24.510 --> 00:12:27.640
The only time when that is broken is
if there's something like operator

216
00:12:27.640 --> 00:12:28.650
precedence.

217
00:12:28.650 --> 00:12:30.990
Or there's another related
concept called associativity,

218
00:12:30.990 --> 00:12:36.010
which we don't need to get into, but
if precedence or associativity overrides

219
00:12:36.010 --> 00:12:39.920
that left to right behavior, and in those
cases it could force something to happen.

220
00:12:39.920 --> 00:12:47.504
So, if I were to simply reverse these two.
&gt;&gt; Kyle Simpson: And say b+2*foo.

221
00:12:48.520 --> 00:12:52.738
Now we know that operator
precedence is gonna say, don't,

222
00:12:52.738 --> 00:12:58.290
I mean we are gonna evaluate the b part
first and evaluate the 2 part first.

223
00:12:58.290 --> 00:13:03.220
But here we're going to call this
foo function before we add it to b,

224
00:13:04.970 --> 00:13:08.390
because we've got to compute that
whole expression expression first.

225
00:13:08.390 --> 00:13:13.600
So operator precedence can work to sort
of tweak the way this normal left or

226
00:13:13.600 --> 00:13:15.290
right processing happens.

227
00:13:15.290 --> 00:13:17.728
But overall you still see that
even inside of each expression,

228
00:13:17.728 --> 00:13:19.340
it still works in a left to right fashion.

229
00:13:20.910 --> 00:13:22.540
So, it's a great question.

230
00:13:22.540 --> 00:13:26.410
Yeah, I like what's said in the chat room,
be kind to your future more elderly self,

231
00:13:26.410 --> 00:13:31.614
that's definitely true.
&gt;&gt; Speaker 4: I probably

232
00:13:31.614 --> 00:13:36.319
getting way ahead of myself but is there
any difference between specifying as 2 or

233
00:13:36.319 --> 00:13:39.640
2.0, does it matter?
&gt;&gt; Kyle Simpson: In some languages it

234
00:13:39.640 --> 00:13:42.150
matters, in JavaScript it doesn't.

235
00:13:42.150 --> 00:13:43.505
In JavaScript 2 and

236
00:13:43.505 --> 00:13:48.140
2.0 are all the same value because
there is just one number value.

