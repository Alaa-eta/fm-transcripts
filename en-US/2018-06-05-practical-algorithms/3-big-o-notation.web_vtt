WEBVTT

1
00:00:00.050 --> 00:00:03.650
&gt;&gt; Bianca: So
what if we had multiple expressions, and

2
00:00:03.650 --> 00:00:04.990
we put them inside of a loop?

3
00:00:04.990 --> 00:00:07.970
How do we reason with a function that,
in the function body,

4
00:00:07.970 --> 00:00:09.836
has multiple expressions?

5
00:00:09.836 --> 00:00:14.670
And so, the way I think about it

6
00:00:16.000 --> 00:00:20.440
is if you have multiple expressions
that are not inside of a loop,

7
00:00:20.440 --> 00:00:21.570
I just add them together.

8
00:00:21.570 --> 00:00:27.430
So if we have a bunch in constant time,
I would just say 1 + 1 + 1 equals 3.

9
00:00:27.430 --> 00:00:32.370
However, if these things get put inside
of a loop, then you start to multiply it.

10
00:00:32.370 --> 00:00:36.480
So if you have a loop inside of a loop,
right?

11
00:00:36.480 --> 00:00:37.180
We have n.

12
00:00:37.180 --> 00:00:38.270
A loop is linear, right?

13
00:00:38.270 --> 00:00:38.990
We talked about that.

14
00:00:38.990 --> 00:00:42.500
And then we have a loop inside of a loop,
it's n times n, which is then quadratic.

15
00:00:42.500 --> 00:00:45.947
If we have three loops, n times n times n.

16
00:00:45.947 --> 00:00:50.002
However, we also need to think about
what is going on inside of those loops.

17
00:00:50.002 --> 00:00:54.941
So if inside of a loop,
we're doing recursion,

18
00:00:54.941 --> 00:00:58.078
that can add some more things.

19
00:00:58.078 --> 00:01:05.669
And so depending on the time complexity
of that method that you're calling,

20
00:01:05.669 --> 00:01:10.472
you need to just multiply
it by n inside of a loop.

21
00:01:10.472 --> 00:01:13.356
Otherwise, just add it.

22
00:01:13.356 --> 00:01:16.289
Does that make sense?

23
00:01:16.289 --> 00:01:24.047
Questions about this?
&gt;&gt; Bianca: Okay.

24
00:01:27.882 --> 00:01:32.270
&gt;&gt; Bianca: Okay, so what about O(logn)?

25
00:01:32.270 --> 00:01:36.680
So logarithmic time, so we don't
really talk about logarithms anymore,

26
00:01:36.680 --> 00:01:39.920
after I don't know,
high school or something.

27
00:01:39.920 --> 00:01:44.423
Unless you're a scientist, I guess
logarithms are really important if you

28
00:01:44.423 --> 00:01:47.671
deal with really big numbers or
really small numbers.

29
00:01:47.671 --> 00:01:51.090
Which is what we do, right,
if we're analyzing large sets of data?

30
00:01:51.090 --> 00:01:54.832
I'm not gonna teach you
logarithms right now, but

31
00:01:54.832 --> 00:01:58.850
all you need to know really
is that logarithmic times.

32
00:01:58.850 --> 00:02:00.890
Logarithms can have different bases.

33
00:02:00.890 --> 00:02:03.540
You can have base 10,
you can have base 2 and

34
00:02:03.540 --> 00:02:08.090
you can think about as your
input increases, the work or

35
00:02:08.090 --> 00:02:12.540
the number of operations that needs
to be done decreases by a fraction.

36
00:02:12.540 --> 00:02:18.710
So commonly,
if you are looping through an array and

37
00:02:18.710 --> 00:02:22.340
you have a loop and
then every time you loop,

38
00:02:22.340 --> 00:02:26.430
you cut your problem in half,
that is going to be a logarithmic time.

39
00:02:26.430 --> 00:02:29.050
So every time you loop,

40
00:02:29.050 --> 00:02:33.930
you only have to do work on half of your
data set, or a third, or some fraction.

41
00:02:33.930 --> 00:02:38.670
So logarithmic can be some fraction, so
base 2 will be divided by 2, base 3, 3,

42
00:02:38.670 --> 00:02:39.200
10, 10, etc.

43
00:02:40.490 --> 00:02:45.310
So as it increases, the time complexity

44
00:02:47.010 --> 00:02:52.260
increases at a fraction, so it grows
really, really slow, which is good.

45
00:02:52.260 --> 00:02:56.229
Which is why it's pretty close
here to constant time and

46
00:02:56.229 --> 00:03:01.719
it's often better than linear time when
we have a large enough data set that we

47
00:03:01.719 --> 00:03:07.427
care about this kind of stuff.
&gt;&gt; Bianca: So

48
00:03:07.427 --> 00:03:11.160
that's what you need to know about logn.
&gt;&gt; Bianca: Cool.

49
00:03:11.160 --> 00:03:12.910
And there's also nlogn.

50
00:03:12.910 --> 00:03:15.540
Nlogn happens when you have a loop and
then

51
00:03:17.950 --> 00:03:22.950
you have a linear loop, and then you're
also looping and cutting it in half.

52
00:03:22.950 --> 00:03:25.000
So linear, and
then you're cutting it in half, and

53
00:03:25.000 --> 00:03:28.060
you multiply them together to make nlogn.

54
00:03:28.060 --> 00:03:30.500
And we'll see an example of that later.

55
00:03:31.520 --> 00:03:35.449
So you'll put some examples
to these vocab terms.

56
00:03:37.220 --> 00:03:38.530
Questions?
&gt;&gt; Speaker 2: So

57
00:03:38.530 --> 00:03:41.120
you mentioned different bases,
how is that determined?

58
00:03:41.120 --> 00:03:44.200
It says base two or base ten, is that-
&gt;&gt; Bianca: It's what you divide it by.

59
00:03:44.200 --> 00:03:47.120
So if you're dividing your input by two,
it's base two.

60
00:03:47.120 --> 00:03:49.160
If you're dividing by ten, it's base ten.

61
00:03:49.160 --> 00:03:53.010
Typically you're gonna see
it divided by two, mostly.

62
00:03:53.010 --> 00:03:54.860
&gt;&gt; Speaker 2: Kinda like a binary search?

63
00:03:54.860 --> 00:03:55.888
&gt;&gt; Bianca: Yeah, exactly.

64
00:03:55.888 --> 00:03:59.964
Binary search,
anything where you're cutting it in half.

65
00:03:59.964 --> 00:04:07.767
Okay, so here's a little table
to help us have some reference.

66
00:04:07.767 --> 00:04:11.659
So if we're just running a statement,
like returning a value for

67
00:04:11.659 --> 00:04:14.490
example, there's constant time.

68
00:04:14.490 --> 00:04:16.909
Any sort of value look-up, array, object.

69
00:04:17.950 --> 00:04:20.170
Variable is going to be constant time.

70
00:04:20.170 --> 00:04:25.110
Again, with the needle going directly
to where it is in memory, easy.

71
00:04:25.110 --> 00:04:28.250
So loop, you can think of this as loop
that cuts the problem in half every time.

72
00:04:29.340 --> 00:04:32.030
And it's just gonna loop
through all of them.

73
00:04:32.030 --> 00:04:35.160
So anything where you have to look at
everything at least once is going to be be

74
00:04:35.160 --> 00:04:36.810
at least n, right?

75
00:04:38.670 --> 00:04:42.902
So n squared is gonna be
double nested loops and

76
00:04:42.902 --> 00:04:48.558
then we have triple nested loops
of n to the three, or n cubed.

77
00:04:48.558 --> 00:04:56.598
So just a word of caution, I'm giving you
some tools to make rough estimations here.

78
00:04:56.598 --> 00:05:00.531
This is not the full version of
how to calculate time complexity,

79
00:05:00.531 --> 00:05:05.510
which is deeply mathematical and
really out of the scope of this workshop.

80
00:05:05.510 --> 00:05:10.390
But what you need to be mindful of is what
is n, because you're gonna have a lot of

81
00:05:10.390 --> 00:05:14.860
different data points in your methods or
in your algorithms, and so you wanna make

82
00:05:14.860 --> 00:05:18.320
sure that you're identifying what
is the data set that's growing.

83
00:05:18.320 --> 00:05:21.670
And if you have more than one data
set that has a variable length,

84
00:05:21.670 --> 00:05:23.510
you're gonna need to take
that into consideration.

85
00:05:23.510 --> 00:05:25.720
That's something that when
people get started with this,

86
00:05:25.720 --> 00:05:28.430
they just assume that n is always
gonna be the length of the array,

87
00:05:28.430 --> 00:05:32.600
or n is always gonna be a certain input,
and it's not necessarily so.

88
00:05:32.600 --> 00:05:37.678
You need to really think about how
your code is executing and what

89
00:05:37.678 --> 00:05:41.722
is changing as your input changes, mm-hm?
&gt;&gt; Speaker 3: Can you

90
00:05:41.722 --> 00:05:45.488
provide a concrete example?
&gt;&gt; Bianca: Of what exactly?

91
00:05:45.488 --> 00:05:46.990
&gt;&gt; Speaker 3: What you're describing.

92
00:05:46.990 --> 00:05:47.880
&gt;&gt; Bianca: Of what I'm describing.

93
00:05:47.880 --> 00:05:51.295
So I will in our future slides.
&gt;&gt; Speaker 3: Okay.

94
00:05:51.295 --> 00:05:53.420
&gt;&gt; Bianca: Yeah, yeah, yeah, yeah.

95
00:05:54.610 --> 00:05:57.590
Yeah, and when we go through it, I'm gonna
ask you, okay, what exactly is in here?

96
00:05:57.590 --> 00:06:01.440
And we're gonna think about,
what are the things that are changing?

97
00:06:01.440 --> 00:06:05.494
Because that's one of the common mistakes,

98
00:06:05.494 --> 00:06:09.226
is assuming that n is a particular thing,

99
00:06:09.226 --> 00:06:13.620
when it's not necessarily
a particular input.

100
00:06:13.620 --> 00:06:16.340
And then we use m to call it,

101
00:06:17.490 --> 00:06:21.820
to make it really confusing,
because those are hard to say.

