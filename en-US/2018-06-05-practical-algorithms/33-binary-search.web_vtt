WEBVTT

1
00:00:00.000 --> 00:00:01.482
&gt;&gt; Bianca Gandolfo: So
we're gonna talk about binary search.

2
00:00:01.482 --> 00:00:06.602
Again, binary search is our search where
we are expecting our way to be sorted and

3
00:00:06.602 --> 00:00:09.702
we are going to break our
list in half every time.

4
00:00:09.702 --> 00:00:14.549
And we're gonna say is our value that
we're searching for less than or

5
00:00:14.549 --> 00:00:17.189
greater than this current location.

6
00:00:17.189 --> 00:00:19.402
So if it's less we're
gonna go to the left.

7
00:00:19.402 --> 00:00:21.981
If it's greater than,
we're gonna go to the right.

8
00:00:21.981 --> 00:00:26.102
All right,
what does this look like in reality?

9
00:00:26.102 --> 00:00:32.124
All right, so,
we can do the calls that came with this.

10
00:00:32.124 --> 00:00:35.209
Let me go and find one, all right.

11
00:00:45.446 --> 00:00:49.669
&gt;&gt; Bianca Gandolfo: My goodness,
this is a mess.

12
00:00:49.669 --> 00:00:53.961
All right, so
we are going to delete all that.

13
00:00:53.961 --> 00:00:59.581
And, so we just called our binary

14
00:00:59.581 --> 00:01:04.206
search with these values.

15
00:01:04.206 --> 00:01:06.048
I'm gonna keep them up here for
a reference.

16
00:01:06.048 --> 00:01:10.760
So we're initializing a minimum,
our maximum is list length minus one,

17
00:01:10.760 --> 00:01:14.484
which is one, two, three,
four, five, which is four.

18
00:01:14.484 --> 00:01:17.534
Initializing, a guess,
that's gonna be empty.

19
00:01:17.534 --> 00:01:20.831
So while the minimum is less than the max,
right?

20
00:01:20.831 --> 00:01:25.625
So why we aren't looping outside
of the bounds of our function.

21
00:01:25.625 --> 00:01:28.782
We are going to grab the center.

22
00:01:28.782 --> 00:01:34.348
So our guess is,
let's just start in the middle.

23
00:01:34.348 --> 00:01:38.519
And this is common for
divide and conquer algorithm.

24
00:01:38.519 --> 00:01:40.531
We start in the middle, but

25
00:01:40.531 --> 00:01:45.794
if you take a look at quick sort which
we won't have time to cover today.

26
00:01:45.794 --> 00:01:47.973
It's not always gonna be in the middle.

27
00:01:47.973 --> 00:01:52.009
Sometimes you'll pick a point to do a
divide and conquer at the end in the case

28
00:01:52.009 --> 00:01:55.176
of quick sort, but
there's different implementations.

29
00:01:55.176 --> 00:01:58.385
However, you can kind of reason
that if it's divide and conquer,

30
00:01:58.385 --> 00:02:02.643
you'll probably gonna split in the middle,
although sometimes that's not the case.

31
00:02:02.643 --> 00:02:05.037
Okay, so we're splitting in the middle.

32
00:02:05.037 --> 00:02:09.637
So if, so let's say min+max, so

33
00:02:09.637 --> 00:02:13.293
that's 5 / 2 is 2.5.

34
00:02:13.293 --> 00:02:16.844
You're gonna floor it so that's 2.

35
00:02:16.844 --> 00:02:20.208
So that's 2, so list at guess.

36
00:02:20.208 --> 00:02:25.750
So if list at guest,
which is 2, is the item,

37
00:02:25.750 --> 00:02:30.024
we're going to return that index.

38
00:02:30.024 --> 00:02:36.063
Again, we're returning
the index of where we find it.

39
00:02:36.063 --> 00:02:40.705
Okay, so let's see, our index is 2.

40
00:02:40.705 --> 00:02:43.369
012 we're so close but not quite.

41
00:02:43.369 --> 00:02:48.923
So we didn't met the condition,
so we're gonna hop into the else.

42
00:02:48.923 --> 00:02:52.883
So if the list of guess, so

43
00:02:52.883 --> 00:02:58.283
that's 7, is less than the item.

44
00:02:58.283 --> 00:03:03.377
Then lets increment the min by 1,
so let's see.

45
00:03:03.377 --> 00:03:04.316
What is the current item?

46
00:03:04.316 --> 00:03:10.028
Our item is 90, is 7 less than 90?

47
00:03:10.028 --> 00:03:13.751
Yes, so
we're going to increment our guess by 1.

48
00:03:15.953 --> 00:03:20.353
&gt;&gt; Bianca Gandolfo: Or sorry,
our min by 1 2 3, otherwise,

49
00:03:20.353 --> 00:03:24.404
we're going to look on the other side.

50
00:03:26.972 --> 00:03:29.843
&gt;&gt; Bianca Gandolfo: This is
driving me a little bit crazy,

51
00:03:29.843 --> 00:03:33.879
I can't fix it right now,
I don't have time, okay,

52
00:03:33.879 --> 00:03:38.377
so
&gt;&gt; Bianca Gandolfo: Great, so

53
00:03:38.377 --> 00:03:42.881
we need to, so our min is now 3, okay?

54
00:03:42.881 --> 00:03:46.569
You saw how we got that here?

55
00:03:46.569 --> 00:03:49.546
So now we're going to loop here again.

56
00:03:49.546 --> 00:03:51.117
So is min less than max?

57
00:03:51.117 --> 00:03:51.898
Is 3 less than 5?

58
00:03:51.898 --> 00:03:56.399
Yes, great, so let's add our min and

59
00:03:56.399 --> 00:04:00.770
max, and we're gonna chop it in 2.

60
00:04:00.770 --> 00:04:02.534
Where does that bring us?

61
00:04:02.534 --> 00:04:06.135
To 4, so now, our center is 4.

62
00:04:06.135 --> 00:04:13.200
So, in the middle of that is the fourth
item in the list equal our item.

63
00:04:13.200 --> 00:04:16.891
So zero, one, two,

64
00:04:16.891 --> 00:04:21.617
three, did we do it wrong?

65
00:04:21.617 --> 00:04:27.076
zero, one, two, three, maybe, yeah,

66
00:04:27.076 --> 00:04:31.695
nope, we're just gotta keep going.

67
00:04:31.695 --> 00:04:38.823
So, the fourth one, so
we overshot it this time.

68
00:04:38.823 --> 00:04:43.850
And then, we're gonna say if we found it.

69
00:04:43.850 --> 00:04:45.444
Great, let's return it, but we didn't.

70
00:04:45.444 --> 00:04:47.225
So is it less?

71
00:04:47.225 --> 00:04:48.575
No, it's not.

72
00:04:48.575 --> 00:04:52.116
So we're going to subtract it instead.

73
00:04:52.116 --> 00:04:55.316
So our max is guess -1.

74
00:04:55.316 --> 00:04:56.005
So what's guess?

75
00:04:56.005 --> 00:05:00.022
4, so now we're back at 3, and

76
00:05:00.022 --> 00:05:04.045
then we're gonna do this again.

77
00:05:04.045 --> 00:05:06.874
Hold on, are you guys checking my math?

78
00:05:10.392 --> 00:05:15.271
&gt;&gt; Bianca Gandolfo: So we go,
&gt;&gt; Bianca Gandolfo: Hm?

79
00:05:18.089 --> 00:05:25.208
&gt;&gt; Bianca Gandolfo: Okay, so it was 4, our
max but min is still 3, okay, we're good.

80
00:05:25.208 --> 00:05:31.987
So our max is now 3, and so 3+3,
we're gonna divide it by 2.

81
00:05:31.987 --> 00:05:33.894
So now we're back at 3.

82
00:05:33.894 --> 00:05:38.412
I think we're off by 1 somewhere,

83
00:05:38.412 --> 00:05:41.880
are we off by 1 somewhere?

84
00:05:41.880 --> 00:05:43.067
Let's debug this.

85
00:05:46.899 --> 00:05:51.531
&gt;&gt; Bianca Gandolfo: All right, so
let's start from the beginning, shall we?

86
00:05:56.016 --> 00:06:00.736
&gt;&gt; Bianca Gandolfo: So we're going to,
&gt;&gt; Bianca Gandolfo: So

87
00:06:00.736 --> 00:06:03.328
we're initializing min as 0.

88
00:06:03.328 --> 00:06:08.653
This is list.length and there's one,
one, two, three, four, five, four.

89
00:06:08.653 --> 00:06:12.488
Maybe that's what I did wrong, we'll see.

90
00:06:12.488 --> 00:06:15.242
Yes, that's what I did wrong.

91
00:06:15.242 --> 00:06:19.609
We had it off by one error, okay,
off by one error, sorry guys.

92
00:06:19.609 --> 00:06:23.959
It's just because I don't, I didn't
subtract this correctly in my head.

93
00:06:23.959 --> 00:06:28.504
Okay, so is min less than or
equal to the max?

94
00:06:28.504 --> 00:06:35.354
Sure is, and then now our guess is
going to be the second index, okay?

95
00:06:35.354 --> 00:06:37.545
So did we find it?

96
00:06:37.545 --> 00:06:40.531
Zero, one, two, no we didn't.

97
00:06:40.531 --> 00:06:47.050
So we're gonna go into this else,
is 7 less than 90, yes.

98
00:06:47.050 --> 00:06:53.557
So we'are going to
increment our min now to 1.

99
00:06:53.557 --> 00:06:59.981
And then we are going to
loop back into our while.

100
00:06:59.981 --> 00:07:03.564
So is 1 less than or equal to max?

101
00:07:03.564 --> 00:07:10.442
Sure is, so
now we are going to map that floor, 5 / 2.

102
00:07:10.442 --> 00:07:16.187
So we're kind of like narrowing

103
00:07:16.187 --> 00:07:21.068
the
&gt;&gt; Bianca Gandolfo: Range

104
00:07:21.068 --> 00:07:24.305
that we're looking in, okay.

105
00:07:24.305 --> 00:07:30.467
So then, that is going to be 2.math.floor,

106
00:07:30.467 --> 00:07:35.252
5/2, 2.5 2.math.floor.

107
00:07:37.644 --> 00:07:44.493
&gt;&gt; Bianca Gandolfo: Let's just double
check, let me just double check this.

108
00:07:48.426 --> 00:07:50.914
&gt;&gt; Bianca Gandolfo: Brutal, yeah,
it is 2, that's what I thought.

109
00:07:50.914 --> 00:07:56.598
Okay, so
we keep getting back to where we started.

110
00:08:01.161 --> 00:08:03.516
&gt;&gt; Speaker 2: Why is that not okay?

111
00:08:03.516 --> 00:08:07.169
&gt;&gt; Bianca Gandolfo: Maybe it is fine,
zero, one, two three, maybe it's fine.

112
00:08:07.169 --> 00:08:11.591
It's not how I think about it in my head,
but maybe it's fine.

113
00:08:11.591 --> 00:08:17.295
Okay, so we're back at two,
did we find it?

114
00:08:17.295 --> 00:08:23.642
No, otherwise we are going to,
so is 7 less than 90?

115
00:08:23.642 --> 00:08:28.529
Yes, then we increment it again,
so now this is 2.

116
00:08:28.529 --> 00:08:33.043
Okay, then 2+4=6, so now this is 3.

117
00:08:33.043 --> 00:08:37.406
So is zero, one, two, three,
then we find it, okay?

118
00:08:37.406 --> 00:08:40.731
Then we find it and we return it.

119
00:08:40.731 --> 00:08:47.954
We did it, there it is,
any questions about this?

120
00:08:47.954 --> 00:08:53.596
&gt;&gt; Speaker 3: If you were dealing
with a larger array instead

121
00:08:53.596 --> 00:08:59.238
of incrementing or
lowering your guess by 1,

122
00:08:59.238 --> 00:09:05.325
you'd want to add the array
length divided by 2.

123
00:09:05.325 --> 00:09:06.187
And each time you'd
[CROSSTALK] [INAUDIBLE]

124
00:09:06.187 --> 00:09:06.791
&gt;&gt; Bianca Gandolfo: You can do it

125
00:09:06.791 --> 00:09:07.339
that way.

126
00:09:07.339 --> 00:09:12.558
So if, so
you could just divide the length,

127
00:09:12.558 --> 00:09:16.085
so you can divide the length or

128
00:09:16.085 --> 00:09:21.304
you can just choose
an index in the middle and

129
00:09:21.304 --> 00:09:26.681
compare your item to
the index in the middle.

130
00:09:26.681 --> 00:09:28.799
And say, is it greater than or
is it less than?

131
00:09:28.799 --> 00:09:35.434
And then you can change your
starting index to the one after it.

132
00:09:35.434 --> 00:09:41.167
So, your minimum, so
say your index, you are looking for

133
00:09:41.167 --> 00:09:45.742
something that's in
the right of your array.

134
00:09:45.742 --> 00:09:48.708
So it's gonna be greater
than your min-index.

135
00:09:48.708 --> 00:09:52.917
You can just set your
min-index to that current one.

136
00:09:52.917 --> 00:09:58.815
So then, the min and
then you can just look in the left.

137
00:09:58.815 --> 00:10:01.851
That's another way of doing it,
yeah, cool.

