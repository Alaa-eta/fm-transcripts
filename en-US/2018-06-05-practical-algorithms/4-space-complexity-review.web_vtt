WEBVTT

1
00:00:00.000 --> 00:00:05.370
&gt;&gt; Bianca Gandolfo: So
rough estimations, space complexity.

2
00:00:05.370 --> 00:00:08.340
I'm gonna pass the mic to you guys.

3
00:00:08.340 --> 00:00:11.801
So given our conversation
about time complexity,

4
00:00:11.801 --> 00:00:15.110
what do you think space
complexity is all about?

5
00:00:21.510 --> 00:00:26.630
&gt;&gt; Speaker 2: Dealing with stacks and
in queues possibly.

6
00:00:26.630 --> 00:00:27.410
I'm not super familiar.

7
00:00:27.410 --> 00:00:31.500
&gt;&gt; Bianca Gandolfo: Yeah,
yeah, so spaces is good.

8
00:00:31.500 --> 00:00:33.521
Yeah, so stacks and queues,
those are data structures.

9
00:00:33.521 --> 00:00:39.060
And it's all about the space that
it takes up in memory, right?

10
00:00:39.060 --> 00:00:42.787
So if your algorithm is copying your
array a bunch of times, right, and

11
00:00:42.787 --> 00:00:46.590
you're making a new array,
then in memory you're having five arrays.

12
00:00:46.590 --> 00:00:50.380
And that's a certain amount
of space complexity.

13
00:00:50.380 --> 00:00:55.265
And it works in the same scale of
constant linear etc, as time complexity.

14
00:00:55.265 --> 00:00:59.448
Except that instead of the number of
operations that are being executed,

15
00:00:59.448 --> 00:01:03.190
we're thinking about how much
more space are we taking up.

16
00:01:03.190 --> 00:01:05.620
So are we, for every loop,
creating a new array?

17
00:01:05.620 --> 00:01:12.243
Okay, so that's like n times the length
of the array of space every time.

18
00:01:12.243 --> 00:01:20.150
Or if we're sorting, what we call sorting
in place where we don't make a new array.

19
00:01:20.150 --> 00:01:23.798
And then our space complexity is constant
even though our algorithm's time

20
00:01:23.798 --> 00:01:26.309
complexity could be
something totally different.

21
00:01:26.309 --> 00:01:30.150
So things to think about when you're
thinking about space complexity is are you

22
00:01:30.150 --> 00:01:31.870
making a new data structure?

23
00:01:31.870 --> 00:01:36.230
How often are you doing it
in comparison to your input?

24
00:01:36.230 --> 00:01:41.386
And also with your call stack,
if you're doing recursion,

25
00:01:41.386 --> 00:01:49.010
that's another thing to consider is that
that stack is also taking place in memory.

26
00:01:49.010 --> 00:01:54.080
However, that's not something you probably
need to go in depth about in an interview.

27
00:01:54.080 --> 00:01:58.657
Just be aware to just mention that
when you're talking about space

28
00:01:58.657 --> 00:02:01.080
complexity with recursion.

29
00:02:01.080 --> 00:02:03.322
And we're going to go through a lot of
recursion so we'll see that in action.

30
00:02:03.322 --> 00:02:10.620
All right, so here are some words,
lots of words.

31
00:02:10.620 --> 00:02:15.741
Something that you should know from this
slide is that there are other notations.

32
00:02:15.741 --> 00:02:18.598
We just typically use big O notation,
which is the worst case scenario.

33
00:02:18.598 --> 00:02:21.681
But there's also the average case
scenario, and the best case scenario, and

34
00:02:21.681 --> 00:02:22.760
all these different ones.

35
00:02:22.760 --> 00:02:26.399
And you can learn about it
by following that link.

36
00:02:26.399 --> 00:02:28.549
However, in interviews,

37
00:02:28.549 --> 00:02:33.602
it's expected that we speak in
the pessimistic big O notation.

38
00:02:33.602 --> 00:02:37.104
What is the worst case
scenario of this algorithm.

39
00:02:37.104 --> 00:02:39.437
So this is just a review.

40
00:02:39.437 --> 00:02:44.149
Worst case scenario we're going to
drop any non-significant operation or

41
00:02:44.149 --> 00:02:44.967
constants.

42
00:02:46.073 --> 00:02:46.857
&gt;&gt; Bianca Gandolfo: Break.

