WEBVTT

1
00:00:00.040 --> 00:00:04.730
&gt;&gt; Bianca: So next we're going to talk
a little bit about two patterns for

2
00:00:04.730 --> 00:00:05.650
recursion.

3
00:00:05.650 --> 00:00:09.320
The first one is a wrapper function and
the second is the accumulator pattern.

4
00:00:09.320 --> 00:00:13.360
[LAUGH]
I love my own jokes.

5
00:00:15.760 --> 00:00:16.820
So awesome.

6
00:00:16.820 --> 00:00:20.490
Okay, so back to our looping.

7
00:00:20.490 --> 00:00:22.650
We're going to loop first.

8
00:00:22.650 --> 00:00:24.560
This is our original loop actually.

9
00:00:24.560 --> 00:00:30.255
So the loop that we already did,
we're using a wrapper function,

10
00:00:30.255 --> 00:00:35.050
and in this one we are just
passing our values each time.

11
00:00:35.050 --> 00:00:42.080
So let's investigate how this loop works
using our call back game, call stack game.

12
00:00:43.340 --> 00:00:46.411
All right, so let's call,
what are we gonna call it with?

13
00:00:46.411 --> 00:00:48.385
Let's just call it with 1 and 3.

14
00:00:48.385 --> 00:00:52.919
So
&gt;&gt; Bianca: So

15
00:00:52.919 --> 00:00:58.460
this is our functions actually
being called over here.

16
00:00:58.460 --> 00:01:02.520
And then somewhere else, inside your
execution environment of your browser

17
00:01:02.520 --> 00:01:04.894
wherever you're running your javascript,

18
00:01:04.894 --> 00:01:10.731
this is happening
&gt;&gt; Bianca: Over there.

19
00:01:10.731 --> 00:01:17.836
Okay, so, I is 1 and 3 is the end.

20
00:01:17.836 --> 00:01:20.812
Okay, so
we're gonna remove this console log.

21
00:01:23.627 --> 00:01:25.540
&gt;&gt; Bianca: Just so
that we have a little more space here.

22
00:01:26.810 --> 00:01:31.636
So we will start, so
this is a lot shorter than the other one,

23
00:01:31.636 --> 00:01:34.677
but it's doing the exact same thing.

24
00:01:34.677 --> 00:01:38.856
So we are going to check,

25
00:01:38.856 --> 00:01:42.439
is i greater than 3?

26
00:01:42.439 --> 00:01:43.185
Yes.

27
00:01:43.185 --> 00:01:47.999
So we're gonna do the thing where we
add our function to the call stack,

28
00:01:47.999 --> 00:01:50.501
cuz we're executing the function.

29
00:01:50.501 --> 00:01:53.383
And we're creating a new
execution environment.

30
00:01:53.383 --> 00:01:58.247
All of these scope variables live in a
separate world from these scope variables.

31
00:01:58.247 --> 00:02:02.328
How then do we get i and
end In this execution contacts,

32
00:02:02.328 --> 00:02:04.630
we get that by passing it in.

33
00:02:04.630 --> 00:02:05.580
So what do we pass in?

34
00:02:06.730 --> 00:02:08.070
And I'm just gonna put our line there.

35
00:02:08.070 --> 00:02:11.744
We are passing in i + 1, which is 2.

36
00:02:11.744 --> 00:02:15.935
And then end,
we're not doing anything to it, 3.

37
00:02:15.935 --> 00:02:17.970
So we're just passing it through.

38
00:02:17.970 --> 00:02:21.250
And then, so we say i is 2, end is 3.

39
00:02:21.250 --> 00:02:23.210
That is still working for us.

40
00:02:23.210 --> 00:02:28.065
So we're going to call it again,
we're gonna add it to our call stack.

41
00:02:28.065 --> 00:02:29.661
Again we're just leaving off right here,

42
00:02:29.661 --> 00:02:31.408
just a little reference
where we were before.

43
00:02:31.408 --> 00:02:35.341
So then

44
00:02:35.341 --> 00:02:43.211
2+1=3.

45
00:02:43.211 --> 00:02:45.995
Okay, so is 3 less than 3?

46
00:02:45.995 --> 00:02:48.485
No, so we have our implicit return.

47
00:02:48.485 --> 00:02:49.970
Implicit return, we pop.

48
00:02:51.090 --> 00:02:56.480
Again, we're gonna finish up
where we left off with this line.

49
00:02:56.480 --> 00:02:57.921
And we're gonna move down here.

50
00:02:57.921 --> 00:03:00.796
Here we're gonna have our
implicit return and pop.

51
00:03:00.796 --> 00:03:02.791
We're gonna continue
here where this line is.

52
00:03:02.791 --> 00:03:06.069
And again, this is important if we're
doing more work which a lot of times,

53
00:03:06.069 --> 00:03:09.211
you will be doing more work in your
recursive functions after this line.

54
00:03:09.211 --> 00:03:12.605
And it is important to recognize
that the stuff that's happens

55
00:03:12.605 --> 00:03:15.613
after this line like even
though this is the first call,

56
00:03:15.613 --> 00:03:19.280
anything that happens after this
line is actually happening last.

57
00:03:19.280 --> 00:03:21.447
So just keep that in mind.

58
00:03:21.447 --> 00:03:24.458
&gt;&gt; Speaker 2: What's the purpose of this
if it returns back undefined, right?

59
00:03:24.458 --> 00:03:27.521
So then why are we even doing this?

60
00:03:27.521 --> 00:03:32.823
&gt;&gt; Bianca: As an exercise on how we can
loop and how we can pass things around.

61
00:03:32.823 --> 00:03:36.934
And get to a certain base case
without having to worry about what is

62
00:03:36.934 --> 00:03:39.624
a intermediary step that
we need to take and

63
00:03:39.624 --> 00:03:43.200
what is our big picture
problem that we're solving.

64
00:03:43.200 --> 00:03:45.700
We're starting with a small problem,
which is like let's just loop and

65
00:03:45.700 --> 00:03:48.820
console log some stuff and
see how this executes.

66
00:03:48.820 --> 00:03:53.581
And then we're going to take this and
apply it to some subproblems right?

67
00:03:53.581 --> 00:04:00.161
Recursion is just all about breaking
a bigger problem into subproblems and

68
00:04:00.161 --> 00:04:04.658
In calculating,
calculating through each loop.

69
00:04:04.658 --> 00:04:10.042
Okay, so end plus hit return pops it off.

70
00:04:10.042 --> 00:04:14.717
So this is doing the exact same

71
00:04:14.717 --> 00:04:19.846
thing as,
&gt;&gt; Bianca: Our other one that we

72
00:04:19.846 --> 00:04:25.432
were doing earlier of this, which is
defining a function, calling it here.

73
00:04:25.432 --> 00:04:27.420
We're retaining access to the closure.

74
00:04:27.420 --> 00:04:32.217
So one is using a closure,
&gt;&gt; Bianca: With a recursion.

75
00:04:34.441 --> 00:04:36.906
&gt;&gt; Bianca: And this one is not.

76
00:04:36.906 --> 00:04:38.101
That's the difference.

77
00:04:46.078 --> 00:04:50.317
&gt;&gt; Bianca: Any questions about
the difference between these approaches?

78
00:04:52.937 --> 00:04:55.259
&gt;&gt; Speaker 3: So you said
the first one has a closure in it.

79
00:04:55.259 --> 00:04:57.590
&gt;&gt; Bianca: Yup.

80
00:04:57.590 --> 00:05:03.160
&gt;&gt; Speaker 2: But there's no returning
of the function, though, right?

81
00:05:03.160 --> 00:05:04.430
&gt;&gt; Bianca: No, yeah, that's a good point.

82
00:05:04.430 --> 00:05:09.351
So a closure happens
when you have a function

83
00:05:09.351 --> 00:05:14.406
inside of a function
which in javascript land

84
00:05:14.406 --> 00:05:18.972
is all the time, so it's kind of silly.

85
00:05:18.972 --> 00:05:27.170
However things get interesting when you
return a function that is in a closure.

86
00:05:27.170 --> 00:05:30.383
So that's when we can do the interesting
thing with the [INAUDIBLE],

87
00:05:30.383 --> 00:05:31.200
the generic [INAUDIBLE],

88
00:05:31.200 --> 00:05:35.280
is because we're returning a function that
has access to closure scoped variables.

89
00:05:35.280 --> 00:05:38.462
And so we have this interesting interface
where we can interact with scoped

90
00:05:38.462 --> 00:05:39.684
variables that are static.

91
00:05:39.684 --> 00:05:46.118
And then we can create new execution
context for our child function.

92
00:05:46.118 --> 00:05:50.584
So interesting things can happen when we
do that, but you don't have to do that for

93
00:05:50.584 --> 00:05:52.020
it to be a closure, yeah.

94
00:05:53.160 --> 00:06:00.504
And so end, for example, the fact that
we're referencing end while we're in here,

95
00:06:00.504 --> 00:06:04.896
is accessing the coder's coded variable,
yeah.

96
00:06:06.880 --> 00:06:10.493
&gt;&gt; Bianca: But you don't another vocab
words, just need to be able to make it

97
00:06:10.493 --> 00:06:14.186
work and understand how it runs
when you press the display button.

