[00:00:00]
>> Bianca: So next we're going to talk a little bit about two patterns for recursion. The first one is a wrapper function and the second is the accumulator pattern. I love my own jokes. So awesome, okay. So back to our looping. We are going to loop first, this is our original loop actually.

[00:00:24]
So the loop that we already did we are using a wrapper function. And in this one we are just passing a values each time. So, let's investigate how this loop works using our call back game, call stack game. All right, so let's call, what are we gonna call it with?

[00:00:46]
Let's just call it with one and three.
>> Bianca: So this is like our function's actually being called over here. And then somewhere else inside your execution environment of your browser, wherever you're running your JavaScript, this is happening,
>> Bianca: Over there. Okay, so i is one, and three is the end, okay?

[00:01:18]
So we're just gonna remove this console log.
>> Bianca: Just so that we have a little more space here. So we will start, so this is a lot shorter than the other one but it's doing the exact same thing. So we are going to check. Is i greater than three?

[00:01:42]
Yes, so we're gonna do the thing where we add our function to the call stack. Cuz we're executing the function and we are creating a new execution environment. All of these sculpt variables live in a separate world from these sculpt variables. How then do we get i and n in this execution context?

[00:02:03]
We get that by passing it in. So what do we pass in? And I'm just gonna put our line there. We are passing in i + 1, which is 2. And then end, we're not doing anything to it, 3. So we're just passing it through and then, so we see i is 2, n is 3.

[00:02:21]
That is still working for us. So we're going to call it again, we're going to add it to our call stack. Again we're just leaving off right here, just a little reference where we were before. So then, 2 [LAUGH] 2 plus 1 is 3. Okay, so is 3 less than 3?

[00:02:46]
No, so we have our implicit return. Implicit return, and we pop. Again, we are going to finish up where we left off with this line. We're gonna move down here. We're gonna have implicit return and pop. We're gonna continue here where this line is. And again, this is important if we were doing more work.

[00:03:05]
Which a lot of times you will be doing more work in your recursive functions after this line. And it's important to recognize that the stuff that happens after this line. Even though this is first call, anything that happens after this line is actually happening last. So just keep that in mind.

[00:03:21]

>> Speaker 2: What's the purpose of this if it returns back undefined, right? So why are we even doing this?
>> Bianca: Just as an exercise.
>> Speaker 2: Okay.
>> Bianca: On how we can loop and how we can pass things around and get to a certain base case. Without having to worry about what is an intermediary step that we need to take and what is our big picture problem that we're solving.

[00:03:43]
We're starting with a small problem which is, let's just loop and console.log some stuff, and see how this executes. And then we're gonna take this and apply it to some sub problems, right? Recursion is just all about breaking a bigger problem into sub problems, and calculating, calculating for each loop.

[00:04:04]
Okay, so implicit return pops it off. So this is doing the exact same thing as our other one that we were doing earlier which is, defining a function. Calling it here. We're retaining access to the closure. So one is using a closure with a recursion. This one is not.

[00:04:37]
That's the difference.
>> Bianca: Any questions about the difference between these approaches?
>> Speaker 2: So you said the first one has a closure in it?
>> Bianca: Yep.
>> Speaker 2: But there's no returning of the function, though, right?
>> Bianca: No, yeah, that's a good point. So this closure is not, so a closure happens when you have a function inside of a function, which, in JavaScript land is all the time, so it's almost silly.

[00:05:18]
However, things get interesting when you return a function that is in a closure. So that's when we can do the interesting thing with a memo wise, a generic memo wise. Is because we're returning that function that has access to closure scoped variables. And so we have this interesting interface where we can interact with scope variables.

[00:05:38]
That are static and then we can create new execution context for our child function. So interesting things can happen when we do that, but you don't have to do that for it to be a closure.
>> Speaker 2: Mm, okay.
>> Bianca: Yeah, and so end for example, the fact that we're referencing end while we're in here, is accessing variable.

[00:06:06]
Yeah, but you don't need to know the vocab words, just need to be able to make it work. And understand how it runs when you press this play button.

