[00:00:00]
>> Bianca: So next we're going to talk a little bit about two patterns for recursion. The first one is a wrapper function and the second is the accumulator pattern. [LAUGH]
I love my own jokes. So awesome. Okay, so back to our looping. We're going to loop first. This is our original loop actually.

[00:00:24]
So the loop that we already did, we're using a wrapper function, and in this one we are just passing our values each time. So let's investigate how this loop works using our call back game, call stack game. All right, so let's call, what are we gonna call it with?

[00:00:46]
Let's just call it with 1 and 3. So
>> Bianca: So this is our functions actually being called over here. And then somewhere else, inside your execution environment of your browser wherever you're running your javascript, this is happening
>> Bianca: Over there. Okay, so, I is 1 and 3 is the end.

[00:01:17]
Okay, so we're gonna remove this console log.
>> Bianca: Just so that we have a little more space here. So we will start, so this is a lot shorter than the other one, but it's doing the exact same thing. So we are going to check, is i greater than 3?

[00:01:42]
Yes. So we're gonna do the thing where we add our function to the call stack, cuz we're executing the function. And we're creating a new execution environment. All of these scope variables live in a separate world from these scope variables. How then do we get i and end In this execution contacts, we get that by passing it in.

[00:02:04]
So what do we pass in? And I'm just gonna put our line there. We are passing in i + 1, which is 2. And then end, we're not doing anything to it, 3. So we're just passing it through. And then, so we say i is 2, end is 3.

[00:02:21]
That is still working for us. So we're going to call it again, we're gonna add it to our call stack. Again we're just leaving off right here, just a little reference where we were before. So then 2+1=3. Okay, so is 3 less than 3? No, so we have our implicit return.

[00:02:48]
Implicit return, we pop. Again, we're gonna finish up where we left off with this line. And we're gonna move down here. Here we're gonna have our implicit return and pop. We're gonna continue here where this line is. And again, this is important if we're doing more work which a lot of times, you will be doing more work in your recursive functions after this line.

[00:03:09]
And it is important to recognize that the stuff that's happens after this line like even though this is the first call, anything that happens after this line is actually happening last. So just keep that in mind.
>> Speaker 2: What's the purpose of this if it returns back undefined, right?

[00:03:24]
So then why are we even doing this?
>> Bianca: As an exercise on how we can loop and how we can pass things around. And get to a certain base case without having to worry about what is a intermediary step that we need to take and what is our big picture problem that we're solving.

[00:03:43]
We're starting with a small problem, which is like let's just loop and console log some stuff and see how this executes. And then we're going to take this and apply it to some subproblems right? Recursion is just all about breaking a bigger problem into subproblems and In calculating, calculating through each loop.

[00:04:04]
Okay, so end plus hit return pops it off. So this is doing the exact same thing as,
>> Bianca: Our other one that we were doing earlier of this, which is defining a function, calling it here. We're retaining access to the closure. So one is using a closure,
>> Bianca: With a recursion.

[00:04:34]

>> Bianca: And this one is not. That's the difference.
>> Bianca: Any questions about the difference between these approaches?
>> Speaker 3: So you said the first one has a closure in it.
>> Bianca: Yup.
>> Speaker 2: But there's no returning of the function, though, right?
>> Bianca: No, yeah, that's a good point. So a closure happens when you have a function inside of a function which in javascript land is all the time, so it's kind of silly.

[00:05:18]
However things get interesting when you return a function that is in a closure. So that's when we can do the interesting thing with the [INAUDIBLE], the generic [INAUDIBLE], is because we're returning a function that has access to closure scoped variables. And so we have this interesting interface where we can interact with scoped variables that are static.

[00:05:39]
And then we can create new execution context for our child function. So interesting things can happen when we do that, but you don't have to do that for it to be a closure, yeah. And so end, for example, the fact that we're referencing end while we're in here, is accessing the coder's coded variable, yeah.

[00:06:06]

>> Bianca: But you don't another vocab words, just need to be able to make it work and understand how it runs when you press the display button.

