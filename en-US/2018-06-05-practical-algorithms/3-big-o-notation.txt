[00:00:00]
>> Bianca Gandolfo: So what if we have multiple expressions and we put them inside of a loop, like how do we reason with a function that in the function body has multiple expressions? And so if the way I think about it is if you have multiple expressions that are not inside of a loop I just add them together.

[00:00:21]
So if we have a bunch in constant time, I would just say, 1 + 1 + 1 equals 3. However, if these things get put inside of a loop, then you start to multiply it. So if you have a loop inside of a loop, right, we have n, a loop is linear, right?

[00:00:38]
We talked about that and if we have a loop inside of a loop, it's n times n, which is then quadratic. If we have three loops, n * n * n, however, we also need to think about what is going on inside of those loops. So if, inside of the loop, we're doing like recursion, you know, that could add some more things, and so depending on the time complexity of that method that you're calling, you need to just multiply it by n, inside of a loop,

[00:01:10]

>> Bianca Gandolfo: Otherwise just add it.
>> Bianca Gandolfo: Does that make sense? Questions about this?
>> Bianca Gandolfo: Okay.
>> Bianca Gandolfo: Okay so, what about of log n? So logarithmic time. So we don't really talk about logarithms anymore after like, I don't know, high school or something. Unless you're a scientist, I guess logarithms are really important if you deal with really big numbers or really small numbers, which is what we do if we're analyzing large sets of data.

[00:01:51]
I'm not going to teach you logarithms right now, but all you need to know really is that, logarhythmic time. So logarithms can have different bases, you can have base ten, you can have base two, and you can think about as your input increases, the work or the number of operations that need to be done decreases by a fraction.

[00:02:12]
So commonly if you are looping through an array, you have a loop and then every time you loop, you cut your problem in half. That is going to be a logarithmic time. So every time you loop, you only have to do work on half of your data set, or a third, or some fraction, right?

[00:02:34]
Logarithmic can be some fraction so, base two will be divided by two, base three, three, ten, etc. So as it increases, the difficulty, the time complexity increases at a fraction. So it grows really, really slow, which is good. Which is why it's pretty close here to constant time and it's often better than linear time.

[00:02:57]
When we have a large enough data sets that we care about this kinda stuff.
>> Bianca Gandolfo: So that's what you need to know about log n,
>> Bianca Gandolfo: Cool, and there's also n log n. N log n happens when you have a loop, and then you're also, you have a linear loop, and then you're also looping and cutting it in half.

[00:03:22]
So linear and then you're cutting it in half. And you multiply them together to make n log n. And we'll see an example of that later. So you'll put some examples to these vocab terms. Okay. Questions.
>> Speaker 2: So you mentioned different bases and how is that determined? Does it say base two or base ten.

[00:03:43]
Is that,
>> Bianca Gandolfo: It's when you divide it by. So if you're dividing your input by two, there's base two. If you're dividing it by ten, it's base ten. Typically, you're gonna see it divided by two mostly.
>> Speaker 2: Like a binary search.
>> Bianca Gandolfo: Yeah, exactly. Binary search, anything where you're cutting it in half.

[00:03:59]

>> Bianca Gandolfo: Okay so here's a little table to help us have some reference. So if we're just running a statement, like returning a value for example is constant time. Any sort of value lookup, array object, variable is gonna be constant time. Again, with the needle just going directly to where it is in memory, easy.

[00:04:24]
So loop, you can think of this as, loop that cuts the problem in half every time. N is just gonna loop through all of them. So anything where you have to look at everything at least once, is gonna be at least n, right. So n squared is gonna be double nested loops.

[00:04:42]
And we have triple nested loops n to the three or n cubed. So just a word of caution. I'm giving you some tools to make rough estimations here. This is not the full version of how to calculate time complexity. Which is deeply mathematical and really out of the scope of this workshop.

[00:05:05]
But what you need to be mindful of is what is n. Because you're going to have a lot of different data points and your methods and your algorithms. So you want to make sure that you're identifying what is the data set that's growing. And if you have more than one data set that has a variable length, you're gonna need to take that into consideration.

[00:05:23]
That's something that, when people get started with this, they just assume that n is always gonna be the length of the array, or n is always gonna be a certain input, and it's not necessarily so you need to really think about how your code is executing, and what is changing as your input changes?

[00:05:40]

>> Speaker 3: Can you provide a concrete example?
>> Bianca Gandolfo: Of what exactly?
>> Speaker 3: What you're describing?
>> Bianca Gandolfo: Of what I was describing, so like when there, I will in our future slides.
>> Speaker 3: Okay.
>> Bianca Gandolfo: Yeah, yeah, yeah, yeah. Yeah, and when we go through it I am going to ask you, okay, what is exactly in here and we are going to think about like what are the things that are changing?

[00:06:01]
Cuz that's one of the common mistakes, is assuming that n is a particular thing when it's not necessarily a particular,
>> Bianca Gandolfo: Input. And then we use m. Like we have another one, we'll use m to call it, to make it really confusing, cuz those are hard to say.

