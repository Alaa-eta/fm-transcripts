[00:00:00]
>> Brian: So for us, we're gonna do something with componentDidMount, except we're gonna do this on, not on search, so get rid of that. We're gonna do it on details.
>> Brian: So the first thing that we're gonna have to do here as unfortunately, this is a function component, right?

[00:00:25]
That's just a function that returns mark up. We're gonna have to convert this to an ES6 class which is something that you'll find yourself kind of going back and forth with sometimes. But that's normal and healthy. So I'm gonna say class details extends Component. And bring in Component up here.

[00:00:54]

>> Brian: Okay.
>> Brian: Then we're gonna turn this into our render method right here.
>> Brian: Then down here,
>> Brian: And then we need to turn the props up here. In fact, let me just get rid of that, and say props. Show is going to be a show.
>> Brian: And everywhere that we say props.show which I think is that just one place, right?

[00:01:49]
We're just gonna say this.props.show, because now it's gonna be on the context and not being passed in from the props.
>> Brian: So you're gonna notice up here that class is complaining is like, hey, this should be a stateless component, that's what the Airbnb config does for you, but it's normal, okay?

[00:02:19]

>> Brian: So what we're gonna do is we're gonna have this kind of request something from our fake API. This used to use the Open Movie Database which unfortunately went closed. So it's no longer so open, [LAUGH] understandably so. So I mocked out a fake API for you. So if you go over to your terminal really quick, open a new window.

[00:02:48]

>> Brian: I'm gonna go in to tolks/fem/complete mess, so I'm not gonna close by depth server. I'm gonna leave that open. But this one I'm gonna run yarn API, which I already included for you. And you're gonna get something that looks like this. Starting server import 3000, and what this is going to do is it's basically going to make a fake API for you.

[00:03:11]
That's gonna give you back ratings for your TV shows, it's random, right, I did not rate these myself, right. It's just randomly generated every single time.
>> Brian: Cool? So now, that this is an ES6 component, let's go ahead and, yeah, start requesting data. So by virtue of the fact that we only make the API request after the item has amounted to the dom.

[00:03:53]
We have this entrance state that we're going to be loading, right? Because it's going to load the first time without that rating. So that means that we need to load with the loading state and then eventually, render something else, that makes sense, right? This is good, this is why you don't make API request in component will mount, because you don't want to wait for your API request to finish before your render something.

[00:04:15]
You wanna render first, and then request something, and then render again once the data is back. That's why you do all these in component in mount. So let's create a new class in a new page called Spinner.jsx. And this will be a reusable component that we can use anytime we're loading.

[00:04:38]
So let's opt into flow, we're going to import React from react.
>> Brian: And we're going to import styled, and { keyframes } from styled-components. So I'm gonna show you another fun capability with styled-components. We can still do keyframe animations with them. So we're gonna do is we're gonna make a spin keyframe animation.

[00:05:12]
That's gonna be equal to keyframes which is another tags template literal. And I'm gonna go from { transform,
>> Brian: Rotate 0 degrees,
>> Brian: To transform rotate 360 degrees. Actually, I'm pretty sure now that I've written this out. I'm pretty sure you just need to, right? And then it infers the from?

[00:05:51]
Whatever the case, we're just gonna leave it, cuz that's what it is in my notes.
>> Brian: Okay, then we're gonna do const Image = styled.img.
>> Brian: And we're gonna say, animation. And then we're gonna put in spin.
>> Brian: 4 seconds infinite linear, and background image. Url (/public/image/loading.png). And then const Spinner equals an anonymous function that returns Image.

[00:06:54]

>> Brian: I guess you don't need that style. You don't need that background image. Okay, get rid of that.
>> Brian: /public/image/loading.png. And alt = loading indicator, and then export default Spinner.
>> Brian: Okay, so we created a new key frame up here. And what's going to be stored in this key frame is actually going to be the name, the generated name of that keyframe.

[00:07:37]
And then we're gonna be outputting that here in the animation for the CSS in the image tag, right. So now, we have this dumb components, this presentational component that we can just render anywhere that we want a nice little spinning pinwheel. Really nice for loading. Now, we have this spinner component that we can use anywhere that we're loading anything.

[00:08:01]
So we'll actually end of using it in a couple of places. Hence, why we made its own component, but this is kind of the gist of how you key frame animations with styled components, which I think is pretty slick in my opinion, okay. So now, we're going to use this inside of details.

[00:08:20]

>> Brian: So we're going to import Spinner from ./Spinner, okay.
>> Brian: And the other thing we're gonna import up here at the top is a library called axios. Import axios from axios, this is just an ajax client, I'm not it doesn't bother me if you don't like this one or want to use a different sort of ajax client.

[00:08:50]
Or if you just wanna write using the fetch API that all works for me. I'm just gonna use axios, because it's really easy and it's one that I've used for a long time. It's super reliable, it's also very easy to test with, which I will show you later how to test these ajax requests.

[00:09:06]
So suffice to say, that's where we're gonna use axios for now.
>> Brian: Okay, down here in details.
>> Brian: Had a prop type inside of show, yeah. Okay, so go back to your types.js real quick. And I already have it, so you don't need to do that. No problem, we're gonna go to details, cool.

[00:09:35]
And then we're gonna have some state up here at the top. So state =,
>> Brian: apiData, is that what it's stored in? Yep, apiData.
>> Brian: And its initial state is going to be an imdbRating.
>> Brian: Right?
>> Brian: So we're gonna request all of this information back from the API and one of the request, or one of the answers that's going to get back to us is this rating that we're going to display.

[00:10:11]

>> Brian: Okay, and then we're going to make a componentDidMount, I think it goes between these two, componentDidMount. And what we're gonna do is we're gonna do axios.get,
>> Brian: http://localhost:3000/$ this.props.show.imdbID, okay, this is going to get us the data from the API, it's going give us back a promise so we're going to say .then.

[00:11:01]

>> Brian: And we're going to get a response back from the API, so the response is going to look like
>> Brian: data: { rating: string }.
>> Brian: So, this is just typing for the data that we know we're gonna be getting back from the API. And coming here, then we're gonna say, this.setState, and that's gonna be apiData: response.data.

[00:12:11]

>> Brian: And I call this imdb, so let's just call this rating up here.
>> Brian: Okay, so just to recap here.
>> Brian: So the first thing it's gonna do is it's gonna do a .get on that local host 3000, providing your API server is running. So make sure your API server is running.

[00:12:42]

>> Brian: And it's going to go out and get from the imdbID, based on the imdbID, then it's going to give you back this response object which is gonna give you back data which is something that axios does. Then it's gonna do rating and that's gonna be a string and we're going to use that to set state, so that API data is gonna be replaced by whatever comes back from the API.

[00:13:03]

>> Speaker 2: There's just a comment in chat about why would you use axios versus fetch, and the fact is that you don't have to called.json and all of that stuff, it just sends all of the data as you'd expect. And then also error handling, you don't have to check if its response code is 200.

[00:13:21]
You just do a .catch and grab any errors.
>> Brian: It's a little bit more baked than just, it does a lot more for you than fetch does. In particular for this workshop, the reason why I chose it is that axios is very easy to test. And so, we're gonna be using that capability later.

[00:13:37]
Whereas with fetch, you have to do a little bit more mocking on your part. So, that's why I chose axios and again, I've been using axios for years, at this point.
>> Brian: Cool.
>> Brian: So now, we have that coming back from the API. So what we're gonna do here is underneath here, I'm gonna say, let ratingComponent.

[00:14:14]
And then we're gonna say if (this.state.apiData.rating). So if we have gotten this back from the APIi, then ratingComponent is going to be equal to an h3 with that rating, so it's gonna be {this.state.apiData.rating}, else ratingComponent is going to be equal to our Spinner.
>> Brian: So again, coming back to, you wanna think about your components in snapshots, right?

[00:14:56]
So given the snapshot that the API did has come back. It's gonna be equal to this h3 right here. Given the snapshot that has not come back from the API. It's gonna be this loading state, right?
>> Brian: Okay, and then what we're gonna do is we're going to put that between year and poster.

[00:15:18]
So right here and we're gonna say ratingComponent, cool? So if we come back here, let me go to one of our details page. Notice, we get this nice little spinner right there and it eventually resolves and gives us back a rating. So again, what that looks like.
>> Brian: I have it introduced in artificial delay, cuz it was coming back too fast.

[00:15:55]
So it's gonna come back between like zero and five seconds, so that's why it seems slow.
>> Brian: If you look that code ratings API,
>> Brian: See, it's just generating a random timeout there for five seconds. So that's why it seems slow, it's because it's intentionally slow.
>> Brian: Any questions?

[00:16:20]
Yeah.
>> Speaker 3: Yeah, just a general question about components. So in that if else, I just wanna make sure I understand. So we could capitalize the rating component, and then call it as in the or as-
>> Brian: So if you wanted to do that, what you'd have to do is, RatingComponent like this, right?

[00:16:40]
Then you would to make it a function.
>> Speaker 3: Okay.
>> Brian: And then here, you would say rating component like that, right? Same thing for the one up there, that's a bad idea, don't do that. [LAUGH] The reason why is we'd be creating a component, you'd be creating components, you'd be creating functions rather on every render which is slow.

[00:17:02]
Right, that's why we don't do dot buying before inside of the render body, you don't wanna be generating and destroying things on every render, cuz that's a lot of garbage collection that you don't want to go through. Does it make sense? Cool, that's a good question.
>> Brian: Other questions?

[00:17:28]

>> Brian: All right, so I don't know, I think this is pretty amazing. It just makes doing things like, requesting stuff from APIs and asynchronous data. Like thinking of things in terms of snapshots, it's just really makes sense for me, right. Given this data, it looks like this, right?

[00:17:48]
Before it gets stuff from the API it looks like this, after it gets stuff from the API it looks like this. There's no imperative like grab this thing and change this into HTML and then make sure later that it has changed. I don't know, it's crazy, having components just keep track of their state and then just referencing the state makes a lot of sense to me, personally.

