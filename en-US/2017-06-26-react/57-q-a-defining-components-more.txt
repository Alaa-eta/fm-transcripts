[00:00:00]
>> Speaker 2: This is just a question about defining components, when to use functional components versus class components.
>> Brian Holt: One, Airbnb's rules are going to yell at you, so that's a pretty good indication. But the principle underneath that is, if you have no state, if you have no life cycles or anything like that, it's a good idea to use functional components.

[00:00:27]
The reason why is that they're more simple and I'm a big believer in the, what is it the?
>> Brian Holt: Rule of the least powerful abstraction. So you want something that's the least powerful possible that fulfills what you're doing. And that kinda reduces your area for bugs, right? So there's not really a whole lot that can go wrong with the function, for example.

[00:00:52]
As soon as you start introducing classes, you have more to mentally parse to get through it. And then you have more power. You can have lifecycle methods, you can have state. You can have all these different things. Whereas a function is more simple, it's just, it's easier to not have bugs.

[00:01:11]
So that's my general principle of no life cycle methods and no state, than use a stateless functional component, otherwise use an ES6 class.
>> Speaker 2: You ever had to use context?
>> Brian Holt: I have, in fact in version two of this, we do talk about how to use context, just because it was necessary with previous versions of react router.

[00:01:40]
So, I showed you how to use props and I showed you how to use state. But there is a lurking third type of way to store your state which is called context. So instead of saying this.prop whatever, you're gonna say this.context.something, right? The difference between context and props is that, your app has one context, so as soon as I set context in one component, it's available everywhere in your entire app, right?

[00:02:07]
If that sounds scary to you, that's because it's scary. That's a bad idea, right? In fact, inside of the react document, it says, this is an experimental API and you should use caution when building up on this. It's been around for like, a year and a half, right?

[00:02:28]
So, it's not super experimental anymore. And there are people, in the react community, that are big applicants for using contacts and places. I have literally never set anything on contacts before. Like in all of my react apps that I've ever built, I've never had to use, I've never had to write to context.

[00:02:48]
The part where context is actually useful is for things like react router dom, right? So when it instantiates itself like here on app.jsx, what this component is going to do here, it's actually gonna set the router on context, right? And then when I go down into like showcard and I have a link right here, right, a link.

[00:03:13]
This link actually reads the router from context, so it's a great way for libraries to be able to connect with the components that they render out. So for that particular use case, I'm all for it. If you're writing a library that uses these higher order components. It makes a ton of sense.

[00:03:30]
If you're writing stuff yourself, it's a really bad idea. If you're trying to set something on context. You really need to ask the question of what am I doing. And why is this a good idea and can I do this differently. Can I achieve this with state? can I achieve this with props?

[00:03:44]
can I avoid setting context? When you start using context in a lot of places, this is where you need to start saying to yourself, I probably need something like Redux. So once you get to that point, you either go down the route of using context or you go down the redux using [INAUDIBLE].

[00:04:05]

>> Brian Holt: So, that's my spiel on context is I don't use it. Once I get to the point that I want to use it, I use Redux, but there are people that disagree with me.
>> Speaker 2: More interest in fiber but as you mentioned, you're not gonna cover it and it's.

[00:04:23]
Supposed to keep the API the same, so nothing in this workshop will change [CROSSTALK]
>> Brian Holt: Yeah, nothing in this workshop will change, except you won't be able to use the proof tools and the one thing that'll change with fiber that I don't really care about but I will show you nonetheless.

[00:04:41]
So you will be able to have multiple top-level returns.
>> Brian Holt: This does not work today, this will work with fiber. But I think that that's really it. That they're gonna do some other interesting things. Something that they're talking about doing, which will not ship with 16, so if I have something like, let's see, like search.

[00:05:15]

>> Brian Holt: Let's do our details. So here, I have componentDidMount, right? I'm doing axios here. And I'm using a promise here, eventually if they want to get to the point where all of these life cycle methods are async methods, so you can do async await, so I can do async componentDidMount and then instead I can say const response.

[00:05:47]
Equal await axios.get and then rather than doing all this then business down here, then it'll do like async/await. If that doesn't look familiar to you then I invite you to go look at what async/await does, but that's kinda one of their goals. And they're getting there but that's down the road.

[00:06:11]

>> Speaker 3: Follow up would be can you do that now with async 08 and the back poly fill with the ES 2017?
>> Brian Holt: Not with a lifecycle method.
>> Speaker 3: Okay, [INAUDIBLE]
>> Brian Holt: No, because it has to be invoked like an A sync method, right? And that doesn't work within the stack architecture.

[00:06:35]

>> Speaker 3: I see, thanks.

