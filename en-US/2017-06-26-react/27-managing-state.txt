[00:00:00]
>> Brian Holt: Let's go inside here and search. And I want you to put a header.
>> Brian Holt: And a h1 with the name of whatever you decided to call your video service. And then input type= 'text' placeholder ='Search'.
>> Brian Holt: Cool, save that. Check it out, you got a nice little header up here at the top now.

[00:00:35]
Wouldn't it be nice if all of your stuff just styled itself like this, right? That would be fun.
>> Brian Holt: But yeah, you should be seeing this little fixed header at the top.
>> Brian Holt: So now we have this input right here. It doesn't really do anything particularly interesting, I'll just put some inputs to that header.

[00:01:02]
But we have no access to this input anywhere in the header. So what we need now is we need react to keep track of whatever is in that input. Right now, we refer to this as an untracked input.
>> Brian Holt: Okay, so React has this other ability that we have not yet used called state, right?

[00:01:24]
So I guess something that we didn't mention is if we go down here to show card, we have this props.title, props.year, props.description. This data, this props object is immutable. You cannot change it. If I say props.poster equals something else it's not gonna actually change it, right? In fact, I think reactable will give you an error.

[00:01:48]
Or in other words, don't change it. [LAUGH] So, things that pass down from the parent to the child, can not be changed in anyway shape or form. It's totally up to the parent what to pass down and the child just gets whatever it gets, right?
>> Brian Holt: So that's useful, however, sometimes we need state.

[00:02:10]
We need things that are stateful. So react has this other concept beside props called state. So the peculiar thing about state is a component can have its own state, right? If we have some sort of if I click on s video and it goes bold or un-bold, right?

[00:02:27]
Depending on if I click on it or not. This particular component can keep track of its own state, but only a component can modify its own state. So for example, if ShowCard has state, the search can't modify a ShowCard state and vice versa showCard can't modify a searches state, right?

[00:02:49]
They can only each modify their own state. So again, if one of them has a problem, you know that the problem lies right there with the state. Furthermore, let's say I gave ShowCard state and if I have a problem with Atlanta state here, I can be assured that billions didn't cause it, right?

[00:03:10]
It must live within Atlanta so it can only modify it's own instance, right? So let's take a look at what that actually looks like.
>> Brian Holt: If you go here to Search and you wanna make Search be able to have it's own state. So far we've been using what are called functional components often called stateless functional components.

[00:03:32]
They are stateless functional components because as you see here, there's no mechanism to get the state. So we need to convert this to a different kind of component, which is called an ES6 class component. So what we're gonna do here is we're just gonna do a little bit of change.

[00:03:49]
I'm just gonna say class Search extends,
>> Brian Holt: Component, and we're gonna import Component up here.
>> Brian Holt: And we're going to remove that.
>> Brian Holt: Okay, and then this is going to be a render method.
>> Brian Holt: It's kind of awkward to get this going. But the nice thing, again, is that I don't have to format this.

[00:04:36]
Prettier it's gonna do it for me voluntarily. Lo and behold,
>> Brian Holt: It looks like this. Okay, so I have class Search extends Component, I imported a Component up here. You are equally working to say react.component. This is just how I prefer to do it.
>> Brian Holt: Okay, an lint error, for now, we're gonna fix that.

[00:05:06]
Basically what it's saying right now is, hey you don't have any state, this should be a stateless functional component. But we're going to need a state here in just a second. So ES6 classes, classes came with ES6. Much to the joy of Java developers everywhere. [LAUGH] Just kidding.

[00:05:31]
I like to prod Java developers. Keep in mind that these are like pseudo classes in the sense that these are not true classical inheritance, so don't treat them like Java classes. These are still protypal inheritance, just like it's always been in JavaScript. This is just a different way to write protypal inheritance.

[00:05:49]
So definitely keep that in mind. One thing about react component classes is that they must have a render method. 100% of the time without exception, must have a render method. So just keep that in mind. And the render method must return markup. That's really the only hard requirements of react components.

[00:06:16]
Everything else is kind of optional, okay?
>> Speaker 2: And the rendered math has the return markup?
>> Brian Holt: Mm-hm.
>> Brian Holt: Yep, yep, yep. Just like those stateless functional components, they also must return markup, right? It's the same kind of idea. So you can think of those function bodies of the stateless functional components as being the same as render, right?

[00:06:45]

>> Brian Holt: Okay, so now we have that, we've converted this to an ES6 class,
>> Brian Holt: [INAUDIBLE] we're gonna fix that momentarily.
>> Brian Holt: So what we're gonna do here is we're gonna make a constructor. And the constructor takes in props, and then it passes props up. This is kind of annoying about ES6 classes, you just have to do this.

[00:07:25]
This is just boiler plate that you have to do it this way. It takes in props and you have to pass it up. Then here we're going to say this.state. We're initializing our state here in the constructor and we're gonna keep track of the search term which is going to be, this is some sort of debug statement.

[00:07:50]

>> Brian Holt: Eventually we're gonna make this just an empty string to be initialized with but I want to put this debug statement there, so you can kinda see how we're using it. So now, we have some state for search.
>> Brian Holt: So what I want you to do is I want you to come in here and on the input say value={this.state.searchTerm}.

[00:08:30]

>> Brian Holt: Okay, so you should be able to save that and come back over to your browser, and you should see here the value of this is now tied to whatever the initial value of state was, right?
>> Brian Holt: Now I want you to try and type in there.
>> Brian Holt: I'm typing I promise, I'm not just making noises.

[00:08:55]
We broke it, right? It doesn't work.
>> Speaker 3: Log me out.
>> Brian Holt: [LAUGH] So, what happened, right? We broke the browser. That's actually pretty hard to do, right? Typically, breaking an input like this takes work. [LAUGH] So, let's evaluate what's actually happening here. So I press a key, right?

[00:09:20]
That fires off an event, that event is caught by react and then react says, an event happened, right? I'm gonna kick off a re-render. So it re-renders everything and then finds the diff of between what was there and what you're trying to put there now, right? So, in this particular case, if I type a letter, and then it re-renders, and it goes back to re-render this value right here, what is this .state.searchTerm?

[00:09:49]
Well, this is some sort of de-bug statement, right? And as soon as I press that key, nothing is modifying that, right? So, every time I kick off an event you still end up with that same string, right? Hence, that's why it never changes, right? Because whenever we kick off those events, nothing goes back and modifies the state.

[00:10:08]
So it's aways gonna re-render what it has. That make sense? So now we need to de-break that. So we need to give it an onChange handler. So onChange = {this.handleSearchTermChange}. And we'll create a method called handleSearchTermChange that takes an event and calls this.setState and searchTerm, which is going to be event.target.value.

[00:10:52]
So now we have this method here handleSearchTermChange which is going to get called every time a change event happens on this input, right? It in turn it's gonna call this.setState which is the way that you change state.
>> Brian Holt: So again it's do not do this.state.searchTerm = "blah", don't do that.

[00:11:17]
The reason being is this will work, this actually will modify the state. React doesn't put any safeguards in front of you. The problem is if you do that, React doesn't know something changed, right? It's not observing for those sorts of changes. You need to let React know, hey React, I called set state, now you need to kick off another re-render, right?

[00:11:39]
So that's how that happens. So that's why we call this.setState, this is just a way that we let React know, hey, I'm updating this, you need to kick off a re-render. I'm simplifying there. To be honest with you, it's actually batching your changes. So you can call setState a bunch of times in a row and it'll only kick off one re-render.

[00:12:00]
So you're kind of opting into that optimization path by using set state. Or in other words, do not modify state directly. That's the takeaway here, use setState. So if I save this, still not quite there, right? This still doesn't actually work. If you go back here and refresh and I type in here, you're gonna get all sorts of error messages.

[00:12:27]
It says you can't read set state of undefined. Why? Okay so I kicks off in of it. This is new as well. This finally are long enough that prettier set I'm gonna wrap this. So while this sets is weird for HTML to be written this way, this is very normal to see React in this way.

[00:12:48]
Once you start recon this really long HTML elements it's just easier to see it in multiple lines, it's how that happen. Okay so here, handleSearchTerm this gets called on every event, right? Where is this event handler called? The answer is, I don't know. I don't know where it's getting called but the answer is not here, right?

[00:13:10]
It's not getting called within this context. So what is this wherever handle search term is being called? Again, I don't know, but it's not search and it needs to be search, right? But because we're called this.setState on search, we want to modify that instance of search. So in another words we need to bind the context to be the correct context.

[00:13:35]
There's several ways to do this.I will show you the bad way, which inevitably you'll see someone write it this way because it's the lazy way to writing it. I could totally put.bind this, right? I'll save this. I'm sure Lint is going to yell at me. Js prac should not use .bind.

[00:13:56]
Good job, but it'll work, right? Now this works, and the state is being set correctly. Why is this bad? This is bad because, if you remember I was telling you, render gets called a lot, right? It gets called every single time that an event gets kicked off to make sure something changed or didn't change.

[00:14:20]
What happens when I call .bind? It's creating a new function every single time render gets called. Which, functions are cheap but they certainly are not free. And particularly bind, bind's a pretty expensive one. Recent versions of Chrome are a lot better, but if you're more than two or three versions old of Chrome, or pretty much any other browser, it's really expensive.

[00:14:44]
So, in other words, this is bad, do not do it, and if you see your colleagues do it, just throw something at them, right? So that one's out. So our answer is here, we're gonna say this.handleSearchTermChange = this.handleSearchTermChange.bind(this).
>> Brian Holt: This will happen once in the constructor and then it's forever working.

[00:15:14]

>> Brian Holt: So this looks super awkward, right? But now any time handleSearchTermChange gets called, we are guaranteed it is going to be in the right context. So again, if we come in here, now this works again, and we're not getting any errors.
>> Brian Holt: So you'll see this a lot.

[00:15:42]
This is valid ES6 today, everything works. This is the way, for example for a long time and that's right at this way.
>> Speaker 4: Supposing arrow function is just as expensive as using bind.
>> Brian Holt: Yeah, if you're creating an arrow function inside of here, yeah. It is.

