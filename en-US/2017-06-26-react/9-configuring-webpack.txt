[00:00:00]
>> Brian Holt: We're gonna go ahead and start with webpack. So let's go ahead and first make it necessary for us to have webpack. So here, in clienApp.jsx, rather than having React look like this up here, we're gonna say import React from 'react'. And we're gonna say import { render } from 'react-dom'.

[00:00:33]

>> Brian Holt: Okay, so these are ES6 modules, this is what they look like now. For those of you who are coming from a Node background or a common JS background, this is the same as const React = require ('react').
>> Brian Holt: But we're not doing this anymore, this is the old way of doing it.

[00:00:58]
And import React from 'react', this is the new way of doing it. Now you might ask yourself why are we doing it this way, why didn't we just stick to require because everything already supported require? Well, if you'll look at what this was there, this is dynamic, right?

[00:01:15]
We're feeding React in to a function that's gonna bring it in. Therefore, we could say require x, right, and x = 'react'. So this can be dynamic, which is cool. But to be honest with you, most of us were not using the dynamic functionality of importing modules. Some of us were, someone's gonna point that out to me.

[00:01:36]
But most of us, we're just using it statistically, right? Which is just exactly like this. You can't say import react from x, that's invalid, right? It's always going to be from that. So in light of this, if we do static modules as opposed to dynamic modules, this affords us some really cool things.

[00:01:56]
That, for example, we can have webpack go through all of our code and only include the things that are actually being included. So, an example of that would be, let's say how to module that export default, or let's say export const x = 5, and I have another that says export const y = 10, right?

[00:02:28]
So let's say I had a file that did this, that exported these two different constants, right? In another file I would say import, it's a different file.
>> Brian Holt: Import x from like, I'm in ClientApp right now, but it could be from MyModule, right? This is MyModule.
>> Brian Holt: What's cool about this is I'm only including x, right?

[00:03:03]
And I'm not including y. Webpack is smart enough to say now, because of static modules, y is never imported, I'm not going to include it. Now this is often referred to as tree shaking, right? That's the common terminology for this which is a total misnomer, right? Cuz tree shaking has the idea of like, we were gonna go through and shake all the dead things off.

[00:03:26]
It sounds like dead code or elimination which is not actually quite true. It's actually live code inclusion. [LAUGH] So it's actually going to only include things that could possibly be reached. As opposed to dead code elimination, it's going to go through your code and remove things that could not be run.

[00:03:44]
Largely, you're gonna end up at similar situations, but let's be accurate here, right? So, [COUGH] that's why we went with this new module system is it can be statically analyzed by our tools and we can start pruning things off that don't need to go down the wire, right?

[00:03:59]
That's really important to us because we're trying to constantly get things down in terms of file size.
>> Brian Holt: So, notice that I'm saying, include only render from react-dom. Now I have no idea how react-dom is actually structured. But ideally if render is not importing other things and react-dom was built with this static analysis in mind, we could only include the render function.

[00:04:26]
We could leave everything else behind. I don't know if that actually happens or not, but it's just a good idea to only include the things that you need. So just in case they built in such a way that or maybe in the future, it gets built in such a way that you're only including code that could possibly be run.

[00:04:41]
So that's what these curly braces mean. It means I'm only including this particular piece. So down here, instead of saying ReactDOM.render, I'm actually just gonna say render, right? Cuz these two we've referenced to each other, render and render. That make sense? Now, notice I don't have curly braces around React.

[00:05:02]
I'm including the entire package here. So if you remember here, I had export const x = 5, right?
>> Brian Holt: So, if I say export default 5, right, that's what you're getting here. That's the default export.
>> Audience 1: If you mixed in a require in there, if you did have a dynamic module that was being loaded, would webpack just skip over it then?

[00:05:32]

>> Brian Holt: I think the answer to that question is it would just compile them to be the same thing. I think it would actually work, it's not valid, right? But I think it would still work with webpack.
>> Brian Holt: The real answer to that question is you can still do dynamic imports, it's just done differently now.

[00:05:54]
We're gonna talk about it at the end of the third day. But there's a thing called import as a function, right? And this is going to be how we do dynamic imports now. And then you can say, promise.then(React).
>> Brian Holt: Right, and then you can start working with React inside of that promise body.

[00:06:22]
So it's also asynchronous.
>> Brian Holt: So semantically it's a bit different, but this is ultimately going to be better for us. It's gonna be better for the web. Okay, so now this doesn't work. [LAUGH] We broke it, because this has to be compiled now. Because right now, well actually, Chrome does support a little bit of ES6 modules native to the browser.

[00:06:51]
But we're not going to be doing that today. So we need to run this through webpack now, so that webpack can go out and grab React. It can go out and grab react-dom, compile them together, and send down one file.
>> Brian Holt: So,
>> Brian Holt: What we're gonna do here is, there it is.

[00:07:20]

>> Brian Holt: We're gonna go to the command line and we are gonna say,
>> Brian Holt: First of all, you're going to have to do a either a yarn global add or a npm install--global
>> Brian Holt: If you're getting sick of this, there's also kind of a little cheat that you can do here.

[00:07:38]
You can also say ./node.modules.bin/webpack. This should work for all of you if you've done the Yarn installs. So inside of bin is gonna be all of the different things that are being included into our project. So we can call eslint from there, we can call flow from there, prettier, all these different things.

[00:08:03]
So, if you want to you can do that as well, or you can just install it globally. That's kind of up to you. I have installed globally so I'm just gonna do it that way. Maybe I don't, so I'm gonna do it that way, node_modules/.bin/webpack.
>> Brian Holt: Then the entry file is going to be client or it's gonna be jsx, ClientApp.jsx.

[00:08:25]
And then I'm gonna have it output to public/bundle.js
>> Brian Holt: So you can see now, it took in this file ClientApp.jsx and it output bundle.js. So now if you go into js, sorry not js, if you go into public you should see a file called bundle.js.
>> Brian Holt: And you can see that it has all this stuff in there.

[00:09:07]

>> Brian Holt: Did I not save this? I did not save it, okay. This should be a lot bigger now because it's going to include, let me run it again.
>> Brian Holt: There you go, okay. Yours should look something like that, right? Basically it's saying, I need to include all of this stuff, right?

[00:09:32]
Cuz this is all the stuff coming from React and I outputted a bundle that is 739 Kb. Seems reasonable, doesn't it? [LAUGH] It's not, it's not reasonable at all. But you have to keep in mind this is unminified, this is ungzipped and this is the development build, right?

[00:09:50]
So we're building specifically now for our purposes. This is gonna be code that's easier to read, so you can actually open up the bundle and read it. And it's gonna be a version of React that has all of like the developer warnings and all that kind of stuff available.

[00:10:04]

>> Brian Holt: So when we build this for production, it's gonna be much smaller, right? Cuz it's gonna be minified, it's gonna be gzipped, it's gonna be treeshook, it's gonna be all of those different things.
>> Brian Holt: Okay, so now if you go to index.html. And we have the script right here, we're gonna say src= public/bundle,

[00:10:34]

>> Brian Holt: .js, right? And now we don't have to include these two script tags up here either, right? Cuz they're already being included with our bundle. So this is one of the nice parts about webpack is every time I include a module I don't have to go add another script tag.

[00:10:51]
It's just going to always be included in that bundle.
>> Brian Holt: So I should be able now to go to this, and I can refresh and it still works, right? Everything's still being included.
>> Brian Holt: You can see that it's only including bundle. Which if you look at how big it is, it's quite large.

[00:11:25]

>> Brian Holt: You can see it's huge.
>> Brian Holt: I mean look at that, look on the side there, it's just astronomically huge. But this is literally the entire library for React unminified with all of the development helpers. Any questions about webpack?
>> Audience 2: Can you go back to the ClientApp again?

[00:11:51]

>> Brian Holt: Yeah.
>> Audience 1: How does it know how to do that without any webpack config for l?
>> Brian Holt: Well, we're just using all the default settings.
>> Audience 1: And webpack already has that out of the box?
>> Brian Holt: Yeah, it's actually, people like think that webpack is a big complicated beast for sure.

[00:12:16]
It doesn't have to be a big complicated beast. The only thing that it's bare minimum that it requires, it requires an entry point which we gave it, ClientApp. And it requires an exit point which is Bundle.js, everything else we can just rely on webpack to take care of.

[00:12:35]
Now don't get me wrong, we're about to make a big ass config file, right? Because we don't want the default build, but by in itself this works as is. Webpack can be configured through the CLI, I guess that's what I'm trying to get at here.

