[00:00:00]
>> Brian Holt: Now, we want to go make search uses as well, right? So, go back to search jsx. We have this imput here and the first thing Im just going to do is pull this input out, go back to header. So, if space Does want to use the input, it's going to look like the one that we had there.

[00:00:29]
So, it's gonna be a bit of a problem for us because
>> Brian Holt: Handle search term doesn't happen in header. In fact, header has no concept of what handling a search term is. It doesn't keep track of it. And, that's not important in header. Right? So, we need, well, let's go ahead and pull that out, and say header, right?

[00:00:57]
import header up here. import header from ./header.
>> Brian Holt: And the first thing I wanna say is showSearchTerm or showSearch, right?
>> Brian Holt: But the problem is, the input that modifies this searchTerm right here, lives in header now, right? So, we kinda have this problem because it's not like header can reach up to the parent and modify state.

[00:01:26]
We talked about that right. Only a component can modify its own state. This is kind of a problem right. Because we have this encapsulation state and encapsulation is a good thing right. Knowing where state gets modified is a big part of debugging. But sometimes other things need to modify each other right.

[00:01:44]
While there's kind of this escape hatch that we have this handle search term change, right? This already exists. Why can't we just pass that down to the child? So we can just say HandleSearchTermChange={this .handlesearchtermchange}. Right, so now we're passing this function down into the child and now the child has a function called this.props.handlesearchtermchange that I can call with whatever happening right.

[00:02:24]
Another thing that it's gonna need as well because it needs to display the search term is it's also gonna have to have searchTerm equals this.state.searchTerm. So, can I make this multiple lines cuz it's getting hard to read.
>> Brian Holt: Nope, won't let me. Thanks.
>> Brian Holt: Right, so we're gonna be passing these things down into Header so then Header's gonna know what to do with these.

[00:02:59]
So, come back down to Header and now, we have a couple more props coming in. Which are gonna be all maybe types, so handleSearchTermChange?: is going to be a capital F Function. The reason why it's not lowercase f function is because that's a keyword, right? So they use capital F to get around that.

[00:03:24]
And then search term question mark is going to be a string. I'm going to come down here to the defaultProps and handleSearchTermChange is just going to be by default a noop function.
>> Brian Holt: And searchTerm, if nothing is provided it's going to be an empty string. These are actually not really super important because we're gonna be careful to not read from these.

[00:03:54]
But this is just kind of further guarding yourself against run time errors. It's also required by the linter, so we're placating the linting gods.
>> Brian Holt: Okay, so now this input onChange this.props.handleSearch TermChange And value is not going to be this.state, it's going to be this.props.searchTern.
>> Brian Holt: I think those are right, let's just run our Yarn flow.

[00:04:41]
Make sure that's correct. No, it's not. Right. The reason why is it's not this anymore, right. Because header is a functional component, it's not this.props, it's just props.
>> Brian Holt: Okay. Now all of the linting gods are happy. So now if we go back to here, and go back, just a hard refresh to make sure.

[00:05:14]
If I type black in here, it's still doing our searching, right? This is the way you have child and parent components interact with each other is you pass functions up and down. Well, just down, really. So the child has to let the parent know, like "hey, parent. I had a an event, this happened." But the cool thing is, if you go up here to search, search is still in charge of it's own destiny, right?

[00:05:40]
There's nothing from stopping me from saying, "you know what, I'm not gonna handle that event, right? So, the parent is still responsible for modifying its own state, it's just the child is reaching up and saying, this happened. Now, it's your problem, right? Any questions about that?
>> Audience 1: Can you click on header?

[00:05:59]

>> Brian Holt: Yeah, sure. I'll push a branch right here momentarily here as well.
>> Brian Holt: It's worth talking about this as well. This if statement right here, this is kind of the way that you do conditionals, like conditionally showing and hiding things. You just create a variable, in this case I called it utilSpace, right?

[00:06:19]
If I'm gonna showSearch, then put this input there. If not, show the Back button. You can get clever with ternaries. I do not like getting clever with ternaries. So that's why I do not do it, right. I could do something like props.utilSpace, or showSearch, right. And then if that, then h1 showSearch.

[00:06:43]
else h2 don't show search, right? This would work as well. Some people like it, I don't like it at all.
>> Brian Holt: There's an upcoming JavaScript
>> Brian Holt: Feature called do expressions which we're not gonna go over since it's like stage one or something like that but this would solve a lot of this stuff, as well.

[00:07:22]
Basically, the idea is, you could say, inside of here, do something like that. And then you can actually write a block of code in here. And you could do like the conditions in line that way. Again, I think it would look something like this. If show (prop showSearch) then each one here else < h2 > show this, right?

[00:07:56]
This is what it would look like with the do expression. It looks kinda weird, right. But anyway, that's kind of the way it works.
>> Brian Holt: You can ask yourself if you like that better, I'm not sure I do.
>> Brian Holt: I like this as well because it's explicit at the top.

[00:08:19]
You can say I have this util space and then when I'm reading this down here. It's like okay. Either this or [INAUDIBLE] just going to show up down there. So, up to you.

