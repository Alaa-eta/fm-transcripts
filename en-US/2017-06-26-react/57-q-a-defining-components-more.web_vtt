WEBVTT

1
00:00:00.460 --> 00:00:03.320
&gt;&gt; Speaker 2: This is just a question
about defining components,

2
00:00:03.320 --> 00:00:06.650
when to use functional components versus

3
00:00:07.731 --> 00:00:09.465
class components.
&gt;&gt; Brian Holt: One,

4
00:00:09.465 --> 00:00:14.140
Airbnb's rules are going to yell at you,
so that's a pretty good indication.

5
00:00:14.140 --> 00:00:19.060
But the principle underneath that

6
00:00:20.170 --> 00:00:23.640
is, if you have no state,
if you have no life cycles or

7
00:00:23.640 --> 00:00:27.640
anything like that, it's a good
idea to use functional components.

8
00:00:27.640 --> 00:00:32.416
The reason why is that they're more
simple and I'm a big believer in the,

9
00:00:32.416 --> 00:00:39.124
what is it the?
&gt;&gt; Brian Holt: Rule

10
00:00:39.124 --> 00:00:40.690
of the least powerful abstraction.

11
00:00:42.230 --> 00:00:45.010
So you want something that's the least
powerful possible that fulfills

12
00:00:45.010 --> 00:00:45.720
what you're doing.

13
00:00:45.720 --> 00:00:49.650
And that kinda reduces your area for
bugs, right?

14
00:00:49.650 --> 00:00:52.610
So there's not really a whole lot that can
go wrong with the function, for example.

15
00:00:52.610 --> 00:00:54.920
As soon as you start introducing classes,

16
00:00:54.920 --> 00:00:57.870
you have more to mentally
parse to get through it.

17
00:00:57.870 --> 00:00:59.990
And then you have more power.

18
00:00:59.990 --> 00:01:02.240
You can have lifecycle methods,
you can have state.

19
00:01:02.240 --> 00:01:04.430
You can have all these different things.

20
00:01:04.430 --> 00:01:10.160
Whereas a function is more simple,
it's just, it's easier to not have bugs.

21
00:01:11.180 --> 00:01:15.868
So that's my general principle of
no life cycle methods and no state,

22
00:01:15.868 --> 00:01:20.887
than use a stateless functional component,
otherwise use an ES6 class.

23
00:01:24.397 --> 00:01:28.490
&gt;&gt; Speaker 2: You ever had to use context?

24
00:01:28.490 --> 00:01:30.431
&gt;&gt; Brian Holt: I have,

25
00:01:30.431 --> 00:01:34.630
in fact in version two of this,
we do talk about how to use context,

26
00:01:35.680 --> 00:01:38.360
just because it was necessary with
previous versions of react router.

27
00:01:40.080 --> 00:01:43.480
So, I showed you how to use props and
I showed you how to use state.

28
00:01:43.480 --> 00:01:46.810
But there is a lurking
third type of way to store

29
00:01:46.810 --> 00:01:48.740
your state which is called context.

30
00:01:49.920 --> 00:01:52.292
So instead of saying this.prop whatever,

31
00:01:52.292 --> 00:01:55.433
you're gonna say this.context.something,
right?

32
00:01:55.433 --> 00:01:58.830
The difference between context and
props is that,

33
00:02:01.030 --> 00:02:05.340
your app has one context, so
as soon as I set context in one component,

34
00:02:05.340 --> 00:02:07.680
it's available everywhere
in your entire app, right?

35
00:02:07.680 --> 00:02:12.550
If that sounds scary to you,
that's because it's scary.

36
00:02:12.550 --> 00:02:13.910
That's a bad idea, right?

37
00:02:14.930 --> 00:02:19.150
In fact, inside of the react document,
it says,

38
00:02:19.150 --> 00:02:25.460
this is an experimental API and you should
use caution when building up on this.

39
00:02:25.460 --> 00:02:28.250
It's been around for like,
a year and a half, right?

40
00:02:28.250 --> 00:02:30.020
So, it's not super experimental anymore.

41
00:02:31.050 --> 00:02:33.750
And there are people,
in the react community,

42
00:02:33.750 --> 00:02:36.860
that are big applicants for
using contacts and places.

43
00:02:37.930 --> 00:02:40.520
I have literally never set
anything on contacts before.

44
00:02:41.610 --> 00:02:45.790
Like in all of my react apps that I've
ever built, I've never had to use,

45
00:02:45.790 --> 00:02:47.370
I've never had to write to context.

46
00:02:48.550 --> 00:02:50.940
The part where context is
actually useful is for

47
00:02:50.940 --> 00:02:53.760
things like react router dom, right?

48
00:02:53.760 --> 00:02:56.625
So when it instantiates
itself like here on

49
00:02:56.625 --> 00:03:03.140
app.jsx, what this component
is going to do here,

50
00:03:03.140 --> 00:03:06.760
it's actually gonna set
the router on context, right?

51
00:03:06.760 --> 00:03:10.520
And then when I go down
into like showcard and

52
00:03:10.520 --> 00:03:13.460
I have a link right here, right, a link.

53
00:03:13.460 --> 00:03:19.070
This link actually reads the router
from context, so it's a great way for

54
00:03:19.070 --> 00:03:23.520
libraries to be able to connect with
the components that they render out.

55
00:03:23.520 --> 00:03:25.740
So for that particular use case,
I'm all for it.

56
00:03:25.740 --> 00:03:28.790
If you're writing a library that
uses these higher order components.

57
00:03:28.790 --> 00:03:30.460
It makes a ton of sense.

58
00:03:30.460 --> 00:03:33.650
If you're writing stuff yourself,
it's a really bad idea.

59
00:03:33.650 --> 00:03:35.170
If you're trying to set
something on context.

60
00:03:35.170 --> 00:03:37.750
You really need to ask
the question of what am I doing.

61
00:03:37.750 --> 00:03:40.580
And why is this a good idea and
can I do this differently.

62
00:03:41.750 --> 00:03:43.430
Can I achieve this with state?

63
00:03:43.430 --> 00:03:44.970
can I achieve this with props?

64
00:03:44.970 --> 00:03:46.090
can I avoid setting context?

65
00:03:46.090 --> 00:03:51.040
When you start using context in
a lot of places, this is where

66
00:03:51.040 --> 00:03:56.032
you need to start saying to yourself,
I probably need something like Redux.

67
00:03:56.032 --> 00:04:00.541
So once you get to that point, you either
go down the route of using context or

68
00:04:00.541 --> 00:04:06.017
you go down the redux using [INAUDIBLE].
&gt;&gt; Brian Holt: So,

69
00:04:06.017 --> 00:04:10.950
that's my spiel on context
is I don't use it.

70
00:04:10.950 --> 00:04:13.382
Once I get to the point that I
want to use it, I use Redux, but

71
00:04:13.382 --> 00:04:19.275
there are people that disagree with me.
&gt;&gt; Speaker 2: More

72
00:04:19.275 --> 00:04:23.960
interest in fiber but as you mentioned,
you're not gonna cover it and it's.

73
00:04:23.960 --> 00:04:26.567
Supposed to keep the API the same,
so nothing in this

74
00:04:26.567 --> 00:04:29.383
workshop will change [CROSSTALK]
&gt;&gt; Brian Holt: Yeah, nothing in this

75
00:04:29.383 --> 00:04:33.317
workshop will change, except you won't
be able to use the proof tools and

76
00:04:33.317 --> 00:04:37.314
the one thing that'll change with fiber
that I don't really care about but

77
00:04:37.314 --> 00:04:38.910
I will show you nonetheless.

78
00:04:41.130 --> 00:04:44.423
So you will be able to have
multiple top-level returns.

79
00:04:48.502 --> 00:04:50.156
&gt;&gt; Brian Holt: This does not work today,

80
00:04:50.156 --> 00:04:51.890
this will work with fiber.

81
00:04:56.420 --> 00:04:57.440
But I think that that's really it.

82
00:04:59.650 --> 00:05:02.130
That they're gonna do some
other interesting things.

83
00:05:03.640 --> 00:05:06.850
Something that they're
talking about doing,

84
00:05:06.850 --> 00:05:11.744
which will not ship with 16, so
if I have something like, let's see,

85
00:05:11.744 --> 00:05:18.430
like search.
&gt;&gt; Brian Holt: Let's do our details.

86
00:05:18.430 --> 00:05:21.240
So here, I have componentDidMount, right?

87
00:05:21.240 --> 00:05:22.470
I'm doing axios here.

88
00:05:22.470 --> 00:05:28.430
And I'm using a promise here,
eventually if they want

89
00:05:28.430 --> 00:05:33.990
to get to the point where all of these
life cycle methods are async methods,

90
00:05:33.990 --> 00:05:40.870
so you can do async await, so
I can do async componentDidMount and

91
00:05:40.870 --> 00:05:47.475
then instead I can say const response.

92
00:05:47.475 --> 00:05:50.383
Equal await axios.get and

93
00:05:50.383 --> 00:05:56.454
then rather than doing all
this then business down here,

94
00:05:56.454 --> 00:06:00.260
then it'll do like async/await.

95
00:06:00.260 --> 00:06:02.648
If that doesn't look familiar to you
then I invite you to go look at what

96
00:06:02.648 --> 00:06:06.540
async/await does, but
that's kinda one of their goals.

97
00:06:06.540 --> 00:06:08.923
And they're getting there but
that's down the road.

98
00:06:11.243 --> 00:06:14.910
&gt;&gt; Speaker 3: Follow up would be can you

99
00:06:14.910 --> 00:06:19.274
do that now with async 08 and

100
00:06:19.274 --> 00:06:25.260
the back poly fill with the ES 2017?
&gt;&gt; Brian Holt: Not

101
00:06:25.260 --> 00:06:26.781
with a lifecycle method.
&gt;&gt; Speaker 3: Okay,

102
00:06:26.781 --> 00:06:28.079
[INAUDIBLE]
&gt;&gt; Brian Holt: No,

103
00:06:28.079 --> 00:06:31.440
because it has to be invoked
like an A sync method, right?

104
00:06:32.700 --> 00:06:35.378
And that doesn't work within
the stack architecture.

105
00:06:35.378 --> 00:06:37.690
&gt;&gt; Speaker 3: I see, thanks.

