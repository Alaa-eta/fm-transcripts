[00:00:00]
>> Brian Holt: Let's go make our other routes enabled. Let's go to app.jsx. I want you to delete both details and search. After this I will push another branch.
>> Brian Holt: And what I want to do here, just make sure I get this correct.
>> Brian Holt: I'm gonna do another AsyncRoute. Props is gonna be equal to props.

[00:00:44]

>> Brian Holt: Actually props is going to be equal Object.assign. We're gonna have an object of shows cuz we're gonna to have to pass in preload.shows cuz it's what we were doing before.
>> Brian Holt: ,props, so we're making sure that we're also bringing in all the props as well.
>> Brian Holt: So that is object out of sign.

[00:01:16]
That's the end of props.
>> Brian Holt: And then here, we're also gonna have to pass in loadingPromise, which is going to be equal to import search ./Search. That should be enough, okay so that's our second route. And then the last route here, we are going to mess around with this component here.

[00:01:48]

>> Brian Holt: So down here what we are going to return is instead of returning details right here, we are going to return async route.
>> Brian Holt: Props is going to be equal to.
>> Brian Holt: Again Object.assign and show is going to be selected show.
>> Brian Holt: And do we really need that?

[00:02:27]
I hope we don't need that.
>> Brian Holt: And props.
>> Brian Holt: Okay, so to placate the type checker and saying, hey I need you to guarantee me that match is coming because details depends on match, if you remember that. So just to placate the type checker, just to make sure that always come through is we're gonna pass it match that way.

[00:03:13]
Oops.
>> Brian Holt: Match. So what happened here
>> Brian Holt: And we're gonna say match colon that, okay.
>> Brian Holt: Now, what are you mad about? And you need loading promise, obviously. So the other thing you could do if you didn't want this type error, is you could go make match or maybe type and then do default props.

[00:03:57]
And that would work okay. I don't really have a problem doing with this either way. It's up to you. loadingPromise is going to be equal to ./details. So again another reason why I left flow here is I totally forgot to put loading promise on there. But flow is quick to say hey you promised me that this loading promise is coming in.

[00:04:19]
Where is it? Right? And it just instantly reminded me to do that. So it's just very tight feedback loop coming from the type checker.
>> Speaker 2: Don't you have to import that?
>> Brian Holt: You do, thank you. Import, so again if you see right there, it was erroring out. It's saying you're passing me a string and I want to promise.

[00:04:49]

>> Brian Holt: Okay. So now if we go to our webpack console, we should see three different bundles right? So if we go down here all the way to the bottom, you're gonna see 0.bundle, bundle, bundle 4, bundle.5. So it's actually being quite a bit stuff going out here. And a lot of times I get to bundle in weird and mysterious ways.

[00:05:10]
Sometimes you will have two bundles that'll share a library so it will spit that out into a yet different bundle. So that the last bundle doesn't have get it and only the other two have to get it. It does some really clever stuff that it's only possible if the machine is analyzing your dependency graph and not you.

[00:05:30]

>> Brian Holt: So again, I got bundle and 5.bundle.js. As soon as I go to Browse All, I'm gonna get 0. And as soon as I go to the last one, I'm gonna get 4. And then again, I can go back, and it's not going to request it after that, cuz it's already in the cache.

[00:05:45]
And webpack is very good about keeping that cache so you can keep handing it to it. So pretty awesome. Any questions about that? Well, let me pose a question on your behalf. What we're doing server side rendering and if you look at our server side rendering. Well we're not doing service site rendering now.

[00:06:10]
But when we do service site rendering. I think we can just do that right now. Yes, that should work. Yarn start. Shut that down. Whatever. Screw you hot module reload.
>> Brian Holt: If you look here at the output of it, we're getting the loading spinner as the output, right?

[00:06:42]
Because the first load is going to be the loading spinner. That's what we expect. So this is the dark side of splitting your code, is there's not really a good way of doing server-side rendering and code splitting because those initial renders are never going to match up. And so what's gonna happen is you're gonna load that markup.

[00:07:05]
And say your able to inject that component so it's loading synchronously on the server. It gets sent down to the client. React is gonna say this is different than what I render. My first render is a loading spinner. I'm gonna blow this away. But then it blows that away, puts the loading spinner up, and then it's gonna reload the one that you have.

[00:07:24]
And right now it's kind of an unavoidable problem. Just by the architecture of web pack, we really can't get around it. So, we're working on it is the answer to that question. The web pack team's aware of it, there's a couple, James Kyle put out a component called react-loadable that kinda seeks to sidestep it.

[00:07:46]
But suffice to say that for today we're not going to be able to sidestep it. So server side rendering and code splitting are kind of choose one right now. And it's kind of up to you to decide which one is the best one.
>> Brian Holt: Don't get me wrong.

[00:08:02]
You can do both. There's some difficulties in getting it to work.
>> Brian Holt: Any other questions?
>> Speaker 3: So for our purposes we just have to change the web pack config, right? From the server side to the client side? With the HMR? Like when we read this? Do we change it back to the-

[00:08:26]

>> Brian Holt: The dev server?
>> Speaker 3: Yeah.
>> Brian Holt: Yeah. I did. But it's easier to work with.
>> Speaker 3: Yeah.
>> Brian Holt: Yeah.

