[00:00:00]
>> Brian Holt: Hopefully, we had a really good experience learning React. What we wrote was totally complete. I'm happy with that architecture and I think you can scale that to, well, let me rephrase that. I have personally scaled that architecture to large applications. Now we're going to introduce you to another concept which is Redux, right?

[00:00:19]
Redux is not married to React at all. They're two totally separate libraries. It was birthed for sure in the React community, hence, why it actually lives in the React-js repo. But it is totally acceptable to use Redux with Angular, with Ember, or by itself. Redux by itself, is not a particularly verbose framework for storing data.

[00:00:46]
There's actually a gist out there you can write Redux in 80 lines of code, like bare minimum. It's not like code call for anything like that. There's not a lot to Redux. That being said, it's hard, right? And I just wanna re-emphasize, throughout this entire course, if any of this feels hard, or unapproachable, or anything like that.

[00:01:10]
It's cuz it is hard. We're learning some hard stuff here. All of this stuff is hard. So, I permiss you to feel like this is hard, right? Sometimes it's good just to have acknowledged that we're doing hard stuff together, right? That being said, we're about to do harder stuff together.

[00:01:31]
Integrating reaction Redux is going to make our architecture more complicated. And you'll see here, I want you to make your own judgment calls here. But it's going to make it overly complicated to the point that what we're going to do is actually not worth it for this size of application.

[00:01:48]
But again, that's my opinion, and I want you to make your own decision. But I don't integrate Redux until further along in the project life cycle. I wait for Redux to become necessary before I integrate it, which is what I'm gonna suggest to you, as well.
>> Brian Holt: A Redux was invented by Dan Abramov, a really smart and nice guy.

[00:02:14]
He based it on Facebook's Flux architecture, and also a bit on Elm's architecture, as well. So those kind of ideas combined in his mind cuz he wanted to write a data store that was hot reloadable. What we were just looking at, and he came up with Redux. Redux is really similar to Flux.

[00:02:33]
A lot of you have probably heard of Flux before, that came out at the same time as React from Facebook as well. And Flux is a really interesting idea, that you have data stores and you dispatch actions into the data stores which then modify themselves, and then update whatever view layer, in this case React, is subscribed to it.

[00:02:59]
The difference between Flux and Redux is with Flux, you have many stores, right? They're kinda like single concern stores. So, for example, you'd have maybe a user store, then you'd have a messages store, and then you'd have all these different kind of stores that like worry about one particular thing.

[00:03:20]

>> Brian Holt: [COUGH] I attended a talk from a Facebook engineer that told me on their ads product, at its height, it had over 100 stores on the page. Now, as you may imagine, that's a nightmare, right? Trying to figure out what data goes into what store is, at least at that scale, unscalable.

[00:03:42]
It became more complicated than it was worth. And so, and particularly, let's say we had an animation that were animating a component across an entire page, right? That was almost impossible to do with Flux because you would have all these different stores that were asynchronously dispatching actions to each other, and trying to coordinate that change across multiple stores.

[00:04:05]
It's pretty much impossible. So Dan came up with this idea like, well, we have this one application in react, right? And this react application is a tree of things, right? Well, why can't we have a data mimic the way that our views are stored, right? So why don't we have one tree of data?

[00:04:27]
And that's how Redux was born instead of having one or instead of having many tiny stores let's have one big store but the big store is just a tree. And then each part of our application can just subscribe to one part of the tree, right? That's the basic gist,

[00:04:44]

>> Brian Holt: So, yeah, you're gonna have one Redux store on the page. The top level function in any store, in Redux is called a Reducer or rootReducer. You're gonna hear the term Reducer over and over again. And Reducer is just a function that takes in state and an action, and gives you back a new state, right?

[00:05:09]
So given this store and this particular state that it's in right now and this action, this is the state that you get back out. This is really awesome because everything is reproducible, right? If given the state and this action, you get this new state, right? So it makes everything extremely testable at every single level.

[00:05:27]
And we're actually gonna do quite a bit of testing with Redux. One of the big strengths of Redux is it makes your state management very testable.
>> Brian Holt: So,
>> Brian Holt: And the way it addresses those kind of large changes where it changes multiple things like that animation example that I previously gave is you have access to all of the state all at once, right?

[00:05:52]
You can modify multiple things at once, so if you have those massive changes that you need to make, go right ahead, you're welcome to do so. So this is kinda high level of what Redux is gonna do for you. State management, right, it's a state management framework. So we're gonna be taking things out of React, right?

[00:06:13]
Right now, React is managing all the state views, it's state this.state.whatever, and this.setState, we're going to take that data out of React, and we're gonna stick it into Redux, right? So, we're kind of divorcing our data from React. Now, I'm gonna assert to you, I think react does a really good job of managing state.

[00:06:35]
However, you might get to a point at some point, where you have tons of components all worried about the same state. And that's the point where you say, maybe I should use Redux now, right? Cuz imagine for a moment, let's say we had ten different routes, right? Each of those routes was very complicated, had lots of components.

[00:06:53]
And they were all interested in about the shows that we were requesting from the API. Our two options here is that we can either put all that data up into App.jsx, and pass that down into every single route, that's very burdensome. Or we could have some sort of centralized stay container like Redux that will take care of all of that for us.

[00:07:13]
Does that make sense?
>> Audience 1: When you say burdensome, you just mean from a development perspective, not from performance or?
>> Brian Holt: Yeah, development, from a maintainability and things like that, right? Cuz what you're gonna have is you're gonna have these shows to the top level. And doing an after pass shows in every single components.

[00:07:33]
So now, every single component inside of your application cares about these shows, right? This becomes a real problem if I have top level app and bottom level component down here, and there's like ten components here in the middle. There's gonna have to be a bunch of components passing state from parent to child, parent to child, parent to child, so it eventually lands at the bottom, right?

[00:07:53]
Otherwise, they wouldn't have to have cared about that shells component, right? But it's just kind of tying your data into your application structure. We call this data tunneling, right? This alleviates the data tunneling problem. So with React, we had a very tight loop, right? This dot sets date, well, let's say I type into the input.

[00:08:15]
That kicks off an event that goes into our event handler that calls setState. The setState updates the state and it kicks off a re-render, right? Pretty tight circle. What we're gonna do with Redux is we're going to make that circle a little less tight, right? We're gonna expand that circle.

[00:08:32]
So what's gonna happen is we're going to kick off an event. The event is gonna call the handler, the handler is going to dispatch an action to Redux via an action creator, which is then going to get called into the Reducer. The Reducer is then going to modify its state.

[00:08:47]
Once the state's been modified, it's going to notify React, which is a subscriber, which is then going to kick off a re-render, and then you have an updated state at that point. So we've added three or four more steps in there. So if that sounds more complicated, it is so [LAUGH] tough, I guess,

[00:09:07]

>> Brian Holt: So let's go ahead and get started with that then. First thing I want you to do, is I want you to create a new file called reducers.js, lower case r and not jsx, just js. We're not gonna have any React living in here. That's why we're not gonna have any, there's no x on the end, and it's not a component, so it's not a capital r.

[00:09:36]
That's what those conventions mean.

