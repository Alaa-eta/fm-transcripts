[00:00:00]
>> Brian: Okay, so now let's talk about HashRouter. HashRouter is what we're gonna call a higher order component. In that it doesn't actually render anything itself out, right? You don't expect your router to render markup itself, right? What it does, is it does routing and then you tell it what markup to render.

[00:00:21]
So it's higher order in the sense that it introduces behavior, right? It's taking care of routing for you, but it's not actually rendering any sort of markup out of it. That's what we call a higher order component. Now, we're gonna use this one and we're gonna use more of but there's nothing to stop us ourselves from writing.

[00:00:35]
In fact, later on, we'll actually be writing a couple high order components ourselves. So, this is actually kind of an advanced use case for react.
>> Brian: But I think it's one worth knowing. It's one of the more powerful parts about using react. Any questions about high order components?

[00:00:54]

>> Brian: So they encapsulate behavior but they do not necessarily encapsulate style of mark up. So, right now we have a really lame router system because we match exactly, we have one route. But let's go ahead and make sure that it works anyway. So, make sure your, did I put dev in there?

[00:01:18]
I did not. So Let's go ahead and go back to our webpack.json. We're gonna put another thing in here. And it's just going to be dev, which is going to be webpack-dev-server Just how it is in there. We don't have to pass in anything because it is already gonna read that from the web pack config.

[00:01:54]
Okay and now if we go run your dev It'll run our server for us.
>> Speaker 2: So, that's equivalent to like mpm start, right?
>> Brian: I mean, yes, sorta. So, mpm start would typically be like, just. The answer to your question is, it can be whatever you want it to be.

[00:02:17]
Mpm start To me, semantically means how you would start your production server, whereas npm run dev is how I would run my own developer environment, but I guess that's just a choice I made. I don't even know if that's necessarily the best practices, but did I sufficiently vaguely answer your question?

[00:02:35]

>> Speaker 2: Yeah.
>> Brian: Okay, cool.
>> Brian: Okay, so I want you to take note of one thing really quick. Notice this weird hash that's now suddenly showing up in our URL. How many of you have seen that before, right? Really common way of being lazy about doing single page applications.

[00:02:57]
The reason why is that your server doesn't have to care about any of the routes. Basically, what you say to your server is, "Go to this page if you see any url that looks remotely like this," and then the client side code is going to take care of all the routing for you.

[00:03:14]
So it's super lazy and don't do it, right? Like, take the time to actually go and set up your server correctly. But what is actually doing that is HashRouter. So we're gonna migrate momentarily here to browser router, but I'm gonna show you, we're gonna build one more route first.

[00:03:37]

>> Brian: So, make a new file. Call it search.jsx, and we're just going to make like the most bare bone things possible. So, import react from react.
>> Speaker 3: Sorry, can you go back to the client app?
>> Speaker 3: Can you go back to landing?
>> Brian: I'll push a branch here in just a second, too.

[00:04:14]

>> Speaker 3: Okay. All right, it looks right.
>> Brian: So in search what I want you to do really quick is just make the most bare bones thing possible
>> Brian: I'm highly paid for my abilities to find UIs. Export default search.
>> Brian: Okay, so just something dumb, because we just want to test real quick that we can route correctly.

[00:05:04]
Go back to ClientApp.jsx
>> Brian: And import Search from ./Search.
>> Brian: I'm going to create another Route,
>> Brian: And this is not going to be exact, doesn't need to be /search. So, any time we go to /search, the component is going to be, as you may have guessed, search.

[00:05:48]

>> Brian: So, now we have two routes.
>> Brian: If we refresh so, landing still works and now i'm just gonna URL hack up here, and type in search at the end of that, refresh, sorry hit enter on that, you should see your second route. And now we can go back and forth.

[00:06:10]

>> Speaker 3: Can you go back to search?
>> Brian: Yeah, I was just as barebones as possible.
>> Speaker 3: wow.
>> Brian: So this is using a library called history underneath it. And what's really nice about history is it's directly interacting with DOM's history API. Which means if you're just building With react rather you get all like the back button forward button, opening links with command clicks and a lot of stuff.

[00:06:52]
And that all just works for free which is really good. So again if I like hit 4 around here you can see I get forward, backwards all that stuff just works automatically.
>> Speaker 3: Again the router is not defined.
>> Brian: In client app,
>> Brian: I would imagine that's problematic.

[00:07:24]

>> Brian: In landing, it'd be better if we didn't necessarily have this browse all button, it actually took us to the search page, right? So luckily, if we go to landing, what we can do there Is we can import a link component from react-router-dom, and we can just replace this Browse All, replace that link with a link and that goes to /search

[00:08:07]

>> Brian: And what link is going to do, all it's gonna do is it's gonna generate an anchor tag, an a tag with the correct URL to go to.
>> Brian: So if we refresh, notice that the UI hasn't changed. It looks exactly like it did, because it just went from being an anchor tag to being an anchor tag.

[00:08:26]
However, if I click on it, it will take me to search.
>> Brian: And again. Because it's an anchor tag I can command click and notice that it opens the new tab and it works just fine. So as long as you, you know, don't mess up the browser, don't use you know event click listeners that do window dot location that forward you on to somewhere else.

[00:08:55]
As long as you don't do any of that shenanigans you just get all of the browser functionality built for free. And your site is a ton more accessible, so all good things.

