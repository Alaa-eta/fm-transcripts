[00:00:00]
>> Brian Holt: So, we've written our entire application. We did React first, then we integrated Redux. And then, we did Flow and all that kind of fun stuff. And we're gonna take it down the final stretch here, and do a couple more build oriented sort of things. The first thing that we're gonna do is universal rendering, also formally known as isomorphic rendering, also formally known as a bunch of other really dumb terms.

[00:00:23]
Let's stick with server side rendering because that's actually what we're gonna be doing. We're gonna take React and we're gonna take our application, we're gonna stick in to node and say render this out to a string so that when you go down to the client, you have fully rendered markup.

[00:00:38]
So kinda to demonstrate to you here, if I view page source here. That is 100% of the HTML that I'm sending down to the user, which is nothing, right? It's just the shell that React then bootstraps itself, and renders out to the DOM. To be honest with you, this is gonna be fine most of the time.

[00:00:56]
Server side rendering is by no means required, right? However, it's going to improve perceived load time, right? We're playing a psychology game here with our users, right? We want them to think that our web page is as fast as possible, right? So if I send down complete markup, right, the browser will read it.

[00:01:16]
It will render out your markup and then behind the scenes React is gonna hurry and bootstrap itself and then make your page interactive, right? So it's kind of a game, a little bit, right? It's a game in the sense that the user sees the page rendered, and it's not actually interactive yet, right?

[00:01:36]
If they click on the buttons, the JavaScript is not yet there to be interacted with, right? But by the time hopefully that the user sees something, makes a decision in their mind that's like, I'm going to click on that button. And by the time they actually move the mouse to click on the button, hopefully by that point, your JavaScript will have downloaded, parsed, attached to all of the DOM and then it'll be ready to happen.

[00:02:00]
Usually that's the case, right? So the user thinks that the page is faster despite the fact that the time to interactive, right, the time that it actually is ready to be clicked on, is gonna be about the same, if not even a tiny bit slower, right? Cuz you're sending down more HTML.

[00:02:15]
React is having to do a little bit more, all that kind of stuff. So that's what we're gonna do. The key here is that this requires Node, right? So if you're writing Rails, right? Rails doesn't really have a way to run JavaScript, at least not directly that I'm aware of.

[00:02:32]
Same thing with Java, etc., etc., etc., right? So you're gonna need Node in here somewhere to be able to do that. So, something that a lot of companies will do, say for example you do have like a Java backend, they'll introduce what we call a Node middle end.

[00:02:46]
Or at least that's what I call it. [LAUGH] I don't know if other people call it that. But you'll have like a Node middle end, right? So you have this Node server that makes requests to your API server, your Java server, your Rails server. It gets all the information there in the Node middle end.

[00:03:00]
It'll do your server side rendering for you, and then send down complete markup. So, that's always a possibility as well. I would say it's pretty common. It also helps if you're just running Node in the first place, because that just works. Cool. So, I wanna tell you that service side rendering by itself is actually not terribly difficult to do.

[00:03:22]
I'm gonna just pull up one of my other repos here. /btholts/, I think it's the es.
>> Brian Holt: I think it's this one. Okay, yeah, so if I go to the GitHub project here. I'm just gonna show you an example server side rendering that's a lot more simple than what we're gonna do today.

[00:03:50]
So I'll make this larger. So I did this with Culla, you could easily do this with Express, but really the big key here is 21 and through 24. You just say ReactDOMServer.renderToString and then you pass it the React app, right? It's going to go through and render out your app to a string.

[00:04:14]
And then you just put that in a template and you send that down. The end. That's it, right? So React server-side rendering at its most basic is really just that. That is to say, not a whole lot. However, we kind of have a strange issue here. That we're doing client-side routing, right, cuz we're using React Router.

[00:04:36]
And so the fact that we're using the client side router introduces a little bit of complexity. Because we don't have to write the routing code twice. Now if you're into it, like if you want to, right, you totally can write a server version of the routing and then you can go and write a separate version of client routing and just try and keep those in sync.

[00:04:57]
I'm gonna say that's usually a bad idea, right, cuz something like I say all the time is, if something has to be kept in sync it's always going to fall out of sync. That just always happens, it's a really prone to bugs to do it that way. So it's really great if we can make React Router handle both server side routing and client side routing.

[00:05:17]
And the answer is you can. That does work.

