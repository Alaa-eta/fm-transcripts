[00:00:00]
>> Brian Holt: I could show you how to do this with a command line, so you could actually start configuring Web Pact through the command line to do this. Let's just build a config file so we don't have to do it any more. So, go ahead and make a new file,

[00:00:16]

>> Brian Holt: And put it in the root director of your project, called webpack.config.js.
>> Brian Holt: And what we're gonna do here is we're gonna say const path = require path. Now, this is meant for node, right? This is not going to be transpiled, so we're not going to use the ES6 modules because node does not yet understand ES6 modules.

[00:00:48]
So we have to use common JS. Okay? Then we're going to say module.exports and we're just gonna put a bunch of stuff in here, context dirname. What this is saying is that we're running this from our root directory always. So you can run web pack from anywhere in your project, and it's always gonna run from that root directory.

[00:01:19]
That's what the context dirname translates to. Dirname is just a node, a global variable that refers to that root directory of your project.
>> Brian Holt: Entry
>> Brian Holt: So for now, we're just gonna have one entry which is going to be .js/clientapp.jsx.
>> Brian Holt: This is just telling you this is the front door to your project, right.

[00:01:48]
Everything is going to be included out from here.
>> Brian Holt: Dev tool, we're gonna do cheap-eval-source-map, I think that's what it is. I have to make sure that that's the case. There are several different types of devtools like you can do full source maps and everything like that. This is the one that's placed the nicest with all the tools that we're gonna use, that's why we're gonna stick with it.

[00:02:17]
This is just saying it in line all of my source maps into my bundled code. It's gonna make your bundled code bigger in development but it won't be included in production. And source maps for those who aren't familiar with them. If I transpile from my source code to evaluated code.

[00:02:35]
If I don't have source maps it's going when I click on the error it's gonna show me directly in the bundled code, which is worthless, right? It's impossible to read. If I have source maps it's actually going to show me my code, right? It's gonna show me the pre-transpiled code, that's why we do source maps.

[00:02:55]

>> Brian Holt: Output
>> Brian Holt: Path and that's gonna be path.join(_dirname,'public'). So path is a node module that just resolves like unique style, relative paths for you. So if we do this, dirname public, we can be assure that's always going to land on this, the public directory that we're talking about, no matter what we call it from our project.

[00:03:29]
That's why we're using it. And filename I call it bundle.js, that's a common thing to call it. But you could call it whatever you want to. Resolve. Extensions.
>> Brian Holt: So if I say for just, you don't have to copy on this const App = require./App, right? This is the order that it's going to try a file extensions before it finds the correct one, right.

[00:04:18]
So I'm going to say .js, .jsx, and then .json. So the first thing is it's going to do is it's going to try and see if I find a file call app. Like app with no file extension, that's the first thing it's going to check. Then it's going to say, does .js exist?

[00:04:39]
If that doesn't exist then it's gonna try .jsx, and if that doesn't exist then it's gonna try .json, and if that doesn't exist then it fails. So it's the order of resolution of the those extensions.
>> Brian Holt: Stats, this is just the various things that you wanna reported back to you when you're building.

[00:05:01]
So we're gonna say colors true, because I like colors. Reasons, this is gonna give you more useful error output, so I'll definitely put that. And chunks, I don't think this one's useful anymore, but we're gonna put it in there anyway. This is just saying if your code is being broken up into multiple different chunks, please tell me about that.

[00:05:23]

>> Brian Holt: And then the last thing we're gonna do here is we're going to start using bubble.
>> Brian Holt: Sorry not modules, module singular. Then rules inside of that which is actually, this is gonna be an array. So this is going to be an array of rules that webpack is going to be used to apply different loaders to your code.

[00:06:04]
Now what is a loader? A loader is just a plugin, it's actually not a plugin. Let's not conflate words [LAUGH]. It is a tool, that Webpack is going to use on your code, in some fashion. So the first tool that we're going to be using is double right.

[00:06:23]
So when we give it the babel loaders so the web pack will use babel for us right. That makes sense? So going to give it an object. The first thing that we're gonna do is we're gonna give it a test of some sort, this could be a function, this could regx, this could be several different things, we're just going to use a regx.

[00:06:45]
So you do slash, backslash, dot jsx, question mark, dollar sign, slash
>> Brian Holt: And then we're gonna say loader: 'babel-loader'.
>> Brian Holt: I am by no means a regex expert. But, what this means is the file extension for the file must be .JS and possibly x, right? The question mark means that x might be there, and the dollar sign means this must be at the end of the file name, right?

[00:07:30]
So anything that ends in .js or .jsx run through babel. That's what that means. Cool? Okay. Loader, you're just telling it here, this is the name of loader that I want you to run it through. So it's going to call Babel and it says, here Babel here's your thing, right.

[00:07:47]
It's going to call it with all the output from the file and then Babel is going to do something and hand it back to Webpack. That's the contract that is going on here. Just so you know, you could say loaders and then give it an array, right, of different loaders to run it through.

[00:08:03]
Right now we just have one, we just want to run it through babel -loader, so we gonna leave it at that.
>> Brian Holt: Any questions?
>> Brian Holt: Make sense?
>> Brian Holt: Okay.
>> Brian Holt: Save it. Thanks to Prettier, it's gonna be all nicely formatted.
>> Brian Holt: Okay, so, now I can go to

[00:08:39]

>> Brian Holt: My command line and notice before I was saying. I was giving it the entry and exit. I don't have to do that anymore. I can just say webpack. It's automatically going to pick up the config, and it's just going to do it for me.
>> Brian Holt: Now you're gonna notice that's gonna take significantly longer than it was before.

[00:09:03]
Why? Because everything's being run through Babel, and it's a pretty intense process. So again, we're introducing tools for the sake of ease but it comes with the cost of complexity.
>> Brian Holt: And now, we went from having 700 kilobytes, which was ridiculous, to having 2 megabytes, which is yet further ridiculous.

[00:09:25]
[LAUGH] But again, you have to remember now, Babel is including all its polyphils too, right. So Babel actually is going to add quite a bit of weight to our bundle as well. When we go actually to minify in G and goes into production it's going to be significantly smaller.

[00:09:44]
In fact, I can show you what it looks like. If you put -P, this is saying hey I'm building for production and it's going to do a whole different set of transformations.
>> Brian Holt: And we've saved to point point one five. Because we have all the source maps in there.

[00:10:05]
Source maps are huge. They're going to over double the size of your code, so we'd have to drop the source maps too. We'll talk about performance and building for production in the third day, so
>> Brian Holt: So yeah, let's build and let's go see if everything works.
>> Brian Holt: Everything is still working.

[00:10:32]

>> Brian Holt: And looking good.
>> Speaker 2: Can you go back to your index? [INAUDIBLE]
>> Brian Holt: Yeah, you just need to include public/bundle.js.

