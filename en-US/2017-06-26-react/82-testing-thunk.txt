[00:00:00]
>> Brian Holt: So the last thing that we're gonna wanna test is our Thunk. It's a little bit more complicated cuz now we're gonna have to start dealing with asynchronous code, it's not so easy. But it's not horrible, which is the good news. So the first thing we're gonna import up here, and this is actually one of the reasons I chose axios for this course, is it actually has its own mocking library called moxios.

[00:00:27]

>> Brian Holt: Let me push a branch real quick.
>> Brian Holt: So I'm gonna yarn add .get. Why am I doing this? git add ., git checkout -b v3-25, git commit -m25, git push origin v3-25.
>> Brian Holt: Okay, so v3-25 is out there. I guess I pushed it with moxios in there, so you'll have that linting error, but that's okay.

[00:01:06]
So now we're going to go do some testing with,
>> Brian Holt: moxios. So the first we're gonna do is we're gonna pull this addAPIData thing out. And we're just gonna say this is Stranger Things.
>> Brian Holt: And we're gonna say const strangerThings = blah. And then we can reuse it in this next test here.

[00:01:36]

>> Brian Holt: So we're gonna test('getAPIDetails',
>> Brian Holt: getAPIDetails.
>> Brian Holt: And up here, we're gonna import getAPIDetails.
>> Brian Holt: So moxios has this cool ability to do moxios.withMock.
>> Brian Holt: And then inside of here,
>> Brian Holt: If I ever call axios, it's just going to substitute the mock version instead of actually trying to make a request, right?

[00:02:18]
So, anything inside of that body will happen.
>> Brian Holt: So the first thing we're gonna do is const dispatchMock,
>> Brian Holt: = jest.fn(). This is called a spy function, so ultimately, what we're concerned about is given input, right, if I request something, I'm going to expect,
>> Brian Holt: For the dispatch to be called with the correct functionality, right?

[00:02:56]
So, if I request Stranger Things, I'm going to expect it to eventually dispatch an action to update that in Redux, right? That's what I'm testing here. So that's why I'm gonna use this dispatchMock function. I'm going to pass this in as the dispatch function and test later if it was called with the correct parameters, that's what we're going for here.

[00:03:20]

>> Brian Holt: That makes sense? So another thing about this is this test is going to be asynchronous, right? It's not going to complete synchronously, right? This one, there's no asynchronous component to it, whereas with moxios and with API requests, it's asynchronous in nature. So we have to be worried about that, we don't want the test to complete before we've actually finished the testing, right?

[00:03:47]
So what you can do here is you can say done: Function. This is an ability for jest, right? This done: Function, this is when you call and say I'm done, right? So as soon as you call done, your test case is finished, and so if everything hasn't wrapped up, it's gonna fail your test.

[00:04:03]
It also knows that don't finish the test case until I call this, okay?
>> Brian Holt: So, what I'm gonna do here is with Mock, I do this outside, it doesn't really matter, but whatever. With Mock, I'm going to call getAPIDetails, and I'm going to pass in strangerThings.imdbID, right? What does this return to me?

[00:04:34]
It's a thunk, right? So if I call getAPIDetails with strangerThings id, this is going to return to me another function. Typically, Redux calls this function for us, but we're not involving Redux in this process, right? We're testing just this thunk, so we actually have to call the function given back.

[00:04:53]
So that's why we're gonna put a second set of parentheses here. Cuz we're gonna call the function that's given back. If this is more clear to you, you're welcome to say const thunk = that and then call thunk right after it. If you wanna be more explicit that way, that's totally fine as well.

[00:05:09]
But what we're gonna do here is we're gonna call it, and what is that function called with? So if we go look at our actionCreators.js, if you look right here, what is it called with, it's called with dispatch, right? This is injected by Redux, right? So if we go back to actionCreators.spec.js, we wanna call it with our dispatchMock.

[00:05:34]
And so now, that's going to be provided to our function, and we're going to wait to see if that's called with the correct parameters. That's what we're actually testing here. So, what we're gonna say is hey, moxios, just chill out for a second. So you're gonna say moxios.wait,

[00:05:54]

>> Brian Holt: And give that a callback function.
>> Brian Holt: And then you're gonna say, const request = moxios.requests.mostRecent. So the first thing we're gonna check to see is, was it called with the right URL? Did our thunk reach out to the correct API, right? And we can inspect that request here given back to us by moxios.

[00:06:26]

>> Brian Holt: So we're gonna say request,
>> Brian Holt: .respondWith,
>> Brian Holt: status: 200, and response is going to be strangerThings.
>> Brian Holt: So yeah, that's what we're doing here in particular, is it's gonna make that request, and you're gonna say hey, respond to this request with a 200. And then our next test case could be text, what happens if this is 404 and this is error, right?

[00:07:02]
And we can test that as well. Not gonna test that right now, but that's how you would do that as well.
>> Brian Holt: This is gonna give you back a promise, so I'm gonna say .then.
>> Brian Holt: And in here, we can test what actually is gonna happen. So the first thing we're gonna expect is we're going to expect(request.url),

[00:07:31]

>> Brian Holt: toEqual,
>> Brian Holt: (http:// localhost:3000/$[strangerThings.imdbID], right? So that's the URL it should be calling, right? The next thing is we're gonna say expect(dispatchMock),
>> Brian Holt: toBecalledWith, this is a function of the spy function that we're using here. It's very similar to signOn, if you've ever used that one. And we're going to expect it to be called with addAPIData, right, that's ultimately the action that we're looking for.

[00:08:15]
So, it's gonna be addAPIData with strangerThings.
>> Brian Holt: And then down here, we're gonna have to call done, right, otherwise, it doesn't know that it's finished, so, done.
>> Brian Holt: So a big key here is we're testing kind of the integration between the thunk and then eventually getting to dispatch in the addAPIData.

[00:08:48]
We need to test addAPIData before we test the thunk, right? That's actually really, really key here, so that's why addAPIData is up here, right? We need to be sure that this is iron clad before we test this one because if this fails, right, we want this test case to fail first, right?

[00:09:06]
We want this one to say, hey, this is messed up. And all these tests that depend on this working need to, this needs to be tested first before we get to here. So the fact that we've tested this first means that I feel okay down here testing the integration between the two, okay?

[00:09:24]

>> Brian Holt: So that's the two things we're testing here. We're testing that the correct API is being called, right? And then we're testing that the correct action is being dispatched.
>> Brian Holt: So now if you come in here and say yarn test, hopefully we should pass, cool.
>> Brian Holt: So,
>> Brian Holt: The hallmark of any good test is to go make sure that it actually fails when you anticipate it should fail, so that's always what I do.

[00:09:59]
I'm always suspicious of things that pass the first time, so let's go into actionCreators and make sure that it fails. So the first thing, let's say, I'm gonna update the URL to 9000, right? I should expect that URL to fail, right? So now it's saying, hey, I expected this to be 3000, and I got back 9000 and that's a problem.

[00:10:23]
So that test is good.
>> Brian Holt: Yep, so that's good. So that failed the way I wanted it to, and let's say that this dispatch is, I don't know, null for now. So let's go make sure that that fails as well.
>> Brian Holt: And that fails as well because it's saying, hey, I expected to get this back, and it didn't get that, so that sucks, so cool.

[00:11:04]
That fails as well when we anticipate it should fail.
>> Brian Holt: Okay, go make sure that I deep roped everything. And it all works, okay.
>> Brian Holt: Any questions about this?
>> Brian Holt: To be totally honest with you, going back to our spec here,
>> Brian Holt: Mocking API responses and testing that, this is, I mean, obviously more involved than any of the other tests we wrote.

[00:11:42]
But I would say this is pretty good for testing asynchronous code, right? It's pretty nested, right? We're how many layers deep, but at the same time, this reads pretty well to me.
>> Brian Holt: So the fact that we can test that in one small chunk, and now we have confidence that getAPIDetails is not going to regress over time, unless we anticipate changing it in some direction.

[00:12:08]
So this is a good test case, I'm pretty happy with this. Again, this is one of the big strengths about redux, is we can isolate these little tiny pieces, and then just really test them super well. And then you can kind of have bigger and bigger test case that cover more and more of the stack to get more of an integration, instead of just a unit style test.

[00:12:27]
So, I'm a fan.

