[00:00:00]
>> Brian Holt: Let's go to landing now. Yep, we're gonna go landing. What we're gonna do here is we're going to import a function called connect from react-redux.
>> Brian Holt: Now, what we're gonna do,
>> Brian Holt: Is we're going to write this function called mapStateToProps. mapStateToProps, it's gonna take in state.
>> Brian Holt: And it's going to return an object.

[00:00:45]
Now, something that people get kind of confused with here is, if you have a one-liner object that you want to return, like let's say it was just like searchTerm: state.searchTerm. This is technically not valid JavaScript despite the fact that it really, really looks like it should be valid JavaScript.

[00:01:11]
Well, what do curly braces mean in this particular case? It means the beginning of a body. A function body, right? It doesn't mean an object. So it's expecting me to put like stuff in here like console outlog, whatever, or, I don't know, stuff like that. Really common mistake to make with ES6 arrow functions, and it's just because curly braces mean more than one thing, right?

[00:01:37]
And in this particular case, they mean function bodies, so if you wrap this in parentheses with a letter I, just kidding, that's a joke. [COUGH] If you wrap it with a parentheses, then you're letting us know, I actually mean to return an object literal here, right?
>> Brian Holt: Does that make sense why I put parenthesis around it, and why they're there?

[00:02:05]
Okay, cool.
>> Brian Holt: So what this function does is it takes the whole state of redux, right, that's what this state is, and it pulls out just the thing that this component cares about. You don't wanna be passing around the state of redux willy nilly. Like that's a bad idea, promise.

[00:02:31]
This is gonna pull out just the things that you need, it's going to inject them as a prop into your component. The way that it does that connecting is with, as you may have guessed, the connect function. So we're gonna say connect (mapStateToProps)(Landing), like that.
>> Brian Holt: Kind of a weird notation, but I will show you why it's in that notation in just a second.

[00:03:02]
But basically, you call connect with mapStateToProps which returns a function, right? Just this bit right here is a function that when called the something else, is going to connect that component. So we could potentially reuse it multiple times. You won't, [LAUGH] but you could, right? So that's why there are two function calls here.

[00:03:23]
The first bit is going to be what you're going to use to pull out state, and the second bit is that gonna be the component. That make sense?
>> Brian Holt: So let me show you why that is actually the way it is.
>> Brian Holt: How many of you have heard of decorators?

[00:03:43]

>> Brian Holt: Super cool, there are, one of the things I'm most excited about upcoming in JavaScript, if you write a lot of Python inevitably you end up writing a lot of decorators, right. There's a lot of other languages that have these really cool language features called decorators. So what we could do here if we could use decorators, which we can't.

[00:04:06]
But what you would do is it would look like this.
>> Brian Holt: You would say up here above landing,
>> Brian Holt: We'd have to convert this to a class. So pretend just for a second that I had converted this to a class. I would say, class landing extends React.Component. Or component, whatever, I don't care.

[00:04:32]
Component, and there was a bunch of useful stuff in here, right. Okay, can we all pretend momentarily, cuz I don't wanna have to rewrite it, just to go back. So if this was class, we could put @connect (mapStateToProps) like that, and then suddenly, rather than doing this kind of awkward looking thing down here.

[00:04:57]
This landing would just automatically be connected to it. So basically, this is going to get passed in, which is going to return the function, which is going to run on the result of the landing class. This is called a decorator, right? This is gonna be Stage 2 or Stage 3 proposal for JavaScript.

[00:05:20]
So it's most likely gonna make it, cuz everyone's pretty excited about it, me included. I'm really excited for one of the day I can use this. You can actually do this right now, with the bubble transform. The issue is that, flow doesn't understand decorators yet. So we're not gonna do it today, but you'll see lots of people out there using decorators this way.

[00:05:40]
So I wanted to make you aware that you may see it, and it's also something to be excited about, in my opinion. But for today, we're just gonna stick with the normal, if calling connect. So that's what I wanna say that connect has this weird way of looking right where it looks like this.

[00:05:54]
Connect(mapStateToProps), because they didn't like this. That's how a decorator works anyway. So they didn't have to make two functions, right? Then it'd have to make a connect decorator and a connect function. They were able to just reuse both of those. Any questions about that? So this is kind of on the side, but it's something I'm excited about, so I wanted to share.

[00:06:23]

>> Audience 1: It's just whatever function follows or whatever constructor, class follows?
>> Brian Holt: So the at connect is going to return a function, that's going to be called on the class.
>> Audience 1: Whatever is next, cuz you didn't explicitly say like-
>> Brian Holt: Right, it's called on your behalf, right. The connect function is going to be called by the language.

[00:06:45]
Right and like [COUGH], I had @connect mapsStateToProps, right. But there are gonna be decorators like @auth, right. That's just gonna look like that, and it doesn't say have to return a function. Well, let me rephrase that, it doesn't have to be a function that you call that returns a function, right, it could just be a function.

[00:07:05]

>> Audience 2: So is that almost like constructors and destructors in C++ or something like that, where you got a class object and there's something that's called either during instantiation or when it exits-
>> Brian Holt: Okay, so yeah, I kind of see what you are saying. I'm gonna say no comment on it, because I don't actually know enough exactly what connection you're gonna make with that.

[00:07:32]
But, I will say that if it's just providing additional functionality in a declarative fashion, right? So if I had something like this where I was calling @auth, you basically mean something like, you can't construct this unless it's authorized, right? So you're just kinda declaring, this must be auth, right?

[00:07:50]
And then you can just kinda go about your way doing that, right? And this is gonna work both on whole classes like I showed you here and also on individual methods. So that's probably where that be like you could have a route on your router and then you just say @auth.

[00:08:05]
And it's like the user can't call this method unless they're authorized, right? So it's kind of declaring in that particular sense. Does that make sense?
>> Brian Holt: Okay, so that's enough about decorators. They're super exciting, but not yet. They're not yet exciting.

