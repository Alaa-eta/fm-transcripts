[00:00:00]
>> Brian Holt: What I want you to do here, you are going to leave your API server running. And for now I am going to shut off web pack. And I am going to change that to be yarn watch. Because we still need to compile our web pack code, but we are not going to be reading from the dev server anymore.

[00:00:15]
We are going to be requesting it from our API server. Not our API server, but our Express server that we just wrote.
>> Brian Holt: And now we're going to do a NODE_ENV equals server node server.js.
>> Brian Holt: So now it says listening on 8080. So if I come on to here And refresh 8080 on here.

[00:00:43]
Notice we're still getting our website, and every thing's kind of fine. I don't think we're going to get any console errors. We screwed up hot reload. I'll show you how to fix hot reload with this. But that's why I was saying "hey, I'm trying to find hot reload".

[00:01:03]
That's because we're not talking to the dev server anymore, we're talking to the node server that we wrote, right, but now what's more interesting about this, this is what it was before, totally empty. If I refresh, look at how much stuff now is coming down, right? This is a fully rendered experience.

[00:01:26]

>> Brian Holt: Which is pretty cool, right? Now, something I want to show you that's perhaps even more impressive about this, oops. So I'm going to come in here, and I'm going to click right there. I forgot how to do this with Chrome dev tools. Settings. I am going to disable JavaScript.

[00:01:56]
Wherever disable JavaScript is.
>> Speaker 2: You passed it. It was on the right.
>> Brian Holt: Disable Javascripts, right? So now, as long as the DevTools are open, JavaScript is going to be disabled, so now if I refresh the page, you know what's going on here? It's Styles components doesn't work without JavaScript.

[00:02:21]
That's a problem. So that's something you accept when you take on styles components, but notice that everything is still being rendered out okay. I can actually click onto Game of Thrones, and it will take me into the page. I can go back. I can click s-video. So I'm actually able to, besides the styled components stuff, I'm able to still navigate my site, right, because what's happening If you look at my server here, it's just routing to each one of these, it's making a full server request, right, the server side rendering that code and then just sending it back down to you, right?

[00:02:56]
So we made our page work without JavaScript. Really any more that's not really much of a problem almost every client that's going to be accessing your page is going to have JavaScript enabled. But let's say you have a JavaScript error, right? You're still going to be able to work, right?

[00:03:12]
It's kind of this progressive enhancement idea that's typically a pretty good idea. I would say, right? So, I think that's really cool. That's because it is really cool. If you aren't using styled components that would be a little bit more impressive, but I digress. Any questions about server side rendering?

[00:03:39]

>> Speaker 3: The idea is just the first page at the client loads pre-rendered and once React takes over, it goes back to its old single page application behavior?
>> Brian Holt: Exactly. So what this is going to buy for you: one, it's going to buy you a lot with Google, right?

[00:03:55]
Because you're going to send that markup faster, which Google is then going to rank higher, and it's going to be more controllable, in the sense that, yes, the Google caller does run Java script, but it's imperfect, for sure. If you send a predetermined markup you get to control what Google's crawling over.

[00:04:14]
So it's a SEO win, for sure. It's a big win for perceived web performance. If you're on a 2G connection in the middle of nowhere or just maybe you're stuck on crappy wi-fi or something like that, this is going to load a whole lot faster. And there is just tons and tons and tons of data out there that says, if you load faster use this rule to give you more money, right?

[00:04:37]
In some capacity. But that's more page clicks to get more ad revenue or your funnel is faster on your e-commerce website, all of that, right? So this is a win. If you can server side render, I recommend it.
>> Brian Holt: Other questions?
>> Speaker 4: And this is to get you ready to put your side on to production?

[00:04:58]

>> Brian Holt: Mm-hmm. So you typically you going to do a server side rendering, I would say that it doesn't always have to be just for production, but yeah, you would want to be doing in production. What I would do in this particular case, my god, look at that. That is the hot module reload just losing its mind.

[00:05:20]
I would do like the web pack depth server for like local development, because that's a really nice developer experience and you don't care if it's server side rendering or not. And then when I send it off to production I'll let server side rendering happen just to production.
>> Speaker 5: And you said hopefully when you click on the button, React is loaded.

[00:05:42]
What happens if React hasn't reloaded yet?
>> Brian Holt: So what I just showed you here out site works without JavaScript, right, because it's actually a real link it's an a tag that goes to that so it's going to hit your server again make a full request and come back.

[00:05:57]
So in that particular case, everything is going to work. However, If, like it's something that pops up a modal, or something like that, it's just not going to work, right? Nothing's going to happen. However.
>> Speaker 5: What about our dispatch events?
>> Brian Holt: Yeah, so, what will happen then, if I'm able to type in there before React and Redux have bootstrapped, it's going to blow it away, right?

[00:06:26]
Because it's gonna bootstrap and say, my state is actually empty string. However, that's usually not a problem. We're talking like, you're going to load that first payload and within a hundred milliseconds, you're going to get the JS. And once the JS is down, that parsing and bootstrapping is going to be five to fifty milliseconds a most?

[00:06:49]
Users don't make decisions that fast, right? You would have to be prepared with your fast-twitch muscles, okay now click it, right? Even on a slow connection, right? In other words, it's not something I find myself concerned a lot with mean definitely instrument, right? If that is something you're worried about but,

[00:07:12]

>> Brian Holt: it has yet to be a problem for me.
>> Speaker 5: It is good to keep in mind, especially on a site like this, where downloading the JavaScript will content with all the posters, right?
>> Brian Holt: Mm-hm.
>> Speaker 5: If you have large images or something, and you can only develop so many of those in parallel.

[00:07:29]
Yeah.
>> Brian Holt: Most definitely. I mean this is loading large posters, because I'm super lazy and I didn't want to downscale them. But you definitely should worry about things like that, like compressing your images, making sure that the right, like you have thumbnails for the right pages and full size for the other ones.

[00:07:49]
For sure.
>> Brian Holt: Yeah, Mark?
>> Mark: If you make API calls to Node, how do you make mix in server side rendering?
>> Brian Holt: So this is, you're getting into the questions about hydration and things like that. So, for example, if I click on here, ideally when I was service side rendering, I would not come down and make a request.

[00:08:18]
Did I shut this down? I did. NODE_ENV equals, I guess I have it on here, don't I. Ideally, I would come to here. And, I wouldn't be making this request, right? I would already have it loaded, because I loaded it from the server, right? This is a really touchy situation to get this correct, right?

[00:08:42]
So, a big key about service side rendering, which I actually should address, is if you come in here, and if you zoom in, we're going to look for this thing right here, data-react-checksum. So this is basically your app gets run through this hashing algorithm. They generate a hash.

[00:09:00]
Then when you get down to the client, it's going to render for the first time, run the hashing algorithm again and make sure that those hashes match, so that you're generating the same markup on the server as you are on the client. If those mismatch, in fact, I'll show you how you can, we'll just make it mismatch really quick.

[00:09:18]
If I put, I don't know like here, I'm just going to put a H one that's going to render out math.random. So this will be different on the client, right, because everything you're on math.random it's going to give you a different output. So it will be different on the client than it is on the server, so if I load this again, it's going to say, what the hell are you doing?

[00:09:49]

>> Brian Holt: So, right there is what I'm talking about, it says, hey, React tried to reuse the mark up that you sent down there, but like hey, you messed up, right? What I got on the client is different than what I got on the server. I'm going to blow everything away.

[00:10:03]
So all those performance benefits are actually now worse, right, because you had to pay all the extra cost to get the server side rendering done. It's going to say, you messed up, I'm just going to blow it away and then restart. So that's something you definitely have to be careful about.

[00:10:19]
So getting to the hydration side of things, getting it to have the ability to have API requests before they're made, it's tough, right? Because when you first create your app, you're doing it with the thought in mind that it's going to request it from the API. So with redox, it's actually not too bad.

[00:10:36]
You just have to make sure that you're providing the same initial states. You have to have the kind of the variable initial state based on the context available or not. But the problem with that is you have to make sure the context is both available on the server and on the client.

[00:10:51]
Plus it can still do it if you navigate to that page without that being hydrated, right? So what I'm trying to paint a picture of yours it's a bit of a complicated mess to kind of preempts those API requests and you have to have kind of where answers of like is this worth it to me to try and do.

[00:11:09]
It's possible for sure. But it's tough. And we're actually going to deal this problem even more in depth here in just a second, because we are going to do code split, which like compounds this problem. Other questions?
>> Brian Holt: Stop that.

