[00:00:00]
>> Brian Holt: Now go to action creators. The first thing that I wanna do here is I'm gonna import ADD_API_DATA.
>> Brian Holt: I'm gonna export another function called ADD_API_DATA
>> Brian Holt: It's gonna take in apiData, which is going to be of type Show, right?
>> Brian Holt: And then in here, we're going to return a well-formed action object, which is going to be of type ADD_API_DATA and payload,

[00:00:43]

>> Brian Holt: apiData.
>> Brian Holt: So in particular here, we're actually not going to be calling ADD_API_DATA outside of this particular function, right? We're gonna actually handle this inside of action creators. But it's a good idea to export it anyway. Say, for example, you got API data maybe from local storage, right, for example.

[00:01:10]
You could use this ADD_API_DATA action to kind of load it from different sources, right? This is going to be useful other places other than just stuff coming back from the API. So that's why it's good to do that. And this is also good because now this is testable, right?

[00:01:25]
So I can import it into my test suite and test it. And it's a good idea to test action creators. In fact, we're gonna do it, so, cool.
>> Brian Holt: Okay, so now everything's all ready for us to start adding action, our API datas into our redux store. Now we wanna tackle the problem of making that asynchronous request, it's add inside of a thunk.

[00:01:53]
So what we're gonna do now is we're going to export another function called getAPIDetails.
>> Brian Holt: Okay, this is gonna take an imdbID, which is going to be a string, okay? Now, these action creators always return objects, right? That's kind of the contract there. However, this is going to return a thunk, right?

[00:02:20]
And what is a thunk? A thunk is a function, right? So this function returns a function. It kinda throws people off, but just remember that we're dispatching this function into the redux store, and then redux is gonna say cool, this is a deferred action. So something's going to come from this.

[00:02:37]
I'm gonna call this function and wait for it to dispatch, okay? So, that's why here, you're gonna say return,
>> Brian Holt: Function. So, it's gonna be a function that has dispatch injected into it, which is going to be a function.
>> Brian Holt: Okay, so that's why we're returning a function here.

[00:03:07]

>> Brian Holt: And then in here, we're just gonna do pretty much what we were doing inside of details. We're just gonna make our axios request here, in fact, you need to go import axios at the top. Import axios from axios.
>> Brian Holt: Okay, and then we're gonna say, axios.get. And this is gonna go to http://localhost:3000/, and then we're just gonna put that imdbID right there, okay?

[00:03:46]
And then we're gonna say .then, thine, .then response,
>> Brian Holt: The response is gonna be something that the API gave back to us. All we're gonna do at this point is now we're gonna use this dispatch function, which redux gives you to dispatch an action, right? So this is where the thunk is resolving and finally giving out an action.

[00:04:16]
So it's gonna say dispatch,
>> Brian Holt: addAPIData with response.data.
>> Brian Holt: Then as is always is the case with an API, it's usually good idea to have a catch statement at the end, just in case something goes wrong. It's gonna be an error, and here, I just say console.error, so it doesn't get dropped on the floor.

[00:04:46]
Axios error, error, it's gonna warn here, it's gonna say hey, I don't like console logs going down a production. But for me, this is useful to have as a developer. So I'm just gonna say hey, eslint, go ahead and shut up about it.
>> Brian Holt: So we're just saying hey, disable the console warning just for this particular line.

[00:05:25]

>> Brian Holt: So, to recap again, this is a thunk, this particular piece. This function that gets returned here, that's the thunk, right? The thunk function is going to be invoked by Redux, right, the Redux thunk thing, that middleware that we put in there. It's going to inject this dispatch function and just say, cool, go do whatever you need to do and then call me back whenever you have the action that you wanna do, right?

[00:05:51]
So what we do is we go out to our API via axios, and once it resolves, it's gonna say cool, now I have the action data that I wanna dispatch, so I call dispatch. With addAPIData, which gives me back a real action object, which then gets passed into Redux.

[00:06:08]
So, this is how you do asynchronous code with Redux. So, I would say thunks are the easiest way. I don't wanna say easiest, maybe simplest. There's just not a lot to it, it's just a callback, right? But there are other ways to do this. You can dispatch promises with Redux promise, observables with Redux observables, and generators with Redux sagas.

[00:06:27]
And I would say those are the most common ones.
>> Speaker 2: Well, there's a bunch of debating going on about-
>> Brian Holt: Which one's the best?
>> Speaker 2: Redux and the whole fact that you have tons of actions and how the scales, whether or not someone like Facebook is using Redux and across.

[00:06:46]

>> Brian Holt: I assert pretty unequivocably that this does scale, right? So right now, if you go to our reducers file, we have all of our reducers living in one file. Typically in a large application, you're gonna separate your reducers into separate files. But when you're using combined reducers like this, this one reducer owns API data, right?

[00:07:08]
It owns that one particular piece of the state tree, and it has no concept of search term, for example, right? So the fact that these are siloed from each other is why this scales, right? If you are worrying about every single object and every single reducer, that gets unruly, especially when you start getting 50 things in your Redux store.

[00:07:26]
But the fact that these are so siloed from each other, I can keep them in separate parts of my application. And they can be tested individually, that's why this scales, for sure. I would confidently assert that this scales.
>> Speaker 2: And then what about adding typings to, say, some of the things you're returning and what not to make the actions-

[00:07:48]

>> Brian Holt: Like this stuff right here?
>> Speaker 2: More clear?
>> Brian Holt: The response and the error typings are coming from the axios typings from flow typed, so that's why we don't have to type these. It knows that there's a response.data. You could do it explicitly if you needed to, but I don't think you need to.

[00:08:10]

>> Brian Holt: Yeah, there's nothing that you need to do with this in particular right now.
>> Brian Holt: And addAPIData, we already told it that APIdata's gonna be a show. And that's fine, so.
>> Speaker 2: And they said, does something like Immutable.js help with immutability of state?
>> Brian Holt: For sure, Immutable.js and there's also the other one that I can't think of off the top of my head.

[00:08:36]
There's a couple of libraries that handle immutability with JavaScript. Immutability just makes things a little bit safer, right, that you can't directly modify things. And it also allows for really fast checking for things to say like, is this the same object as this? No, cool, they're not equal anymore, and there's no sort of deep nesting that you need to check, that definitely helps.

[00:08:55]
My problem with Immutable.js and why I don't use it and why I don't teach it is it's a pretty large library. And yeah, so the value that it gives me in my developer experience does not match how big the library is. I think it's, the last time I was checking, I think it was 50 KB, which is, for me, kind of a non-starter, right?

[00:09:16]
I think it's bigger than React, which is a problem, right? So it is cool, there are reasons to use it. I've just not so far chosen to use it.
>> Speaker 2: I'm sure there's micro libraries and whatnot as well.
>> Brian Holt: I'm sure, I think Joffer was writing one, last time I talked to him.

[00:09:38]

>> Brian Holt: Any other questions?
>> Brian Holt: To be honest with you, a lot of that same similar type benefits that Immutable is gonna gain you, you're gonna get from having typings with your language, right? Cuz it's gonna catch some similar problems, like, hey, you're modifying this and probably shouldn't be modifying that.

[00:09:58]
So, a type system can help catch similar bugs. Not totally the same, and Immutable, in particular cases, will have some speed benefits, just by checking high level, shallow checking, is this the same object as this? But so far, I haven't felt the need to use it, personally.
>> Speaker 2: And a few people are commenting that they use React set state for UI state and then Redux for application state.

[00:10:28]

>> Brian Holt: Yep, totally, we talked about that yesterday too.
>> Brian Holt: But I agree, I think that's a good thing to do.

