WEBVTT

1
00:00:00.580 --> 00:00:05.040
&gt;&gt; Speaker 1: And there's a few questions
going back around the use of the key,

2
00:00:05.040 --> 00:00:09.860
guess there's some confusion around if
you don't use the index, how does that.

3
00:00:13.279 --> 00:00:16.040
&gt;&gt; Speaker 1: The index
of an array versus an ID.

4
00:00:16.040 --> 00:00:18.990
I know you kind of covered it.

5
00:00:18.990 --> 00:00:21.200
&gt;&gt; Brian Holt: Sure,
no I can kind of like diagram it out.

6
00:00:22.800 --> 00:00:23.830
So if I have,

7
00:00:31.748 --> 00:00:39.650
&gt;&gt; Brian Holt: ID: 0, name: 'Brian'.

8
00:00:43.740 --> 00:00:45.130
Let's do one more.

9
00:00:45.130 --> 00:00:50.581
If I have one, two, and three.

10
00:00:50.581 --> 00:00:52.057
And we have Mark.

11
00:00:52.057 --> 00:00:54.333
And we have Tanner.

12
00:00:54.333 --> 00:00:56.517
And we have John.

13
00:01:00.899 --> 00:01:06.819
&gt;&gt; Brian Holt: So
say I'm rendering these out to a map, and

14
00:01:06.819 --> 00:01:13.700
I have names.map, and
it's object, and index.

15
00:01:19.351 --> 00:01:24.472
&gt;&gt; Brian Holt: So and then that returns

16
00:01:24.472 --> 00:01:31.130
to a h3 with key equals index,

17
00:01:31.130 --> 00:01:37.287
and objects.name, okay.

18
00:01:37.287 --> 00:01:40.818
So picture for
a moment this is names, right.

19
00:01:40.818 --> 00:01:41.849
Names equals, ops.

20
00:01:41.849 --> 00:01:42.650
Don't do that.

21
00:01:49.358 --> 00:01:51.000
&gt;&gt; Brian Holt: So
right now I'm sorting based on ID, right?

22
00:01:51.000 --> 00:01:52.580
That's what the array is sorted by.

23
00:01:54.020 --> 00:01:58.350
Let's say, I allow the user
to sort by name eventually.

24
00:01:58.350 --> 00:02:02.320
So if I have it sort by name.

25
00:02:02.320 --> 00:02:05.420
Then really the only other thing that
happens is John gets to go up here.

26
00:02:05.420 --> 00:02:06.930
So now the IDs are out of order.

27
00:02:09.660 --> 00:02:14.630
So I guess right now this is going to be,
it's going to

28
00:02:14.630 --> 00:02:19.250
be an output to Brian, Marc,

29
00:02:19.250 --> 00:02:24.720
Tanner and Jon, so
by idea it looks like that, right.

30
00:02:26.630 --> 00:02:28.640
So this is going to be the first element.

31
00:02:28.640 --> 00:02:29.530
The second element.

32
00:02:29.530 --> 00:02:30.540
The third element.

33
00:02:30.540 --> 00:02:31.480
The fourth element.

34
00:02:31.480 --> 00:02:38.787
If then I sort by name,
it's going to be Brian,

35
00:02:38.787 --> 00:02:43.554
Jon, Marc, Tanner, right.

36
00:02:43.554 --> 00:02:44.791
So that's what it's gonna look like.

37
00:02:46.161 --> 00:02:48.190
&gt;&gt; Brian Holt: So
if my key is index, right.

38
00:02:48.190 --> 00:02:53.950
It's going to comparing the previous zero
at the element to the next zero element,

39
00:02:53.950 --> 00:02:57.078
so this one's not gonna change,
so it's gonna leave Brian alone.

40
00:02:57.078 --> 00:03:05.700
But Mark and
Jon are both the first index, right?

41
00:03:05.700 --> 00:03:08.550
So it's going to assume that
those things stayed the same.

42
00:03:08.550 --> 00:03:11.680
Because it's gonna say index one
is equal to index one, right?

43
00:03:14.320 --> 00:03:15.550
And it's not true, right?

44
00:03:15.550 --> 00:03:16.870
They change, right?

45
00:03:16.870 --> 00:03:21.370
So the index is not an accurate indicator
of what has changed and what's not.

46
00:03:21.370 --> 00:03:25.500
So the key here is that it needs
to be tied to the object, right.

47
00:03:25.500 --> 00:03:28.650
The index is not tied to the object
because the object can move anywhere

48
00:03:28.650 --> 00:03:31.400
throughout the array depending
on how we sort it, right.

49
00:03:31.400 --> 00:03:35.565
But if we're tying it to the ID, the ID
travels with that particular object,

50
00:03:35.565 --> 00:03:36.140
right.

51
00:03:36.140 --> 00:03:40.501
So if Brian's here, or if Jon here,
or if Jon here, right.

52
00:03:40.501 --> 00:03:43.740
That his ID is always going
to be the same, right.

53
00:03:43.740 --> 00:03:45.930
So that when we react compare
those against each other,

54
00:03:45.930 --> 00:03:48.810
it's gonna say,
this object move over here.

55
00:03:48.810 --> 00:03:53.220
I'm gonna take this entire dhum tree and
move it over here, right?

56
00:03:53.220 --> 00:03:55.010
So that's how I was able
to carry this throughout.

57
00:03:57.500 --> 00:04:02.490
&gt;&gt; Speaker 1: Is there any reason
to use key within the component?

58
00:04:03.530 --> 00:04:05.240
&gt;&gt; Brian Holt: You actually can't.

59
00:04:05.240 --> 00:04:07.190
So react is actually going
to hide key from you.

60
00:04:07.190 --> 00:04:11.540
So in this particular case with show card,
if we went and looked at the props,

61
00:04:11.540 --> 00:04:13.240
key is not passed through.

62
00:04:13.240 --> 00:04:14.370
Key is just for react.

63
00:04:14.370 --> 00:04:16.326
And that's the only special property.

64
00:04:20.951 --> 00:04:24.055
&gt;&gt; Brian Holt: So no, please don't.

65
00:04:24.055 --> 00:04:29.206
&gt;&gt; Speaker 1: Some questions
with the style components.

66
00:04:29.206 --> 00:04:30.190
&gt;&gt; Brian Holt: Sure.

67
00:04:30.190 --> 00:04:35.380
&gt;&gt; Speaker 1: And I'm not sure if you
answered these but how does it work for

68
00:04:35.380 --> 00:04:40.712
output devices, and responsive design,
like media queries?

69
00:04:40.712 --> 00:04:46.357
&gt;&gt; Brian Holt: So you can do all
sorts of fancy stuff within the,

70
00:04:46.357 --> 00:04:48.705
so like I could say,

71
00:04:56.579 --> 00:04:57.889
&gt;&gt; Brian Holt: Like this stuff that works

72
00:04:57.889 --> 00:05:01.590
within like lessons as, this all works
within style components as well.

73
00:05:03.150 --> 00:05:11.650
So @media like myBreakPoint.

74
00:05:18.780 --> 00:05:19.734
&gt;&gt; Brian Holt: All that stuff works, so

75
00:05:19.734 --> 00:05:22.689
stuff that you would typically expect
within Sass and LESS for the most part,

76
00:05:22.689 --> 00:05:24.340
just kinda work within style components.

77
00:05:25.440 --> 00:05:27.881
And you can use the &amp; selector
as well which is really nice.

78
00:05:32.514 --> 00:05:36.090
&gt;&gt; Speaker 1: What if multiple components
use the same CSS with slight variations?

79
00:05:37.370 --> 00:05:40.610
Is the CSS repeated several times?

80
00:05:40.610 --> 00:05:41.573
&gt;&gt; Brian Holt: That's kind of up to you.

81
00:05:41.573 --> 00:05:43.729
Sometimes it is a good idea to repeat it.

82
00:05:44.890 --> 00:05:48.190
There is a way to share that CSS.

83
00:05:50.100 --> 00:05:55.220
I want to say it's like,
there's a style.extend.

84
00:05:55.220 --> 00:05:57.240
You'd have to look at the documentation.

85
00:05:57.240 --> 00:06:02.030
But suffice to say there is
a way to mix in more CSS.

86
00:06:02.030 --> 00:06:04.810
So if you have a standard
button that you want to use.

87
00:06:04.810 --> 00:06:07.280
One you can just make another
button in the file, and export it,

88
00:06:07.280 --> 00:06:09.840
and then extend it inside of the file.

89
00:06:09.840 --> 00:06:13.800
There's a couple ways to solve that issue
that styled components takes care of.

90
00:06:13.800 --> 00:06:15.705
I don't remember off the top of my head or
I'd show you.

91
00:06:15.705 --> 00:06:22.410
&gt;&gt; Speaker 1: Have you or do you recommend
using style components in production?

92
00:06:22.410 --> 00:06:26.660
&gt;&gt; Brian Holt: The answer to the question
is this, it depends on what you are doing.

93
00:06:26.660 --> 00:06:30.290
If you are in a highly
performative sensitive area,

94
00:06:30.290 --> 00:06:33.435
the extra milliseconds makes a difference.

95
00:06:33.435 --> 00:06:36.940
It's something that you want to consider.

96
00:06:36.940 --> 00:06:39.332
&gt;&gt; Speaker 1: So you're saying that
the JavaScript has a [INAUDIBLE].

97
00:06:39.332 --> 00:06:39.976
&gt;&gt; Brian Holt: It's got a [INAUDIBLE].

98
00:06:39.976 --> 00:06:41.390
It's got to be shifted.

99
00:06:41.390 --> 00:06:42.593
So with CSS, right.

100
00:06:42.593 --> 00:06:45.760
You typically ship all
the CSS in the head, right?

101
00:06:45.760 --> 00:06:49.897
And then you parse the body, and
then you parse the JS, right?

102
00:06:54.122 --> 00:06:57.117
&gt;&gt; Brian Holt: If you're not gonna do
server-side rendering you have to wait for

103
00:06:57.117 --> 00:06:58.140
the body to be loaded.

104
00:06:58.140 --> 00:07:00.560
Then you have to wait for
the the JS to be parsed.

105
00:07:00.560 --> 00:07:01.580
Then you have to wait for

106
00:07:01.580 --> 00:07:04.750
the CSS to be put onto the page
before a style starts showing up.

107
00:07:04.750 --> 00:07:08.220
So you have a big change for
flashes of unstyled content.

108
00:07:08.220 --> 00:07:10.950
And there's all sorts
of problematic things.

109
00:07:10.950 --> 00:07:13.860
There's also a runtime penalty for
styles components, right?

110
00:07:13.860 --> 00:07:15.650
It's not free, right.

111
00:07:15.650 --> 00:07:18.251
There's a stouts component library
working in the background.

112
00:07:18.251 --> 00:07:22.311
&gt;&gt; Speaker 1: But as we said
webpack will eventually be able to

113
00:07:22.311 --> 00:07:24.660
pre-compile this stuff.

114
00:07:24.660 --> 00:07:26.270
&gt;&gt; Brian Holt: Hopefully.
Hopefully, eventually, right.

115
00:07:26.270 --> 00:07:28.527
&gt;&gt; Speaker 1: It's better than
the stout sheet I mean ideally.

116
00:07:28.527 --> 00:07:32.350
Especially if this is the way
of the future kinda thing.

117
00:07:32.350 --> 00:07:34.640
&gt;&gt; Brian Holt: For sure.
And with server side rendering,

118
00:07:34.640 --> 00:07:37.750
which I'll show you prior on third day.

119
00:07:40.496 --> 00:07:44.060
It will pre-render out that style tag for
you right because it's gonna service hide

120
00:07:44.060 --> 00:07:47.820
render all that stuff for you and so
that style's components will be or

121
00:07:47.820 --> 00:07:50.720
the style tag will be sent
down with all the CSS.

122
00:07:50.720 --> 00:07:55.509
So it will get an order set up for
free, so it's still pretty fast.

123
00:07:57.650 --> 00:08:00.200
Max, the guy that wrote it,

124
00:08:00.200 --> 00:08:02.720
he has a couple of big websites in
production that are using it, so.

125
00:08:02.720 --> 00:08:08.150
&gt;&gt; Speaker 1: Can the style components
be used to target semantic elements,

126
00:08:08.150 --> 00:08:10.570
instead of the div.

127
00:08:10.570 --> 00:08:11.300
&gt;&gt; Brian Holt: Yeah, sure.

128
00:08:11.300 --> 00:08:12.700
I mean this could be the article, right?

129
00:08:14.460 --> 00:08:14.960
Or a section.

130
00:08:16.140 --> 00:08:17.915
&gt;&gt; Speaker 1: If each
page had an H1 style,

131
00:08:17.915 --> 00:08:20.616
would you repeat the in
lining in every page?

132
00:08:23.506 --> 00:08:26.063
&gt;&gt; Brian Holt: No, no it's smart enough
to pull that out into a single class.

133
00:08:29.813 --> 00:08:33.069
&gt;&gt; Speaker 1: Are the class name
generating always random characters?

134
00:08:34.380 --> 00:08:37.170
&gt;&gt; Brian Holt: The answer to that question
is that it is a hash, I'm pretty sure.

135
00:08:39.230 --> 00:08:43.570
So given these set of CSS properties,
this hash is to this class name,

136
00:08:43.570 --> 00:08:45.120
and that's how they
generate this class name.

137
00:08:47.070 --> 00:08:48.080
That was my understanding, anyway.

138
00:08:50.020 --> 00:08:53.370
&gt;&gt; Speaker 1: Which has precedence,
the class on the styled component, or

139
00:08:53.370 --> 00:08:56.490
the components define styles.

140
00:08:56.490 --> 00:08:58.420
&gt;&gt; Brian Holt: It's just
a normal CSS cascade.

141
00:08:58.420 --> 00:08:59.638
Whatever that amounts to.

142
00:09:04.345 --> 00:09:07.380
&gt;&gt; Speaker 1: If any questions I
missed please post them in chat.

143
00:09:07.380 --> 00:09:10.650
I'm trying to get them all but
there's a lot of them here.

144
00:09:13.932 --> 00:09:18.371
&gt;&gt; Brian Holt: So I mean, I guess the sum
of my story here with styles components,

145
00:09:18.371 --> 00:09:20.050
it's worth exploring.

146
00:09:20.050 --> 00:09:22.280
It's worth for
you trying to understand what's going on.

147
00:09:23.580 --> 00:09:27.460
They're still pretty nascent, we're still
kind of messing around with these ideas.

148
00:09:27.460 --> 00:09:30.210
And some people are less
thrilled than others about it.

149
00:09:30.210 --> 00:09:32.690
I totally accept that opinion
if you're not into it, but

150
00:09:32.690 --> 00:09:34.340
I think it's innovation worth exploring.

151
00:09:35.885 --> 00:09:39.780
&gt;&gt; Speaker 1: And people are saying,
please push, please push.

152
00:09:39.780 --> 00:09:43.850
&gt;&gt; Brian Holt: Okay, yeah,
I can do that really quick.

153
00:09:43.850 --> 00:09:47.620
&gt;&gt; Speaker 3: So one of the ways that
we've used CSS within the react context

154
00:09:47.620 --> 00:09:52.850
is, like you show you have the same
CSS file from the same components, and

155
00:09:52.850 --> 00:09:53.504
then you pull it.

156
00:09:53.504 --> 00:09:56.669
Is that reasonable?

157
00:09:56.669 --> 00:09:58.525
Still good?

158
00:09:58.525 --> 00:10:02.540
&gt;&gt; Brian Holt: Yeah, I would say that
one's, I don't think anyone's questioning

159
00:10:02.540 --> 00:10:05.730
the safety doing that, like that's
totally a production ready strategy.

160
00:10:07.860 --> 00:10:11.160
I'm just really hesitant to say yes,
go for it and styles components right now,

161
00:10:11.160 --> 00:10:12.860
as much as I think the library is amazing.

162
00:10:15.210 --> 00:10:17.070
I say judge for yourself.

163
00:10:17.070 --> 00:10:18.800
That's what I want to say
about styles components.

164
00:10:18.800 --> 00:10:22.030
There's trade offs to be made there,
and there are reasons too, right.

165
00:10:22.030 --> 00:10:25.670
I think this is a big productivity win

166
00:10:25.670 --> 00:10:29.110
to just have it all there in one place for
you.

167
00:10:29.110 --> 00:10:34.204
So you need to balance developer
experience versus runtime complexity.

