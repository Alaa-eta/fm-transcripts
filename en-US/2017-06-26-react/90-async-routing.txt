[00:00:00]
>> Brian Holt: What I want you to do, is the first thing that we're gonna have to do is we're gonna have to create a component called an a synch route. So create a new component inside of js. And don't get me wrong, other people have written libraries that will do this for you.

[00:00:16]
But I wanted to show you that there's nothing scary here, you can do this all yourself. So create a component called asyncroute.jsx inside of your js directory. Make it a flow component. Import react from react.
>> Brian Holt: And also you're gonna need component. And we're going to import Spinner as well because we're going to want a nice little loading spinner.

[00:00:51]
From ./spinner. Then we're going to have class AsyncRoute extends component.
>> Brian Holt: And then at the bottom you're gonna have to export default AsyncRoute.
>> Brian Holt: Okay, so this is the first higher order component that we're gonna write. So AsyncRoute itself I guess can render it's own mark up cuz sometimes it will render spinner for us but it's actually capturing a behavior, right?

[00:01:26]
What it's going to is is when it rendered it's going to go out and fetch the component that you asked for and then only after has it that its fetched it that's going to render itself. Does that make sense? Cool, so it's going to take two things in, two props.

[00:01:45]
It's going to take the props that you want to pass to the component and then the second thing that it's going to take is a loading promise, right? So let's take a look at what that looks like. And it's also going to have a state of whether or not it's loaded.

[00:02:02]
By default it's not going to be loaded, right? Then we're going to have props in here. Which is going to take in two different props. One's going to be mixed. So, we don't know or care what are in the props, right? We're just going to take the props that they give us and pass it down to the component.

[00:02:22]
So props is going to be mixed. That's what we're kind of asserting there. And then loadingPromise,
>> Brian Holt: Is going to be of type promise, right? But with promises, you actually have to give it what the promise is going to return, right? Do you remember how we did parameters with types?

[00:02:48]

>> Brian Holt: So it's going to give us back an object and the default parameter inside of this object is going to be a react component, right? So it's going to be a class of react component. React.component. And then let's not get too far into the weeds about how React is typed.

[00:03:13]
But React has three different props that you pass to React components. We're not gonna validate what those are because we don't know what kind of React components it's gonna be. So you're just gonna say *,*,*. I believe this is default props, props, and state are the parameters there.

[00:03:32]
I usually don't care. Suffice to say to just believe me that this is okay. Cool, cool.
>> Brian Holt: Oops, that needs to be on the other side.
>> Brian Holt: No, I think that's it.
>> Audience 1: Do you wanna [INAUDIBLE]?
>> Brian Holt: Yeah, I think I need that. There we go. So I realized, this is kind of a lot right here so let's just talk about it one more time.

[00:04:07]
This is a promise, right. A loadingPromise is a promise. What that promise returns when it resolves is an object, right. Inside of that object, this is what is gonna come back from webpack when it loads your code asynchronously. It's gonna be an object with a default property on it, right?

[00:04:25]
And that default property is going to be a class, like this sort of class, right? And the type of class that it is, is a react component, right? And react components can be typed in various ways that we're going to ignore for now, that's what the stars mean, it means I don't care what they are, right?

[00:04:42]
I don't care what type of React component it is, I just know that it's going to be something that React can render.
>> Brian Holt: Good, cool? All right.
>> Brian Holt: So, something that we could do, we could store the component here in state, this is a bad idea. The reason why this is a bad idea is, if you remember, React, when it's doing it's diffing algorithm, it's gonna be checking everything inside of your state.

[00:05:11]
A react component has a lot of stuff on it and we don't actually want react to be going through that every single time it does a re-render. So a good way to kind of side step that is just to say, I'm gonna put component on the class itself.

[00:05:26]
If the component lives on the class itself or anything lives on the class itself. React doesn't check that. So it's stiffing algorithm is not gonna put its tendrils in there, right? Which we don't want it to. So that's why we're going to put it on the class and not necessarily in state.

[00:05:40]
Does that make sense? Only keep things in state that have to do with re-renders, right? If I change state and load it from true to false, I need to re-render right there. Component is never going to force a re-render, right? We're going to load the component once, and then not do anything more with it.

[00:05:58]
So it's good to put that on just the class itself, okay? Now, between these two, I need to create a componentDidMount, mount it to the DOM, we wanna go and start requesting, or sorry we actually wanna be acting upon this promise that we're gonna get from props, right?

[00:06:22]
So what we're gonna say right here is this.props.loadingPromise.
>> Brian Holt: And we're gonna say .then. It's gonna take in a module that web pack is going to give us.
>> Brian Holt: And then we're gonna say this.component,
>> Brian Holt: = module.default. Then at that point we're going to say this.setstate loaded is true.

[00:07:09]

>> Brian Holt: Okay, so it's going to be passed as promised. When that promise resolves, it's going to get that module from web pack, right? This can happen immediately, right? If I go from details to search and then back to details, details is going to be in Webpacks cash. It's just going to immediately resolve that promise for me.

[00:07:30]
But this will still work in either scenario. So this .component is going to be equal to module .default, right? We know that that's going to come back because we created that type right here. So that's why that plays nicely with flow. And then once that's been loaded, we're gonna set loaded to true, okay?

[00:07:52]
Last thing we need to do here is create the render function.
>> Brian Holt: And it's just going to be if this .state.loaded. So if I'm loaded then I want you to return this .component and then I want to just pass whatever props into that. This.props.props.
>> Brian Holt: I know this looks weird, right?

[00:08:24]
But we have a props called props, right, so that's what you end up with.
>> Brian Holt: Okay, if I don't have a state being loaded yet, what I'm going to return is Spinner.
>> Brian Holt: I'm gonna return some sort of loading UI, right? In this case we're just gonna put a big spinner on the page.

[00:08:52]

>> Brian Holt: And that's it.
>> Brian Holt: Any questions about this?
>> Brian Holt: So now we have this AsyncRoute component that we can use inside of our router, so that it's only going to load components when they're only, when they're needed.

