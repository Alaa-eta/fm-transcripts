[00:00:00]
>> Sarah Drasner: In order to use vuex we have to npm install --save or we say yarn add vuex. I typically set it up this way within my source directory. I create another directory name store. Remember I had created that other directory named components before. This is a preference. You could also just make a stored.js file and have it chilling in that source directory, if you wanted to.

[00:00:25]
The reason why I put a store directory there, and put that single file in the store directory, is there are cases with a giant application. Where you might even wanna break up that file into several files and manage the state in a different way. If I keep that in one directory from the get-go, if I get into a situation where I need to refactor or move it into a few different files, I'm already in a place to do that.

[00:00:51]
I don't have to rewrite paths and a bunch of the components or anything like that. But again, that's a preference. You can create that store file wherever you want.
>> Sarah Drasner: So the initial setup in store.js would look something like this. This is the vstore sublime snippet if you wanted to use sublime.

[00:01:12]
So you would import Vue from vue, import Vuex from vuex. We'd say, vue.use vuex, and import const store. And I'm gonna go into more depth on this too. I know that I'm throwing a lot at you right now, state and key and value. So that's the smallest state store you could possibly make ever in the world is this tiny little key value state store.

[00:01:42]
In our main.js file, we'd perform the following updates, so we've looked at the main.js file and we're gonna look at it in real life as well. Import from Vue from vue, import App from app.view with import store from store. Store that was the directory structure I have mentioned before.

[00:02:01]
And we have store store. So the things that changes about this file, it's pretty much the same. Here are the things that changed about this file, we have import store from store store, and then we have store store, that's like the second thing here. We can also just write store, because we're using is, what?

[00:02:20]

>> Speaker 2: Could you zoom out?
>> Sarah Drasner: Sorry.
>> Sarah Drasner: So, we can say store store, or we can just say store because it's redundant and ES6 understand that's what we might need.
>> Sarah Drasner: In our store, we have a few different things. You saw that we had our state. Our state is very similar to the way we've been housing our data, so far.

[00:02:44]
We have data in a function and we have a few different values that we're using. So state is pretty much the same thing but it's a centralized place for all that state. The other things that we have in this are getters. Getters will make values able to show statically in our templates.

[00:03:00]
In other words, getters can read the value, but not mutate the state. So you can think about getters as equivalence to computed values. That's kind of how we are using computed values. It's a different view on that same data. We're not mutating that data, we're not mutating the state.

[00:03:16]
We're using getters to have a different view of that state to begin with. Mutations will allow us to update the state. They'll always be synchronous, every single time, they're always gonna be synchronous. Mutations are the only way to change data in the store. That is the only way to change data in the store.

[00:03:37]
So you might say, so how do I make asynchronous things happen? We'll use actions to update the state asynchronously, but we'll always use an existing mutation. So you can't just create an action and mutate the state, you have to create a mutation, and then use that mutation inside of an action.

[00:03:55]
This can be really helpful if you need to perform a few different mutations at once in a particular order, or if you need to reach out to a server. It kind of, doing it this way is really nice because you solve any kind of sequencing or ordering problems.

[00:04:09]
You don't have a situation where you're executing a couple of things but really while the server, you're waiting to get some response from the server. Something that was supposed to follow is being executed, you can kind of make sure that you're executing things exactly when you need to be.

[00:04:24]
So mutations are like how we've been using methods. They're any kind of change to the state that needs to occur, and actions will take an existing mutation and apply some sort of asynchronous activity. Either reaching to to server here, we're gonna use that timeout just so you get the idea of them.

[00:04:45]
We separate actions and mutations because we don't wanna get into an ordering problem. All right, we've got a basic abstract example, we're gonna walk through this really quick. We had kind of talked about that store, and we'd just said key value before. This is kind of like building off of that example.

[00:05:04]
So, in state, we'd maybe have something like counter is 0. This getter, again, like the computed value, this getter is allowing us to use this triple counter and it's really saying state.counter times 3 or whatever kind of logic that we need to use it for.
>> Sarah Drasner: Mutation is mutating the state, mutations are always synchronous.

[00:05:30]
When we mutate the state with an argument, we usually call it payload, that's just like industry standard. So we're showing it passed with payload, we're passing in the state. And then also num, which is the payload, and we're incrementing that value by the none here. Now this is a lot.

[00:05:50]
And I'll use the next couple of slides to go into much more detail about this, so that you don't feel like I'm overwhelming you with just this information. In actions, we're showing it pass with the payload, represented as asyncNum, which is an object. So we've got this commit, we're passing an asyncNum.

[00:06:11]
We have this set time out and this asyncNum is an object so we can say asyncNum.by and asyncNum.duration. It can also just be static amounts if you want to. So, okay, let's go a little bit further into actions cuz that was a lot of things for you to understand very, very quickly.

[00:06:31]
We have to pass in the context, in actions. So context, we will use like context.state, context.getter. The reason why we're not using state directly is so that we avoid collisions because there's a more complicated reason for this, but we have different modules and then it can be name space differently.

[00:06:53]
So in order to keep those from colliding in actions, we have to pass in context. But we're actually gonna abstract the context away. Typically, we don't use it like this. What we'll do is destructure it. And just say, instead of that, we'll pass in parens, commit and then commit increment.

[00:07:15]
So that's a little bit more legible, a little bit clearer to read as well.
>> Sarah Drasner: If we're going to do some sort of asynchronous calculation from this, so we first we had that commit, we're passing in commit increments. We have commit, we have setTimeout, and we're committing increments, so increment would be a method that we've already created.

[00:07:38]
If we go back increment with something that we made in mutation, so we're taking that mutation. In mutations, always have to be committed when we start to use these in our component files, we're committing the mutation in our templates, and we're also committing the mutation in our actions as well.

[00:07:58]
And so we're committing this increments. And we have it happening after one second, if you setTimeout, we're waiting for one second, and then we're doing that mutation. If we just did the mutation, and let's say it's something that takes a long time, and we're not using it asynchronously, it could actually block up our application.

[00:08:22]
Because they can only synchronous, and we wanna avoid that. Those actions become really useful for those mutations because we don't wanna block up our application waiting for something to happen.
>> Sarah Drasner: So, if we're gonna use this action in our actual component, we use a thing called dispatch. I will go over this part again.

[00:08:47]
So I'm going to go over it here and then we're gonna go over how they're each used again in a second. We have methods, and then we're going to say asyncIncrement. I'm just calling it the same thing, I could call this something else. I could call it go get tacos.

[00:09:02]
And then we have this.store.dispatch asyncIncrement. So I'm calling this and what it's going to do is, it's going to then reach out and it's going to set a time out and execute and commit that increment after waiting one second. But we-.
>> Speaker 3: [INAUDIBLE] some actions.
>> Sarah Drasner: What's that, yeah?

[00:09:26]

>> Speaker 3: So on the actions, are you kinda using set time out as an illustrative thing to show.
>> Sarah Drasner: Yeah, just because it's a little bit easier than also showing all of the-
>> Speaker 2: [INAUDIBLE] an HTTP requires [INAUDIBLE] what you might need to do.
>> Sarah Drasner: Yeah, it's a lot to understand in general so the set time out is kind of an abstraction, so you're not bogged down with some of the other details.

[00:09:51]

>> Sarah Drasner: So let's say we need to change some of these values, maybe we need to pass in a payload. If we needed to pass in a different duration, here we're just hard coding that one second, but let's say we need a different duration. We would then create this payload here, and we say duration.

[00:10:12]
And then we would create an object here where we say duration is 1,000. So that's how we update it in those two places. So here, it's hard coded. We're just calling asyncIncrement, if we want to dispatch with a payload, we have duration, and then we're passing in an object to where we have duration, yeah?

[00:10:34]

>> Speaker 3: If the object that you're passing has only one property, does it just somehow [INAUDIBLE] single property cuz seems to be passing an object with the-.
>> Sarah Drasner: Yeah, I mean, we can do it either way. We can pass in just the one, but if you need to build off of it in any way and create more values, then it becomes easier to then kind of update from that point.

[00:11:02]
So if we need to do something like this object, and that's actually kind of a typical use case, I would say, is that we're not just passing in one argument to this, it's a little bit easier to update. But that's-.
>> Speaker 3: Like, this is an exact example, it looks like you're passing an object as the second parameter to setTimeout.

[00:11:24]

>> Sarah Drasner: We are, we're passing in an object and that's going to be the duration. So this is destructuring, it's kind of an ES6.
>> Speaker 3: So it is destructuring right now.
>> Sarah Drasner: Yeah, it's destructuring.
>> Sarah Drasner: And so then we can say, asyncNum, we pass an asyncNum, and then we can update this to by and dur.

[00:11:44]
So then we can say where asyncNum.by asyncnum.dur and then we can update it in that way.
>> Sarah Drasner: So, the way is that we would use all of these things that we just talked about is that on the component itself, we'd use computed for getters. This makes sense because it's kind of similar to computed values anyway.

[00:12:08]
We have our computed, and we can use value directly in our code. We say we will return this.store.getts.tripleCounter, or whatever you want for that example. But we basically use that as a computer value because that's basically well, the same kind of dance that we're doing is that different view on the same state.

[00:12:32]
We'd use commit for mutations. So, anytime we use a mutation, we use commit. Even if it's in the component, even if it's in store.js. And then for asyncIncrement, we use dispatch for the actions. So anytime we use an action in one of our components, we use asyncIncrement.
>> Sarah Drasner: So, I'm gonna bring up our example where we are doing a few different things here.

[00:12:59]
So we have got,
>> Sarah Drasner: I tried to separate these out as much as possible so that they were easier to understand. So if we go into vuex-example, then I'll do subl first, then,
>> Sarah Drasner: Here we have the state from the store is 0. The getter for triple counter from the store is 0.

[00:13:35]
So that's the getter that kind of computed value. Let's increment by two with a mutation. We're gonna increment by two. You can see that that getter is changing, but it's always gonna be times three. Let's increment by two with an async, or by ten, sorry, with an action async.

[00:13:52]
So we wait one second, and then we increment by ten. And this is a really simple adjustment of store state with a component. I would never do this, but people do do this, so I'm showing it to you. I don't think that you should do this. [LAUGH] But I've seen it in enough applications now that I wanna call out to you, it's possible, but I don't think that that's how you should be working with it.

[00:14:14]
So, here we go into the source, and were going into components. And I made a separate component for each thing that you're gonna do, so that it is a little bit easier to understand. So here's our store directory. Like I said, we have our store here and it's pretty similar to the stuff that we mentioned that we would be working with.

[00:14:34]
Then, in our main.js file, remember I said, we're gonna import store from store. Here that is, and there's the store here. And then in the action, let's start with the store, the app. So I can say, the state from the store is span, and then state. And then in here, in that computed value, again, we're just accessing the state from the store.

[00:15:01]
But I'm still gonna use a computed value because that computed value's going to be cashed until the dependency has changed. So it's a good chance for me to use computed value just returning that state from the store. So I'm gonna say state, return this .store.state.counter. And it's going to be this, and then $store, and we're able to use state.

[00:15:25]
Remember we saw that earlier with getters, we can use the state right here. Then in the getter, we have something very similar. We have a computed value, we have tripled this .$store.getters.tripleCounter and then we have triple passed in here. And then in mutation, we can increment two with the mutation button @click is increment, that's going to call this method here.

[00:15:51]
And the method is this.store.commit increment, and then we are passing in something like two. There's so many different ways that we could actually use this mutation, that's just an example. And then in the action, we should actually say 10 with an action async, button @click asynInc. And then in our methods we say, asynInc, this.store.dispatch aysncInc and passing in 10.

[00:16:23]
So if we go back to looking at that store, you can see that we're actually committing this is our payload, this is our payload, those are the things are we were passing in.
>> Sarah Drasner: So that is all organized in the repo for you. We just went over all of these kind of stuff.

[00:16:41]
So the getter is, I kept these in different slides for you, the getter we're using a computed value. We're saying .store.getter.tripleCounter and then store.js, we are using whatever logic we would like to do for that different take on that value. We have a mutation methods @click increment, and increment, we say this .store.commit.

[00:17:07]
Remember, mutations are always committed, and actions are always dispatched. So we're always going to commit it this way in store.js. In async action, we've got button asyncInc, and we've got store.dispatch and this.store.js. And there are times when you have a lot of stuff that you need to get from the store.

[00:17:30]
And rewriting out new values for each one of these can get a little arduous and painful and not at all dry. [LAUGH] So vue, vuex allows us to do a thing called map getters, map actions, map mutations. So you would say in the same file at import map actions from vuex.

[00:17:55]
And then, I would be able to, with the spread operator, say map actions, and then say all of the things that I wanna go get from that source, so I don't have to keep rewriting all of those values. Some people just write it like this right away, so this maps this.increment to this.store.commitincrement.

[00:18:14]
Actually, that would be dispatch for actions. So, this allows us to still make our own computer properties, if we wish, because we could use these and then reuse them and create another method below them that uses that value. So it can make new computed properties from these as well, if this doesn't fit our exact use case.

[00:18:38]
So that's pretty great. One thing, though, is that spread operators are not supported in all of these, even in newer babel, necessarily, it depends on your build. So you might need babel-preset-stage-2, or babel-plugin-transform-object-rest-spread. [LAUGH] So, you might have to yarn add, or NPM install, one of these two to get this working correctly.

[00:19:06]

>> Sarah Drasner: So, if we're working with this, if we're working with map actions, before we were doing that thing, where we were saying increment and then comma five or whatever, in that order to pass the payload. In this instance, we'd write @click and then the increment we'd pass that in parens instead.

[00:19:26]
Because we're not kind of using it exactly the same way, so we pass the payload this way. And in store.js, that's the same, that's there.

